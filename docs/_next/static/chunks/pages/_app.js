_N_E =
(window["webpackJsonp_N_E"] = window["webpackJsonp_N_E"] || []).push([["pages/_app"],{

/***/ "./node_modules/@babel/runtime/helpers/arrayLikeToArray.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/arrayLikeToArray.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

module.exports = _arrayLikeToArray;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/arrayWithHoles.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/arrayWithHoles.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

module.exports = _arrayWithHoles;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/asyncToGenerator.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/asyncToGenerator.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

module.exports = _asyncToGenerator;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/defineProperty.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/defineProperty.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

module.exports = _defineProperty;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/extends.js":
/*!************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/extends.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _extends; });
function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js ***!
  \****************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _objectWithoutProperties; });
/* harmony import */ var _objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./objectWithoutPropertiesLoose */ "./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js");

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = Object(_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_0__["default"])(source, excluded);
  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js ***!
  \*********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _objectWithoutPropertiesLoose; });
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/interopRequireDefault.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

module.exports = _interopRequireDefault;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/interopRequireWildcard.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/interopRequireWildcard.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = __webpack_require__(/*! ../helpers/typeof */ "./node_modules/@babel/runtime/helpers/typeof.js");

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
    return {
      "default": obj
    };
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

module.exports = _interopRequireWildcard;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _iterableToArrayLimit(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

module.exports = _iterableToArrayLimit;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/nonIterableRest.js":
/*!****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/nonIterableRest.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

module.exports = _nonIterableRest;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/slicedToArray.js":
/*!**************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/slicedToArray.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayWithHoles = __webpack_require__(/*! ./arrayWithHoles */ "./node_modules/@babel/runtime/helpers/arrayWithHoles.js");

var iterableToArrayLimit = __webpack_require__(/*! ./iterableToArrayLimit */ "./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js");

var unsupportedIterableToArray = __webpack_require__(/*! ./unsupportedIterableToArray */ "./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js");

var nonIterableRest = __webpack_require__(/*! ./nonIterableRest */ "./node_modules/@babel/runtime/helpers/nonIterableRest.js");

function _slicedToArray(arr, i) {
  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();
}

module.exports = _slicedToArray;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/typeof.js":
/*!*******************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/typeof.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    module.exports = _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    module.exports = _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

module.exports = _typeof;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeToArray = __webpack_require__(/*! ./arrayLikeToArray */ "./node_modules/@babel/runtime/helpers/arrayLikeToArray.js");

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);
}

module.exports = _unsupportedIterableToArray;

/***/ }),

/***/ "./node_modules/@babel/runtime/regenerator/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@babel/runtime/regenerator/index.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! regenerator-runtime */ "./node_modules/regenerator-runtime/runtime.js");


/***/ }),

/***/ "./node_modules/@moxy/next-link/es/NextLink.js":
/*!*****************************************************!*\
  !*** ./node_modules/@moxy/next-link/es/NextLink.js ***!
  \*****************************************************/
/*! exports provided: NextLink, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NextLink", function() { return NextLink; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/link */ "./node_modules/next/link.js");
/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_link__WEBPACK_IMPORTED_MODULE_2__);



const NextLink = Object(react__WEBPACK_IMPORTED_MODULE_0__["forwardRef"])(({
  children,
  className,
  href,
  newTab,
  prefetch,
  as,
  scroll,
  external,
  ...props
}, ref) => {
  const Anchor = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("a", Object.assign({
    ref: ref,
    className: className,
    target: newTab ? '_blank' : undefined,
    rel: newTab ? 'noopener noreferrer' : undefined,
    href: external ? href : undefined
  }, props), children);

  if (external) {
    return Anchor;
  }

  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(next_link__WEBPACK_IMPORTED_MODULE_2___default.a, {
    href: href,
    prefetch: prefetch && undefined,
    as: as,
    scroll: scroll,
    passHref: true
  }, Anchor);
});
NextLink.propTypes = {
  href: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string.isRequired,
  children: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.node.isRequired,
  className: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,
  newTab: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.bool,
  external: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.bool,
  prefetch: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.bool,
  as: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,
  scroll: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.bool
};
/* harmony default export */ __webpack_exports__["default"] = (NextLink);

/***/ }),

/***/ "./node_modules/@moxy/next-link/es/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@moxy/next-link/es/index.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _NextLink__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./NextLink */ "./node_modules/@moxy/next-link/es/NextLink.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _NextLink__WEBPACK_IMPORTED_MODULE_0__["default"]; });



/***/ }),

/***/ "./node_modules/classnames/index.js":
/*!******************************************!*\
  !*** ./node_modules/classnames/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
  Copyright (c) 2017 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/
/* global define */

(function () {
	'use strict';

	var hasOwn = {}.hasOwnProperty;

	function classNames () {
		var classes = [];

		for (var i = 0; i < arguments.length; i++) {
			var arg = arguments[i];
			if (!arg) continue;

			var argType = typeof arg;

			if (argType === 'string' || argType === 'number') {
				classes.push(arg);
			} else if (Array.isArray(arg) && arg.length) {
				var inner = classNames.apply(null, arg);
				if (inner) {
					classes.push(inner);
				}
			} else if (argType === 'object') {
				for (var key in arg) {
					if (hasOwn.call(arg, key) && arg[key]) {
						classes.push(key);
					}
				}
			}
		}

		return classes.join(' ');
	}

	if ( true && module.exports) {
		classNames.default = classNames;
		module.exports = classNames;
	} else if (true) {
		// register as 'classnames', consistent with npm package name
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {
			return classNames;
		}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {}
}());


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/index.js?!./www/shared/components/grain/Grain.module.css":
/*!*********************************************************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js??ref--5-oneOf-2-1!./node_modules/next/dist/compiled/postcss-loader??__nextjs_postcss!./www/shared/components/grain/Grain.module.css ***!
  \*********************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
exports = ___CSS_LOADER_API_IMPORT___(true);
// Module
exports.push([module.i, "@keyframes Grain_grain__hVFR0 {\n  0%,\n  100% { transform: translate(0, 0); }\n\n  10% { transform: translate(-5%, -10%); }\n  20% { transform: translate(-15%, 5%); }\n  30% { transform: translate(7%, -25%); }\n  40% { transform: translate(-5%, 25%); }\n  50% { transform: translate(-15%, 10%); }\n  60% { transform: translate(15%, 0%); }\n  70% { transform: translate(0%, 15%); }\n  80% { transform: translate(3%, 30%); }\n  90% { transform: translate(-10%, 10%); }\n}\n\n.Grain_grain__hVFR0 {\n  position: relative;\n  z-index: 0;\n}\n\n.Grain_grain__hVFR0::after {\n  content: \"\";\n  position: absolute;\n  top: -100%;\n  left: -100%;\n  width: 300%;\n  height: 300%;\n  opacity: 0.4;\n  background-image: url(\"data:image/png;base64,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\");\n  /*animation: grain 8s steps(10) infinite;*/\n}\n", "",{"version":3,"sources":["C:/Users/paulo/Desktop/Work/Projects/Personal/Web/paulobmarcos/www/shared/components/grain/Grain.module.css"],"names":[],"mappings":"AAAA;EACE;SACO,0BAA0B,EAAE;;EAEnC,MAAM,+BAA+B,EAAE;EACvC,MAAM,8BAA8B,EAAE;EACtC,MAAM,8BAA8B,EAAE;EACtC,MAAM,8BAA8B,EAAE;EACtC,MAAM,+BAA+B,EAAE;EACvC,MAAM,6BAA6B,EAAE;EACrC,MAAM,6BAA6B,EAAE;EACrC,MAAM,6BAA6B,EAAE;EACrC,MAAM,+BAA+B,EAAE;AACzC;;AAEA;EACE,kBAAkB;EAClB,UAAU;AACZ;;AAEA;EACE,WAAW;EACX,kBAAkB;EAClB,UAAU;EACV,WAAW;EACX,WAAW;EACX,YAAY;EACZ,YAAY;EACZ,+msCAAqD;EACrD,0CAA0C;AAC5C","file":"Grain.module.css","sourcesContent":["@keyframes grain {\n  0%,\n  100% { transform: translate(0, 0); }\n\n  10% { transform: translate(-5%, -10%); }\n  20% { transform: translate(-15%, 5%); }\n  30% { transform: translate(7%, -25%); }\n  40% { transform: translate(-5%, 25%); }\n  50% { transform: translate(-15%, 10%); }\n  60% { transform: translate(15%, 0%); }\n  70% { transform: translate(0%, 15%); }\n  80% { transform: translate(3%, 30%); }\n  90% { transform: translate(-10%, 10%); }\n}\n\n.grain {\n  position: relative;\n  z-index: 0;\n}\n\n.grain::after {\n  content: \"\";\n  position: absolute;\n  top: -100%;\n  left: -100%;\n  width: 300%;\n  height: 300%;\n  opacity: 0.4;\n  background-image: url(\"../../media/images/grain.png\");\n  /*animation: grain 8s steps(10) infinite;*/\n}\n"]}]);
// Exports
exports.locals = {
	"grain": "Grain_grain__hVFR0"
};
module.exports = exports;


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/index.js?!./www/shared/components/header/Header.module.css":
/*!***********************************************************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js??ref--5-oneOf-2-1!./node_modules/next/dist/compiled/postcss-loader??__nextjs_postcss!./www/shared/components/header/Header.module.css ***!
  \***********************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
exports = ___CSS_LOADER_API_IMPORT___(true);
// Module
exports.push([module.i, "/* ==========================================================================\n   Custom media queries\n\n   Use it like so: @media (--layout-small) { ... }\n   ========================================================================== */\n\n/* 375px */\n\n/* 480px */\n\n/* 768px */\n\n/* 1024px */\n\n/* 1280px */\n\n/* 1440px */\n\n/* 1920px */\n\n/* ==========================================================================\n   Colors\n   ========================================================================== */\n\n/* ==========================================================================\n   Z-Indexes\n   ========================================================================== */\n\n/* ==========================================================================\n   Sizes\n   ========================================================================== */\n\n/* ==========================================================================\n    Landscape\n    ========================================================================== */\n\n/* ==========================================================================\n    Portrait\n    ========================================================================== */\n\n/* ==========================================================================\n   Custom medias\n   ========================================================================== */\n\n/* MIXINS */\n\n/* ==========================================================================\n   Smooth & sharp mixins\n   ========================================================================== */\n\n/* ==========================================================================\n   Ellipsis mixin\n\n   The container needs to have a width for it to work\n   ========================================================================== */\n\n/* ==========================================================================\n  Fonts\n  ========================================================================== */\n\n/* ==========================================================================\n  All typography variants\n\n  $unit - Either em or rem\n  ========================================================================== */\n\n.Header_header__36fEK {\n  position: fixed;\n  top: calc(calc(2.2rem * 2) + 2.2rem);\n  top: calc(calc(2.2rem * 2) + 2.2rem);\n  left: 0;\n  width: 100vw;\n  height: 4rem;\n  height: 4rem;\n  z-index: 5;\n  z-index: 5;\n  padding: 0 calc(2.2rem * 2);\n  padding: 0 calc(2.2rem * 2);\n  display: flex;\n  justify-content: center;\n}\n\n@media (max-width: 48em) {\n\n  .Header_header__36fEK {\n  padding: 0 calc(2vw * 2);\n  }\n}\n\n@media (max-width: 48em) {\n\n  .Header_header__36fEK {\n  top: calc(calc(2.2rem * 2) + 2vw);\n  }\n}\n\n@media (max-width: 48em) {\n\n  .Header_header__36fEK {\n  top: calc(calc(2.2rem * 2) + 2vw);\n  }\n}\n\n.Header_content__nDQJf {\n  width: 100%;\n  max-width: 150rem;\n  max-width: 150rem;\n  display: flex;\n  flex-direction: row;\n  justify-content: space-between;\n  align-items: center;\n}\n\n.Header_name__16TYA {\n  flex: 1 1 0;\n  font-size: 3.2rem;\n  cursor: default\n}\n\n.Header_name__16TYA > * {\n    font-weight: normal;\n    white-space: nowrap;\n  }\n\n.Header_name__16TYA b {\n    pointer-events: none;\n  }\n\n.Header_social__2Du7_ {\n  display: flex;\n  flex: 1 1 0;\n  justify-content: flex-end;\n  -webkit-user-select: none;\n      -ms-user-select: none;\n          user-select: none\n}\n\n.Header_social__2Du7_ a {\n    color: #fff;\n    color: #fff\n  }\n\n.Header_social__2Du7_ a:not(:first-child) {\n      margin-left: 3rem;\n    }\n\n.Header_social__2Du7_ a svg {\n      height: 2.4rem;\n      transition: fill 0.2s ease-out;\n      fill: #fff;\n      fill: #fff;\n    }\n\n.Header_social__2Du7_ a:hover svg {\n      fill: #64f4ac;\n      fill: #64f4ac;\n    }\n\n.Header_links__1j8LT {\n  display: flex;\n  -webkit-user-select: none;\n      -ms-user-select: none;\n          user-select: none\n}\n\n.Header_links__1j8LT > *:not(:first-child) {\n    margin-left: 5ch;\n  }\n\n/* ==========================================================================\n   Custom medias\n   ========================================================================== */\n\n@media (max-width: 64em) {\n  .Header_links__1j8LT {\n    display: none;\n  }\n}\n\n@media (max-width: 30em) {\n  .Header_header__36fEK {\n    top: 3rem;\n    padding: 0 2.5rem;\n  }\n\n  .Header_name__16TYA {\n    font-size: 6.5vw;\n  }\n}\n", "",{"version":3,"sources":["C:/Users/paulo/Desktop/Work/Projects/Personal/Web/paulobmarcos/www/shared/styles/imports/custom-medias.css","C:/Users/paulo/Desktop/Work/Projects/Personal/Web/paulobmarcos/www/shared/styles/imports/variables.css","C:/Users/paulo/Desktop/Work/Projects/Personal/Web/paulobmarcos/www/shared/styles/imports/index.css","C:/Users/paulo/Desktop/Work/Projects/Personal/Web/paulobmarcos/www/shared/styles/imports/mixins/text.css","C:/Users/paulo/Desktop/Work/Projects/Personal/Web/paulobmarcos/www/shared/styles/imports/mixins/typography.css","C:/Users/paulo/Desktop/Work/Projects/Personal/Web/paulobmarcos/www/shared/components/header/Header.module.css"],"names":[],"mappings":"AAAA;;;;+EAI+E;;AAEtB,UAAU;;AAChB,UAAU;;AACX,UAAU;;AACT,WAAW;;AACZ,WAAW;;AACV,WAAW;;AACT,WAAW;;ACVhE;;+EAE+E;;AAa/E;;+EAE+E;;AAQ/E;;+EAE+E;;AAiB/E;;gFAEgF;;AAShF;;gFAEgF;;AAShF;;+EAE+E;;ACnE/E,WAAW;;ACHX;;+EAE+E;;AAY/E;;;;+EAI+E;;AChB/E;;8EAE8E;;AAO9E;;;;8EAI8E;;ACb9E;EACE,eAAe;EACf,oCAA0D;EAA1D,oCAA0D;EAC1D,OAAO;EACP,YAAY;EACZ,YAA4B;EAA5B,YAA4B;EAC5B,UAA8B;EAA9B,UAA8B;EAC9B,2BAAkC;EAAlC,2BAAkC;EAClC,aAAa;EACb,uBAAuB;AACzB;;AJ4DA;;EItEA;EAOE,wBAAA;EAGF;AJgEA;;AAJA;;EItEA;EAEE,iCAAA;EAQF;AJgEA;;AAJA;;EItEA;EAEE,iCAAA;EAQF;AJgEA;;AI9DA;EACE,WAAW;EACX,iBAAkC;EAAlC,iBAAkC;EAClC,aAAa;EACb,mBAAmB;EACnB,8BAA8B;EAC9B,mBAAmB;AACrB;;AAEA;EACE,WAAW;EACX,iBAAiB;EACjB;AAUF;;AARE;IACE,mBAAmB;IACnB,mBAAmB;EACrB;;AAEA;IACE,oBAAoB;EACtB;;AAGF;EACE,aAAa;EACb,WAAW;EACX,yBAAyB;EACzB,yBAAiB;MAAjB,qBAAiB;UAAjB;AAmBF;;AAjBE;IACE,WAAyB;IAAzB;EAeF;;AAbE;MACE,iBAAiB;IACnB;;AAEA;MACE,cAAc;MACd,8BAA8B;MAC9B,UAAwB;MAAxB,UAAwB;IAC1B;;AAEA;MACE,aAAwB;MAAxB,aAAwB;IAC1B;;AAIJ;EACE,aAAa;EACb,yBAAiB;MAAjB,qBAAiB;UAAjB;AAKF;;AAHE;IACE,gBAAgB;EAClB;;AAGF;;+EAE+E;;AAE/E;EACE;IACE,aAAa;EACf;AACF;;AAEA;EACE;IACE,SAAS;IACT,iBAAiB;EACnB;;EAEA;IACE,gBAAgB;EAClB;AACF","file":"Header.module.css","sourcesContent":["/* ==========================================================================\n   Custom media queries\n\n   Use it like so: @media (--layout-small) { ... }\n   ========================================================================== */\n\n@custom-media --layout-lte-xxsmall (width <= 23.4375em); /* 375px */\n@custom-media --layout-lte-xsmall (width <= 30em); /* 480px */\n@custom-media --layout-lte-small (width <= 48em); /* 768px */\n@custom-media --layout-lte-medium (width <= 64em); /* 1024px */\n@custom-media --layout-lte-large (width <= 80em); /* 1280px */\n@custom-media --layout-lte-xlarge (width <= 90em); /* 1440px */\n@custom-media --layout-lte-xxlarge (width <= 120em); /* 1920px */\n","@import \"./custom-medias\";\n\n/* ==========================================================================\n   Colors\n   ========================================================================== */\n\n:root {\n  --color-white: #fff;\n  --color-black: #000;\n  --color-dark: #0f0f11;\n  --color-gray: #2d2e32;\n  --color-light-gray: #c1c5d4;\n  --color-dark-gray: #191a1d;\n  --color-green: #64f4ac;\n  --color-green-dark: #286144;\n}\n\n/* ==========================================================================\n   Z-Indexes\n   ========================================================================== */\n\n:root {\n  --z-index-base: 1;\n  --z-index-header: 5;\n  --z-index-frame: 6;\n}\n\n/* ==========================================================================\n   Sizes\n   ========================================================================== */\n\n:root {\n  --layout-width: 100vw;\n  --layout-height: 100vh;\n  --layout-max-width: 150rem;\n  --layout-padding: 2.2rem;\n\n  --header-height: 4rem;\n  --header-frame-top: calc(var(--layout-padding) * 2);\n\n  --content-viewport-height: calc(100vh - (var(--layout-padding) * 2));\n\n  --carousel-item-width: 60vw;\n  --carousel-item-height: 30vw;\n}\n\n/* ==========================================================================\n    Landscape\n    ========================================================================== */\n\n@media (orientation: landscape) {\n  :root {\n    --carousel-item-width: 60vw;\n    --carousel-item-height: 33vw;\n  }\n}\n\n/* ==========================================================================\n    Portrait\n    ========================================================================== */\n\n@media (orientation: portrait) {\n  :root {\n    --carousel-item-width: 80vw;\n    --carousel-item-height: 80vw;\n  }\n}\n\n/* ==========================================================================\n   Custom medias\n   ========================================================================== */\n\n@media (--layout-lte-small) {\n  :root {\n    --layout-padding: 2vw;\n  }\n}\n","@import \"./custom-medias.css\";\n@import \"./variables.css\";\n\n/* MIXINS */\n@import \"./mixins/text.css\";\n@import \"./mixins/typography.css\";\n@import \"./mixins/unstyled-button.css\";\n","/* ==========================================================================\n   Smooth & sharp mixins\n   ========================================================================== */\n\n@define-mixin text-smooth {\n    -moz-osx-font-smoothing: grayscale;  /* Font smoothing tweaks for MacOSx in Gecko */\n    -webkit-font-smoothing: antialiased; /* Font smoothing tweaks for MacOSx in Webkit */\n}\n\n@define-mixin text-sharp {\n    -moz-osx-font-smoothing: initial;   /* Turn off font smoothing tweaks for MacOSx in Gecko */\n    -webkit-font-smoothing: initial;    /* Turn off font smoothing tweaks for MacOSx in Webkit */\n}\n\n/* ==========================================================================\n   Ellipsis mixin\n\n   The container needs to have a width for it to work\n   ========================================================================== */\n\n@define-mixin text-ellipsis {\n    overflow: hidden; /* \"overflow\" value must be different from \"visible\" */\n    text-overflow: ellipsis;\n    white-space: nowrap;\n    overflow-wrap: normal;\n}\n\n@define-mixin text-ellipsis-multiline $max-line-count, $max-height {\n    max-height: $max-height;\n    overflow: hidden;\n    /* stylelint-disable */\n    display: -webkit-box;\n    text-overflow: ellipsis;\n    -webkit-line-clamp: $max-line-count;\n    -webkit-box-orient: vertical;\n    /* stylelint-enable */\n}\n","@import \"../custom-medias\";\n\n/* ==========================================================================\n  Fonts\n  ========================================================================== */\n\n@define-mixin _font-karasuma $fontWeight: normal {\n  font-family: \"Karasuma\", sans-serif;\n  font-weight: $(fontWeight);\n}\n\n/* ==========================================================================\n  All typography variants\n\n  $unit - Either em or rem\n  ========================================================================== */\n\n@define-mixin typography-h1 $unit: rem {\n  @mixin _font-karasuma bolder;\n  font-size: 8$(unit);\n}\n\n@define-mixin typography-h2 $unit: rem {\n  @mixin _font-karasuma bold;\n  font-size: 4.8$(unit);\n}\n\n@define-mixin typography-body $unit: rem {\n  @mixin _font-karasuma;\n  font-size: 1.6$(unit);\n}\n\n@define-mixin typography-body $unit: rem {\n  @mixin _font-karasuma;\n  font-size: 1.6$(unit);\n}\n","@import \"../../styles/imports/index.css\";\n\n.header {\n  position: fixed;\n  top: calc(var(--header-frame-top) + var(--layout-padding));\n  left: 0;\n  width: 100vw;\n  height: var(--header-height);\n  z-index: var(--z-index-header);\n  padding: 0 var(--header-frame-top);\n  display: flex;\n  justify-content: center;\n}\n\n.content {\n  width: 100%;\n  max-width: var(--layout-max-width);\n  display: flex;\n  flex-direction: row;\n  justify-content: space-between;\n  align-items: center;\n}\n\n.name {\n  flex: 1 1 0;\n  font-size: 3.2rem;\n  cursor: default;\n\n  & > * {\n    font-weight: normal;\n    white-space: nowrap;\n  }\n\n  & b {\n    pointer-events: none;\n  }\n}\n\n.social {\n  display: flex;\n  flex: 1 1 0;\n  justify-content: flex-end;\n  user-select: none;\n\n  & a {\n    color: var(--color-white);\n\n    &:not(:first-child) {\n      margin-left: 3rem;\n    }\n\n    & svg {\n      height: 2.4rem;\n      transition: fill 0.2s ease-out;\n      fill: var(--color-white);\n    }\n\n    &:hover svg {\n      fill: var(--color-green);\n    }\n  }\n}\n\n.links {\n  display: flex;\n  user-select: none;\n\n  & > *:not(:first-child) {\n    margin-left: 5ch;\n  }\n}\n\n/* ==========================================================================\n   Custom medias\n   ========================================================================== */\n\n@media (--layout-lte-medium) {\n  .links {\n    display: none;\n  }\n}\n\n@media (--layout-lte-xsmall) {\n  .header {\n    top: 3rem;\n    padding: 0 2.5rem;\n  }\n\n  .name {\n    font-size: 6.5vw;\n  }\n}\n"]}]);
// Exports
exports.locals = {
	"header": "Header_header__36fEK",
	"content": "Header_content__nDQJf",
	"name": "Header_name__16TYA",
	"social": "Header_social__2Du7_",
	"links": "Header_links__1j8LT"
};
module.exports = exports;


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/index.js?!./www/shared/components/layout/Layout.module.css":
/*!***********************************************************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js??ref--5-oneOf-2-1!./node_modules/next/dist/compiled/postcss-loader??__nextjs_postcss!./www/shared/components/layout/Layout.module.css ***!
  \***********************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
exports = ___CSS_LOADER_API_IMPORT___(true);
// Module
exports.push([module.i, "/* ==========================================================================\n   Custom media queries\n\n   Use it like so: @media (--layout-small) { ... }\n   ========================================================================== */\n\n/* 375px */\n\n/* 480px */\n\n/* 768px */\n\n/* 1024px */\n\n/* 1280px */\n\n/* 1440px */\n\n/* 1920px */\n\n/* ==========================================================================\n   Colors\n   ========================================================================== */\n\n/* ==========================================================================\n   Z-Indexes\n   ========================================================================== */\n\n/* ==========================================================================\n   Sizes\n   ========================================================================== */\n\n/* ==========================================================================\n    Landscape\n    ========================================================================== */\n\n/* ==========================================================================\n    Portrait\n    ========================================================================== */\n\n/* ==========================================================================\n   Custom medias\n   ========================================================================== */\n\n/* MIXINS */\n\n/* ==========================================================================\n   Smooth & sharp mixins\n   ========================================================================== */\n\n/* ==========================================================================\n   Ellipsis mixin\n\n   The container needs to have a width for it to work\n   ========================================================================== */\n\n/* ==========================================================================\n  Fonts\n  ========================================================================== */\n\n/* ==========================================================================\n  All typography variants\n\n  $unit - Either em or rem\n  ========================================================================== */\n\n.Layout_layout__1b33Q {\n  position: absolute;\n  width: 100vw;\n  width: 100vw;\n  height: 100vh;\n  height: 100vh;\n  padding: 2.2rem;\n  padding: 2.2rem;\n  color: #fff;\n  color: #fff;\n}\n\n@media (max-width: 48em) {\n\n  .Layout_layout__1b33Q {\n  padding: 2vw;\n  }\n}\n\n.Layout_frame__3A9ng {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  border: 2.2rem solid #fff;\n  border: 2.2rem solid #fff;\n}\n\n@media (max-width: 48em) {\n\n  .Layout_frame__3A9ng {\n  border: 2vw solid #fff;\n  }\n}\n\n@media (max-width: 48em) {\n\n  .Layout_frame__3A9ng {\n  border: 2vw solid #fff;\n  }\n}\n\n.Layout_container__23RSi {\n  width: 100%;\n  height: 100%;\n  overflow-x: hidden;\n}\n\n.Layout_content__3Wwdu {\n  position: relative;\n  width: 100%;\n  height: 100%;\n  overflow-y: auto;\n  scroll-behavior: smooth;\n\n  /* Hide Scrollbar */\n  scrollbar-width: none; /* Firefox */\n  -ms-overflow-style: none /* IE, Edge */\n}\n\n.Layout_content__3Wwdu::-webkit-scrollbar {\n    display: none; /* Chrome, Safari, Opera */\n  }\n\n.Layout_progress__3VuyA {\n  position: absolute;\n  right: calc(2.2rem / 2);\n  right: calc(2.2rem / 2);\n  width: 0.2rem;\n  height: calc(100vh - (2.2rem * 2));\n  height: calc(100vh - (2.2rem * 2));\n  transform: translate(50%, 0);\n  background-color: #c1c5d4;\n  background-color: #c1c5d4\n}\n\n@media (max-width: 48em) {\n\n  .Layout_progress__3VuyA {\n  height: calc(100vh - (2vw * 2));\n  }\n}\n\n@media (max-width: 48em) {\n\n  .Layout_progress__3VuyA {\n  right: calc(2vw / 2);\n  }\n}\n\n.Layout_progress__3VuyA .Layout_percentage__-f0vS {\n    position: absolute;\n    width: 100%;\n    height: 100%;\n    transform: scaleY(1);\n    transform-origin: center top;\n    background-color: #191a1d;\n    background-color: #191a1d;\n  }\n\n.Layout_grain__262sJ {\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: 100vw;\n  width: 100vw;\n  height: 100vh;\n  height: 100vh;\n  padding: 2.2rem;\n  padding: 2.2rem;\n}\n\n@media (max-width: 48em) {\n\n  .Layout_grain__262sJ {\n  padding: 2vw;\n  }\n}\n", "",{"version":3,"sources":["C:/Users/paulo/Desktop/Work/Projects/Personal/Web/paulobmarcos/www/shared/styles/imports/custom-medias.css","C:/Users/paulo/Desktop/Work/Projects/Personal/Web/paulobmarcos/www/shared/styles/imports/variables.css","C:/Users/paulo/Desktop/Work/Projects/Personal/Web/paulobmarcos/www/shared/styles/imports/index.css","C:/Users/paulo/Desktop/Work/Projects/Personal/Web/paulobmarcos/www/shared/styles/imports/mixins/text.css","C:/Users/paulo/Desktop/Work/Projects/Personal/Web/paulobmarcos/www/shared/styles/imports/mixins/typography.css","C:/Users/paulo/Desktop/Work/Projects/Personal/Web/paulobmarcos/www/shared/components/layout/Layout.module.css"],"names":[],"mappings":"AAAA;;;;+EAI+E;;AAEtB,UAAU;;AAChB,UAAU;;AACX,UAAU;;AACT,WAAW;;AACZ,WAAW;;AACV,WAAW;;AACT,WAAW;;ACVhE;;+EAE+E;;AAa/E;;+EAE+E;;AAQ/E;;+EAE+E;;AAiB/E;;gFAEgF;;AAShF;;gFAEgF;;AAShF;;+EAE+E;;ACnE/E,WAAW;;ACHX;;+EAE+E;;AAY/E;;;;+EAI+E;;AChB/E;;8EAE8E;;AAO9E;;;;8EAI8E;;ACb9E;EACE,kBAAkB;EAClB,YAA0B;EAA1B,YAA0B;EAC1B,aAA4B;EAA5B,aAA4B;EAC5B,eAA8B;EAA9B,eAA8B;EAC9B,WAAyB;EAAzB,WAAyB;AAC3B;;AJgEA;;EItEA;EAIE,YAAA;EAEF;AJoEA;;AIlEA;EACE,kBAAkB;EAClB,MAAM;EACN,OAAO;EACP,WAAW;EACX,YAAY;EACZ,yBAAsD;EAAtD,yBAAsD;AACxD;;AJuDA;;EI9DA;EAME,sBAAA;EACF;AJ2DA;;AAJA;;EI9DA;EAME,sBAAA;EACF;AJ2DA;;AIzDA;EACE,WAAW;EACX,YAAY;EACZ,kBAAkB;AACpB;;AAEA;EACE,kBAAkB;EAClB,WAAW;EACX,YAAY;EACZ,gBAAgB;EAChB,uBAAuB;;EAEvB,mBAAmB;EACnB,qBAAqB,EAAE,YAAY;EACnC,uBAAwB,EAAE,aAAa;AAKzC;;AAHE;IACE,aAAa,EAAE,0BAA0B;EAC3C;;AAGF;EACE,kBAAkB;EAClB,uBAAsC;EAAtC,uBAAsC;EACtC,aAAa;EACb,kCAAiD;EAAjD,kCAAiD;EACjD,4BAA4B;EAC5B,yBAAyC;EAAzC;AAUF;;AJeA;;EI/BA;EAIE,+BAAA;EAYF;AJmBA;;AAJA;;EI/BA;EAEE,oBAAA;EAcF;AJmBA;;AI3BE;IACE,kBAAkB;IAClB,WAAW;IACX,YAAY;IACZ,oBAAoB;IACpB,4BAA4B;IAC5B,yBAAwC;IAAxC,yBAAwC;EAC1C;;AAGF;EACE,eAAe;EACf,MAAM;EACN,OAAO;EACP,YAA0B;EAA1B,YAA0B;EAC1B,aAA4B;EAA5B,aAA4B;EAC5B,eAA8B;EAA9B,eAA8B;AAChC;;AJMA;;EIbA;EAME,YAAA;EACF;AJUA","file":"Layout.module.css","sourcesContent":["/* ==========================================================================\n   Custom media queries\n\n   Use it like so: @media (--layout-small) { ... }\n   ========================================================================== */\n\n@custom-media --layout-lte-xxsmall (width <= 23.4375em); /* 375px */\n@custom-media --layout-lte-xsmall (width <= 30em); /* 480px */\n@custom-media --layout-lte-small (width <= 48em); /* 768px */\n@custom-media --layout-lte-medium (width <= 64em); /* 1024px */\n@custom-media --layout-lte-large (width <= 80em); /* 1280px */\n@custom-media --layout-lte-xlarge (width <= 90em); /* 1440px */\n@custom-media --layout-lte-xxlarge (width <= 120em); /* 1920px */\n","@import \"./custom-medias\";\n\n/* ==========================================================================\n   Colors\n   ========================================================================== */\n\n:root {\n  --color-white: #fff;\n  --color-black: #000;\n  --color-dark: #0f0f11;\n  --color-gray: #2d2e32;\n  --color-light-gray: #c1c5d4;\n  --color-dark-gray: #191a1d;\n  --color-green: #64f4ac;\n  --color-green-dark: #286144;\n}\n\n/* ==========================================================================\n   Z-Indexes\n   ========================================================================== */\n\n:root {\n  --z-index-base: 1;\n  --z-index-header: 5;\n  --z-index-frame: 6;\n}\n\n/* ==========================================================================\n   Sizes\n   ========================================================================== */\n\n:root {\n  --layout-width: 100vw;\n  --layout-height: 100vh;\n  --layout-max-width: 150rem;\n  --layout-padding: 2.2rem;\n\n  --header-height: 4rem;\n  --header-frame-top: calc(var(--layout-padding) * 2);\n\n  --content-viewport-height: calc(100vh - (var(--layout-padding) * 2));\n\n  --carousel-item-width: 60vw;\n  --carousel-item-height: 30vw;\n}\n\n/* ==========================================================================\n    Landscape\n    ========================================================================== */\n\n@media (orientation: landscape) {\n  :root {\n    --carousel-item-width: 60vw;\n    --carousel-item-height: 33vw;\n  }\n}\n\n/* ==========================================================================\n    Portrait\n    ========================================================================== */\n\n@media (orientation: portrait) {\n  :root {\n    --carousel-item-width: 80vw;\n    --carousel-item-height: 80vw;\n  }\n}\n\n/* ==========================================================================\n   Custom medias\n   ========================================================================== */\n\n@media (--layout-lte-small) {\n  :root {\n    --layout-padding: 2vw;\n  }\n}\n","@import \"./custom-medias.css\";\n@import \"./variables.css\";\n\n/* MIXINS */\n@import \"./mixins/text.css\";\n@import \"./mixins/typography.css\";\n@import \"./mixins/unstyled-button.css\";\n","/* ==========================================================================\n   Smooth & sharp mixins\n   ========================================================================== */\n\n@define-mixin text-smooth {\n    -moz-osx-font-smoothing: grayscale;  /* Font smoothing tweaks for MacOSx in Gecko */\n    -webkit-font-smoothing: antialiased; /* Font smoothing tweaks for MacOSx in Webkit */\n}\n\n@define-mixin text-sharp {\n    -moz-osx-font-smoothing: initial;   /* Turn off font smoothing tweaks for MacOSx in Gecko */\n    -webkit-font-smoothing: initial;    /* Turn off font smoothing tweaks for MacOSx in Webkit */\n}\n\n/* ==========================================================================\n   Ellipsis mixin\n\n   The container needs to have a width for it to work\n   ========================================================================== */\n\n@define-mixin text-ellipsis {\n    overflow: hidden; /* \"overflow\" value must be different from \"visible\" */\n    text-overflow: ellipsis;\n    white-space: nowrap;\n    overflow-wrap: normal;\n}\n\n@define-mixin text-ellipsis-multiline $max-line-count, $max-height {\n    max-height: $max-height;\n    overflow: hidden;\n    /* stylelint-disable */\n    display: -webkit-box;\n    text-overflow: ellipsis;\n    -webkit-line-clamp: $max-line-count;\n    -webkit-box-orient: vertical;\n    /* stylelint-enable */\n}\n","@import \"../custom-medias\";\n\n/* ==========================================================================\n  Fonts\n  ========================================================================== */\n\n@define-mixin _font-karasuma $fontWeight: normal {\n  font-family: \"Karasuma\", sans-serif;\n  font-weight: $(fontWeight);\n}\n\n/* ==========================================================================\n  All typography variants\n\n  $unit - Either em or rem\n  ========================================================================== */\n\n@define-mixin typography-h1 $unit: rem {\n  @mixin _font-karasuma bolder;\n  font-size: 8$(unit);\n}\n\n@define-mixin typography-h2 $unit: rem {\n  @mixin _font-karasuma bold;\n  font-size: 4.8$(unit);\n}\n\n@define-mixin typography-body $unit: rem {\n  @mixin _font-karasuma;\n  font-size: 1.6$(unit);\n}\n\n@define-mixin typography-body $unit: rem {\n  @mixin _font-karasuma;\n  font-size: 1.6$(unit);\n}\n","@import \"../../styles/imports/index.css\";\n\n.layout {\n  position: absolute;\n  width: var(--layout-width);\n  height: var(--layout-height);\n  padding: var(--layout-padding);\n  color: var(--color-white);\n}\n\n.frame {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  border: var(--layout-padding) solid var(--color-white);\n}\n\n.container {\n  width: 100%;\n  height: 100%;\n  overflow-x: hidden;\n}\n\n.content {\n  position: relative;\n  width: 100%;\n  height: 100%;\n  overflow-y: auto;\n  scroll-behavior: smooth;\n\n  /* Hide Scrollbar */\n  scrollbar-width: none; /* Firefox */\n  -ms-overflow-style: none; /* IE, Edge */\n\n  &::-webkit-scrollbar {\n    display: none; /* Chrome, Safari, Opera */\n  }\n}\n\n.progress {\n  position: absolute;\n  right: calc(var(--layout-padding) / 2);\n  width: 0.2rem;\n  height: calc(100vh - (var(--layout-padding) * 2));\n  transform: translate(50%, 0);\n  background-color: var(--color-light-gray);\n\n  & .percentage {\n    position: absolute;\n    width: 100%;\n    height: 100%;\n    transform: scaleY(1);\n    transform-origin: center top;\n    background-color: var(--color-dark-gray);\n  }\n}\n\n.grain {\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: var(--layout-width);\n  height: var(--layout-height);\n  padding: var(--layout-padding);\n}\n"]}]);
// Exports
exports.locals = {
	"layout": "Layout_layout__1b33Q",
	"frame": "Layout_frame__3A9ng",
	"container": "Layout_container__23RSi",
	"content": "Layout_content__3Wwdu",
	"progress": "Layout_progress__3VuyA",
	"percentage": "Layout_percentage__-f0vS",
	"grain": "Layout_grain__262sJ"
};
module.exports = exports;


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/index.js?!./www/shared/components/link/Link.module.css":
/*!*******************************************************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js??ref--5-oneOf-2-1!./node_modules/next/dist/compiled/postcss-loader??__nextjs_postcss!./www/shared/components/link/Link.module.css ***!
  \*******************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
exports = ___CSS_LOADER_API_IMPORT___(true);
// Module
exports.push([module.i, "/* ==========================================================================\n   Custom media queries\n\n   Use it like so: @media (--layout-small) { ... }\n   ========================================================================== */\n\n/* 375px */\n\n/* 480px */\n\n/* 768px */\n\n/* 1024px */\n\n/* 1280px */\n\n/* 1440px */\n\n/* 1920px */\n\n/* ==========================================================================\n   Colors\n   ========================================================================== */\n\n/* ==========================================================================\n   Z-Indexes\n   ========================================================================== */\n\n/* ==========================================================================\n   Sizes\n   ========================================================================== */\n\n/* ==========================================================================\n    Landscape\n    ========================================================================== */\n\n/* ==========================================================================\n    Portrait\n    ========================================================================== */\n\n/* ==========================================================================\n   Custom medias\n   ========================================================================== */\n\n/* MIXINS */\n\n/* ==========================================================================\n   Smooth & sharp mixins\n   ========================================================================== */\n\n/* ==========================================================================\n   Ellipsis mixin\n\n   The container needs to have a width for it to work\n   ========================================================================== */\n\n/* ==========================================================================\n  Fonts\n  ========================================================================== */\n\n/* ==========================================================================\n  All typography variants\n\n  $unit - Either em or rem\n  ========================================================================== */\n\n.Link_link__2tPzf {\n  position: relative;\n  color: inherit;\n  font-weight: bold;\n  text-decoration: none\n}\n\n.Link_link__2tPzf::before {\n    position: absolute;\n    opacity: 0;\n    color: #64f4ac;\n    color: #64f4ac;\n    transition: all 0.1s ease-out;\n  }\n\n.Link_link__2tPzf::after {\n    position: absolute;\n    opacity: 0;\n    color: #64f4ac;\n    color: #64f4ac;\n    transition: all 0.1s ease-out;\n  }\n\n.Link_link__2tPzf::before {\n    content: \"<\";\n    top: 0;\n    left: -1ch;\n    transform: translateY(-50%);\n  }\n\n.Link_link__2tPzf::after {\n    content: \" />\";\n    top: 0.1rem;\n    right: 0;\n    transform: translate(100%, 50%);\n    white-space: pre;\n  }\n\n.Link_link__2tPzf:hover::before,\n    .Link_link__2tPzf:hover::after {\n      opacity: 1;\n    }\n\n.Link_link__2tPzf:hover::before {\n      transform: translateY(0);\n    }\n\n.Link_link__2tPzf:hover::after {\n      transform: translate(100%, 0);\n    }\n", "",{"version":3,"sources":["C:/Users/paulo/Desktop/Work/Projects/Personal/Web/paulobmarcos/www/shared/styles/imports/custom-medias.css","C:/Users/paulo/Desktop/Work/Projects/Personal/Web/paulobmarcos/www/shared/styles/imports/variables.css","C:/Users/paulo/Desktop/Work/Projects/Personal/Web/paulobmarcos/www/shared/styles/imports/index.css","C:/Users/paulo/Desktop/Work/Projects/Personal/Web/paulobmarcos/www/shared/styles/imports/mixins/text.css","C:/Users/paulo/Desktop/Work/Projects/Personal/Web/paulobmarcos/www/shared/styles/imports/mixins/typography.css","C:/Users/paulo/Desktop/Work/Projects/Personal/Web/paulobmarcos/www/shared/components/link/Link.module.css"],"names":[],"mappings":"AAAA;;;;+EAI+E;;AAEtB,UAAU;;AAChB,UAAU;;AACX,UAAU;;AACT,WAAW;;AACZ,WAAW;;AACV,WAAW;;AACT,WAAW;;ACVhE;;+EAE+E;;AAa/E;;+EAE+E;;AAQ/E;;+EAE+E;;AAiB/E;;gFAEgF;;AAShF;;gFAEgF;;AAShF;;+EAE+E;;ACnE/E,WAAW;;ACHX;;+EAE+E;;AAY/E;;;;+EAI+E;;AChB/E;;8EAE8E;;AAO9E;;;;8EAI8E;;ACb9E;EACE,kBAAkB;EAClB,cAAc;EACd,iBAAiB;EACjB;AAuCF;;AArCE;IAEE,kBAAkB;IAClB,UAAU;IACV,cAAyB;IAAzB,cAAyB;IACzB,6BAA6B;EAC/B;;AANA;IAEE,kBAAkB;IAClB,UAAU;IACV,cAAyB;IAAzB,cAAyB;IACzB,6BAA6B;EAC/B;;AAEA;IACE,YAAY;IACZ,MAAM;IACN,UAAU;IACV,2BAA2B;EAC7B;;AAEA;IACE,cAAc;IACd,WAAW;IACX,QAAQ;IACR,+BAA+B;IAC/B,gBAAgB;EAClB;;AAGE;;MAEE,UAAU;IACZ;;AAEA;MACE,wBAAwB;IAC1B;;AAEA;MACE,6BAA6B;IAC/B","file":"Link.module.css","sourcesContent":["/* ==========================================================================\n   Custom media queries\n\n   Use it like so: @media (--layout-small) { ... }\n   ========================================================================== */\n\n@custom-media --layout-lte-xxsmall (width <= 23.4375em); /* 375px */\n@custom-media --layout-lte-xsmall (width <= 30em); /* 480px */\n@custom-media --layout-lte-small (width <= 48em); /* 768px */\n@custom-media --layout-lte-medium (width <= 64em); /* 1024px */\n@custom-media --layout-lte-large (width <= 80em); /* 1280px */\n@custom-media --layout-lte-xlarge (width <= 90em); /* 1440px */\n@custom-media --layout-lte-xxlarge (width <= 120em); /* 1920px */\n","@import \"./custom-medias\";\n\n/* ==========================================================================\n   Colors\n   ========================================================================== */\n\n:root {\n  --color-white: #fff;\n  --color-black: #000;\n  --color-dark: #0f0f11;\n  --color-gray: #2d2e32;\n  --color-light-gray: #c1c5d4;\n  --color-dark-gray: #191a1d;\n  --color-green: #64f4ac;\n  --color-green-dark: #286144;\n}\n\n/* ==========================================================================\n   Z-Indexes\n   ========================================================================== */\n\n:root {\n  --z-index-base: 1;\n  --z-index-header: 5;\n  --z-index-frame: 6;\n}\n\n/* ==========================================================================\n   Sizes\n   ========================================================================== */\n\n:root {\n  --layout-width: 100vw;\n  --layout-height: 100vh;\n  --layout-max-width: 150rem;\n  --layout-padding: 2.2rem;\n\n  --header-height: 4rem;\n  --header-frame-top: calc(var(--layout-padding) * 2);\n\n  --content-viewport-height: calc(100vh - (var(--layout-padding) * 2));\n\n  --carousel-item-width: 60vw;\n  --carousel-item-height: 30vw;\n}\n\n/* ==========================================================================\n    Landscape\n    ========================================================================== */\n\n@media (orientation: landscape) {\n  :root {\n    --carousel-item-width: 60vw;\n    --carousel-item-height: 33vw;\n  }\n}\n\n/* ==========================================================================\n    Portrait\n    ========================================================================== */\n\n@media (orientation: portrait) {\n  :root {\n    --carousel-item-width: 80vw;\n    --carousel-item-height: 80vw;\n  }\n}\n\n/* ==========================================================================\n   Custom medias\n   ========================================================================== */\n\n@media (--layout-lte-small) {\n  :root {\n    --layout-padding: 2vw;\n  }\n}\n","@import \"./custom-medias.css\";\n@import \"./variables.css\";\n\n/* MIXINS */\n@import \"./mixins/text.css\";\n@import \"./mixins/typography.css\";\n@import \"./mixins/unstyled-button.css\";\n","/* ==========================================================================\n   Smooth & sharp mixins\n   ========================================================================== */\n\n@define-mixin text-smooth {\n    -moz-osx-font-smoothing: grayscale;  /* Font smoothing tweaks for MacOSx in Gecko */\n    -webkit-font-smoothing: antialiased; /* Font smoothing tweaks for MacOSx in Webkit */\n}\n\n@define-mixin text-sharp {\n    -moz-osx-font-smoothing: initial;   /* Turn off font smoothing tweaks for MacOSx in Gecko */\n    -webkit-font-smoothing: initial;    /* Turn off font smoothing tweaks for MacOSx in Webkit */\n}\n\n/* ==========================================================================\n   Ellipsis mixin\n\n   The container needs to have a width for it to work\n   ========================================================================== */\n\n@define-mixin text-ellipsis {\n    overflow: hidden; /* \"overflow\" value must be different from \"visible\" */\n    text-overflow: ellipsis;\n    white-space: nowrap;\n    overflow-wrap: normal;\n}\n\n@define-mixin text-ellipsis-multiline $max-line-count, $max-height {\n    max-height: $max-height;\n    overflow: hidden;\n    /* stylelint-disable */\n    display: -webkit-box;\n    text-overflow: ellipsis;\n    -webkit-line-clamp: $max-line-count;\n    -webkit-box-orient: vertical;\n    /* stylelint-enable */\n}\n","@import \"../custom-medias\";\n\n/* ==========================================================================\n  Fonts\n  ========================================================================== */\n\n@define-mixin _font-karasuma $fontWeight: normal {\n  font-family: \"Karasuma\", sans-serif;\n  font-weight: $(fontWeight);\n}\n\n/* ==========================================================================\n  All typography variants\n\n  $unit - Either em or rem\n  ========================================================================== */\n\n@define-mixin typography-h1 $unit: rem {\n  @mixin _font-karasuma bolder;\n  font-size: 8$(unit);\n}\n\n@define-mixin typography-h2 $unit: rem {\n  @mixin _font-karasuma bold;\n  font-size: 4.8$(unit);\n}\n\n@define-mixin typography-body $unit: rem {\n  @mixin _font-karasuma;\n  font-size: 1.6$(unit);\n}\n\n@define-mixin typography-body $unit: rem {\n  @mixin _font-karasuma;\n  font-size: 1.6$(unit);\n}\n","@import \"../../styles/imports/index.css\";\n\n.link {\n  position: relative;\n  color: inherit;\n  font-weight: bold;\n  text-decoration: none;\n\n  &::before,\n  &::after {\n    position: absolute;\n    opacity: 0;\n    color: var(--color-green);\n    transition: all 0.1s ease-out;\n  }\n\n  &::before {\n    content: \"<\";\n    top: 0;\n    left: -1ch;\n    transform: translateY(-50%);\n  }\n\n  &::after {\n    content: \" />\";\n    top: 0.1rem;\n    right: 0;\n    transform: translate(100%, 50%);\n    white-space: pre;\n  }\n\n  &:hover {\n    &::before,\n    &::after {\n      opacity: 1;\n    }\n\n    &::before {\n      transform: translateY(0);\n    }\n\n    &::after {\n      transform: translate(100%, 0);\n    }\n  }\n}\n"]}]);
// Exports
exports.locals = {
	"link": "Link_link__2tPzf"
};
module.exports = exports;


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/index.js?!./www/shared/styles/global/index.css":
/*!***********************************************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js??ref--5-oneOf-5-1!./node_modules/next/dist/compiled/postcss-loader??__nextjs_postcss!./www/shared/styles/global/index.css ***!
  \***********************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
exports = ___CSS_LOADER_API_IMPORT___(true);
// Module
exports.push([module.i, "/*! normalize.css v8.0.1 | MIT License | github.com/necolas/normalize.css */\n\n/* Document\n   ========================================================================== */\n\n/**\n * 1. Correct the line height in all browsers.\n * 2. Prevent adjustments of font size after orientation changes in iOS.\n */\n\nhtml {\n  line-height: 1.15; /* 1 */\n  -webkit-text-size-adjust: 100%; /* 2 */\n}\n\n/* Sections\n   ========================================================================== */\n\n/**\n * Remove the margin in all browsers.\n */\n\nbody {\n  margin: 0;\n}\n\n/**\n * Render the `main` element consistently in IE.\n */\n\nmain {\n  display: block;\n}\n\n/**\n * Correct the font size and margin on `h1` elements within `section` and\n * `article` contexts in Chrome, Firefox, and Safari.\n */\n\nh1 {\n  font-size: 2em;\n  margin: 0.67em 0;\n}\n\n/* Grouping content\n   ========================================================================== */\n\n/**\n * 1. Add the correct box sizing in Firefox.\n * 2. Show the overflow in Edge and IE.\n */\n\nhr {\n  box-sizing: content-box; /* 1 */\n  height: 0; /* 1 */\n  overflow: visible; /* 2 */\n}\n\n/**\n * 1. Correct the inheritance and scaling of font size in all browsers.\n * 2. Correct the odd `em` font sizing in all browsers.\n */\n\npre {\n  font-family: monospace, monospace; /* 1 */\n  font-size: 1em; /* 2 */\n}\n\n/* Text-level semantics\n   ========================================================================== */\n\n/**\n * Remove the gray background on active links in IE 10.\n */\n\na {\n  background-color: transparent;\n}\n\n/**\n * 1. Remove the bottom border in Chrome 57-\n * 2. Add the correct text decoration in Chrome, Edge, IE, Opera, and Safari.\n */\n\nabbr[title] {\n  border-bottom: none; /* 1 */\n  text-decoration: underline; /* 2 */\n  -webkit-text-decoration: underline dotted;\n          text-decoration: underline dotted; /* 2 */\n}\n\n/**\n * Add the correct font weight in Chrome, Edge, and Safari.\n */\n\nb,\nstrong {\n  font-weight: bolder;\n}\n\n/**\n * 1. Correct the inheritance and scaling of font size in all browsers.\n * 2. Correct the odd `em` font sizing in all browsers.\n */\n\ncode,\nkbd,\nsamp {\n  font-family: monospace, monospace; /* 1 */\n  font-size: 1em; /* 2 */\n}\n\n/**\n * Add the correct font size in all browsers.\n */\n\nsmall {\n  font-size: 80%;\n}\n\n/**\n * Prevent `sub` and `sup` elements from affecting the line height in\n * all browsers.\n */\n\nsub,\nsup {\n  font-size: 75%;\n  line-height: 0;\n  position: relative;\n  vertical-align: baseline;\n}\n\nsub {\n  bottom: -0.25em;\n}\n\nsup {\n  top: -0.5em;\n}\n\n/* Embedded content\n   ========================================================================== */\n\n/**\n * Remove the border on images inside links in IE 10.\n */\n\nimg {\n  border-style: none;\n}\n\n/* Forms\n   ========================================================================== */\n\n/**\n * 1. Change the font styles in all browsers.\n * 2. Remove the margin in Firefox and Safari.\n */\n\nbutton,\ninput,\noptgroup,\nselect,\ntextarea {\n  font-family: inherit; /* 1 */\n  font-size: 100%; /* 1 */\n  line-height: 1.15; /* 1 */\n  margin: 0; /* 2 */\n}\n\n/**\n * Show the overflow in IE.\n * 1. Show the overflow in Edge.\n */\n\nbutton,\ninput { /* 1 */\n  overflow: visible;\n}\n\n/**\n * Remove the inheritance of text transform in Edge, Firefox, and IE.\n * 1. Remove the inheritance of text transform in Firefox.\n */\n\nbutton,\nselect { /* 1 */\n  text-transform: none;\n}\n\n/**\n * Correct the inability to style clickable types in iOS and Safari.\n */\n\nbutton,\n[type=\"button\"],\n[type=\"reset\"],\n[type=\"submit\"] {\n  -webkit-appearance: button;\n}\n\n/**\n * Remove the inner border and padding in Firefox.\n */\n\nbutton::-moz-focus-inner,\n[type=\"button\"]::-moz-focus-inner,\n[type=\"reset\"]::-moz-focus-inner,\n[type=\"submit\"]::-moz-focus-inner {\n  border-style: none;\n  padding: 0;\n}\n\n/**\n * Restore the focus styles unset by the previous rule.\n */\n\nbutton:-moz-focusring,\n[type=\"button\"]:-moz-focusring,\n[type=\"reset\"]:-moz-focusring,\n[type=\"submit\"]:-moz-focusring {\n  outline: 1px dotted ButtonText;\n}\n\n/**\n * Correct the padding in Firefox.\n */\n\nfieldset {\n  padding: 0.35em 0.75em 0.625em;\n}\n\n/**\n * 1. Correct the text wrapping in Edge and IE.\n * 2. Correct the color inheritance from `fieldset` elements in IE.\n * 3. Remove the padding so developers are not caught out when they zero out\n *    `fieldset` elements in all browsers.\n */\n\nlegend {\n  box-sizing: border-box; /* 1 */\n  color: inherit; /* 2 */\n  display: table; /* 1 */\n  max-width: 100%; /* 1 */\n  padding: 0; /* 3 */\n  white-space: normal; /* 1 */\n}\n\n/**\n * Add the correct vertical alignment in Chrome, Firefox, and Opera.\n */\n\nprogress {\n  vertical-align: baseline;\n}\n\n/**\n * Remove the default vertical scrollbar in IE 10+.\n */\n\ntextarea {\n  overflow: auto;\n}\n\n/**\n * 1. Add the correct box sizing in IE 10.\n * 2. Remove the padding in IE 10.\n */\n\n[type=\"checkbox\"],\n[type=\"radio\"] {\n  box-sizing: border-box; /* 1 */\n  padding: 0; /* 2 */\n}\n\n/**\n * Correct the cursor style of increment and decrement buttons in Chrome.\n */\n\n[type=\"number\"]::-webkit-inner-spin-button,\n[type=\"number\"]::-webkit-outer-spin-button {\n  height: auto;\n}\n\n/**\n * 1. Correct the odd appearance in Chrome and Safari.\n * 2. Correct the outline style in Safari.\n */\n\n[type=\"search\"] {\n  -webkit-appearance: textfield; /* 1 */\n  outline-offset: -2px; /* 2 */\n}\n\n/**\n * Remove the inner padding in Chrome and Safari on macOS.\n */\n\n[type=\"search\"]::-webkit-search-decoration {\n  -webkit-appearance: none;\n}\n\n/**\n * 1. Correct the inability to style clickable types in iOS and Safari.\n * 2. Change font properties to `inherit` in Safari.\n */\n\n::-webkit-file-upload-button {\n  -webkit-appearance: button; /* 1 */\n  font: inherit; /* 2 */\n}\n\n/* Interactive\n   ========================================================================== */\n\n/*\n * Add the correct display in Edge, IE 10+, and Firefox.\n */\n\ndetails {\n  display: block;\n}\n\n/*\n * Add the correct display in all browsers.\n */\n\nsummary {\n  display: list-item;\n}\n\n/* Misc\n   ========================================================================== */\n\n/**\n * Add the correct display in IE 10+.\n */\n\ntemplate {\n  display: none;\n}\n\n/**\n * Add the correct display in IE 10.\n */\n\n[hidden] {\n  display: none;\n}\n\n.rc-wrapper,\n.rc,\n.rc-slider {\n    position: relative;\n}\n\n.rc {\n    overflow-x: auto;\n    -webkit-overflow-scrolling: touch;\n}\n\n.rc.-no-scroll {\n    overflow-x: hidden;\n}\n\n.rc-slider {\n    width: -webkit-fit-content;\n    width: -moz-fit-content;\n    width: fit-content;\n    white-space: nowrap;\n}\n\n.rc-slide {\n    display: inline-block;\n}\n\n.rc-slide:hover {\n    cursor: pointer;\n}\n\n.rc-slider.-draggable:hover {\n    cursor: -webkit-grab;\n    cursor: grab;\n}\n\n.rc-slider.-draggable.-dragging,\n.rc-slider.-draggable.-dragging .rc-slide {\n    cursor: -webkit-grabbing;\n    cursor: grabbing;\n}\n\n.rc-arrow {\n    position:  absolute;\n    top: 50%;\n    transform: translateY(-50%);\n}\n\n.rc-arrow.-left { left: 15px; }\n\n.rc-arrow.-right { right: 15px; }\n\n.rc-dots {\n    display: flex;\n    align-items: center;\n    justify-content: center;\n}\n\n.rc-dot {\n    margin: 0 5px;\n    opacity: 0.5;\n}\n\n.rc-dot.-current {\n    opacity: 1;\n}\n\n/* Internal */\n\n/* ==========================================================================\n   Custom media queries\n\n   Use it like so: @media (--layout-small) { ... }\n   ========================================================================== */\n\n/* 375px */\n\n/* 480px */\n\n/* 768px */\n\n/* 1024px */\n\n/* 1280px */\n\n/* 1440px */\n\n/* 1920px */\n\n/* ==========================================================================\n   Colors\n   ========================================================================== */\n\n/* ==========================================================================\n   Z-Indexes\n   ========================================================================== */\n\n/* ==========================================================================\n   Sizes\n   ========================================================================== */\n\n/* ==========================================================================\n    Landscape\n    ========================================================================== */\n\n/* ==========================================================================\n    Portrait\n    ========================================================================== */\n\n/* ==========================================================================\n   Custom medias\n   ========================================================================== */\n\n/* ==========================================================================\n   Proper box-sizing model\n   ========================================================================== */\n\n*,\n*::before,\n*::after {\n    box-sizing: border-box;\n}\n\n/* ==========================================================================\n   Document\n   ========================================================================== */\n\n/*\n   1. Stretch <html> stretch to fill our screen height\n   2. Make children of html (body) occupy at least 100% of the screen\n   3. Viewport is scalable and occupies at least 320px (iPhone SE)\n*/\n\nhtml {\n    min-width: 32em;\n    height: 0; /* 3 */\n    min-height: 100%; /* 1 */\n    display: flex; /* 2 */\n    flex-direction: column; /* 2 */\n}\n\n/* ==========================================================================\n   Body & #root\n   ========================================================================== */\n\nbody {\n    display: flex;\n    flex: 1 0 auto;\n    flex-direction: column;\n}\n\n:global(#__next) {\n    display: flex;\n    flex: 1 0 auto;\n    flex-direction: column;\n}\n\n/* ==========================================================================\n  Fonts\n  ========================================================================== */\n\n/* ==========================================================================\n  All typography variants\n\n  $unit - Either em or rem\n  ========================================================================== */\n\n/* ==========================================================================\n   Smooth & sharp mixins\n   ========================================================================== */\n\n/* ==========================================================================\n   Ellipsis mixin\n\n   The container needs to have a width for it to work\n   ========================================================================== */\n\n/* ==========================================================================\n   Typography Defaults\n   ========================================================================== */\n\nhtml {\n  font-size: 62.5%; /* 62.5% so that all the REM measurements re based on 10px sizing */\n}\n\nbody {\n  font-family: \"Karasuma\", sans-serif;\n  font-weight: normal;\n  font-size: 1.6rem;\n  -moz-osx-font-smoothing: grayscale;\n  /* Font smoothing tweaks for MacOSx in Gecko */\n  -webkit-font-smoothing: antialiased;\n  /* Font smoothing tweaks for MacOSx in Webkit */\n\n  overflow-wrap: break-word;  /* Break long words by default */\n  -webkit-tap-highlight-color: transparent;  /* Do not show a highlight (rectangle around the link) while tapping it */\n}\n\n/* ==========================================================================\n  Headings\n  ========================================================================== */\n\nh1,\nh2,\nh3,\nh4 {\n  margin: 0.7em 0;\n}\n\nh1 {\n  font-family: \"Karasuma\", sans-serif;\n  font-weight: bolder;\n  font-size: 8rem;\n}\n\nh2 {\n  font-family: \"Karasuma\", sans-serif;\n  font-weight: bold;\n  font-size: 4.8rem;\n}\n\n/* ================================================================================\n  Fonts\n  If you are going to include custom fonts please use the /www/shared/media/fonts\n  directory.\n  ================================================================================ */\n\n/* stylelint-disable scale-unlimited/declaration-strict-value */\n\n@font-face {\n  font-family: \"Karasuma\";\n  font-weight: normal;\n  font-style: normal;\n  font-display: swap;\n  src: url(\"data:font/woff2;base64,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\") format(\"woff2\");\n}\n\n@font-face {\n  font-family: \"Karasuma\";\n  font-weight: bold;\n  font-style: normal;\n  font-display: swap;\n  src: url(\"data:font/woff2;base64,d09GMgABAAAAAFRsAA4AAAABIHgAAFQQAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGoFcG+VSHIGQIAZgAINwEQgKgfdMgb4hC4YmAAE2AiQDjEgEIAWWFgehEhuw/1eoefdfJWzoPLP0lUwek3UJ86wPDnWziue2JayjEUlJa6uy////T00qY+zfdRcuhkhYZiVE7uJgccWUKRF5VVFy3oCLB6D4owjVUssuqWRp0Ml69PyUsAxw+vRU1CynHGCZXU0JlNd7b/koEtQuLpf+iCN2l3Z/RlljO+WlFiFeb+lg+DlS3SRW2DnDLCNC0rBzwnqg70VS1d/JnbrZ04QZNXMnfNM8CEnDs93himp3ddcGaUhO4NMNyC/m/G8ViLPbdaGpM9FYdSNwElTzZ93lobv6K9cLohDSfE3q8GdIM1kExi121Jl5eR7qz/5/7apT6aR1lfSD0nkGhzI/RpBn30MI/QM/t97/C8bIFMmBAYyqMcYYMHJjhEqMGqNHCS3RIgLSBliEIm2AjYhRDNHzFO84QQ85QfQEo+gpD959l8tMwao1qnjhi2hzZatd5WhkNhFqk2H79aFFaDwRNiHSiC+iXUdGNbZYI9q4nuqrLaIT9/MXjQPaPcIBTjEq8lf89G5+f04EOTNDStndJ+Z/ar+ZmUDulhrQlmtCclYS+jS0732qaUhW/VcUcWSwlMKfuq+OzO0jUwt+U0UtAvzn1/qdO+Jv1FdcIho6iZxoiZB/asvz+HvdlZ3MoRCK4Njq+a9QFZoZj3EYuRRpPL7xdYwdv975a+13RxSbzpChS4iEsre4Z9uQyYRGJBQRffK/r5wgnsQG59V6h9heAoTNl4indj+z774OI0pJykISjWxz0BKlEDopwTVjoheRh4eQRgbvbkQnu/o1S5FJ5tKlMSlTpku3pckYCbj7O/9vv4CMxSdGq/VXXlWd3gDL2IMWXo6QBrTv4jGQGywS64v/tAUAV7OkHaBNLFvJlp7r5cnwBVU40IJO7EKeYykHyNc88GBU6dlLTZoFn7sytUynueRzWcQZynmWfqtAGV85CfLkTaxIofxs7xKL2dklF9gzAJZULXBvaM7APL9A83osQN6D5DncybwxhnIe4N077zJZHxofGpdESmPjQ4UK0kj/t1Zpp3a2Xweoj2WAHD8/S7PvVAgssD363dOVmtqavmzvwUwd8RxvCKahunt4YY5RhR0AyAgZFXU2qIB0ohLhkud33QHKfREq71RibKyJlOHhn3uV/3jnZnpE4/qyRxdQzYpY0DGPh61WgbpXy/P8n8y3d+2/LCDf2f6sSWmBWeJYMIUDaacS9UNoJz+Vl4JZ5aH5LP5ZFl9KA5pMlP9tzQEObGDz+9ZWz3+F2HbBY2TOHEiBTLo50YS8TkkRc/tHvYTmfvQjhJJ2D3HBibuNRTnK2T0N1N4TsUSEiHgyiMgwiEh0z3usDaG1gSOnGPlb9TDm6qjs1q6+rZsVyEhRFLG631Y2w5VSrOghxohMZJDB8vgo2y3/lgswC0ChDVEEUawCqlIlRJV6qAYNEAe0QrVphzioA6rTUYhjuqF69ED0GoIaNgwx4gLUmHGIi65CXXMN4rrrUBMmIG6YhLrpJ8Qvv6B+pyDZILrQbBg9SDYKCZqNow/JJtkKzebZDsmWMYVm+8RAckmx0FxWKSR3VQ+FANN0mUIP+EVZQPKKvzYHJGEBS09ALv/UOUAAAgQWigBFnDkPkp1ggac1AtDnmFl7F525Ol95yr8g0VPmj2x7dnh//BIGaw7sm8ZA0wYZd3vLKZQ9Zt8TBeMvp7X/1oSovyhNVQaRF02Zi1JJDcvvJ5WtrHySdVCQjxWo9YoN90r9cj+gjeDcN89YoY9BrUYaH1HTbCtMBgz4Zncm42eo/zPPFcJPAHtds+Nql9yEj2xYGT7j7VUnRK2co8P6R9kD2u781iT7yqVsMAi6Hf7sQjTDIRBFJEGSFGkyZMlRokyFKnVatOki0bfFNtsZMmKMzIQpM+asWLNhy449B46c0Lhyx+TJizcf/gLtsFOwMOEixYiXIJlAqoxylClLtjz5ihQrUapMuQpVau3X4IBGTZq1aGWybNmHHHZEB565fgMGDRlx3gVjrrpugqP/WzXvH4teW/LWqvV8lwXiM9qjyWq9OV9/ECRFMyzHC6brhdX5cqMZluOpEDhfgX+yFgOvs9ZZWnAJYsIql03ANmafsSOxMxGcSIgJCsmLdWRcTVxPzOdYzLEUextPB88MzxzPm+ZD86WxaGyaH41D86cF0AJp0QSlJpQCRHwCWz3lfKq9o9ZL6tXTbgLna2nhWvr3WsKzYjIxw4ANGbZkrMYwrOrJVG+1elhWITKFCPKtFoJn9YJML9AiryJvIqu94AqfSzQiVcB0AbMVKZaj1F7KtVOpSNUWatVRr92mhEZicw7dFMM02gl6hBFyDbmFmCF2KCAWFUoMFKeUpJSmlKWUp1SkVKYcixyPnIicjHRFuiM9kd7QqdDpUF/oTGjIuOHQaOhs6FzofOhCaDw0FXp1ud5crtUCfsCCpcXxDpUTGmd0LhhcucmBWoFKS6BFZKlm6OaxaiWbDNsMu1z2ORwCxXlK8pTmKctTnqciT2WejhzzaYtpBG1PAAAAAACA4QDDSdD6jblaFawqKymUHa00QcRi0qHwWNL5UiPZgYXIv5F11ovLMIyiWpBsKyllbc5mWq5sdvKSdUXpmaLBFeN60qXbcwSQyEaybaRU86c1dBKOZGQ0JwWyWdFqtkVbfj4iElB/H73pkSAMs5huNjGCThyumZTHfpPh8VvFbDrEtvt2hIIbXIXrw+fz/JNrMeF18yqWdRMjqOGElmVGojO5qV8+RVGblXIpM5XO1ADq/aTY1gBTMMeGwK3Tnp6VnLI8MXiZ4isES8APOOAv7giCh8fHUrOyen9VrBHQBM3QAq3QDgfhEByGI839GAZg0G9EiKvB9aefwHAzNk8Ww5NUjjaKTdGqg3hiwOTYv7kqSdYvyu3Z9IeQ0SvZQccuOoLpSEpcpeM6HYiq1/B2WTYJ+6yOrPnEYgLnGwYhJGEgDFLLqhQLpg0ArsxMlvHJqgIaoQmaoQVaoR1utjQEyd8YpLksGzjzm4XPkMSSk2UHjD1u/jfCYgsk/S7gNjBqdvz9CangBDRwBjq4AANcwa3ZG0IQH/AFFrDBDzjgDwEQCNHNsb+LmAIFsAeKoASqoJrsPZnajpS0l3QThpHwY8zu6bcPFVesRKEUyqAcKqCSdey4SImZrah9qE5AuMi6x6PNewWaEE+OVnew3nFYLoINsxfocFBu0Tjv4A5FotRA2ua0NnF8qC0y0C2r6TGWLkeqaWSC6/YPk+PGkANYsUIJlEIZlEMFVLL5k/5XBTwmvMn+bhrUV1el2hLricWrOQbD0FCM1Lh+/mQjdiE8UbYZasPAIWCQZTWTqRrmoM4lo+jGZD/YgAGbmyOb5v/aKuqYJ+ASIxXQzpK9jsb0UYxtTq5TuHQWHskMVjSw2TPcmtJG4jKJSUCoPD2EqY4J2ia6P1v+duanVaIyWNc0C2JJTXYk3mRu5HiDHA1yDMixIMe9ND+QE0BOBDkJ5GSQC4GkLTlo2pIIfyk0eJANDHjHrMJFuuYZRRj6nYKu98dgweJwgwk6e8tA5zq44PeKGjQSwOxICzTO1zO7IqDCqZhsoUwFBvubXhOK13uqKWtsPV7D6m8J8l2sbkWssS6cJ/aKuLxhZ3vsjnxovPW3zFW0ifwk6SgfCwwG2Zc3VQKNIWy5OeA4jxAyjGPbqjDjVzbNtNbAmvPrQNqjFKJvvThABdmWvrZ3gOvg9Hvp2hJCpcJGiYN0aHE/dLG5rzJ2MV9La+ePvqRCPfDBKS79+VGHAje5DLG78GLl5s62Us9pQMpHKaRYtAAE0NrtcZUFhcHALv0yI0fcrOYBQG8MJ8m1qR8DQEwupQvVeJHilUCmWTcrqSCFbsdj0x9RVJ+Yrt5oB0oswDRTxjCbkicRuutGJzUZKfIe1tZ9+KvH0LizmagJHk/XoCfZdF0cwkk1W2UhoIWiVKoqvmFPenm17IlCLS1/3CP9A/hkjV4/8QW4JSyWylDvLS12M60w9TDH+etUDO+bRBvIgYpodyZnKFTSXff2JiWrB2nCCbCsDsFi8V93rsiY7qAvJzkX9EDHOk4leG6WtHhi2fGsueQacpTUak8dV8ut4KV5/xYs1urLePTkcZ7m8hn5sEpgYEwSJj+wEJse2uud8b9ojZ8yHY9Ezm1JjpyyXUe1ji25H16U6XB5OtEzVIpWGMaq6qcdp+TPykfs7xdAvobe3Wi7oRZWUZr29cH37rrLwOrBTmKaW9H4ZVXdzwqEWzaeg39uuQWH6uJ/bWnH561re1IZis9ErEVn5lyCcdddJFZwlZLeXn3UMTNK1kdyNwBhumfk0BgmYU1Q2QY61lFS6i1MSpAW+yXKqntw1uQejc5SZLdWp1MtpRsK7xkjGc/DPu3upMuZ7rT7AsUpjL8CQ6eMVo4tEjXcfWZbgcvprrcjJSKRFjnsohDQ8pAuvQDIMQmjJBcMqX5xDBIAn+7mFdXrQUn8RpKOgvrW6b+azBgJJD5l6xLnHyQKxsXedCmanqHK4ndTL0MZJMRR/iFsDs5FCp4nPePvOs1o9vCAO/JOhrUR6ecSedpFvQ8AQXjEmMm4joLwUL2POF7lfRxr33nkfq5HyTF+a6SmP8Xgg/OIiE+iHD/InCrxMXUk5TjjSu1OsUlUmpLaHwtzHChwaFhLO9fZ7N33cJDkdR4y4Z6oOvCIVRGQT3tV/CoOU+IBYs/CclBao7V7+rHau7/uidqoQ0CH7qmK4KD2A3q8XtD9yRzLn3lMOXOiK4D875toHBxPRJMqWWo1X9tV4K4n9IZif2S2SrUdo3VksTN2MmXbKU++EMVahWnXYbejJuSZNOWIea8cteiNE5a81W3Vql7rWc8p3/I9px0/uDRnIp45/ZGOtMFoRctQdKJrONuyzWgMY+hsyCE7F7OYOx+rWBmLTWyMxz72LsYxbi7Fu0BTiS7adPjxCRNXnJkklOBxkkoym5RSPEl+ezxNUSX+TFmV5iBwufOUmMmACACMzU2t2BbTDw+M7N0MnQHAw5eRpeUN+uMSBXwC2VoNADSZBgAQtAhiEYNmoK9iKc0hxUcHAMJxAYquFNHpcgAhnHl7xqHimdqaTGFo2G7nWj68oOcIsG0AK56LBMCfEeb0HACC4pvTZD4ZARVnCADhNECg3bgFCNBpCpcS1s/awSHcaTYOf04Tx6TD9StTYOutid1GenDxfWVjYi/p6FDz1LuFGrZEz4v22E32R50bmBC6hl/hez5plVFXUj8YSdLEDPHJ0Yz12BRhpziABSEoIhV2Xqylp2uA6X/kW03GDhW0ZM1ItMFzw9KEbDyhbekaHeHjB3EYgEohogv1IIXGA8wWVBLiKQlCBscboslPTZWKqVw9pIsBAE4Iv8a5BYYZAQYswBqgmGGAndxcMZG4RMT3pU9II48BFB3VlGUubJMMkTxiTIGkimjYvwfhsdl6rG2ykdyRh5Dd13L74hfmmrcMQgvii2todKA5hJlh7XhWCSnAvv/GUUgI+YK1XsDXiAU7mJtlF27wMLe44XjYnufgbAXrYxNA8/b/t1mcD+bVxaHqHUEMHwsgHAE+7nD/4wnExsp5MKipve5OMPXiw9LK2z7X1jvzIKjUWtoAUgIYnkim0jEWhycQSWQAAgCkcPePSKO8vx3TythThxuQB+0wTuYaFoAE3pD1g3RhX+3aqTdyK7+z35esdmskj/JrbK49fO0jbDv/X2fdXEwvJjxQEGnAAAWFAQQFAuTcxCQvMIcWCER2qUyCAckmhM/hwZqEugRj4Qbgf/mMkLGlazRqxlri2SS0gkuvpmNd6H7zfRxsGRZdGGILa86JogiRbwSgAslfiY3+CXL1/oKKOPoeuJmBaH4w+8DBlB8xcvH+gEp09DS41ABhfiC7cj/FtcZOumMXhNFp4CYAwvwgttt20l5GXvB6ZyKjiXajAWF+AOt2JX1jI93lO/DD30PCMoSad9jMput7xjZz1YMbfgZmxDjEuCc7URvvahsnLuLY4ePgohbCfC+WU+o3Gz85QBWHl82IB8HzYJwqdIrYOKePjg4PQoOgOZlp4ezEdB6KDDeC0N5Wgg7CKQfvf9srC39WQu1Vfy8pIFP1LrN/As2b2U+B+v2fg8m9zjUx0PTg68DmMuAoBppddjtwOQxsrzDQ/Ipz4LMJ2K5hoOUH24NIOrAdwkArD7mA4C/guzHA8P1a+XuizgH3xkALh/4lRDXAdXGm1SGQtJLvfeXjxAyNIWTJ7zxmgzWh0BvCzJAd4wYJeZnTom2vPKLODkIehbWbjirwkGfGQ5yFmW7M+QuNMiCTXQUX9JtjfOdvlp2bHRAyxIiTJEeeAsXfp2NqnFmTJ1a2RZwxv8e6pHJEXrnnGGpO0XKOnkuMXHPLIyaEVLQH2db0HlmxEQJFtUPxXjWo5X+Mm8e63j4zZ+68OWv9tthuvlu90+62d5YddZnL2dDlb+rmbfnWbfue2P69sBN7f5/u/C7vp/11hLayqTdSaZ8T0z8XZmLuz9OZn+VLbtaNet2u7w2aT/Oj2HqZ1JCgtJB4CxIhwW6FqjU6osewS6ZMe27Rqi+hmc1CNLM15qHELXbBRZVQenmVVlNjhzrRqfiwBns12Yk2HCBFG1EBACRJkqruArHDLVStXIUQRVUL9qeAW7Li1OiV2yVY/wmFdbo1jW3dwVi6UO3ozWDDhRlDv6TKU65OuxP6XTBRQl1elatmNahk982aq7XFxNZuNf3tRBsOkKoWohTDLVT9hiAmSss251xz16y/LPnoR/gsj2p0YxTr0PIsIG5xpVdQZQ0dqqvBxpvsYc961bs2BtDpMiwahVSMimWhFIagVEFzo22Mv+clKMdeX1trx+rrXNe63XTPmm+ptezFY/L2ToCWMDmjunML67YE0AiuSAkAAEiSJEmqmj9vhtupHUOIqmZJPPuPgRnO4MLRnK1jPpRxG/YED28EkzOlQx3+KMc83olPcdoznf085xcI3oYqdGEEa9DgiQBwEYd0FKASTIihhR1BpFFFH0uc8b6greCvxhqs6dovY31350Zt0mZt8ZKXu/I1rnujm9/mjne79/0+mGiK8Wnf9rM86jGPc6HHv9TLu/Kjn/DUZz3/Ja983Zvf8V7vnyjJpTpJJNOWdHoziBFM4G4Wkkg2pdTTyTCzrHPINa/8FEQ25FCa2ipzUeQmtoLFk0A5KhVVfClllldxFdXWVHs99WuEYlvVujaytWn2dIC5jnO6C1xppsXW2u6g066676XPfg8oVf1oxCCmv0F/Gd/sTFSSkpXikMONPMa4E00+zYyzzT3fhf0e/de217LUMstpaPlNbU6LSyyzwiprbE8LNtlimx122WOf/X6Iro1CtX/rm77t05750Z0f8XGf+jlf/MRnPv+lTx5NfHca7VftDKobiHOoE8YGVJcwNpOUAAAgSZIkqS6LlDA0AxieQXU5DSHXCYDGKQEAACRJkiTVXcFlAAAAAAAAAAAAAAAAAAAAAABAkiRJkiRJkiRJkiRJkiRJkiRFCQAAAJIkSZIS7k5sbjkPj0qgpb2oOxzzBNCMDQAAIEmSJCmYEGcZw1fBaD4EBIG0zXmpVT65XHigI0mDNd/n56YE9r2a4NiUh86lX1ci5KhftqSRBQKLvQhpW8+EiY5mUPyBumZzJBs4i9pZcgMUnnjuAvzsiXED5GYEijzxCOTEPjtLIEKaKu1oRtVW5JjC0qRJK2SY3c5We3G0YgzNVjGAZiM4XwKYTZ98TFxki02LWvcmRtj6o8siIbNFf+JJL1CuVjN33KXfOZdSn7TT+JL3mOTTUs/U0CdogmZu+Yo26ygpm3r05SbFJVQamlpMPoJqlOBN74fm/mqhuQ+GBb3K2RfH3BfOa+7warnhYV3rs3YSHhH29yMINt8168YwuX+clVVOBDhQnVadegy64Jrbpj0zb8maLwHSz/IoRzMGIcc61NzyLShu/ARlVVhldbXWWU+DXXgCuLm+DAiiuMRqfXN7dyCSyBQqja4EhkBhsGMMAgJ4ACx+O2bmC1jW2rkdTn4RDIfHckqRVAn2ieKZkbg7MXVmFc9JwpQ+JduVqlY6TxlBspL0J2fAieS1OZaCLs9UPKVSp8qtqsSpSklNnneqT7npkhqjbu5X85RaPWp3qtOubrN6jUfiU/qy46yV5xloLGo9rLbFcuw1MNtW+QWsnbm/TfM5Gr26YrtpNX2O91fHofGEAC2SsuJJYqHN9+43oP5SOPODgPrLNLtMR4sH9Y2T0zhXYzf04/QSNcXA35IuqCYvu4QgDJ68MZ2+WfBnkg4Kql1CcYVL02bMcxo/m8v+CzZzmc8GIcUgW7I122IYoxiHHJOYhl8s2VeCQ3+nsh3Q36ntAxURukvJ8cJLTNUtEb+0zXuQCM2dHjGURClgQN5RZYRDN4RAbOqFaM1twPcENInncrQRhHC7tTVB9aBHVw9C2is6LyLnEHpWAwgycCaKA3cscRigI4vOHB2gwKELAV5zgapxE0xNmmRnyhR7KBQmm4Nsmfq2QOCJES8qxPuv0shjsGSJMbXuUeTGet1Z3PDOU5Qx2cLOwkQoa5TM7cMVlAzF0mOiQ1QSS9vPKUmXAylh59wiUrStYhRDWa9npEArY+06Md1oCsvNH57tg4/8/PSLfwiZFhjtaNtJ9Iqh4yVxMFDAeedE3PcH1NoJkhkfSqRy4Y08+/48MPBxT8FSgZzBIrc9gbh8/hlW0kzR5E6OkOS9ewiQ1uuSaNwng/xrFag1SNXa6D2njgstmYuFd5Pc3GrFEsP7fth9qWuPASUgk+5qwygMY4q0YnQCppW3gonPIqYf6r4HHnpkmtCMx2Y98dQfiUdYmwoeT90w42E8SZas0j2nLsWx5NfDp3KIHhyLowiHT5UQp1C70/3dmUKUgvSigw8QRLL/rMyhypVPFH5zJcztWskFMwbQHtEPXRH4RO/IrnmjcGvkIS8P9x5FyM0vhuuiM+D2W0gCOXVKXCV2/d+QNUP8f1gJBNiIwogD1iLPsvR9UoCNKzDioGWCCGuI/tw5baIasNqj7MM2jT+lWOvzs8rjkdgsr6bI28J/E2BzPJRhKa8ehyS2UKEKRxU8AUlsqUx2ylOZbqtReHZhKl81qq1zr9LVODWgtsGruDVBLattMdThqa89SR2y2k5ZGxA+se2VxDHbQUkCtR2VJLHaSYUGERq6CLyhBJx2VnYfg0LeShD4vQx2gVCDQyRBigxZGqXlhCbMbXfM+8cri157Y8Wq//Mp69nI53wh7ZShkFxWMvjuVVD9Z3/GgQ1/Osn6E7WtUYqoEAKMSkWsbM5RKGbYuT8NwhaCho2xq0ZjjiKUBiFjNx+xaFbNUZrWUN7XBNg9DsUwg9AHUgUD0Bh7MIRSCIOnxtjTQCGEwdAYe3EM3efJpRHqr2sG7J0lU2WhrLp8xC4rUcKUhm+EY1hniRqmlnpjhFmiMHUybBMP7zLH/DWU99UONo2SyZKgKpNLv1kchtAJYfAU/c0NFCwsZltoX8SVra5LvWWkhE+6mzpuLsGBtn33AHhua1G+bXI6/rYiVKDA3go2Bi4HwHH/GAN0gv8/+en/NAimPtd7kFcAPQTAmDjQARXYAOiAn8JAgA1gEIGfwroGbEETljgwp8DvZsRvLs3UPJ+5H6G58fjssR1fbgCLjzVYTexk9H+fB+Zo6oxJ2HPR8/WB5vLx1ucfXX2rrucdacP1q/BP/x0TnxhE/zZm+9vWJ95Zy+FDgD4LczLbegQx5xAKjOFmqPAqLJHzfNm2hS+AHPf0xwNfBuWTz/op4KugfEX0dV/5kegbvvKTFr4Jxp5+BsC3wHj5028M/ACMtyZni/7oG18pZtE3fr+YSd2imPV9i4+J2dC3+ISYjX2TlWI2901GYrbw/f9d7bkYyNK/AeRxQN0AlHfBZBew05cB2AHgAneoGI+Jy9j5wHg2dVY1/kEfsw3anF3juHg8HzoFLqFhjrqNQGa9Sp7Oqi4L9zfunsvlOJO6eQ4tQlHP+POArVrCLHU8HwXpH2/5qrBW8Hk7+fB3djalFgLBTw1yIapU9pwzvwhAQZnXjYeu4vpT/FDLvapjwJqFDm9ezDMBneQ6Mj5Or4ArPORUKmq9ohAxqSDcnt3aZ3R312FHxA2lIgPsVv+rMZC3pPxemEoaNHtw72t+sdGG6m4wA17j9Hb6nrbnWMHCguc1/NT+4+u22qAb9Adfl1DL91fagb8ih/G48pwT+igGhnD1gb2ot1pzDljXYPGG7pYY/CKkU0QnpzQf8CXoCIVexoyL2aWozY4vQtJcMx08PIJaHCPzw8n318DXwxiv7QSCfFXoX+S3PeHOYiJ58Px4G2sLZUJIWgoJaWnDKzRhGgfsZVgJJSqPrVsPtNlWusJHa8q3Fv4R0DdJhMu1k3kppn3MWc4rOiDdCKp2YNwK395CLdxUDHT2qYY0TQit5SBLVg90urpwKBWk7AxE91aMhFBV8QQsMajma8jaW3S313hfFVfa1aVB00dIQOWQ4WYfPx1SEjf8IZJLSIq85CuRywk/fitvVB6a3rR9l510csZ4JtOkIFuxWKAugT3yg7tnimVEMVnRJCL1QBFS356K5bHTrjVqyavE5pbOylkrwlG/rGT0qpBb6jCMa7afy0cO4hKgVFgXPlMISzigdFqJCkpYzM7AZ3H2OH46fp7KIX3OOVZYzNlWFjPkQibCfu2ruRsuTdkxvqiE7OCIHlv7Ob35DztI/nkZvmdUlbl357W8Y+bdQ7Iuvqdg1O2TcWis9tcDEVkd+pv+CVe6ijjfE+lshWUbfZg/zXX9FMvQwY0yuaJmko/dEsfXJh+KoqvCOw6zJs8cpMJSJbJN6+6WwDM1Y07tCWtZJWJhIIMwhMA5VpQSMmOZmtmEK0wTDWWt5FoMl1FYoj9uHSOrhgBypGt92oFri6gKQnmsVsCrN7nrdCLx+ysk0sM4KkfjtYlaGC2rAolQI7jBIbPTlKFg7Lg9Z/awYm3FFivyljs8zkuklCx6XJDtQNa75gUXwwtU28LVoaS+oqUSqIhNzrVmdErZzqtqyqPS2cZblqXDo9Vjl52TcMqxbtdJ4eR45p7B024ywZzr/7+Lhxpv8BmJLI2y5yQH8eDa7K1qJ7y8WrJSWpLKuKkyZB1fbWt8mUDhfXZLLDrylwdhyaoSXB2pBVtd6jWvmxAsGUpPSElWiRx0rFojwYGKKaWyHcg0jdVjj0SxWkhcyjZkpUE28J5Oo9fsZ9tUcRgFHQ7cNs48PJ1YFxKzneBb2yzyGEJNekBiANnj4EHs5lnxVdOClRf4KpH+QeoymVWr1CRuEyWBsa64oM7y2F7ojKKtwGkjiTiRYU2aUUoNeQkXeGzr5qNUikwD4Sdxed0+AdYcCbJMopUhScdn0s5SVaxA+sTVM6X3gpnM5uAEIdyVe+Q1xaGflxNXCrS0RK1NwRJ58EIXuTEXlJ4uo9ntObIl26waWSgPYmzGATxkZAYGZzJVKSudO1cozXgkJmpnV45pW073WO2KqZp50hfIHbcHs8DpcwAyUcCB085JBxVL5KnYpQFFXViJB6q/QXTUkbG1/fNB/eOVg8jLwqduntzAEjyJqpS1YMSfCCljKS/+NscZmbwThuCGx6+eLxnTRezuJwx5dcNRpT5HF2OeM/wi8YoGCzf2q5l97CAjRjkAnTfxFRuRPcXD0QzUkE1CYf5OJAj/VFpcApwqrNn6LmaEMyUhSKBqZR9x7VyOTz15AqrZdTzpm58+0VatR27RAvU9pIZjmpcXTfjFssUNPhqil5mjERO1vSvHoaOD8nkDiuB6gbziPvfyV6Gp1JJ0ASbzYQYTkTOfetyq9uxnnxXwdZ73yO6Ykz5z5l28oxONIKfR+RvyOK9/7mXx0z6hfiIVwhZ7BpO//3ByYZCBvOxMLFp0KUqyPqFwlcO+akkHqXB85WXRWRdxTp1zqRjO6SxjjY5wP1bH8CBio0aFtEu2L0l0JjZmV5XhBexgF85CAElBH4qm6a7IkA18HIQCAOowDvUtMqNUdmQxuNflJEDuGJh1icXCjNgshn6qsHGxxZJs/V/lkKVHktXAZHIyn5FjWJEfl1gUgJoafqf3EUXM8YFf8nKzvVWIWhpCYSpd4ZvzFK0VSJ1lBEkhQ9MeY1OK+ijX8aWXtaeo0HRVSXm1lMiXDtWOAAkKpCNdiQolir1YeZI96bP8XCWp8o6NpfgE/OMvz7zozcd5GqoM7Z/FiOUr46TNqrVmUzX9xzqrpfkZPLHU+oesoV1m5cwVtp5C05J59Tx1k1nwKwYKW87yjn0ucULLM13QRakwBUoHIy4wJ8gw1oblZMcaPtXRANnYF7Ac40RtR4szww65HWTo4JnCXrOfvfXQtEXIgaBxXGp8tSiXWckQuGKxUXSFSMnTHlVonw+X9b6mXS2D6BCVJkDkZnEHezDEyc9XrnbAsYHIUa2KZ1AwLciIT87BXE3zkCdSzaEyZXCsoj6rsNx41PprIq/bJo+KGPNEBMmk6Y6Kpy7D2VgCmUXrp8lMfQrRigZ3wVQJiRYQpRqMOTEZqxFsdxYnyzhRjgACwhmL2VrmaolLEfTa+vXGjRuFT6g0TZafuztlMzgbx4wduaozdP2CCHb2n7eXdTAyi3akokahGBvh+UEzT8u/z8FA9V8fEquoCkuciBFIM1vUjsxucrYL/Gr9P8WPd57RmRpb0M8a/kXFZpJCK8a4RjuDWtqVhSvqy0SHRR778Mc3+fUri8vsSjBbDB/oiiujofI7HWXhEyVk21tsB7RBPBbHPtOB6u++bKyiIFOeIxbO9QitUBtNtgPVX/aOVaRngq1ceeLmqo4hzeVbQiBMi0VS2HHuubdV4HTcRwJ7AkCnWyCFD6TZc+6txttmMrajid4ebRhbSUgzmWZJVsgseSGXO0JtOToVsL1FBOzaHwEW7QFmyz7UnihsP1Eu5NUccWjmWpIjp7ZrcztvJfUKNrRj2oEJVerKtDWxJW7ZVD5YYkClFzkwFwKzrJ5kc1mpLXA8JTz3I62VF/kpJ9EMXSYjJv9YQvEfbOJJfQ56lFlYrV/uWNc2ZiB94WdU5XDb1CkrrjJo1xYOXdZNiAeqH3lpYhVhodEjqdwXketafQaLFqoJLOHcAIBhZXZ2M/jfWoXLNMzDRlBzHe/xBlHJdWP/ZdZaBvYh19i5S1vYQE2cO7ug8c5HQamdAabcRYx3qJ20b2sFK+2qVjDdgKGC/LEX4BCX8aR73ZwFZbJiuf1TWxlK3/koiMMZYAadYxxItrW02bzxyvH9fkTo5SMki06FYpvHASooiOZKJ+55gdYt8fBWoKbOD/Ra0KamxZsQTqBTJbudDv4dYyk0nenbNWPtj0gJYOM63dQ+djIs1T1oznIXHY7kl5bOSbArtW+UotVwCsSTAJ/UhZWSFGOOMsIztnCfWcAyCCvS43OLhLmDHLmDrMYWjBdzFMiGbEpU7sbwegNx/7DpXjt4nXmnf8rjZtkUqcKsgA1XIH1t6DEQeByJBCcfZM20ZkLWMzzTC4NvY+HdB5huMaSG6sg0IJbaJkVrahLcnQB4iVMRTcSIBo8/4Zg0WSvcONHpeItwvPV5XuBTPwsFpZ/XKaBv5CgPMdr/wNElXbAM5wWDDfrHPcE1EX54UclTJ7O2oLOyuR8csTe3zOF0zZWlQvPjcuLQaN7uh4PIMBNyDRBaYokgmsDuCcXRsI5MBi5AB6UDoChYrMNB4PFrLEg6eCIexjXoRnlKonVvIhCnYi627q4BZ4O0Y8k7dxPZvuBTizx33/8nCtpnoRrGJcc21QLnQJvCpZHfe9joGmmU/iQqauMXp4V7rS8a/M+JD40OK0sHfeZOmU19KvvU6UGUZ2Q0xIwVKFhE3sz6V/XDDj0Ex8AMszk8oAsF3Sl++qgBhFnio/ZNvK8sVQK+61p4MF0e7+dP//CAJ3zgSYkdwPHP4jNupSdncuvE8QW7tsui2vz3aZ+BYKM/QrPxdEilcOQWctQghQ9k4lymcKo8B1q3TnEOh/ITHtQqL1d2q/blu2TFp1pWR/W6zdJD+dx4PHDIF/1YeORGHZdQATnJ+Qt6uwern25721w4F45biZmsYm9sz3Fros+et6N2PONZ31kzSUd7ol2xrDkgdo2cxVZ1uBkOe/gkZmxNGrKz4mrWszwMjstYx8yFoGAWeS8cass0Dad4VyZSGszqVOa5w6ZopCU1AdihHFttvcjNNbsb/C/YWwOvTA0+FCaGKEqx4YugdvgCc96SB9I++LkmDkCG4usvw7ZU/6bmnar6GIULPVbqXuqJn0AxRYkB7BA/0mIGjNXKCos3idMRHaiMQAX5LhuL9BtnIaE79RvxlE/TqFSkjfrpaIwkLUEDRlEZSTqqo2hMf3NsIKFAAQIITkAHLQZwEgOw+62iTEGW1lQl7xZUZzHPGDHlojSt3zAaU4klaMA0KlNpGL1pCKLBkYxY4kg+Xs33pJZBlE5VE3nilXDF6PJHvAKvHNtzo9/HfQuNpHpczBsT6zQaQXNn3tcoRPA7+U8XZkkvWC/G6ylQ2G/snzrT2RHjMVtJ4yObZDj27I85p/EYNLsNgJojNlzXunc8y8P1LUdhFiZdJa8tzbjhy1iOU27qcm5i7+fONo3ZlXKecus65TZxyq1n3U5jO9zUhj7s35OPp9Pj5wG+fwXLJ9B4LURmZYkgZXL1Ft140eAGDHk63Bgx0cAA1xgeyFsILV5a+OM+GLQT6LCRb+0F90lL94zUJ3Qwlo7U2PXdN1S/p0coifbs0GH3NW3wGEN6/pMX28A+M8EFJSTukkEL6dLNXDCH82If/pBHek/DKaHi1/foqJHE3iYdNL73keHKUxiEy/jlZRnoxoyypUN2gZOYv2egWjcDoXpI+frZQQLYFin5QE3/5daDZy5DjQ/sHbhiypLGj195h6S1HOy/BPtI9YFL7W19l7CRf1NxwivwNHejfcQtWA6UyuI+EuZsR3tLP+MbSt7zp2fbUSzZ4t4SFncvcz9wVliQfHc2q3ygIrhm+PiJf/4c7Z+923jnZm0AZV2FklGD6JQP/w3OOyMPZhPNVWzKMgNDWRn8sOj8S16m8fRgMtNtes3bx3ab0U7eVYSrHBW9AoPUulY8mGhqvcFoI1C2X3F+r4zyf4e5p3/m/sxxNNEsfEO2JOGhHMnCMaVVwMK3sAhXVIQtcldyIdy7J+Ijdz1d7w6qFNqvGC/uLR6ngbLAjPb3Rs8GkGXdYnjgCoyYaDcGT5qEl05mKGngP4s1/6WEa5oqQG2DBIinNJg7HoA4SHJoPYTFN+Hh+5cmLLYJC5/hO5AVhIAT2nWLcp4oCZYge0FmOSUxpNIvfE9qVExuDsRugz91sO9WddZvFB//8ff9P2fFUhE4Irdut46ZcMD47o2KTahKgiDY2ZiSv/ffvQnlCRAAfhn8sIjyGJRthOTvu/0psWVx0xoMQ057T4Gi2FH5/vNQA1doGxCO+0JaeFz9aOzHGN4Qj/ueJV4RLw6tcq3/C/beRgtMsP5l8WHJ++qX6g4IwDnLYpOSCTZSZj+yl5Qumtnhyr0rKg+z8MpcC0bkwnqM2hOSjlO/d0A6o1fxudZnxUuWMl4ZQf77W7/CHNEk/LYgbworBdOwYKHz5XNiXTMkQ9L+5mf1rZCYVNcCo6TGKeIjRAFHOnEfbNbkNxjvYRSqxh5WKRJ3KzWdh2zoM1iY1F+APshpPJeuRKxQHHsIVTA6RJiv3h3Grc1PSKzJCw/7qhWanRwUmJV4JTMxMCgzGba4vAnrMWpLSDrm9O0wZLqeUnqh9VnhqqWMb/qOgLqWb/A3kRx+JzlvCpWER01Vy79KT24k1jUjL2oanzW2IH/UtQD5m1tMtLCBJ/D2KxobKakC41GbjRUY5a4E5x8DFbmhP6IgYaqQ4No8ZgVDES6UCfAoml0VSEw//SqEsivKoUolFsHPjT3I7Egakxfs4RnPRTlb0Jryycc7K19KPb2Uk3o6gbrDwjMTeMolQoPznyp96Mz0zxW4DLqLo5c/mD/ZtWfpTT7tepXx86ieXm4q7i8ptT5RFdqtwGz8OdEPMrCezbixO7fazYOYLvPAyZTIWphCT5La4HCZ25O8mv7QawYJte9ce4rSz1q/KICgrMTItAVDuprrjKuBku25uuKkRqQVquLKSjNLD0C+gyrPOiCKDMUsTT1hs6aCkJXkp+LzKeecmTgUAU7ov/bz0Zk9B05mqUqV4a5PHrkgvvDJCZDC3IjAkNJ0AeHJcmR+dCA7LTxmDXY633aUye6rKR548Lvxnvs/+vecKVXIoIB4TMTFjsb/AvY2/4y5cJWvxYvVHr/6g9coEr4Z6qUBJ1RgFe/dFVJSs0Xi9tMnb9Y/PXn95A7mTbzDDEXmY/MjR7HbN+YLTGdkKDY0Blwer22KPZqe1f/od8OdD2Dk0OhRdC91JflSfdi73o6VgBpK0aHQoTidi9d+8Q/8CFfSeJm3345XyLMN2bYxhTGgdrOSy/QigmG00EoSnir+rp/0WZbEuvUk2kBgZIRfYHAyxOU6yTp5pf3Z+m3a/1tlt0S2X+oOOd4He7BAUBCWqRxfklEZWSoVJ2hyR0JZbmJaWWdK/IEp+K8jyJA2KOkV60VzXhQMzHokeiDk+CFenPb41V+8xqZfMRevxmoPjwC7mFtNjZiuncjjKzP3fvQP3P0xc/fnQD+eX9aeX9UVXi1oyv4UXfj7aUlVeVpqZWnZEwg59nYixyQ5cpZIymxI215fFK0+C9PwZrGkfQlF79/CXLglM7g6v6vi5lsrnhVY2tGCVaTeSEs8lfjrteQTsG3UIwSWhL/KD2aCex4nSaVsc3t1oR6YvpeSd/iGWzHBJxxO25O5PwpYwMj2K9I4atDe3T5v23/98tn4C3oLsI0PMbcwtx9aPQSnJqHdrU/srYpK7C3rt+z6irqOS588XgTK60LF0ngJxcb4EE0FYbOmnhCEqieFQVJRRHEZLFFf+pOEhFS6RND8PJjJ3HgoJjPyEFSbhNu+iRt+i7z576OlOPJ3cZMaK1y6/S+gB9xwv0JJfPxcrf8npGykIOWiUancW0z6uD9Dy1h45gwiJpR/5QAXIbcESJdSwzAoBqQnq2EgS2T//wjrbGxS9M20aPnqkPjlIRD+N/MfbP608pKp0caEMfmu+6ePuhmmMN2TzdJUGLiTJ93FxOR6ZXEu/kwfX57L102Kmu0/B29xu7aXBXk2cj+QDhK2sk6EbHoSXZIRlBk3qDiqnE3ZQYMiwAktyUQcmcqkJOo6hxx1y9vr+rKmyuVF9r4THtzcgyl6bMkR5KZR3kiSIGe0uTFnaB7SFH6R7DFYfYcfz6Xeil7XFefERfklFfYf6igcTGIlhIsH6hInxP4DRRnuCY/sfS4vqmpcX+bvPeoW4pyo4+5IpuKIZAvACU1HJPTYB1OU15PyRoxy+uezhxqbc0YhSwExMCdiSZQNwSXX2irf53v9v+RX1GV4C2hJGrKah8QuTI4+gciCwrtlJWBID3n7Mt0y/cjbI6zBOxdOZIdvsljabEqLt/eA1LE/CX3qVRok1xRXbkIeL+mBhLZXR0we9xgtt9hlprLadS6v+phbiHOSLpNCpuLELpnzp7f+tTYsyDnR2JRzZj57sOFA1kkYLCu3AJzQ0EaCFNWblD848w9M3LKsAx4/NSw8IxvyQixCcJyV6vBdxeG7qiOCqU4gMhli0ZjQLS38+IHgvuIksb455kzmAU5ooS4T3R11ZGEkK5583S80EtTafERy5UNeiP5NCZ3IY8mC1GOpqlwxbe5Iak7HtTsj7y2Gd4aFeXFCY4NOGY6xg7lePjxBcAd1mD5HL6JfkDs4/aojFn7RcWkhYWkVrUDxi4EdFmdg/+Mn/AjHYXU8krPHjbIvJqfmXDTKGYfcY4AHk0uSCnBIYgBExQYZ7k7HLQOIwlutXBEfTPKSqfGkVP/MJCdBXsj2G+KbomsTwizG5bgeMeVFvCxwerxZTeYC193LPcIBCE4WHtJ39Y9pHmmELDiueO/5HOG8wlGylIQzn8HxjXJEgFWrfo10TLOzA/KhA7n4TLg+ANsXQ97ObHLwMVNTIb/2UQlE+/C3jkOnS9vbNnFLcTAvmiuyDNl6T0wvaig999TDV3CdP34R/NSgHXnpbrMhylEhoXDeXSVLNotLpm2GIDlsiM2ZFeLIivm5t6Kn3lrLfgpxu3pFklmglI7rfpmwjOJs6GFk/6LoWRFV/FlxNATbY9num13e+KhnbFZ3N1KRz2dIppmLSx4wdwU13ScxW2D3mPYJgvTnsjtII0HhM5ik0Ol8fKKCt66rwzaOym7Po6lR4bnKuVHhqUc9VXZv47g6eOskKsTgXf7N5YQKnhgquFrSY808pDZ5SMWaWbgouhnOCjihuaClNASi9XogWg/o+qpLDLw6nY4eyw0TzIYlF9Vv2sRW8M0s6QoPt8TBevzdU3+3MHKtvFw2iS4oW1I5iN8K/m7ffKNrnq2X83YjbStHNuIPK1l0ZFaOWCpk2DuNDDf8vW8bjfX8rfB7zv0DYvlSobui64rM0gJhWFeU5hZSV52hpVirKzr8+s01me7yE6VeqoEn9xQFdsNdW2yYtwymDdfZ86VT5BW2KvvubFTV/M9VkSt6ImhAGMvbfQcXdhFeuX6hYPdjMuwZDUBek398bE9paXVtZUXM4ckHgqP19cNpPNDQkXbrTkdGY+O+2pam5CP3J3iHaqvRcZdXHCt+fGnwyy84D2OffwyNNgkYg/N5nyJO+NamyXH2mJ4bJSWQiP92q+0Oow4J9/Fv7tPw9IjCOQWZgKURhRFwnOVKi3q7uVNY5qbGHE+OQuHXFLmXtiS3/fnd2rmJnT0fbly6+/35WVmXcHcOZjrIzFQt/5PcZcX8r0myC3h2QrSzLJqTDQfg0PL985eXnxP/R4iehZYfE8MZxl6inoVWH+ON3LaDMmejYEdADpu5INCf4hAVsHWawLZOaTr8wYPw6UPZ6g/uq2UfEnK5yz12n7tQafpD3YeavWv762o+hFn2x0341dT4TcTXTk4TLpKz9v5U09xl6ZpnXVy6Iydzd4+5zXAcdzp3PZPe98fFxlOgXyLiyS7NLsvhCwYzB/imhVnOTBPykDhvsGR/9dHacttkVca5Tgl9PieAYhyUZRCgOwbu1E5lvREFlKUsd/nOFZW3Y1SRvwxUOdLAA8y+vv5RTteOI2IHD4rZE+p1+0f3yO5df+BKT3ftbhv+9nV46Ns3iH79FsGuI82TKiI+cWFsvr9x9MM29uiOs6qBWi3MJs0gsHUR9kz2AGlExkA4bSAUGkxPNzVGoY4BgQUo7kgJApsIgvON7wt+YH8U3P+9zA/+DJ8haKkzQjXUsf+rshnbxtHZy9H2j+rbHUc7JzuzQ9NbS4MKwwhl5+Da3MknzZjM1/r+hk70HWZGhiFWvjEnY5zZltu2upraOfqbKD1F0oWNh9quNSR68Lk+RJFY0fQ4/4y5ZlCmr7QzNV4yIbcRcB8tiiC6suCv6gJekUXIlg5RTddyH39OuY+mq6g58BdGxwPWRFHhNBHzHgGcEMgv3QCIrou+S1rj9l/xEtu1E9wh8W7BObTqBrpTjG7kSQC9pWHc0/Kr/zbczgfCpLzXkYmpo8evTx3xOnzlxvETEzeG33oFB6cE+gcJQryCd6YFcILTwbND7orcZdls/duPyq9PJzhS9xxN3oBP6SfS91zbw5zeQ8UJL8OvjuGxQNyV3WcfFl1WcvinRZ3wUgEPbfVOX4cj9NQM3U12MyzNrueeq6vfP1CXyImt3O2R6i0S3BUhDXnLgQn/ZvWYIbddqUD5D7U8ttg4sow92WS3sJYwO6YRk2poZeG5TWsSw7tcWlN9pjjcaUeAu6hIKCEmzIM/VVrZ71twHE10qNnD8LW2BySc6lBW0b7HBxq98JKp0c48Pp+/0Bbo5QmLnEUJRD3Hf0mOREL9oNjslVQFoq82zBPpPrS8rJUHOnTFj+sreoX30R4slJW08IBEV8BOXjIg3UPMvXMVxvlVtL4r2BGYs8O/INA/JypwUyBdJcVPDyarS8arSyPCITmu2hic7czhtDovsMc7t91h3wET/ddCli9gBt2aL7oR7CpnYq/fmluIH7//9IUQi9g5Urd/NiSfwFdGYvxR1Apk1Fj1HiNOVSHXySEphndcCx6zeOHzDW5+Cb5OBs0BBCLJ8Y2+I5HQMBixO7YExPEgvz81s+n+OeamdubBGzDe38bUmFtfvFRW+WGT2yCTIBIEQW699LlHetronuL+Cbp/7r6btT1s1WmkvFTcLeb0Cy9iehtKW2udvV7K564YlzkZppaeZjFfh9VOXoKl5XGcMvIy4yoqvY7Qdk+JqeQJX/bPQx10YrP92JevstSAy9f82BOuXGOz+CuAL2NfWHz7rUfRMGfcPxwSsW9+p7iW29NRI3h/lh4dDF7sGHXM/vUXyyKt/97PEeefc2yLlIG7P96edRy5SqO9HNzFmbP2OucKLK2ONSlZdykqmHU5XXtXcwy6yDZL/18isi60lXmB1/vRqPtd5IWZrY3Oiz17MoJD92TueQFFbtcUXy43vgtqGCtMSz0eqS69X7TvPhyGa7hnzyZ/NESm84ADgYX8pLQPXl5hCeAF7KTYMG56wk4115Ojk9vLratAM0u3q7dPII3X3SCIySIktp4h7OJM4T4VuhUR+6MPqQRXP0cqvLehuwTdHbj858tKQbqFLekTgp8GBrvMr6+OimyojeHV10ZG1VWLceRxPqdoafO8E3WboZOT8VoYbrgd3hxYZMXqp3EW4YRtwf8l1Q3PoO3j4Z50E11Mse9yPW+ndfDnwL3oUy5GHnvqnwsuewSe41teZX26dwqtQB09hoMiY3bTf7ykHF4+HSJ4pSheeQmclY32EtvZZPVCqiaQ0ROeN6f8zXxlIANcFO88EmbaO432Lr2Z/K4JFAVLK5l/Vs6RC//n9g7VfI7rBUEBOQYeQ5F4ow5khKRV4rWtlsYVqgA8QHbyH4IYyfENXnV/KbnGjax2PZQ/xhUC6t33NR3Pei4mY/RmUXbruySHS/zCYparOItYbzAs5VEaFQzFnIPjoaXBZhXXCxxzI27zFPVUZtOa6+rTGuP4aQca6jwbi4jZqE5i3g+TI3eqYmlMeblSEAIc1RXhENIPNYikXC4eK9E1CKORLWLoKltUr9afOA/2o41vGz+uMHkx7q4x0e6u0dGu7tEx2LQt7jEx7m4xUe5uUVFu7lExYMCoCXOPaz5EwOnb/axLsXCNqQ1jxrd0iGC32P1oEFgaJtBmJOyqb0kL593P5OzxlkB5F9r0imeFy0Xm8VYoiXk8r80SAeMVHgs4G6oXSLhSigfKeCI2VDOWMFXXht73ptBiXfJ9lQ/fK6ZUu/31yzeXu+84M4xX7fm7srQwNptpzzudnZU42MTdUhu7i52dN1D0yomdayMLzim+awQqxggO8WAPVvTtsGFMrUkomSXsQv+x/dHjEG/YCD97PlptaDha/eyFYUlDp618pigfsHdHu278Dx/h48T7bshU+LFFjdyf35sO6+6PhkL4SlKETaMfoAcONh38/F6gZTeMICVnnJw9dnjyCUTmF94tLwFC5LubwEt44eXS7M2ug+4pULYQHg6Pf+hDq/TZVVd/BFSftXrqWEC58Qm/rjoqsr6hOC5e0TyNus2Q5mS8RqUabodtQQ7777lQvDInfJK8ZNvtmcv+vdG9sRADadFAKkiRisoYCssKAUS0YgbIgGSGLy8lXG073WY7RGw+3Qwi8nA4PPGxF6XSN7iurgOU1k9ifnB9nZU/NhYTHtkVvizl4l2Eb4/A/l31W++nl2OiELiZuyq2dn3X/npIk/2LbZs7RQCOQE8Wph3ahQpIssCIXG3piT8Sw7eFR/6ITAcjl6FM3v88Fm+D12nWGbERwYr4PyITwqSJ4+NfnzCsie1VcQHTsepSqxDNLV53F1NNe9HRPo6SVHAOCfT2DA4EZ3B2lqd3VhlsU5R8oPBsb0OTX6zOajxwrhcK99z6Zr84bDU3pD1gfOPpDQe7jsGOX18wq6dZvQ+O7mpjS3PFrTLsrJzdZs2nkVTqgevkam3TFkS93a7gWE4s6Sx+Mhpt4sTSdXiCisa4x422NsSZWMPyBAnbkUhanTlVOZu62vc5M6rKtvEi3lV3rnssulSWG3lF3Un8Q53JIV/dNqlJldWgiQc7J5ZnVNLhbMfA3fq8Du9QjuLt0QFrC2tzJ1qa+w0NWJlbWdCUQh2UCGW1GkNikeNwjSIRwvL0IFUpjsG+Xp4hvqs91ODVXLakeKhva7APMSO+wCKsUt+rYcyXy41uzrgqZjq/w+829FyRcHD8CxmXzpA+4N/kHRfM9IjnYoZ8vrB/Xlp6W8u1c+JxlTKE+hunTL24pHYbtixaNiBKZMUQGwYWkzjZDrExURn9LRDJOdjilcG+ejOBVeGRxcvLuXTgq+TVA/wcsI4Qsfi5UfUo+oxsl+yMgIR5D0FagRksH36Et2fSgWRfLx7P2yO1LjWzeNGMzkIJxOJHk11Nbdif4CEpdSkPTPT2THV7ke7rExMJUUG94GRfVIynh4C4Xp5RvFF6an2Kr3cMD+8Avt9bp62Dm6JtBkxSJ/+Wc5Jboows7oAGRq//lnWS3SWyq/Q6gbWYmHS3fJ1m5DOd7eGqpaLXgSOrGC/QxL/dlJ05fbiKAVgQDQnEQCgDaSGtxmOuOf0FEvWmVVee64Lo7Pq/BeCem/4L2w3GRxe+AE6IvhfFPhKKou/BqWdqeaFyeXHqO2t9JeNsBhzvYX2fksVjXpjCrIxmjMI7sozK8vVGKaeWD8koT5bU0wf3R+6PnCW6fFFlVcAoPk1TfkrEB1CWMoEjESDmLOfXJsvESDTyXb3FTnR07Qy3z6MlSUGnvyUqIzYm2yGJszhAbMiKIUpod//uYyQyYxgf1G7gkzO2ayLq0ClRBMgTBL3iJd9uiArlSgVgPN4yZf3IwZy7dx8Gu5tD2pZG89p4Iwz2oOMuX0/vEF9HSphv6y6W9giHEsLy8AxjURzCfD2Zob7AXtiUdbm3bYReY5BhJ7DNMbAsygmOv9W7/yazl7KH2UaxTwPLwnTtwZbI3bG8LPtkzuK/XN8UahZPVBJ8rx/+MTDQ13O6b+3/tT6V1jMw8P3j9zql+/TpD58+WBopmeUH2KX2V4fvcqJ2jMiunePNQrpJ60fobRUxntrTrsC3cwW05pXd0w8vE+zaiUHhcKB1bURZ8q5Jj1lkBCDBZnCENpl8n6xdKCzq5HoZvPnMPsAoXQdj2Y2G6eSwp7LJdpijXM69Hztvcn7st9KvCjrbh0phe9KdhSUhNcTe0f3yer+zYPpxsdzPm+ro51XO9pKUavWmz+U90UvyEN6goquCtay2ZrIBy2Zm2qiURUzPdoE389sui1Cb3g8Bs5A72G6rYl0wUtDwtAEddhfdoBLABSN07Xi8SV1lU533MX3Gl+W9FZEZXw4X/7fqqWDx7bHtseJNKqqbL9t2tFp891Jeed1dnvalnlexzPgOViPjWUbG5UqdpdwS7lGlCsPM7Y97jic/TD7eA7YC1pxK7ekeH5PckLQpEChVUtpLWZfeZE9pqRQ4XmP1dI2PR9AleioJ9JvCaKM7YGU4ZiWt/hDqOkLPPm4HQGmprOgevaqXbBsl2dO+f/NZtfdUg/Yr3t++QbFTyGEhWUO9SgBdNKQfM7LqvEKvQVJlcVzgwX6K+4YDS0Eyb8PJWUxaJzqR6gsbQCNC8+5hMR7SnncfF7dLSqDM//aN56xkkHGmZpBhlccFGiRRHpWshrOVY52n0HiybhcZhXDfk8GF+8f3rXkd0FQWv6/Aa0lpTgm/EEd2pYcyXCIYdLKJCw1kGy89nlOaKSUoO6Uz2el7m8uwc3/RqK62Du5e0Ct9ZuLZ5MSN2aCJ2YmbE3+c7vLg5OTu5mR7ePpn787l5ABy6anL55IVYbZxgbialPcbmsXarlRejnqQvbthR7Ye/FYZWBZc1voPCTmuTphTwMMBsdqxKkzMTWcfQ1MHH0cey5lKYqopDGtu7TXuKpfrxOaH6lnmHGtOyb10CI6L2UQqcq3pgVuqgoT3np4qGa2Q5t29Qtc08gtOCBFBdlsysjsPpBRcOdLWQfGnm5mwnR3sONRk7wBPiEuMFTndld+bkAitYgcnCyOZ8fG+RDyDyAmjho7k7K0aygl19OfSiXhfYnyCe+RkYUuLkxt563YvK3sHX6vtW5lkGtvcyYikTzWysPrlTTUEFTmSTZQi14YesKUqaPr+H6fKRiolo+92RHGCE4MJMmmWbpTA5QYHzlfl40xxZDsHewV6QS/+zMSfEnm5z053rwefgnfX+1MQCIhxu60vrySc2rj72NOcTC+4VoCcUAP5NkAoHaY/h2D92E9BPQCuNZeEP3tw75U6MhjOKJ2a752/1XfLHd8UzCz3JvRC0u3u0O4QcXbVgaBN9/zkZWcKV33f3jB1OvXy+etQd4V5/sYlmgNXvXZfqBrd8RL0Pj3fyBPhCemuz9ZzBNt6qWNLUCV4PUfmdhOTFhMs2Bzo1jYt6Bw0tne49VLtHIlrBw94IZ40tzaZb0LzA8OosYUl0PpI3A4qilIB0AX6LuTTdgRxQ/NbQRz/6WQwVqwrtAtE5JN1gno1C1QWSvSeQyo4dCnbQ9DbY1TXhzERP2qswekLMa238r6ui/5L/TKZ0qZmFeVFSL9QCdtrKUQVNpOTdUc7QW3/GgUALwAn4kHGHkQ4fZL0r9meZ7YHTwSICvOqzvFK8FLlwxUPRtItAh/2tO39Mn8DbFh83YfMA2AdBt83fHXpfx62NYhGTSeAi8OzgR7iiSzJAS5cbglIT4tAhHwVKoTvlolg8GYyovSQiNROovswPp6+BKE1gmUNm5KLwm4k2xV0oygzOQoRxa9Hmx8qeLJFYY3LV0JradebLCUqOBe+vEGdLD5bmsjZAIm1anEz56ibmCwqxhNggVkkkDrE6MNErR/W42WzjG+sbI62AWvHalRcwMmx34eO4MNW08+m1ziSBbI4f3U0fbfk5CqmG3P588je4Hwo/A1gb+BRHPZ3ATnR/mG70RW05tUKi1dFRdivry94+MVjv2GBOviIzfJjXb4ySi5vmlFjBc/LY5KtrXmH5IFYCfkGKyyNhQd1bht8BTnW3sSuQY0CrA3Nu/z1hqgEUonbCsQVXbOyPXuaJes5oqm+9lqs61qzcijfwfGaeOd911MspgrGsyqAuD5uyao59/37d58Vy10J228eF1Y6xLvbStqpR4Bx4+6QB2GHZM3Eegb2ybpkaH0v6PdV/2EgZqub4MZvisKk7NcJYgQAAHh+1isSAOCFx4XEL05fQJErIfSFCEGAAgR81YK18KeN+MO6IchD/nl4/CvaLKAA+REozzpcHbwzpdAcsL55fReFndN4dXGtLqy7Ul0ncHYSpPaamglXVA0qrQivy/hHFHsMcZcg4gwUnJvwneB97iLOTcyEKxq+1BO4cALXd1W3kPcPRd59Z3Iyv+jDiicM75tgZ2ZQIF8ahvK0+5FbqaKtFh8rfP/swIkZKdAIFc1OuSDu9wSIR/qnT7+dZ9fu2dr8Ceriz2pQzdNiXN+gd/o5v6PVneB6CkjsMB/MZ+9t0phOk35Sf8kbQ4JILn3cbqAQn0fDfm25xOek5MXYdZmzCzCrxlA+2yCd3gMGXQuzVqJrsHs/4Fh+eke9TRNo4l2hvKLC1HwaqvaATWXCH3tFxLo681h6+1rPITL3uG6Y9XyEb6n5npHC4ZlqFNdWo/VbSq+/vJ0XxfXwXxanHrPz58MJYh6Bw5RfZF9g3xUK47wYiH0HdIPiAk0gWEsJKDu2Cyu8E767VkFInkBXC93gFQiZIfacryLOiwrx+aBAF3gERXjps0Ie2yQrTm8DtigIyRO4uMO7vALdYPzbQpw77B5TUaaSH10xbxp7QpVnHqXLdaKy6hbgzq0Hg+WgA/pAeR8oQE4A7UpQzgXZA3gZQP2o9hbKg+ooKncDa2eGfNakJMG2uk2+iGqYlIawxfFb1X0S97LwbeXTsw622T9MsJKNUPlFqTxHmpT+h/X9dYrf2MnssnitHuG3qbKrLWNkzNdq9MgOh9qIfqTam2YBJ1pn+Xy6unvW+JD/fx8aFE9sPAA46inrhznI2duK9h/1kJ8z2mJ4+ATfDOPueKLdtQo+NdlYV0h77tGWuPdcZZ64rl3SmEdS9pX2M8IYazmXT9OEgfouSstn37Sx3jF3taEtAM7W6XHQYYcuTL6TrM7fyN94IAm+cbkmE70cXvVjW3w5VCLHSmZfPVhVLW61YFX+YVgN2bS1Y6Pi2IhZtbSTPKiUP/lNejmA0ZXuYnEg7gZdgrEDd8k+RWwMQL/ytSs7/UQf95WgmzD81VirxVt2NuCi2bVDmd4U15F/5BRp87iPBCYEz1GGreAuAnknWRnFFh3ZJbAPcCY5cm0ocig4l0Iqh0oFNqdIFTnBUkc+NVIjnlelHrn0SVO25qrUh8uvpAHtrEozFIq0NKdu9Lacp1rOPlnATPmuFJLlR1KxqSydfKVTcTCQbgDK48fgTEJotHEJRWg/kDC4Ny9hGfSoEo5yjy/hkXqFkgjO1yUREHv/lkTRH1YSs3XKTZLIeCp1S0nm/YYnC1joT0mh3p+TCtv+l4NVj3Mn1dNkZODnaNj2HutENQmLd+my0R+o4Ob4Io+cegFBY2Xy+8WhA2NKrDXMmlRv1Pfg3p2tTXt0J9efFk7+3ScL6Oh3I5uzeJDDzjHki3vdpkGxsPpQEQ10MhCgVHNIHitwsaXw2qyTX1goHGgcT1HpmV88W70w22T8gmIDT8Amk3d2VcH1PAu0SFwjTMpmnZYnBqgPGBubP6ZYhPAXbo9DZ9hvqTgMnuJQOt4Vy89v/0iEWrsqsJY7bwpOM4MoXHBiJ22pJuHQ4Xv8mcAEvT/+aMoSmQYk7J+mNLDWdNUvLrHBROJ5T2tiaSoLRqparzc4kl6024xCj6YOs2X1H4GI1f15xjMYSgL/hPWyoDzUQzi8t3uPdX/hRYk1bAUnXRXIdCU346VUfeRYnQfmoPynL2whZXtT1bug5uE2swQZ7U7Tq2NgYaqQriqrDgLTG6QIj54fTstdOaBjwAdi4erbBiaURoIJ7+pK5A85lkgtuKA1HBSwTRpFp+kk2cOavDKSJgC7xPh3RQnVNDDTSClX9F1AvjrWTDfdkdPXZrKE0NZGTcrNOSlXUUrk91ipwUwHLox92xKfIGPaJgIkNk/KKDW3SivphVmM7J+tpAduJAitD56IIzIIEWyk7YainGZogLqg0/pLevg+TkCkTA7u7OsCd34WBHsKxVjr1mJjFsB+cB5SCHlGUoK9oEfVOWBSVgX7AIcLC2YIPnNYDSegPlNL9WV8JaOAHbdy4DHhqavyFyAY0ANFjUk5gJUnuvRsBSfaFA4ieoeWpSsH4BDmeBh/MuMpC6Ti/gP04OSgCFO+hxLKurSHqhkqEZXuo89QA0+l6x4YmHrh8MN+wagXzKMA+BZnmd1cOupkk/vJ4Ysu9G6ooeygFQeAwshnDDaMgW+AZnJmmXyjVbOgZi+1UdfJCbDSYoAjZSar5KZJrSJKspV/U6TkPbtz6nzFJlg4SX2Xt1yPEg4TXvnUlzbGlurYamA4Fpc4GU4gsGgioWySZrMWUIyDERGOvNCNcUxAmYooNKETQMRcgLbKPSWmwE801/EXhW2+gebXdF7Y4cakmRh00UMfG9jEFraRUKBEhR0McMVxPT8IozhJs7woq7rRbLU73d7XOmePe1q+Yr/+7W5/OJ7Ol2tC1yHIRBK+dkwiOy1KcpLZH17TDdOyHdfzgzBKA0/v0jIFOtqkqNe7HyCZPXIkOctWV5LKyewO/1MKoiQrqqYbpmU7rucHYRQnaZYXZVU3bdcPi+Vqvdnu9ofj6Xy53u6P5+v9+f7+hmnZjuv5QRjFSZrlRVnVTdv1wzgBiDChjM/Luu3Hed3P+/0sah5ZPXvvR9IPhCiqphumzbI7vovhr+RweXyBUCSWSGVyhVKl1tDU0tbR1dM3MDQyNjE1M7ewtLK2sbWzd3B0cnZxdXO3sLSytrG1A4LAECgMjkCi0BgsDk8gksgUKo3OYLLYHC6PLxCKxBKpTK5QqtQarU5vMJrsHRydnF1ckSg0BovDE4gkMoVKozOYrD7/9efvA8AuWwKIMKGMC6m0sX6uDBBhQhkXUmlj/VwFIMKEMi6k0sb6uSpAhAllXEiljfVzNYAIE8q4kEob6+fqABEmlHEhlTY2vwUQYUIZF1JpY/1cGyDChDIupNLG+rkOQIQJZVxIpY31c12ACBPKuJBKG+vn+gEiTCjjQiptrJ/rAUSYUMaFVNpYf707MuaGwBl74Ie6ITPGunXI9ty/nwARJpRxIVW6CBBhQhkXUmlj/VwJIMKEMp6b73WSJEmSJEmSJEmSJEmSJEmSJGnDcHmUyhuJoAkQ4UiX5uXtdZFY9ebHuJBLXd5buMR8AAAAAAAAAAAAAAAAvs12jBcK2xe98ZOilPeb4V4Q80xb3DNvLH3+ZEhYimysJZEoE5KeCTM4k8HSJ2YG0kh/sk8STa8BH+j9uXpButPGF/9IKHol+kDBZEP8uOc3TuJ0iUQDUeAyXSlFqZp7OedSvQAA\") format(\"woff2\");\n}\n\n@font-face {\n  font-family: \"Karasuma\";\n  font-weight: 900;\n  font-style: normal;\n  font-display: swap;\n  src: url(\"data:font/woff2;base64,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\") format(\"woff2\");\n}\n\n@font-face {\n  font-family: \"Karasuma\";\n  font-weight: 900;\n  font-style: italic;\n  font-display: swap;\n  src: url(\"data:font/woff2;base64,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\") format(\"woff2\");\n}\n\n@font-face {\n  font-family: \"Leiko\";\n  font-weight: normal;\n  font-style: normal;\n  font-display: swap;\n  src: url(\"data:font/woff2;base64,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\") format(\"woff2\");\n}\n", "",{"version":3,"sources":["C:/Users/paulo/Desktop/Work/Projects/Personal/Web/paulobmarcos/node_modules/normalize.css/normalize.css","C:/Users/paulo/Desktop/Work/Projects/Personal/Web/paulobmarcos/node_modules/@moxy/react-carousel/dist/styles.css","C:/Users/paulo/Desktop/Work/Projects/Personal/Web/paulobmarcos/www/shared/styles/global/index.css","C:/Users/paulo/Desktop/Work/Projects/Personal/Web/paulobmarcos/www/shared/styles/imports/custom-medias.css","C:/Users/paulo/Desktop/Work/Projects/Personal/Web/paulobmarcos/www/shared/styles/imports/variables.css","C:/Users/paulo/Desktop/Work/Projects/Personal/Web/paulobmarcos/www/shared/styles/global/layout.css","C:/Users/paulo/Desktop/Work/Projects/Personal/Web/paulobmarcos/www/shared/styles/imports/mixins/typography.css","C:/Users/paulo/Desktop/Work/Projects/Personal/Web/paulobmarcos/www/shared/styles/imports/mixins/text.css","C:/Users/paulo/Desktop/Work/Projects/Personal/Web/paulobmarcos/www/shared/styles/global/typography.css","C:/Users/paulo/Desktop/Work/Projects/Personal/Web/paulobmarcos/www/shared/styles/global/font-faces.css"],"names":[],"mappings":"AAAA,2EAA2E;;AAE3E;+EAC+E;;AAE/E;;;EAGE;;AAEF;EACE,iBAAiB,EAAE,MAAM;EACzB,8BAA8B,EAAE,MAAM;AACxC;;AAEA;+EAC+E;;AAE/E;;EAEE;;AAEF;EACE,SAAS;AACX;;AAEA;;EAEE;;AAEF;EACE,cAAc;AAChB;;AAEA;;;EAGE;;AAEF;EACE,cAAc;EACd,gBAAgB;AAClB;;AAEA;+EAC+E;;AAE/E;;;EAGE;;AAEF;EACE,uBAAuB,EAAE,MAAM;EAC/B,SAAS,EAAE,MAAM;EACjB,iBAAiB,EAAE,MAAM;AAC3B;;AAEA;;;EAGE;;AAEF;EACE,iCAAiC,EAAE,MAAM;EACzC,cAAc,EAAE,MAAM;AACxB;;AAEA;+EAC+E;;AAE/E;;EAEE;;AAEF;EACE,6BAA6B;AAC/B;;AAEA;;;EAGE;;AAEF;EACE,mBAAmB,EAAE,MAAM;EAC3B,0BAA0B,EAAE,MAAM;EAClC,yCAAiC;UAAjC,iCAAiC,EAAE,MAAM;AAC3C;;AAEA;;EAEE;;AAEF;;EAEE,mBAAmB;AACrB;;AAEA;;;EAGE;;AAEF;;;EAGE,iCAAiC,EAAE,MAAM;EACzC,cAAc,EAAE,MAAM;AACxB;;AAEA;;EAEE;;AAEF;EACE,cAAc;AAChB;;AAEA;;;EAGE;;AAEF;;EAEE,cAAc;EACd,cAAc;EACd,kBAAkB;EAClB,wBAAwB;AAC1B;;AAEA;EACE,eAAe;AACjB;;AAEA;EACE,WAAW;AACb;;AAEA;+EAC+E;;AAE/E;;EAEE;;AAEF;EACE,kBAAkB;AACpB;;AAEA;+EAC+E;;AAE/E;;;EAGE;;AAEF;;;;;EAKE,oBAAoB,EAAE,MAAM;EAC5B,eAAe,EAAE,MAAM;EACvB,iBAAiB,EAAE,MAAM;EACzB,SAAS,EAAE,MAAM;AACnB;;AAEA;;;EAGE;;AAEF;QACQ,MAAM;EACZ,iBAAiB;AACnB;;AAEA;;;EAGE;;AAEF;SACS,MAAM;EACb,oBAAoB;AACtB;;AAEA;;EAEE;;AAEF;;;;EAIE,0BAA0B;AAC5B;;AAEA;;EAEE;;AAEF;;;;EAIE,kBAAkB;EAClB,UAAU;AACZ;;AAEA;;EAEE;;AAEF;;;;EAIE,8BAA8B;AAChC;;AAEA;;EAEE;;AAEF;EACE,8BAA8B;AAChC;;AAEA;;;;;EAKE;;AAEF;EACE,sBAAsB,EAAE,MAAM;EAC9B,cAAc,EAAE,MAAM;EACtB,cAAc,EAAE,MAAM;EACtB,eAAe,EAAE,MAAM;EACvB,UAAU,EAAE,MAAM;EAClB,mBAAmB,EAAE,MAAM;AAC7B;;AAEA;;EAEE;;AAEF;EACE,wBAAwB;AAC1B;;AAEA;;EAEE;;AAEF;EACE,cAAc;AAChB;;AAEA;;;EAGE;;AAEF;;EAEE,sBAAsB,EAAE,MAAM;EAC9B,UAAU,EAAE,MAAM;AACpB;;AAEA;;EAEE;;AAEF;;EAEE,YAAY;AACd;;AAEA;;;EAGE;;AAEF;EACE,6BAA6B,EAAE,MAAM;EACrC,oBAAoB,EAAE,MAAM;AAC9B;;AAEA;;EAEE;;AAEF;EACE,wBAAwB;AAC1B;;AAEA;;;EAGE;;AAEF;EACE,0BAA0B,EAAE,MAAM;EAClC,aAAa,EAAE,MAAM;AACvB;;AAEA;+EAC+E;;AAE/E;;EAEE;;AAEF;EACE,cAAc;AAChB;;AAEA;;EAEE;;AAEF;EACE,kBAAkB;AACpB;;AAEA;+EAC+E;;AAE/E;;EAEE;;AAEF;EACE,aAAa;AACf;;AAEA;;EAEE;;AAEF;EACE,aAAa;AACf;;AC5VA;;;IAGI,kBAAkB;AACtB;;AAEA;IACI,gBAAgB;IAChB,iCAAiC;AACrC;;AAEA;IACI,kBAAkB;AACtB;;AAEA;IACI,0BAAkB;IAAlB,uBAAkB;IAAlB,kBAAkB;IAClB,mBAAmB;AACvB;;AAEA;IACI,qBAAqB;AACzB;;AAEA;IACI,eAAe;AACnB;;AAEA;IACI,oBAAY;IAAZ,YAAY;AAChB;;AAEA;;IAEI,wBAAgB;IAAhB,gBAAgB;AACpB;;AAEA;IACI,mBAAmB;IACnB,QAAQ;IACR,2BAA2B;AAC/B;;AAEA,kBAAkB,UAAU,EAAE;;AAC9B,mBAAmB,WAAW,EAAE;;AAEhC;IACI,aAAa;IACb,mBAAmB;IACnB,uBAAuB;AAC3B;;AAEA;IACI,aAAa;IACb,YAAY;AAChB;;AAEA;IACI,UAAU;AACd;;ACxDA,aAAa;;ACHb;;;;+EAI+E;;AAEtB,UAAU;;AAChB,UAAU;;AACX,UAAU;;AACT,WAAW;;AACZ,WAAW;;AACV,WAAW;;AACT,WAAW;;ACVhE;;+EAE+E;;AAa/E;;+EAE+E;;AAQ/E;;+EAE+E;;AAiB/E;;gFAEgF;;AAShF;;gFAEgF;;AAShF;;+EAE+E;;ACpE/E;;+EAE+E;;AAE/E;;;IAGI,sBAAsB;AAC1B;;AAEA;;+EAE+E;;AAE/E;;;;CAIC;;AAED;IACI,eAAe;IACf,SAAS,EAAE,MAAM;IACjB,gBAAgB,EAAE,MAAM;IACxB,aAAa,EAAE,MAAM;IACrB,sBAAsB,EAAE,MAAM;AAClC;;AAEA;;+EAE+E;;AAE/E;IACI,aAAa;IACb,cAAc;IACd,sBAAsB;AAC1B;;AAEA;IACI,aAAa;IACb,cAAc;IACd,sBAAsB;AAC1B;;AC1CA;;8EAE8E;;AAO9E;;;;8EAI8E;;ACf9E;;+EAE+E;;AAY/E;;;;+EAI+E;;ACd/E;;+EAE+E;;AAE/E;EACE,gBAAgB,EAAE,mEAAmE;AACvF;;AAEA;EFLE,mCAAmC;EACnC,mBAA0B;EA0B1B,iBAAqB;EC7BnB,kCAAkC;EAAG,8CAA8C;EACnF,mCAAmC;EAAE,+CAA+C;;ECUtF,yBAAyB,GAAG,gCAAgC;EAC5D,wCAAwC,GAAG,yEAAyE;AACtH;;AAEA;;8EAE8E;;AAE9E;;;;EAIE,eAAe;AACjB;;AAEA;EFxBE,mCAAmC;EACnC,mBAA0B;EAW1B,eAAmB;AEcrB;;AAEA;EF5BE,mCAAmC;EACnC,iBAA0B;EAgB1B,iBAAqB;AEavB;;ACrCA;;;;oFAIoF;;AAEpF,+DAA+D;;AAE/D;EACE,uBAAuB;EACvB,mBAAmB;EACnB,kBAAkB;EAClB,kBAAkB;EAClB,my9BAAkF;AACpF;;AAEA;EACE,uBAAuB;EACvB,iBAAiB;EACjB,kBAAkB;EAClB,kBAAkB;EAClB,ms4BAAgF;AAClF;;AAEA;EACE,uBAAuB;EACvB,gBAAgB;EAChB,kBAAkB;EAClB,kBAAkB;EAClB,2j4BAAiF;AACnF;;AAEA;EACE,uBAAuB;EACvB,gBAAgB;EAChB,kBAAkB;EAClB,kBAAkB;EAClB,+qhCAAuF;AACzF;;AAEA;EACE,oBAAoB;EACpB,mBAAmB;EACnB,kBAAkB;EAClB,kBAAkB;EAClB,26nBAAuE;AACzE","file":"index.css","sourcesContent":["/*! normalize.css v8.0.1 | MIT License | github.com/necolas/normalize.css */\n\n/* Document\n   ========================================================================== */\n\n/**\n * 1. Correct the line height in all browsers.\n * 2. Prevent adjustments of font size after orientation changes in iOS.\n */\n\nhtml {\n  line-height: 1.15; /* 1 */\n  -webkit-text-size-adjust: 100%; /* 2 */\n}\n\n/* Sections\n   ========================================================================== */\n\n/**\n * Remove the margin in all browsers.\n */\n\nbody {\n  margin: 0;\n}\n\n/**\n * Render the `main` element consistently in IE.\n */\n\nmain {\n  display: block;\n}\n\n/**\n * Correct the font size and margin on `h1` elements within `section` and\n * `article` contexts in Chrome, Firefox, and Safari.\n */\n\nh1 {\n  font-size: 2em;\n  margin: 0.67em 0;\n}\n\n/* Grouping content\n   ========================================================================== */\n\n/**\n * 1. Add the correct box sizing in Firefox.\n * 2. Show the overflow in Edge and IE.\n */\n\nhr {\n  box-sizing: content-box; /* 1 */\n  height: 0; /* 1 */\n  overflow: visible; /* 2 */\n}\n\n/**\n * 1. Correct the inheritance and scaling of font size in all browsers.\n * 2. Correct the odd `em` font sizing in all browsers.\n */\n\npre {\n  font-family: monospace, monospace; /* 1 */\n  font-size: 1em; /* 2 */\n}\n\n/* Text-level semantics\n   ========================================================================== */\n\n/**\n * Remove the gray background on active links in IE 10.\n */\n\na {\n  background-color: transparent;\n}\n\n/**\n * 1. Remove the bottom border in Chrome 57-\n * 2. Add the correct text decoration in Chrome, Edge, IE, Opera, and Safari.\n */\n\nabbr[title] {\n  border-bottom: none; /* 1 */\n  text-decoration: underline; /* 2 */\n  text-decoration: underline dotted; /* 2 */\n}\n\n/**\n * Add the correct font weight in Chrome, Edge, and Safari.\n */\n\nb,\nstrong {\n  font-weight: bolder;\n}\n\n/**\n * 1. Correct the inheritance and scaling of font size in all browsers.\n * 2. Correct the odd `em` font sizing in all browsers.\n */\n\ncode,\nkbd,\nsamp {\n  font-family: monospace, monospace; /* 1 */\n  font-size: 1em; /* 2 */\n}\n\n/**\n * Add the correct font size in all browsers.\n */\n\nsmall {\n  font-size: 80%;\n}\n\n/**\n * Prevent `sub` and `sup` elements from affecting the line height in\n * all browsers.\n */\n\nsub,\nsup {\n  font-size: 75%;\n  line-height: 0;\n  position: relative;\n  vertical-align: baseline;\n}\n\nsub {\n  bottom: -0.25em;\n}\n\nsup {\n  top: -0.5em;\n}\n\n/* Embedded content\n   ========================================================================== */\n\n/**\n * Remove the border on images inside links in IE 10.\n */\n\nimg {\n  border-style: none;\n}\n\n/* Forms\n   ========================================================================== */\n\n/**\n * 1. Change the font styles in all browsers.\n * 2. Remove the margin in Firefox and Safari.\n */\n\nbutton,\ninput,\noptgroup,\nselect,\ntextarea {\n  font-family: inherit; /* 1 */\n  font-size: 100%; /* 1 */\n  line-height: 1.15; /* 1 */\n  margin: 0; /* 2 */\n}\n\n/**\n * Show the overflow in IE.\n * 1. Show the overflow in Edge.\n */\n\nbutton,\ninput { /* 1 */\n  overflow: visible;\n}\n\n/**\n * Remove the inheritance of text transform in Edge, Firefox, and IE.\n * 1. Remove the inheritance of text transform in Firefox.\n */\n\nbutton,\nselect { /* 1 */\n  text-transform: none;\n}\n\n/**\n * Correct the inability to style clickable types in iOS and Safari.\n */\n\nbutton,\n[type=\"button\"],\n[type=\"reset\"],\n[type=\"submit\"] {\n  -webkit-appearance: button;\n}\n\n/**\n * Remove the inner border and padding in Firefox.\n */\n\nbutton::-moz-focus-inner,\n[type=\"button\"]::-moz-focus-inner,\n[type=\"reset\"]::-moz-focus-inner,\n[type=\"submit\"]::-moz-focus-inner {\n  border-style: none;\n  padding: 0;\n}\n\n/**\n * Restore the focus styles unset by the previous rule.\n */\n\nbutton:-moz-focusring,\n[type=\"button\"]:-moz-focusring,\n[type=\"reset\"]:-moz-focusring,\n[type=\"submit\"]:-moz-focusring {\n  outline: 1px dotted ButtonText;\n}\n\n/**\n * Correct the padding in Firefox.\n */\n\nfieldset {\n  padding: 0.35em 0.75em 0.625em;\n}\n\n/**\n * 1. Correct the text wrapping in Edge and IE.\n * 2. Correct the color inheritance from `fieldset` elements in IE.\n * 3. Remove the padding so developers are not caught out when they zero out\n *    `fieldset` elements in all browsers.\n */\n\nlegend {\n  box-sizing: border-box; /* 1 */\n  color: inherit; /* 2 */\n  display: table; /* 1 */\n  max-width: 100%; /* 1 */\n  padding: 0; /* 3 */\n  white-space: normal; /* 1 */\n}\n\n/**\n * Add the correct vertical alignment in Chrome, Firefox, and Opera.\n */\n\nprogress {\n  vertical-align: baseline;\n}\n\n/**\n * Remove the default vertical scrollbar in IE 10+.\n */\n\ntextarea {\n  overflow: auto;\n}\n\n/**\n * 1. Add the correct box sizing in IE 10.\n * 2. Remove the padding in IE 10.\n */\n\n[type=\"checkbox\"],\n[type=\"radio\"] {\n  box-sizing: border-box; /* 1 */\n  padding: 0; /* 2 */\n}\n\n/**\n * Correct the cursor style of increment and decrement buttons in Chrome.\n */\n\n[type=\"number\"]::-webkit-inner-spin-button,\n[type=\"number\"]::-webkit-outer-spin-button {\n  height: auto;\n}\n\n/**\n * 1. Correct the odd appearance in Chrome and Safari.\n * 2. Correct the outline style in Safari.\n */\n\n[type=\"search\"] {\n  -webkit-appearance: textfield; /* 1 */\n  outline-offset: -2px; /* 2 */\n}\n\n/**\n * Remove the inner padding in Chrome and Safari on macOS.\n */\n\n[type=\"search\"]::-webkit-search-decoration {\n  -webkit-appearance: none;\n}\n\n/**\n * 1. Correct the inability to style clickable types in iOS and Safari.\n * 2. Change font properties to `inherit` in Safari.\n */\n\n::-webkit-file-upload-button {\n  -webkit-appearance: button; /* 1 */\n  font: inherit; /* 2 */\n}\n\n/* Interactive\n   ========================================================================== */\n\n/*\n * Add the correct display in Edge, IE 10+, and Firefox.\n */\n\ndetails {\n  display: block;\n}\n\n/*\n * Add the correct display in all browsers.\n */\n\nsummary {\n  display: list-item;\n}\n\n/* Misc\n   ========================================================================== */\n\n/**\n * Add the correct display in IE 10+.\n */\n\ntemplate {\n  display: none;\n}\n\n/**\n * Add the correct display in IE 10.\n */\n\n[hidden] {\n  display: none;\n}\n",".rc-wrapper,\n.rc,\n.rc-slider {\n    position: relative;\n}\n\n.rc {\n    overflow-x: auto;\n    -webkit-overflow-scrolling: touch;\n}\n\n.rc.-no-scroll {\n    overflow-x: hidden;\n}\n\n.rc-slider {\n    width: fit-content;\n    white-space: nowrap;\n}\n\n.rc-slide {\n    display: inline-block;\n}\n\n.rc-slide:hover {\n    cursor: pointer;\n}\n\n.rc-slider.-draggable:hover {\n    cursor: grab;\n}\n\n.rc-slider.-draggable.-dragging,\n.rc-slider.-draggable.-dragging .rc-slide {\n    cursor: grabbing;\n}\n\n.rc-arrow {\n    position:  absolute;\n    top: 50%;\n    transform: translateY(-50%);\n}\n\n.rc-arrow.-left { left: 15px; }\n.rc-arrow.-right { right: 15px; }\n\n.rc-dots {\n    display: flex;\n    align-items: center;\n    justify-content: center;\n}\n\n.rc-dot {\n    margin: 0 5px;\n    opacity: 0.5;\n}\n\n.rc-dot.-current {\n    opacity: 1;\n}\n\n","@import \"normalize.css\";\n@import \"@moxy/react-carousel/dist/styles.css\";\n\n/* Internal */\n@import \"./layout\";\n@import \"./typography\";\n@import \"./font-faces\";\n","/* ==========================================================================\n   Custom media queries\n\n   Use it like so: @media (--layout-small) { ... }\n   ========================================================================== */\n\n@custom-media --layout-lte-xxsmall (width <= 23.4375em); /* 375px */\n@custom-media --layout-lte-xsmall (width <= 30em); /* 480px */\n@custom-media --layout-lte-small (width <= 48em); /* 768px */\n@custom-media --layout-lte-medium (width <= 64em); /* 1024px */\n@custom-media --layout-lte-large (width <= 80em); /* 1280px */\n@custom-media --layout-lte-xlarge (width <= 90em); /* 1440px */\n@custom-media --layout-lte-xxlarge (width <= 120em); /* 1920px */\n","@import \"./custom-medias\";\n\n/* ==========================================================================\n   Colors\n   ========================================================================== */\n\n:root {\n  --color-white: #fff;\n  --color-black: #000;\n  --color-dark: #0f0f11;\n  --color-gray: #2d2e32;\n  --color-light-gray: #c1c5d4;\n  --color-dark-gray: #191a1d;\n  --color-green: #64f4ac;\n  --color-green-dark: #286144;\n}\n\n/* ==========================================================================\n   Z-Indexes\n   ========================================================================== */\n\n:root {\n  --z-index-base: 1;\n  --z-index-header: 5;\n  --z-index-frame: 6;\n}\n\n/* ==========================================================================\n   Sizes\n   ========================================================================== */\n\n:root {\n  --layout-width: 100vw;\n  --layout-height: 100vh;\n  --layout-max-width: 150rem;\n  --layout-padding: 2.2rem;\n\n  --header-height: 4rem;\n  --header-frame-top: calc(var(--layout-padding) * 2);\n\n  --content-viewport-height: calc(100vh - (var(--layout-padding) * 2));\n\n  --carousel-item-width: 60vw;\n  --carousel-item-height: 30vw;\n}\n\n/* ==========================================================================\n    Landscape\n    ========================================================================== */\n\n@media (orientation: landscape) {\n  :root {\n    --carousel-item-width: 60vw;\n    --carousel-item-height: 33vw;\n  }\n}\n\n/* ==========================================================================\n    Portrait\n    ========================================================================== */\n\n@media (orientation: portrait) {\n  :root {\n    --carousel-item-width: 80vw;\n    --carousel-item-height: 80vw;\n  }\n}\n\n/* ==========================================================================\n   Custom medias\n   ========================================================================== */\n\n@media (--layout-lte-small) {\n  :root {\n    --layout-padding: 2vw;\n  }\n}\n","@import \"../imports/variables.css\";\n\n/* ==========================================================================\n   Proper box-sizing model\n   ========================================================================== */\n\n*,\n*::before,\n*::after {\n    box-sizing: border-box;\n}\n\n/* ==========================================================================\n   Document\n   ========================================================================== */\n\n/*\n   1. Stretch <html> stretch to fill our screen height\n   2. Make children of html (body) occupy at least 100% of the screen\n   3. Viewport is scalable and occupies at least 320px (iPhone SE)\n*/\n\nhtml {\n    min-width: 32em;\n    height: 0; /* 3 */\n    min-height: 100%; /* 1 */\n    display: flex; /* 2 */\n    flex-direction: column; /* 2 */\n}\n\n/* ==========================================================================\n   Body & #root\n   ========================================================================== */\n\nbody {\n    display: flex;\n    flex: 1 0 auto;\n    flex-direction: column;\n}\n\n:global(#__next) {\n    display: flex;\n    flex: 1 0 auto;\n    flex-direction: column;\n}\n","@import \"../custom-medias\";\n\n/* ==========================================================================\n  Fonts\n  ========================================================================== */\n\n@define-mixin _font-karasuma $fontWeight: normal {\n  font-family: \"Karasuma\", sans-serif;\n  font-weight: $(fontWeight);\n}\n\n/* ==========================================================================\n  All typography variants\n\n  $unit - Either em or rem\n  ========================================================================== */\n\n@define-mixin typography-h1 $unit: rem {\n  @mixin _font-karasuma bolder;\n  font-size: 8$(unit);\n}\n\n@define-mixin typography-h2 $unit: rem {\n  @mixin _font-karasuma bold;\n  font-size: 4.8$(unit);\n}\n\n@define-mixin typography-body $unit: rem {\n  @mixin _font-karasuma;\n  font-size: 1.6$(unit);\n}\n\n@define-mixin typography-body $unit: rem {\n  @mixin _font-karasuma;\n  font-size: 1.6$(unit);\n}\n","/* ==========================================================================\n   Smooth & sharp mixins\n   ========================================================================== */\n\n@define-mixin text-smooth {\n    -moz-osx-font-smoothing: grayscale;  /* Font smoothing tweaks for MacOSx in Gecko */\n    -webkit-font-smoothing: antialiased; /* Font smoothing tweaks for MacOSx in Webkit */\n}\n\n@define-mixin text-sharp {\n    -moz-osx-font-smoothing: initial;   /* Turn off font smoothing tweaks for MacOSx in Gecko */\n    -webkit-font-smoothing: initial;    /* Turn off font smoothing tweaks for MacOSx in Webkit */\n}\n\n/* ==========================================================================\n   Ellipsis mixin\n\n   The container needs to have a width for it to work\n   ========================================================================== */\n\n@define-mixin text-ellipsis {\n    overflow: hidden; /* \"overflow\" value must be different from \"visible\" */\n    text-overflow: ellipsis;\n    white-space: nowrap;\n    overflow-wrap: normal;\n}\n\n@define-mixin text-ellipsis-multiline $max-line-count, $max-height {\n    max-height: $max-height;\n    overflow: hidden;\n    /* stylelint-disable */\n    display: -webkit-box;\n    text-overflow: ellipsis;\n    -webkit-line-clamp: $max-line-count;\n    -webkit-box-orient: vertical;\n    /* stylelint-enable */\n}\n","@import \"../imports/variables.css\";\n@import \"../imports/mixins/typography.css\";\n@import \"../imports/mixins/text.css\";\n\n/* ==========================================================================\n   Typography Defaults\n   ========================================================================== */\n\nhtml {\n  font-size: 62.5%; /* 62.5% so that all the REM measurements re based on 10px sizing */\n}\n\nbody {\n  @mixin typography-body;\n  @mixin text-smooth;\n\n  overflow-wrap: break-word;  /* Break long words by default */\n  -webkit-tap-highlight-color: transparent;  /* Do not show a highlight (rectangle around the link) while tapping it */\n}\n\n/* ==========================================================================\n  Headings\n  ========================================================================== */\n\nh1,\nh2,\nh3,\nh4 {\n  margin: 0.7em 0;\n}\n\nh1 {\n  @mixin typography-h1;\n}\n\nh2 {\n  @mixin typography-h2;\n}\n","/* ================================================================================\n  Fonts\n  If you are going to include custom fonts please use the /www/shared/media/fonts\n  directory.\n  ================================================================================ */\n\n/* stylelint-disable scale-unlimited/declaration-strict-value */\n\n@font-face {\n  font-family: \"Karasuma\";\n  font-weight: normal;\n  font-style: normal;\n  font-display: swap;\n  src: url(\"../../media/fonts/karasuma/KarasumaGothic-Medium.woff2\") format(\"woff2\");\n}\n\n@font-face {\n  font-family: \"Karasuma\";\n  font-weight: bold;\n  font-style: normal;\n  font-display: swap;\n  src: url(\"../../media/fonts/karasuma/KarasumaGothic-Bold.woff2\") format(\"woff2\");\n}\n\n@font-face {\n  font-family: \"Karasuma\";\n  font-weight: 900;\n  font-style: normal;\n  font-display: swap;\n  src: url(\"../../media/fonts/karasuma/KarasumaGothic-Black.woff2\") format(\"woff2\");\n}\n\n@font-face {\n  font-family: \"Karasuma\";\n  font-weight: 900;\n  font-style: italic;\n  font-display: swap;\n  src: url(\"../../media/fonts/karasuma/KarasumaGothic-BlackItalic.woff2\") format(\"woff2\");\n}\n\n@font-face {\n  font-family: \"Leiko\";\n  font-weight: normal;\n  font-style: normal;\n  font-display: swap;\n  src: url(\"../../media/fonts/leiko/Leiko-Regular.woff2\") format(\"woff2\");\n}\n"]}]);
// Exports
module.exports = exports;


/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
// eslint-disable-next-line func-names
module.exports = function (useSourceMap) {
  var list = []; // return the list of modules as css string

  list.toString = function toString() {
    return this.map(function (item) {
      var content = cssWithMappingToString(item, useSourceMap);

      if (item[2]) {
        return "@media ".concat(item[2], " {").concat(content, "}");
      }

      return content;
    }).join('');
  }; // import a list of modules into the list
  // eslint-disable-next-line func-names


  list.i = function (modules, mediaQuery, dedupe) {
    if (typeof modules === 'string') {
      // eslint-disable-next-line no-param-reassign
      modules = [[null, modules, '']];
    }

    var alreadyImportedModules = {};

    if (dedupe) {
      for (var i = 0; i < this.length; i++) {
        // eslint-disable-next-line prefer-destructuring
        var id = this[i][0];

        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }

    for (var _i = 0; _i < modules.length; _i++) {
      var item = [].concat(modules[_i]);

      if (dedupe && alreadyImportedModules[item[0]]) {
        // eslint-disable-next-line no-continue
        continue;
      }

      if (mediaQuery) {
        if (!item[2]) {
          item[2] = mediaQuery;
        } else {
          item[2] = "".concat(mediaQuery, " and ").concat(item[2]);
        }
      }

      list.push(item);
    }
  };

  return list;
};

function cssWithMappingToString(item, useSourceMap) {
  var content = item[1] || ''; // eslint-disable-next-line prefer-destructuring

  var cssMapping = item[3];

  if (!cssMapping) {
    return content;
  }

  if (useSourceMap && typeof btoa === 'function') {
    var sourceMapping = toComment(cssMapping);
    var sourceURLs = cssMapping.sources.map(function (source) {
      return "/*# sourceURL=".concat(cssMapping.sourceRoot || '').concat(source, " */");
    });
    return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
  }

  return [content].join('\n');
} // Adapted from convert-source-map (MIT)


function toComment(sourceMap) {
  // eslint-disable-next-line no-undef
  var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
  var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
  return "/*# ".concat(data, " */");
}

/***/ }),

/***/ "./node_modules/exenv/index.js":
/*!*************************************!*\
  !*** ./node_modules/exenv/index.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;/*!
  Copyright (c) 2015 Jed Watson.
  Based on code that is Copyright 2013-2015, Facebook, Inc.
  All rights reserved.
*/
/* global define */

(function () {
	'use strict';

	var canUseDOM = !!(
		typeof window !== 'undefined' &&
		window.document &&
		window.document.createElement
	);

	var ExecutionEnvironment = {

		canUseDOM: canUseDOM,

		canUseWorkers: typeof Worker !== 'undefined',

		canUseEventListeners:
			canUseDOM && !!(window.addEventListener || window.attachEvent),

		canUseViewport: canUseDOM && !!window.screen

	};

	if (true) {
		!(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
			return ExecutionEnvironment;
		}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {}

}());


/***/ }),

/***/ "./node_modules/function-bind/implementation.js":
/*!******************************************************!*\
  !*** ./node_modules/function-bind/implementation.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* eslint no-invalid-this: 1 */

var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var slice = Array.prototype.slice;
var toStr = Object.prototype.toString;
var funcType = '[object Function]';

module.exports = function bind(that) {
    var target = this;
    if (typeof target !== 'function' || toStr.call(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slice.call(arguments, 1);

    var bound;
    var binder = function () {
        if (this instanceof bound) {
            var result = target.apply(
                this,
                args.concat(slice.call(arguments))
            );
            if (Object(result) === result) {
                return result;
            }
            return this;
        } else {
            return target.apply(
                that,
                args.concat(slice.call(arguments))
            );
        }
    };

    var boundLength = Math.max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
        boundArgs.push('$' + i);
    }

    bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);

    if (target.prototype) {
        var Empty = function Empty() {};
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
    }

    return bound;
};


/***/ }),

/***/ "./node_modules/function-bind/index.js":
/*!*********************************************!*\
  !*** ./node_modules/function-bind/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var implementation = __webpack_require__(/*! ./implementation */ "./node_modules/function-bind/implementation.js");

module.exports = Function.prototype.bind || implementation;


/***/ }),

/***/ "./node_modules/has/src/index.js":
/*!***************************************!*\
  !*** ./node_modules/has/src/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var bind = __webpack_require__(/*! function-bind */ "./node_modules/function-bind/index.js");

module.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);


/***/ }),

/***/ "./node_modules/lodash/_Symbol.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/_Symbol.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/** Built-in value references. */
var Symbol = root.Symbol;

module.exports = Symbol;


/***/ }),

/***/ "./node_modules/lodash/_baseClamp.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_baseClamp.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.clamp` which doesn't coerce arguments.
 *
 * @private
 * @param {number} number The number to clamp.
 * @param {number} [lower] The lower bound.
 * @param {number} upper The upper bound.
 * @returns {number} Returns the clamped number.
 */
function baseClamp(number, lower, upper) {
  if (number === number) {
    if (upper !== undefined) {
      number = number <= upper ? number : upper;
    }
    if (lower !== undefined) {
      number = number >= lower ? number : lower;
    }
  }
  return number;
}

module.exports = baseClamp;


/***/ }),

/***/ "./node_modules/lodash/_baseGetTag.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_baseGetTag.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(/*! ./_Symbol */ "./node_modules/lodash/_Symbol.js"),
    getRawTag = __webpack_require__(/*! ./_getRawTag */ "./node_modules/lodash/_getRawTag.js"),
    objectToString = __webpack_require__(/*! ./_objectToString */ "./node_modules/lodash/_objectToString.js");

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

module.exports = baseGetTag;


/***/ }),

/***/ "./node_modules/lodash/_freeGlobal.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_freeGlobal.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

module.exports = freeGlobal;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/lodash/_getRawTag.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_getRawTag.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(/*! ./_Symbol */ "./node_modules/lodash/_Symbol.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

module.exports = getRawTag;


/***/ }),

/***/ "./node_modules/lodash/_objectToString.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_objectToString.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;


/***/ }),

/***/ "./node_modules/lodash/_root.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/_root.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var freeGlobal = __webpack_require__(/*! ./_freeGlobal */ "./node_modules/lodash/_freeGlobal.js");

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

module.exports = root;


/***/ }),

/***/ "./node_modules/lodash/clamp.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/clamp.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseClamp = __webpack_require__(/*! ./_baseClamp */ "./node_modules/lodash/_baseClamp.js"),
    toNumber = __webpack_require__(/*! ./toNumber */ "./node_modules/lodash/toNumber.js");

/**
 * Clamps `number` within the inclusive `lower` and `upper` bounds.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Number
 * @param {number} number The number to clamp.
 * @param {number} [lower] The lower bound.
 * @param {number} upper The upper bound.
 * @returns {number} Returns the clamped number.
 * @example
 *
 * _.clamp(-10, -5, 5);
 * // => -5
 *
 * _.clamp(10, -5, 5);
 * // => 5
 */
function clamp(number, lower, upper) {
  if (upper === undefined) {
    upper = lower;
    lower = undefined;
  }
  if (upper !== undefined) {
    upper = toNumber(upper);
    upper = upper === upper ? upper : 0;
  }
  if (lower !== undefined) {
    lower = toNumber(lower);
    lower = lower === lower ? lower : 0;
  }
  return baseClamp(toNumber(number), lower, upper);
}

module.exports = clamp;


/***/ }),

/***/ "./node_modules/lodash/isObject.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/isObject.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

module.exports = isObject;


/***/ }),

/***/ "./node_modules/lodash/isObjectLike.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/isObjectLike.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

module.exports = isObjectLike;


/***/ }),

/***/ "./node_modules/lodash/isSymbol.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/isSymbol.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && baseGetTag(value) == symbolTag);
}

module.exports = isSymbol;


/***/ }),

/***/ "./node_modules/lodash/toNumber.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/toNumber.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js"),
    isSymbol = __webpack_require__(/*! ./isSymbol */ "./node_modules/lodash/isSymbol.js");

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

module.exports = toNumber;


/***/ }),

/***/ "./node_modules/next/dist/build/polyfills/object-assign.js":
/*!*****************************************************************!*\
  !*** ./node_modules/next/dist/build/polyfills/object-assign.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var assign=Object.assign.bind(Object);module.exports=assign;module.exports.default=module.exports;
//# sourceMappingURL=object-assign.js.map

/***/ }),

/***/ "./node_modules/next/dist/build/polyfills/object.assign/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/next/dist/build/polyfills/object.assign/index.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var assign=Object.assign.bind(Object);function g(){return assign;}Object.defineProperties(g(),{implementation:{get:g},shim:{value:g},getPolyfill:{value:g}});module.exports=g();
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?page=%2F_app&absolutePagePath=private-next-pages%2F_app.js!./":
/*!*********************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?page=%2F_app&absolutePagePath=private-next-pages%2F_app.js ***!
  \*********************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


    (window.__NEXT_P = window.__NEXT_P || []).push([
      "/_app",
      function () {
        return __webpack_require__(/*! private-next-pages/_app.js */ "./pages/_app.js");
      }
    ]);
  

/***/ }),

/***/ "./node_modules/next/dist/client/link.js":
/*!***********************************************!*\
  !*** ./node_modules/next/dist/client/link.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _slicedToArray = __webpack_require__(/*! @babel/runtime/helpers/slicedToArray */ "./node_modules/@babel/runtime/helpers/slicedToArray.js");

var _s = $RefreshSig$();

var _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ "./node_modules/@babel/runtime/helpers/interopRequireWildcard.js");

exports.__esModule = true;
exports.default = void 0;

var _react = _interopRequireWildcard(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

var _router = __webpack_require__(/*! ../next-server/lib/router/router */ "./node_modules/next/dist/next-server/lib/router/router.js");

var _utils = __webpack_require__(/*! ../next-server/lib/utils */ "./node_modules/next/dist/next-server/lib/utils.js");

var _router2 = __webpack_require__(/*! ./router */ "./node_modules/next/dist/client/router.js");

let cachedObserver;
const listeners = new Map();
const IntersectionObserver = true ? window.IntersectionObserver : undefined;
const prefetched = {};

function getObserver() {
  // Return shared instance of IntersectionObserver if already created
  if (cachedObserver) {
    return cachedObserver;
  } // Only create shared IntersectionObserver if supported in browser


  if (!IntersectionObserver) {
    return undefined;
  }

  return cachedObserver = new IntersectionObserver(entries => {
    entries.forEach(entry => {
      if (!listeners.has(entry.target)) {
        return;
      }

      const cb = listeners.get(entry.target);

      if (entry.isIntersecting || entry.intersectionRatio > 0) {
        cachedObserver.unobserve(entry.target);
        listeners.delete(entry.target);
        cb();
      }
    });
  }, {
    rootMargin: '200px'
  });
}

const listenToIntersections = (el, cb) => {
  const observer = getObserver();

  if (!observer) {
    return () => {};
  }

  observer.observe(el);
  listeners.set(el, cb);
  return () => {
    try {
      observer.unobserve(el);
    } catch (err) {
      console.error(err);
    }

    listeners.delete(el);
  };
};

function prefetch(router, href, as, options) {
  if (false) {}
  if (!(0, _router.isLocalURL)(href)) return; // Prefetch the JSON page if asked (only in the client)
  // We need to handle a prefetch error here since we may be
  // loading with priority which can reject but we don't
  // want to force navigation since this is only a prefetch

  router.prefetch(href, as, options).catch(err => {
    if (true) {
      // rethrow to show invalid URL errors
      throw err;
    }
  }); // Join on an invalid URI character

  prefetched[href + '%' + as] = true;
}

function isModifiedEvent(event) {
  const target = event.currentTarget.target;
  return target && target !== '_self' || event.metaKey || event.ctrlKey || event.shiftKey || event.altKey || // triggers resource download
  event.nativeEvent && event.nativeEvent.which === 2;
}

function linkClicked(e, router, href, as, replace, shallow, scroll) {
  const nodeName = e.currentTarget.nodeName;

  if (nodeName === 'A' && (isModifiedEvent(e) || !(0, _router.isLocalURL)(href))) {
    // ignore click for browser’s default behavior
    return;
  }

  e.preventDefault(); //  avoid scroll for urls with anchor refs

  if (scroll == null) {
    scroll = as.indexOf('#') < 0;
  } // replace state instead of push if prop is present


  router[replace ? 'replace' : 'push'](href, as, {
    shallow
  }).then(success => {
    if (!success) return;

    if (scroll) {
      window.scrollTo(0, 0);
      document.body.focus();
    }
  });
}

function Link(props) {
  _s();

  if (true) {
    // This hook is in a conditional but that is ok because `process.env.NODE_ENV` never changes
    // eslint-disable-next-line react-hooks/rules-of-hooks
    const hasWarned = _react.default.useRef(false);

    if (props.prefetch && !hasWarned.current) {
      hasWarned.current = true;
      console.warn('Next.js auto-prefetches automatically based on viewport. The prefetch attribute is no longer needed. More: https://err.sh/vercel/next.js/prefetch-true-deprecated');
    }
  }

  const p = props.prefetch !== false;

  const _react$default$useSta = _react.default.useState(),
        _react$default$useSta2 = _slicedToArray(_react$default$useSta, 2),
        childElm = _react$default$useSta2[0],
        setChildElm = _react$default$useSta2[1];

  const router = (0, _router2.useRouter)();
  const pathname = router && router.pathname || '/';

  const _react$default$useMem = _react.default.useMemo(() => {
    const resolvedHref = (0, _router.resolveHref)(pathname, props.href);
    return {
      href: resolvedHref,
      as: props.as ? (0, _router.resolveHref)(pathname, props.as) : resolvedHref
    };
  }, [pathname, props.href, props.as]),
        href = _react$default$useMem.href,
        as = _react$default$useMem.as;

  _react.default.useEffect(() => {
    if (p && IntersectionObserver && childElm && childElm.tagName && (0, _router.isLocalURL)(href)) {
      // Join on an invalid URI character
      const isPrefetched = prefetched[href + '%' + as];

      if (!isPrefetched) {
        return listenToIntersections(childElm, () => {
          prefetch(router, href, as);
        });
      }
    }
  }, [p, childElm, href, as, router]);

  let children = props.children,
      replace = props.replace,
      shallow = props.shallow,
      scroll = props.scroll; // Deprecated. Warning shown by propType check. If the children provided is a string (<Link>example</Link>) we wrap it in an <a> tag

  if (typeof children === 'string') {
    children = /*#__PURE__*/_react.default.createElement("a", null, children);
  } // This will return the first child, if multiple are provided it will throw an error


  const child = _react.Children.only(children);

  const childProps = {
    ref: el => {
      if (el) setChildElm(el);

      if (child && typeof child === 'object' && child.ref) {
        if (typeof child.ref === 'function') child.ref(el);else if (typeof child.ref === 'object') {
          child.ref.current = el;
        }
      }
    },
    onClick: e => {
      if (child.props && typeof child.props.onClick === 'function') {
        child.props.onClick(e);
      }

      if (!e.defaultPrevented) {
        linkClicked(e, router, href, as, replace, shallow, scroll);
      }
    }
  };

  if (p) {
    childProps.onMouseEnter = e => {
      if (!(0, _router.isLocalURL)(href)) return;

      if (child.props && typeof child.props.onMouseEnter === 'function') {
        child.props.onMouseEnter(e);
      }

      prefetch(router, href, as, {
        priority: true
      });
    };
  } // If child is an <a> tag and doesn't have a href attribute, or if the 'passHref' property is
  // defined, we specify the current 'href', so that repetition is not needed by the user


  if (props.passHref || child.type === 'a' && !('href' in child.props)) {
    childProps.href = (0, _router.addBasePath)(as);
  }

  return _react.default.cloneElement(child, childProps);
}

_s(Link, "Yt4+dEXpDdcToH476p06kPk14D0=");

_c = Link;

if (true) {
  const warn = (0, _utils.execOnce)(console.error); // This module gets removed by webpack.IgnorePlugin

  const PropTypes = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");

  const exact = __webpack_require__(/*! prop-types-exact */ "./node_modules/prop-types-exact/build/index.js"); // @ts-ignore the property is supported, when declaring it on the class it outputs an extra bit of code which is not needed.


  Link.propTypes = exact({
    href: PropTypes.oneOfType([PropTypes.string, PropTypes.object]).isRequired,
    as: PropTypes.oneOfType([PropTypes.string, PropTypes.object]),
    prefetch: PropTypes.bool,
    replace: PropTypes.bool,
    shallow: PropTypes.bool,
    passHref: PropTypes.bool,
    scroll: PropTypes.bool,
    children: PropTypes.oneOfType([PropTypes.element, (props, propName) => {
      const value = props[propName];

      if (typeof value === 'string') {
        warn("Warning: You're using a string directly inside <Link>. This usage has been deprecated. Please add an <a> tag as child of <Link>");
      }

      return null;
    }]).isRequired
  });
}

var _default = Link;
exports.default = _default;

var _c;

$RefreshReg$(_c, "Link");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/normalize-trailing-slash.js":
/*!*******************************************************************!*\
  !*** ./node_modules/next/dist/client/normalize-trailing-slash.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.removePathTrailingSlash = removePathTrailingSlash;
exports.normalizePathTrailingSlash = void 0;
/**
* Removes the trailing slash of a path if there is one. Preserves the root path `/`.
*/

function removePathTrailingSlash(path) {
  return path.endsWith('/') && path !== '/' ? path.slice(0, -1) : path;
}
/**
* Normalizes the trailing slash of a path according to the `trailingSlash` option
* in `next.config.js`.
*/


const normalizePathTrailingSlash =  false ? undefined : removePathTrailingSlash;
exports.normalizePathTrailingSlash = normalizePathTrailingSlash;

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/router.js":
/*!*************************************************!*\
  !*** ./node_modules/next/dist/client/router.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _s = $RefreshSig$();

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

var _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ "./node_modules/@babel/runtime/helpers/interopRequireWildcard.js");

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

exports.__esModule = true;
exports.useRouter = useRouter;
exports.makePublicRouterInstance = makePublicRouterInstance;
exports.createRouter = exports.withRouter = exports.default = void 0;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

var _router2 = _interopRequireWildcard(__webpack_require__(/*! ../next-server/lib/router/router */ "./node_modules/next/dist/next-server/lib/router/router.js"));

exports.Router = _router2.default;
exports.NextRouter = _router2.NextRouter;

var _routerContext = __webpack_require__(/*! ../next-server/lib/router-context */ "./node_modules/next/dist/next-server/lib/router-context.js");

var _withRouter = _interopRequireDefault(__webpack_require__(/*! ./with-router */ "./node_modules/next/dist/client/with-router.js"));

exports.withRouter = _withRouter.default;
/* global window */

const singletonRouter = {
  router: null,
  // holds the actual router instance
  readyCallbacks: [],

  ready(cb) {
    if (this.router) return cb();

    if (true) {
      this.readyCallbacks.push(cb);
    }
  }

}; // Create public properties and methods of the router in the singletonRouter

const urlPropertyFields = ['pathname', 'route', 'query', 'asPath', 'components', 'isFallback', 'basePath'];
const routerEvents = ['routeChangeStart', 'beforeHistoryChange', 'routeChangeComplete', 'routeChangeError', 'hashChangeStart', 'hashChangeComplete'];
const coreMethodFields = ['push', 'replace', 'reload', 'back', 'prefetch', 'beforePopState']; // Events is a static property on the router, the router doesn't have to be initialized to use it

Object.defineProperty(singletonRouter, 'events', {
  get() {
    return _router2.default.events;
  }

});
urlPropertyFields.forEach(field => {
  // Here we need to use Object.defineProperty because, we need to return
  // the property assigned to the actual router
  // The value might get changed as we change routes and this is the
  // proper way to access it
  Object.defineProperty(singletonRouter, field, {
    get() {
      const router = getRouter();
      return router[field];
    }

  });
});
coreMethodFields.forEach(field => {
  // We don't really know the types here, so we add them later instead
  ;

  singletonRouter[field] = (...args) => {
    const router = getRouter();
    return router[field](...args);
  };
});
routerEvents.forEach(event => {
  singletonRouter.ready(() => {
    _router2.default.events.on(event, (...args) => {
      const eventField = "on".concat(event.charAt(0).toUpperCase()).concat(event.substring(1));
      const _singletonRouter = singletonRouter;

      if (_singletonRouter[eventField]) {
        try {
          _singletonRouter[eventField](...args);
        } catch (err) {
          // tslint:disable-next-line:no-console
          console.error("Error when running the Router event: ".concat(eventField)); // tslint:disable-next-line:no-console

          console.error("".concat(err.message, "\n").concat(err.stack));
        }
      }
    });
  });
});

function getRouter() {
  if (!singletonRouter.router) {
    const message = 'No router instance found.\n' + 'You should only use "next/router" inside the client side of your app.\n';
    throw new Error(message);
  }

  return singletonRouter.router;
} // Export the singletonRouter and this is the public API.


var _default = singletonRouter; // Reexport the withRoute HOC

exports.default = _default;

function useRouter() {
  _s();

  return _react.default.useContext(_routerContext.RouterContext);
} // INTERNAL APIS
// -------------
// (do not use following exports inside the app)
// Create a router and assign it as the singleton instance.
// This is used in client side when we are initilizing the app.
// This should **not** use inside the server.


_s(useRouter, "gDsCjeeItUuvgOWf1v4qoK9RF6k=");

const createRouter = (...args) => {
  singletonRouter.router = new _router2.default(...args);
  singletonRouter.readyCallbacks.forEach(cb => cb());
  singletonRouter.readyCallbacks = [];
  return singletonRouter.router;
}; // This function is used to create the `withRouter` router instance


exports.createRouter = createRouter;

function makePublicRouterInstance(router) {
  const _router = router;
  const instance = {};

  var _iterator = _createForOfIteratorHelper(urlPropertyFields),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      const property = _step.value;

      if (typeof _router[property] === 'object') {
        instance[property] = Object.assign({}, _router[property]); // makes sure query is not stateful

        continue;
      }

      instance[property] = _router[property];
    } // Events is a static property on the router, the router doesn't have to be initialized to use it

  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  instance.events = _router2.default.events;
  coreMethodFields.forEach(field => {
    instance[field] = (...args) => {
      return _router[field](...args);
    };
  });
  return instance;
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/with-router.js":
/*!******************************************************!*\
  !*** ./node_modules/next/dist/client/with-router.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

exports.__esModule = true;
exports.default = withRouter;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

var _router = __webpack_require__(/*! ./router */ "./node_modules/next/dist/client/router.js");

function withRouter(ComposedComponent) {
  function WithRouterWrapper(props) {
    return /*#__PURE__*/_react.default.createElement(ComposedComponent, Object.assign({
      router: (0, _router.useRouter)()
    }, props));
  }

  WithRouterWrapper.getInitialProps = ComposedComponent.getInitialProps // This is needed to allow checking for custom getInitialProps in _app
  ;
  WithRouterWrapper.origGetInitialProps = ComposedComponent.origGetInitialProps;

  if (true) {
    const name = ComposedComponent.displayName || ComposedComponent.name || 'Unknown';
    WithRouterWrapper.displayName = "withRouter(".concat(name, ")");
  }

  return WithRouterWrapper;
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/amp-context.js":
/*!***************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/amp-context.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.AmpStateContext = void 0;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

const AmpStateContext = _react.default.createContext({});

exports.AmpStateContext = AmpStateContext;

if (true) {
  AmpStateContext.displayName = 'AmpStateContext';
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/amp.js":
/*!*******************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/amp.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _s = $RefreshSig$();

exports.__esModule = true;
exports.isInAmpMode = isInAmpMode;
exports.useAmp = useAmp;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

var _ampContext = __webpack_require__(/*! ./amp-context */ "./node_modules/next/dist/next-server/lib/amp-context.js");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function isInAmpMode({
  ampFirst = false,
  hybrid = false,
  hasQuery = false
} = {}) {
  return ampFirst || hybrid && hasQuery;
}

function useAmp() {
  _s();

  // Don't assign the context value to a variable to save bytes
  return isInAmpMode(_react.default.useContext(_ampContext.AmpStateContext));
}

_s(useAmp, "gDsCjeeItUuvgOWf1v4qoK9RF6k=");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/head-manager-context.js":
/*!************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/head-manager-context.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.HeadManagerContext = void 0;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

const HeadManagerContext = _react.default.createContext({});

exports.HeadManagerContext = HeadManagerContext;

if (true) {
  HeadManagerContext.displayName = 'HeadManagerContext';
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/head.js":
/*!********************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/head.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _defineProperty = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty.js");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

exports.__esModule = true;
exports.defaultHead = defaultHead;
exports.default = void 0;

var _react = _interopRequireWildcard(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

var _sideEffect = _interopRequireDefault(__webpack_require__(/*! ./side-effect */ "./node_modules/next/dist/next-server/lib/side-effect.js"));

var _ampContext = __webpack_require__(/*! ./amp-context */ "./node_modules/next/dist/next-server/lib/amp-context.js");

var _headManagerContext = __webpack_require__(/*! ./head-manager-context */ "./node_modules/next/dist/next-server/lib/head-manager-context.js");

var _amp = __webpack_require__(/*! ./amp */ "./node_modules/next/dist/next-server/lib/amp.js");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
    return {
      default: obj
    };
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj.default = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function defaultHead(inAmpMode = false) {
  const head = [/*#__PURE__*/_react.default.createElement("meta", {
    charSet: "utf-8"
  })];

  if (!inAmpMode) {
    head.push( /*#__PURE__*/_react.default.createElement("meta", {
      name: "viewport",
      content: "width=device-width"
    }));
  }

  return head;
}

function onlyReactElement(list, child) {
  // React children can be "string" or "number" in this case we ignore them for backwards compat
  if (typeof child === 'string' || typeof child === 'number') {
    return list;
  } // Adds support for React.Fragment


  if (child.type === _react.default.Fragment) {
    return list.concat(_react.default.Children.toArray(child.props.children).reduce((fragmentList, fragmentChild) => {
      if (typeof fragmentChild === 'string' || typeof fragmentChild === 'number') {
        return fragmentList;
      }

      return fragmentList.concat(fragmentChild);
    }, []));
  }

  return list.concat(child);
}

const METATYPES = ['name', 'httpEquiv', 'charSet', 'itemProp'];
/*
returns a function for filtering head child elements
which shouldn't be duplicated, like <title/>
Also adds support for deduplicated `key` properties
*/

function unique() {
  const keys = new Set();
  const tags = new Set();
  const metaTypes = new Set();
  const metaCategories = {};
  return h => {
    let isUnique = true;

    if (h.key && typeof h.key !== 'number' && h.key.indexOf('$') > 0) {
      const key = h.key.slice(h.key.indexOf('$') + 1);

      if (keys.has(key)) {
        isUnique = false;
      } else {
        keys.add(key);
      }
    } // eslint-disable-next-line default-case


    switch (h.type) {
      case 'title':
      case 'base':
        if (tags.has(h.type)) {
          isUnique = false;
        } else {
          tags.add(h.type);
        }

        break;

      case 'meta':
        for (let i = 0, len = METATYPES.length; i < len; i++) {
          const metatype = METATYPES[i];
          if (!h.props.hasOwnProperty(metatype)) continue;

          if (metatype === 'charSet') {
            if (metaTypes.has(metatype)) {
              isUnique = false;
            } else {
              metaTypes.add(metatype);
            }
          } else {
            const category = h.props[metatype];
            const categories = metaCategories[metatype] || new Set();

            if (categories.has(category)) {
              isUnique = false;
            } else {
              categories.add(category);
              metaCategories[metatype] = categories;
            }
          }
        }

        break;
    }

    return isUnique;
  };
}
/**
*
* @param headElements List of multiple <Head> instances
*/


function reduceComponents(headElements, props) {
  return headElements.reduce((list, headElement) => {
    const headElementChildren = _react.default.Children.toArray(headElement.props.children);

    return list.concat(headElementChildren);
  }, []).reduce(onlyReactElement, []).reverse().concat(defaultHead(props.inAmpMode)).filter(unique()).reverse().map((c, i) => {
    const key = c.key || i;

    if (false) {}

    return _react.default.cloneElement(c, {
      key
    });
  });
}
/**
* This component injects elements to `<head>` of your page.
* To avoid duplicated `tags` in `<head>` you can use the `key` property, which will make sure every tag is only rendered once.
*/


function Head({
  children
}) {
  const ampState = (0, _react.useContext)(_ampContext.AmpStateContext);
  const headManager = (0, _react.useContext)(_headManagerContext.HeadManagerContext);
  return /*#__PURE__*/_react.default.createElement(_sideEffect.default, {
    reduceComponentsToState: reduceComponents,
    headManager: headManager,
    inAmpMode: (0, _amp.isInAmpMode)(ampState)
  }, children);
} // TODO: Remove in the next major release


_c = Head;

Head.rewind = () => {};

var _default = Head;
exports.default = _default;

var _c;

$RefreshReg$(_c, "Head");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/mitt.js":
/*!********************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/mitt.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.default = mitt;
/*
MIT License
Copyright (c) Jason Miller (https://jasonformat.com/)
Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
// This file is based on https://github.com/developit/mitt/blob/v1.1.3/src/index.js
// It's been edited for the needs of this script
// See the LICENSE at the top of the file

function mitt() {
  const all = Object.create(null);
  return {
    on(type, handler) {
      ;
      (all[type] || (all[type] = [])).push(handler);
    },

    off(type, handler) {
      if (all[type]) {
        // tslint:disable-next-line:no-bitwise
        all[type].splice(all[type].indexOf(handler) >>> 0, 1);
      }
    },

    emit(type, ...evts) {
      // eslint-disable-next-line array-callback-return
      ;
      (all[type] || []).slice().map(handler => {
        handler(...evts);
      });
    }

  };
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router-context.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router-context.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.RouterContext = void 0;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

const RouterContext = _react.default.createContext(null);

exports.RouterContext = RouterContext;

if (true) {
  RouterContext.displayName = 'RouterContext';
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/router.js":
/*!*****************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/router.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _slicedToArray = __webpack_require__(/*! @babel/runtime/helpers/slicedToArray */ "./node_modules/@babel/runtime/helpers/slicedToArray.js");

var _regeneratorRuntime = __webpack_require__(/*! @babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js");

var _asyncToGenerator = __webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ "./node_modules/@babel/runtime/helpers/asyncToGenerator.js");

exports.__esModule = true;
exports.hasBasePath = hasBasePath;
exports.addBasePath = addBasePath;
exports.delBasePath = delBasePath;
exports.isLocalURL = isLocalURL;
exports.resolveHref = resolveHref;
exports.markLoadingError = markLoadingError;
exports.default = void 0;

var _mitt = _interopRequireDefault(__webpack_require__(/*! ../mitt */ "./node_modules/next/dist/next-server/lib/mitt.js"));

var _utils = __webpack_require__(/*! ../utils */ "./node_modules/next/dist/next-server/lib/utils.js");

var _isDynamic = __webpack_require__(/*! ./utils/is-dynamic */ "./node_modules/next/dist/next-server/lib/router/utils/is-dynamic.js");

var _routeMatcher = __webpack_require__(/*! ./utils/route-matcher */ "./node_modules/next/dist/next-server/lib/router/utils/route-matcher.js");

var _routeRegex = __webpack_require__(/*! ./utils/route-regex */ "./node_modules/next/dist/next-server/lib/router/utils/route-regex.js");

var _querystring = __webpack_require__(/*! ./utils/querystring */ "./node_modules/next/dist/next-server/lib/router/utils/querystring.js");

var _parseRelativeUrl = __webpack_require__(/*! ./utils/parse-relative-url */ "./node_modules/next/dist/next-server/lib/router/utils/parse-relative-url.js");

var _normalizeTrailingSlash = __webpack_require__(/*! ../../../client/normalize-trailing-slash */ "./node_modules/next/dist/client/normalize-trailing-slash.js");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/* global __NEXT_DATA__ */
// tslint:disable:no-console


const basePath =  false || '';

function buildCancellationError() {
  return Object.assign(new Error('Route Cancelled'), {
    cancelled: true
  });
}

function hasBasePath(path) {
  return path === basePath || path.startsWith(basePath + '/');
}

function addBasePath(path) {
  // we only add the basepath on relative urls
  return basePath && path.startsWith('/') ? path === '/' ? (0, _normalizeTrailingSlash.normalizePathTrailingSlash)(basePath) : basePath + path : path;
}

function delBasePath(path) {
  return path.slice(basePath.length) || '/';
}
/**
* Detects whether a given url is routable by the Next.js router (browser only).
*/


function isLocalURL(url) {
  if (url.startsWith('/')) return true;

  try {
    // absolute urls can be local if they are on the same origin
    const locationOrigin = (0, _utils.getLocationOrigin)();
    const resolved = new URL(url, locationOrigin);
    return resolved.origin === locationOrigin && hasBasePath(resolved.pathname);
  } catch (_) {
    return false;
  }
}
/**
* Resolves a given hyperlink with a certain router state (basePath not included).
* Preserves absolute urls.
*/


function resolveHref(currentPath, href) {
  // we use a dummy base url for relative urls
  const base = new URL(currentPath, 'http://n');
  const urlAsString = typeof href === 'string' ? href : (0, _utils.formatWithValidation)(href);

  try {
    const finalUrl = new URL(urlAsString, base);
    finalUrl.pathname = (0, _normalizeTrailingSlash.normalizePathTrailingSlash)(finalUrl.pathname); // if the origin didn't change, it means we received a relative href

    return finalUrl.origin === base.origin ? finalUrl.href.slice(finalUrl.origin.length) : finalUrl.href;
  } catch (_) {
    return urlAsString;
  }
}

const PAGE_LOAD_ERROR = Symbol('PAGE_LOAD_ERROR');

function markLoadingError(err) {
  return Object.defineProperty(err, PAGE_LOAD_ERROR, {});
}

function prepareUrlAs(router, url, as) {
  // If url and as provided as an object representation,
  // we'll format them into the string version here.
  return {
    url: addBasePath(resolveHref(router.pathname, url)),
    as: as ? addBasePath(resolveHref(router.pathname, as)) : as
  };
}

function tryParseRelativeUrl(url) {
  try {
    return (0, _parseRelativeUrl.parseRelativeUrl)(url);
  } catch (err) {
    if (true) {
      setTimeout(() => {
        throw new Error("Invalid href passed to router: ".concat(url, " https://err.sh/vercel/next.js/invalid-href-passed"));
      }, 0);
    }

    return null;
  }
}

const manualScrollRestoration =  false && false;

function fetchRetry(url, attempts) {
  return fetch(url, {
    // Cookies are required to be present for Next.js' SSG "Preview Mode".
    // Cookies may also be required for `getServerSideProps`.
    //
    // > `fetch` won’t send cookies, unless you set the credentials init
    // > option.
    // https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch
    //
    // > For maximum browser compatibility when it comes to sending &
    // > receiving cookies, always supply the `credentials: 'same-origin'`
    // > option instead of relying on the default.
    // https://github.com/github/fetch#caveats
    credentials: 'same-origin'
  }).then(res => {
    if (!res.ok) {
      if (attempts > 1 && res.status >= 500) {
        return fetchRetry(url, attempts - 1);
      }

      throw new Error("Failed to load static props");
    }

    return res.json();
  });
}

function fetchNextData(dataHref, isServerRender) {
  return fetchRetry(dataHref, isServerRender ? 3 : 1).catch(err => {
    // We should only trigger a server-side transition if this was caused
    // on a client-side transition. Otherwise, we'd get into an infinite
    // loop.
    if (!isServerRender) {
      markLoadingError(err);
    }

    throw err;
  });
}

class Router {
  /**
  * Map of all components loaded in `Router`
  */
  // Static Data Cache
  constructor(_pathname, _query, _as, {
    initialProps,
    pageLoader,
    App,
    wrapApp,
    Component,
    err,
    subscription,
    isFallback
  }) {
    this.route = void 0;
    this.pathname = void 0;
    this.query = void 0;
    this.asPath = void 0;
    this.basePath = void 0;
    this.components = void 0;
    this.sdc = {};
    this.sub = void 0;
    this.clc = void 0;
    this.pageLoader = void 0;
    this._bps = void 0;
    this.events = void 0;
    this._wrapApp = void 0;
    this.isSsr = void 0;
    this.isFallback = void 0;
    this._inFlightRoute = void 0;

    this.onPopState = e => {
      const state = e.state;

      if (!state) {
        // We get state as undefined for two reasons.
        //  1. With older safari (< 8) and older chrome (< 34)
        //  2. When the URL changed with #
        //
        // In the both cases, we don't need to proceed and change the route.
        // (as it's already changed)
        // But we can simply replace the state with the new changes.
        // Actually, for (1) we don't need to nothing. But it's hard to detect that event.
        // So, doing the following for (1) does no harm.
        const pathname = this.pathname,
              query = this.query;
        this.changeState('replaceState', (0, _utils.formatWithValidation)({
          pathname: addBasePath(pathname),
          query
        }), (0, _utils.getURL)());
        return;
      }

      if (!state.__N) {
        return;
      }

      const url = state.url,
            as = state.as,
            options = state.options;

      const _ref = (0, _parseRelativeUrl.parseRelativeUrl)(url),
            pathname = _ref.pathname; // Make sure we don't re-render on initial load,
      // can be caused by navigating back from an external site


      if (this.isSsr && as === this.asPath && pathname === this.pathname) {
        return;
      } // If the downstream application returns falsy, return.
      // They will then be responsible for handling the event.


      if (this._bps && !this._bps(state)) {
        return;
      }

      this.change('replaceState', url, as, options);
    }; // represents the current component key


    this.route = (0, _normalizeTrailingSlash.removePathTrailingSlash)(_pathname); // set up the component cache (by route keys)

    this.components = {}; // We should not keep the cache, if there's an error
    // Otherwise, this cause issues when when going back and
    // come again to the errored page.

    if (_pathname !== '/_error') {
      this.components[this.route] = {
        Component,
        props: initialProps,
        err,
        __N_SSG: initialProps && initialProps.__N_SSG,
        __N_SSP: initialProps && initialProps.__N_SSP
      };
    }

    this.components['/_app'] = {
      Component: App
    }; // Backwards compat for Router.router.events
    // TODO: Should be remove the following major version as it was never documented

    this.events = Router.events;
    this.pageLoader = pageLoader;
    this.pathname = _pathname;
    this.query = _query; // if auto prerendered and dynamic route wait to update asPath
    // until after mount to prevent hydration mismatch

    this.asPath = // @ts-ignore this is temporarily global (attached to window)
    (0, _isDynamic.isDynamicRoute)(_pathname) && __NEXT_DATA__.autoExport ? _pathname : _as;
    this.basePath = basePath;
    this.sub = subscription;
    this.clc = null;
    this._wrapApp = wrapApp; // make sure to ignore extra popState in safari on navigating
    // back from external site

    this.isSsr = true;
    this.isFallback = isFallback;

    if (true) {
      // make sure "as" doesn't start with double slashes or else it can
      // throw an error as it's considered invalid
      if (_as.substr(0, 2) !== '//') {
        // in order for `e.state` to work on the `onpopstate` event
        // we have to register the initial route upon initialization
        this.changeState('replaceState', (0, _utils.formatWithValidation)({
          pathname: addBasePath(_pathname),
          query: _query
        }), (0, _utils.getURL)());
      }

      window.addEventListener('popstate', this.onPopState); // enable custom scroll restoration handling when available
      // otherwise fallback to browser's default handling

      if (false) {}
    }
  }

  update(route, mod) {
    const Component = mod.default || mod;
    const data = this.components[route];

    if (!data) {
      throw new Error("Cannot update unavailable route: ".concat(route));
    }

    const newData = Object.assign({}, data, {
      Component,
      __N_SSG: mod.__N_SSG,
      __N_SSP: mod.__N_SSP
    });
    this.components[route] = newData; // pages/_app.js updated

    if (route === '/_app') {
      this.notify(this.components[this.route]);
      return;
    }

    if (route === this.route) {
      this.notify(newData);
    }
  }

  reload() {
    window.location.reload();
  }
  /**
  * Go back in history
  */


  back() {
    window.history.back();
  }
  /**
  * Performs a `pushState` with arguments
  * @param url of the route
  * @param as masks `url` for the browser
  * @param options object you can define `shallow` and other options
  */


  push(url, as = url, options = {}) {
    ;

    var _prepareUrlAs = prepareUrlAs(this, url, as);

    url = _prepareUrlAs.url;
    as = _prepareUrlAs.as;
    return this.change('pushState', url, as, options);
  }
  /**
  * Performs a `replaceState` with arguments
  * @param url of the route
  * @param as masks `url` for the browser
  * @param options object you can define `shallow` and other options
  */


  replace(url, as = url, options = {}) {
    ;

    var _prepareUrlAs2 = prepareUrlAs(this, url, as);

    url = _prepareUrlAs2.url;
    as = _prepareUrlAs2.as;
    return this.change('replaceState', url, as, options);
  }

  change(method, url, as, options) {
    var _this = this;

    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
      var cleanedAs, parsed, pathname, searchParams, query, route, _options$shallow, shallow, _ref2, asPathname, routeRegex, routeMatch, missingParams, routeInfo, error, appComp;

      return _regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            if (isLocalURL(url)) {
              _context.next = 3;
              break;
            }

            window.location.href = url;
            return _context.abrupt("return", false);

          case 3:
            if (!options._h) {
              _this.isSsr = false;
            } // marking route changes as a navigation start entry


            if (_utils.ST) {
              performance.mark('routeChange');
            }

            if (_this._inFlightRoute) {
              _this.abortComponentLoad(_this._inFlightRoute);
            }

            cleanedAs = hasBasePath(as) ? delBasePath(as) : as;
            _this._inFlightRoute = as; // If the url change is only related to a hash change
            // We should not proceed. We should only change the state.
            // WARNING: `_h` is an internal option for handing Next.js client-side
            // hydration. Your app should _never_ use this property. It may change at
            // any time without notice.

            if (!(!options._h && _this.onlyAHashChange(cleanedAs))) {
              _context.next = 16;
              break;
            }

            _this.asPath = cleanedAs;
            Router.events.emit('hashChangeStart', as);

            _this.changeState(method, url, as, options);

            _this.scrollToHash(cleanedAs);

            _this.notify(_this.components[_this.route]);

            Router.events.emit('hashChangeComplete', as);
            return _context.abrupt("return", true);

          case 16:
            parsed = tryParseRelativeUrl(url);

            if (parsed) {
              _context.next = 19;
              break;
            }

            return _context.abrupt("return", false);

          case 19:
            pathname = parsed.pathname, searchParams = parsed.searchParams;
            query = (0, _querystring.searchParamsToUrlQuery)(searchParams); // url and as should always be prefixed with basePath by this
            // point by either next/link or router.push/replace so strip the
            // basePath from the pathname to match the pages dir 1-to-1

            pathname = pathname ? (0, _normalizeTrailingSlash.removePathTrailingSlash)(delBasePath(pathname)) : pathname; // If asked to change the current URL we should reload the current page
            // (not location.reload() but reload getInitialProps and other Next.js stuffs)
            // We also need to set the method = replaceState always
            // as this should not go into the history (That's how browsers work)
            // We should compare the new asPath to the current asPath, not the url

            if (!_this.urlIsNew(cleanedAs)) {
              method = 'replaceState';
            }

            route = (0, _normalizeTrailingSlash.removePathTrailingSlash)(pathname);
            _options$shallow = options.shallow, shallow = _options$shallow === void 0 ? false : _options$shallow;

            if (!(0, _isDynamic.isDynamicRoute)(route)) {
              _context.next = 37;
              break;
            }

            _ref2 = (0, _parseRelativeUrl.parseRelativeUrl)(cleanedAs), asPathname = _ref2.pathname;
            routeRegex = (0, _routeRegex.getRouteRegex)(route);
            routeMatch = (0, _routeMatcher.getRouteMatcher)(routeRegex)(asPathname);

            if (routeMatch) {
              _context.next = 36;
              break;
            }

            missingParams = Object.keys(routeRegex.groups).filter(param => !query[param]);

            if (!(missingParams.length > 0)) {
              _context.next = 34;
              break;
            }

            if (true) {
              console.warn("Mismatching `as` and `href` failed to manually provide " + "the params: ".concat(missingParams.join(', '), " in the `href`'s `query`"));
            }

            throw new Error("The provided `as` value (".concat(asPathname, ") is incompatible with the `href` value (").concat(route, "). ") + "Read more: https://err.sh/vercel/next.js/incompatible-href-as");

          case 34:
            _context.next = 37;
            break;

          case 36:
            // Merge params into `query`, overwriting any specified in search
            Object.assign(query, routeMatch);

          case 37:
            Router.events.emit('routeChangeStart', as);
            _context.prev = 38;
            _context.next = 41;
            return _this.getRouteInfo(route, pathname, query, as, shallow);

          case 41:
            routeInfo = _context.sent;
            error = routeInfo.error;
            Router.events.emit('beforeHistoryChange', as);

            _this.changeState(method, url, as, options);

            if (true) {
              appComp = _this.components['/_app'].Component;
              window.next.isPrerendered = appComp.getInitialProps === appComp.origGetInitialProps && !routeInfo.Component.getInitialProps;
            }

            _context.next = 48;
            return _this.set(route, pathname, query, cleanedAs, routeInfo);

          case 48:
            if (!error) {
              _context.next = 51;
              break;
            }

            Router.events.emit('routeChangeError', error, cleanedAs);
            throw error;

          case 51:
            if (false) {}

            Router.events.emit('routeChangeComplete', as);
            return _context.abrupt("return", true);

          case 56:
            _context.prev = 56;
            _context.t0 = _context["catch"](38);

            if (!_context.t0.cancelled) {
              _context.next = 60;
              break;
            }

            return _context.abrupt("return", false);

          case 60:
            throw _context.t0;

          case 61:
          case "end":
            return _context.stop();
        }
      }, _callee, null, [[38, 56]]);
    }))();
  }

  changeState(method, url, as, options = {}) {
    if (true) {
      if (typeof window.history === 'undefined') {
        console.error("Warning: window.history is not available.");
        return;
      }

      if (typeof window.history[method] === 'undefined') {
        console.error("Warning: window.history.".concat(method, " is not available"));
        return;
      }
    }

    if (method !== 'pushState' || (0, _utils.getURL)() !== as) {
      window.history[method]({
        url,
        as,
        options,
        __N: true
      }, // Most browsers currently ignores this parameter, although they may use it in the future.
      // Passing the empty string here should be safe against future changes to the method.
      // https://developer.mozilla.org/en-US/docs/Web/API/History/replaceState
      '', as);
    }
  }

  handleRouteInfoError(err, pathname, query, as, loadErrorFail) {
    var _this2 = this;

    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {
      var _yield$_this2$fetchCo, Component, routeInfo;

      return _regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            if (!err.cancelled) {
              _context2.next = 2;
              break;
            }

            throw err;

          case 2:
            if (!(PAGE_LOAD_ERROR in err || loadErrorFail)) {
              _context2.next = 6;
              break;
            }

            Router.events.emit('routeChangeError', err, as); // If we can't load the page it could be one of following reasons
            //  1. Page doesn't exists
            //  2. Page does exist in a different zone
            //  3. Internal error while loading the page
            // So, doing a hard reload is the proper way to deal with this.

            window.location.href = as; // Changing the URL doesn't block executing the current code path.
            // So let's throw a cancellation error stop the routing logic.

            throw buildCancellationError();

          case 6:
            _context2.prev = 6;
            _context2.next = 9;
            return _this2.fetchComponent('/_error');

          case 9:
            _yield$_this2$fetchCo = _context2.sent;
            Component = _yield$_this2$fetchCo.page;
            routeInfo = {
              Component,
              err,
              error: err
            };
            _context2.prev = 12;
            _context2.next = 15;
            return _this2.getInitialProps(Component, {
              err,
              pathname,
              query
            });

          case 15:
            routeInfo.props = _context2.sent;
            _context2.next = 22;
            break;

          case 18:
            _context2.prev = 18;
            _context2.t0 = _context2["catch"](12);
            console.error('Error in error page `getInitialProps`: ', _context2.t0);
            routeInfo.props = {};

          case 22:
            return _context2.abrupt("return", routeInfo);

          case 25:
            _context2.prev = 25;
            _context2.t1 = _context2["catch"](6);
            return _context2.abrupt("return", _this2.handleRouteInfoError(_context2.t1, pathname, query, as, true));

          case 28:
          case "end":
            return _context2.stop();
        }
      }, _callee2, null, [[6, 25], [12, 18]]);
    }))();
  }

  getRouteInfo(route, pathname, query, as, shallow = false) {
    var _this3 = this;

    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {
      var cachedRouteInfo, routeInfo, Component, __N_SSG, __N_SSP, _require, isValidElementType, dataHref, props;

      return _regeneratorRuntime.wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            _context3.prev = 0;
            cachedRouteInfo = _this3.components[route];

            if (!(shallow && cachedRouteInfo && _this3.route === route)) {
              _context3.next = 4;
              break;
            }

            return _context3.abrupt("return", cachedRouteInfo);

          case 4:
            if (!cachedRouteInfo) {
              _context3.next = 8;
              break;
            }

            _context3.t0 = cachedRouteInfo;
            _context3.next = 11;
            break;

          case 8:
            _context3.next = 10;
            return _this3.fetchComponent(route).then(res => ({
              Component: res.page,
              __N_SSG: res.mod.__N_SSG,
              __N_SSP: res.mod.__N_SSP
            }));

          case 10:
            _context3.t0 = _context3.sent;

          case 11:
            routeInfo = _context3.t0;
            Component = routeInfo.Component, __N_SSG = routeInfo.__N_SSG, __N_SSP = routeInfo.__N_SSP;

            if (false) {}

            _require = __webpack_require__(/*! react-is */ "./node_modules/react-is/index.js"), isValidElementType = _require.isValidElementType;

            if (isValidElementType(Component)) {
              _context3.next = 17;
              break;
            }

            throw new Error("The default export is not a React Component in page: \"".concat(pathname, "\""));

          case 17:
            if (__N_SSG || __N_SSP) {
              dataHref = _this3.pageLoader.getDataHref((0, _utils.formatWithValidation)({
                pathname,
                query
              }), as, __N_SSG);
            }

            _context3.next = 20;
            return _this3._getData(() => __N_SSG ? _this3._getStaticData(dataHref) : __N_SSP ? _this3._getServerData(dataHref) : _this3.getInitialProps(Component, // we provide AppTree later so this needs to be `any`
            {
              pathname,
              query,
              asPath: as
            }));

          case 20:
            props = _context3.sent;
            routeInfo.props = props;
            _this3.components[route] = routeInfo;
            return _context3.abrupt("return", routeInfo);

          case 26:
            _context3.prev = 26;
            _context3.t1 = _context3["catch"](0);
            return _context3.abrupt("return", _this3.handleRouteInfoError(_context3.t1, pathname, query, as));

          case 29:
          case "end":
            return _context3.stop();
        }
      }, _callee3, null, [[0, 26]]);
    }))();
  }

  set(route, pathname, query, as, data) {
    this.isFallback = false;
    this.route = route;
    this.pathname = pathname;
    this.query = query;
    this.asPath = as;
    return this.notify(data);
  }
  /**
  * Callback to execute before replacing router state
  * @param cb callback to be executed
  */


  beforePopState(cb) {
    this._bps = cb;
  }

  onlyAHashChange(as) {
    if (!this.asPath) return false;

    const _this$asPath$split = this.asPath.split('#'),
          _this$asPath$split2 = _slicedToArray(_this$asPath$split, 2),
          oldUrlNoHash = _this$asPath$split2[0],
          oldHash = _this$asPath$split2[1];

    const _as$split = as.split('#'),
          _as$split2 = _slicedToArray(_as$split, 2),
          newUrlNoHash = _as$split2[0],
          newHash = _as$split2[1]; // Makes sure we scroll to the provided hash if the url/hash are the same


    if (newHash && oldUrlNoHash === newUrlNoHash && oldHash === newHash) {
      return true;
    } // If the urls are change, there's more than a hash change


    if (oldUrlNoHash !== newUrlNoHash) {
      return false;
    } // If the hash has changed, then it's a hash only change.
    // This check is necessary to handle both the enter and
    // leave hash === '' cases. The identity case falls through
    // and is treated as a next reload.


    return oldHash !== newHash;
  }

  scrollToHash(as) {
    const _as$split3 = as.split('#'),
          _as$split4 = _slicedToArray(_as$split3, 2),
          hash = _as$split4[1]; // Scroll to top if the hash is just `#` with no value


    if (hash === '') {
      window.scrollTo(0, 0);
      return;
    } // First we check if the element by id is found


    const idEl = document.getElementById(hash);

    if (idEl) {
      idEl.scrollIntoView();
      return;
    } // If there's no element with the id, we check the `name` property
    // To mirror browsers


    const nameEl = document.getElementsByName(hash)[0];

    if (nameEl) {
      nameEl.scrollIntoView();
    }
  }

  urlIsNew(asPath) {
    return this.asPath !== asPath;
  }
  /**
  * Prefetch page code, you may wait for the data during page rendering.
  * This feature only works in production!
  * @param url the href of prefetched page
  * @param asPath the as path of the prefetched page
  */


  prefetch(url, asPath = url, options = {}) {
    var _this4 = this;

    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {
      var parsed, pathname, route;
      return _regeneratorRuntime.wrap(function _callee4$(_context4) {
        while (1) switch (_context4.prev = _context4.next) {
          case 0:
            parsed = tryParseRelativeUrl(url);

            if (parsed) {
              _context4.next = 3;
              break;
            }

            return _context4.abrupt("return");

          case 3:
            pathname = parsed.pathname; // Prefetch is not supported in development mode because it would trigger on-demand-entries

            if (false) {}

            return _context4.abrupt("return");

          case 6:
            route = (0, _normalizeTrailingSlash.removePathTrailingSlash)(pathname);
            _context4.next = 9;
            return Promise.all([_this4.pageLoader.prefetchData(url, asPath), _this4.pageLoader[options.priority ? 'loadPage' : 'prefetch'](route)]);

          case 9:
          case "end":
            return _context4.stop();
        }
      }, _callee4);
    }))();
  }

  fetchComponent(route) {
    var _this5 = this;

    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {
      var cancelled, cancel, componentResult, error;
      return _regeneratorRuntime.wrap(function _callee5$(_context5) {
        while (1) switch (_context5.prev = _context5.next) {
          case 0:
            cancelled = false;

            cancel = _this5.clc = () => {
              cancelled = true;
            };

            _context5.next = 4;
            return _this5.pageLoader.loadPage(route);

          case 4:
            componentResult = _context5.sent;

            if (!cancelled) {
              _context5.next = 9;
              break;
            }

            error = new Error("Abort fetching component for route: \"".concat(route, "\""));
            error.cancelled = true;
            throw error;

          case 9:
            if (cancel === _this5.clc) {
              _this5.clc = null;
            }

            return _context5.abrupt("return", componentResult);

          case 11:
          case "end":
            return _context5.stop();
        }
      }, _callee5);
    }))();
  }

  _getData(fn) {
    let cancelled = false;

    const cancel = () => {
      cancelled = true;
    };

    this.clc = cancel;
    return fn().then(data => {
      if (cancel === this.clc) {
        this.clc = null;
      }

      if (cancelled) {
        const err = new Error('Loading initial props cancelled');
        err.cancelled = true;
        throw err;
      }

      return data;
    });
  }

  _getStaticData(dataHref) {
    const _URL = new URL(dataHref, window.location.href),
          cacheKey = _URL.href;

    if (false) {}

    return fetchNextData(dataHref, this.isSsr).then(data => {
      this.sdc[cacheKey] = data;
      return data;
    });
  }

  _getServerData(dataHref) {
    return fetchNextData(dataHref, this.isSsr);
  }

  getInitialProps(Component, ctx) {
    const App = this.components['/_app'].Component;

    const AppTree = this._wrapApp(App);

    ctx.AppTree = AppTree;
    return (0, _utils.loadGetInitialProps)(App, {
      AppTree,
      Component,
      router: this,
      ctx
    });
  }

  abortComponentLoad(as) {
    if (this.clc) {
      Router.events.emit('routeChangeError', buildCancellationError(), as);
      this.clc();
      this.clc = null;
    }
  }

  notify(data) {
    return this.sub(data, this.components['/_app'].Component);
  }

}

exports.default = Router;
Router.events = (0, _mitt.default)();

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/format-url.js":
/*!***************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/format-url.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.formatUrl = formatUrl;

var querystring = _interopRequireWildcard(__webpack_require__(/*! ./querystring */ "./node_modules/next/dist/next-server/lib/router/utils/querystring.js"));

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
    return {
      default: obj
    };
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj.default = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
} // Format function modified from nodejs
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


const slashedProtocols = /https?|ftp|gopher|file/;

function formatUrl(urlObj) {
  let auth = urlObj.auth,
      hostname = urlObj.hostname;
  let protocol = urlObj.protocol || '';
  let pathname = urlObj.pathname || '';
  let hash = urlObj.hash || '';
  let query = urlObj.query || '';
  let host = false;
  auth = auth ? encodeURIComponent(auth).replace(/%3A/i, ':') + '@' : '';

  if (urlObj.host) {
    host = auth + urlObj.host;
  } else if (hostname) {
    host = auth + (~hostname.indexOf(':') ? "[".concat(hostname, "]") : hostname);

    if (urlObj.port) {
      host += ':' + urlObj.port;
    }
  }

  if (query && typeof query === 'object') {
    query = String(querystring.urlQueryToSearchParams(query));
  }

  let search = urlObj.search || query && "?".concat(query) || '';
  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  if (urlObj.slashes || (!protocol || slashedProtocols.test(protocol)) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname[0] !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash[0] !== '#') hash = '#' + hash;
  if (search && search[0] !== '?') search = '?' + search;
  pathname = pathname.replace(/[?#]/g, encodeURIComponent);
  search = search.replace('#', '%23');
  return "".concat(protocol).concat(host).concat(pathname).concat(search).concat(hash);
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/is-dynamic.js":
/*!***************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/is-dynamic.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.isDynamicRoute = isDynamicRoute; // Identify /[param]/ in route string

const TEST_ROUTE = /\/\[[^/]+?\](?=\/|$)/;

function isDynamicRoute(route) {
  return TEST_ROUTE.test(route);
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/parse-relative-url.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/parse-relative-url.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.parseRelativeUrl = parseRelativeUrl;

var _utils = __webpack_require__(/*! ../../utils */ "./node_modules/next/dist/next-server/lib/utils.js");

const DUMMY_BASE = new URL(false ? undefined : (0, _utils.getLocationOrigin)());
/**
* Parses path-relative urls (e.g. `/hello/world?foo=bar`). If url isn't path-relative
* (e.g. `./hello`) then at least base must be.
* Absolute urls are rejected with one exception, in the browser, absolute urls that are on
* the current origin will be parsed as relative
*/

function parseRelativeUrl(url, base) {
  const resolvedBase = base ? new URL(base, DUMMY_BASE) : DUMMY_BASE;

  const _URL = new URL(url, resolvedBase),
        pathname = _URL.pathname,
        searchParams = _URL.searchParams,
        search = _URL.search,
        hash = _URL.hash,
        href = _URL.href,
        origin = _URL.origin,
        protocol = _URL.protocol;

  if (origin !== DUMMY_BASE.origin || protocol !== 'http:' && protocol !== 'https:') {
    throw new Error('invariant: invalid relative URL');
  }

  return {
    pathname,
    searchParams,
    search,
    hash,
    href: href.slice(DUMMY_BASE.origin.length)
  };
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/querystring.js":
/*!****************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/querystring.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.searchParamsToUrlQuery = searchParamsToUrlQuery;
exports.urlQueryToSearchParams = urlQueryToSearchParams;
exports.assign = assign;

function searchParamsToUrlQuery(searchParams) {
  const query = {};
  searchParams.forEach((value, key) => {
    if (typeof query[key] === 'undefined') {
      query[key] = value;
    } else if (Array.isArray(query[key])) {
      ;
      query[key].push(value);
    } else {
      query[key] = [query[key], value];
    }
  });
  return query;
}

function urlQueryToSearchParams(urlQuery) {
  const result = new URLSearchParams();
  Object.entries(urlQuery).forEach(([key, value]) => {
    if (Array.isArray(value)) {
      value.forEach(item => result.append(key, item));
    } else {
      result.set(key, value);
    }
  });
  return result;
}

function assign(target, ...searchParamsList) {
  searchParamsList.forEach(searchParams => {
    Array.from(searchParams.keys()).forEach(key => target.delete(key));
    searchParams.forEach((value, key) => target.append(key, value));
  });
  return target;
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/route-matcher.js":
/*!******************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/route-matcher.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.getRouteMatcher = getRouteMatcher;

function getRouteMatcher(routeRegex) {
  const re = routeRegex.re,
        groups = routeRegex.groups;
  return pathname => {
    const routeMatch = re.exec(pathname);

    if (!routeMatch) {
      return false;
    }

    const decode = param => {
      try {
        return decodeURIComponent(param);
      } catch (_) {
        const err = new Error('failed to decode param');
        err.code = 'DECODE_FAILED';
        throw err;
      }
    };

    const params = {};
    Object.keys(groups).forEach(slugName => {
      const g = groups[slugName];
      const m = routeMatch[g.pos];

      if (m !== undefined) {
        params[slugName] = ~m.indexOf('/') ? m.split('/').map(entry => decode(entry)) : g.repeat ? [decode(m)] : decode(m);
      }
    });
    return params;
  };
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/route-regex.js":
/*!****************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/route-regex.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.getRouteRegex = getRouteRegex; // this isn't importing the escape-string-regex module
// to reduce bytes

function escapeRegex(str) {
  return str.replace(/[|\\{}()[\]^$+*?.-]/g, '\\$&');
}

function parseParameter(param) {
  const optional = param.startsWith('[') && param.endsWith(']');

  if (optional) {
    param = param.slice(1, -1);
  }

  const repeat = param.startsWith('...');

  if (repeat) {
    param = param.slice(3);
  }

  return {
    key: param,
    repeat,
    optional
  };
}

function getRouteRegex(normalizedRoute) {
  const segments = (normalizedRoute.replace(/\/$/, '') || '/').slice(1).split('/');
  const groups = {};
  let groupIndex = 1;
  const parameterizedRoute = segments.map(segment => {
    if (segment.startsWith('[') && segment.endsWith(']')) {
      const _parseParameter = parseParameter(segment.slice(1, -1)),
            key = _parseParameter.key,
            optional = _parseParameter.optional,
            repeat = _parseParameter.repeat;

      groups[key] = {
        pos: groupIndex++,
        repeat,
        optional
      };
      return repeat ? optional ? '(?:/(.+?))?' : '/(.+?)' : '/([^/]+?)';
    } else {
      return "/".concat(escapeRegex(segment));
    }
  }).join(''); // dead code eliminate for browser since it's only needed
  // while generating routes-manifest

  if (false) {}

  return {
    re: new RegExp("^".concat(parameterizedRoute, "(?:/)?$")),
    groups
  };
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/side-effect.js":
/*!***************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/side-effect.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.default = void 0;

var _react = __webpack_require__(/*! react */ "./node_modules/react/index.js");

const isServer = false;

class _default extends _react.Component {
  constructor(props) {
    super(props);
    this._hasHeadManager = void 0;

    this.emitChange = () => {
      if (this._hasHeadManager) {
        this.props.headManager.updateHead(this.props.reduceComponentsToState([...this.props.headManager.mountedInstances], this.props));
      }
    };

    this._hasHeadManager = this.props.headManager && this.props.headManager.mountedInstances;

    if (isServer && this._hasHeadManager) {
      this.props.headManager.mountedInstances.add(this);
      this.emitChange();
    }
  }

  componentDidMount() {
    if (this._hasHeadManager) {
      this.props.headManager.mountedInstances.add(this);
    }

    this.emitChange();
  }

  componentDidUpdate() {
    this.emitChange();
  }

  componentWillUnmount() {
    if (this._hasHeadManager) {
      this.props.headManager.mountedInstances.delete(this);
    }

    this.emitChange();
  }

  render() {
    return null;
  }

}

exports.default = _default;

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/utils.js":
/*!*********************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/utils.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _regeneratorRuntime = __webpack_require__(/*! @babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js");

var _asyncToGenerator = __webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ "./node_modules/@babel/runtime/helpers/asyncToGenerator.js");

exports.__esModule = true;
exports.execOnce = execOnce;
exports.getLocationOrigin = getLocationOrigin;
exports.getURL = getURL;
exports.getDisplayName = getDisplayName;
exports.isResSent = isResSent;
exports.loadGetInitialProps = loadGetInitialProps;
exports.formatWithValidation = formatWithValidation;
exports.ST = exports.SP = exports.urlObjectKeys = void 0;

var _formatUrl = __webpack_require__(/*! ./router/utils/format-url */ "./node_modules/next/dist/next-server/lib/router/utils/format-url.js");
/**
* Utils
*/


function execOnce(fn) {
  let used = false;
  let result;
  return (...args) => {
    if (!used) {
      used = true;
      result = fn(...args);
    }

    return result;
  };
}

function getLocationOrigin() {
  const _window$location = window.location,
        protocol = _window$location.protocol,
        hostname = _window$location.hostname,
        port = _window$location.port;
  return "".concat(protocol, "//").concat(hostname).concat(port ? ':' + port : '');
}

function getURL() {
  const href = window.location.href;
  const origin = getLocationOrigin();
  return href.substring(origin.length);
}

function getDisplayName(Component) {
  return typeof Component === 'string' ? Component : Component.displayName || Component.name || 'Unknown';
}

function isResSent(res) {
  return res.finished || res.headersSent;
}

function loadGetInitialProps(_x, _x2) {
  return _loadGetInitialProps.apply(this, arguments);
}

function _loadGetInitialProps() {
  _loadGetInitialProps = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(App, ctx) {
    var _App$prototype, message, res, props;

    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          if (false) {}

          if (!((_App$prototype = App.prototype) === null || _App$prototype === void 0 ? void 0 : _App$prototype.getInitialProps)) {
            _context.next = 4;
            break;
          }

          message = "\"".concat(getDisplayName(App), ".getInitialProps()\" is defined as an instance method - visit https://err.sh/vercel/next.js/get-initial-props-as-an-instance-method for more information.");
          throw new Error(message);

        case 4:
          // when called from _app `ctx` is nested in `ctx`
          res = ctx.res || ctx.ctx && ctx.ctx.res;

          if (App.getInitialProps) {
            _context.next = 12;
            break;
          }

          if (!(ctx.ctx && ctx.Component)) {
            _context.next = 11;
            break;
          }

          _context.next = 9;
          return loadGetInitialProps(ctx.Component, ctx.ctx);

        case 9:
          _context.t0 = _context.sent;
          return _context.abrupt("return", {
            pageProps: _context.t0
          });

        case 11:
          return _context.abrupt("return", {});

        case 12:
          _context.next = 14;
          return App.getInitialProps(ctx);

        case 14:
          props = _context.sent;

          if (!(res && isResSent(res))) {
            _context.next = 17;
            break;
          }

          return _context.abrupt("return", props);

        case 17:
          if (props) {
            _context.next = 20;
            break;
          }

          message = "\"".concat(getDisplayName(App), ".getInitialProps()\" should resolve to an object. But found \"").concat(props, "\" instead.");
          throw new Error(message);

        case 20:
          if (true) {
            if (Object.keys(props).length === 0 && !ctx.ctx) {
              console.warn("".concat(getDisplayName(App), " returned an empty object from `getInitialProps`. This de-optimizes and prevents automatic static optimization. https://err.sh/vercel/next.js/empty-object-getInitialProps"));
            }
          }

          return _context.abrupt("return", props);

        case 22:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return _loadGetInitialProps.apply(this, arguments);
}

const urlObjectKeys = ['auth', 'hash', 'host', 'hostname', 'href', 'path', 'pathname', 'port', 'protocol', 'query', 'search', 'slashes'];
exports.urlObjectKeys = urlObjectKeys;

function formatWithValidation(url) {
  if (true) {
    if (url !== null && typeof url === 'object') {
      Object.keys(url).forEach(key => {
        if (urlObjectKeys.indexOf(key) === -1) {
          console.warn("Unknown key passed via urlObject into url.format: ".concat(key));
        }
      });
    }
  }

  return (0, _formatUrl.formatUrl)(url);
}

const SP = typeof performance !== 'undefined';
exports.SP = SP;
const ST = SP && typeof performance.mark === 'function' && typeof performance.measure === 'function';
exports.ST = ST;

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/link.js":
/*!***********************************!*\
  !*** ./node_modules/next/link.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./dist/client/link */ "./node_modules/next/dist/client/link.js")


/***/ }),

/***/ "./node_modules/prop-types-exact/build/helpers/isPlainObject.js":
/*!**********************************************************************!*\
  !*** ./node_modules/prop-types-exact/build/helpers/isPlainObject.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports['default'] = isPlainObject;
function isPlainObject(x) {
  return x && (typeof x === 'undefined' ? 'undefined' : _typeof(x)) === 'object' && !Array.isArray(x);
}
module.exports = exports['default'];
//# sourceMappingURL=isPlainObject.js.map

/***/ }),

/***/ "./node_modules/prop-types-exact/build/index.js":
/*!******************************************************!*\
  !*** ./node_modules/prop-types-exact/build/index.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports['default'] = forbidExtraProps;

var _object = __webpack_require__(/*! object.assign */ "./node_modules/next/dist/build/polyfills/object.assign/index.js");

var _object2 = _interopRequireDefault(_object);

var _has = __webpack_require__(/*! has */ "./node_modules/has/src/index.js");

var _has2 = _interopRequireDefault(_has);

var _isPlainObject = __webpack_require__(/*! ./helpers/isPlainObject */ "./node_modules/prop-types-exact/build/helpers/isPlainObject.js");

var _isPlainObject2 = _interopRequireDefault(_isPlainObject);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var zeroWidthSpace = '\u200B';
var specialProperty = 'prop-types-exact: ' + zeroWidthSpace;
var semaphore = typeof Symbol === 'function' && typeof Symbol['for'] === 'function' ? Symbol['for'](specialProperty) : /* istanbul ignore next */specialProperty;

function brand(fn) {
  return (0, _object2['default'])(fn, _defineProperty({}, specialProperty, semaphore));
}

function isBranded(value) {
  return value && value[specialProperty] === semaphore;
}

function forbidExtraProps(propTypes) {
  if (!(0, _isPlainObject2['default'])(propTypes)) {
    throw new TypeError('given propTypes must be an object');
  }
  if ((0, _has2['default'])(propTypes, specialProperty) && !isBranded(propTypes[specialProperty])) {
    throw new TypeError('Against all odds, you created a propType for a prop that uses both the zero-width space and our custom string - which, sadly, conflicts with `prop-types-exact`');
  }

  return (0, _object2['default'])({}, propTypes, _defineProperty({}, specialProperty, brand(function () {
    function forbidUnknownProps(props, _, componentName) {
      var unknownProps = Object.keys(props).filter(function (prop) {
        return !(0, _has2['default'])(propTypes, prop);
      });
      if (unknownProps.length > 0) {
        return new TypeError(String(componentName) + ': unknown props found: ' + String(unknownProps.join(', ')));
      }
      return null;
    }

    return forbidUnknownProps;
  }())));
}
module.exports = exports['default'];
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/prop-types/checkPropTypes.js":
/*!***************************************************!*\
  !*** ./node_modules/prop-types/checkPropTypes.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var printWarning = function() {};

if (true) {
  var ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ "./node_modules/prop-types/lib/ReactPropTypesSecret.js");
  var loggedTypeFailures = {};
  var has = Function.call.bind(Object.prototype.hasOwnProperty);

  printWarning = function(text) {
    var message = 'Warning: ' + text;
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };
}

/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?Function} getStack Returns the component stack.
 * @private
 */
function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
  if (true) {
    for (var typeSpecName in typeSpecs) {
      if (has(typeSpecs, typeSpecName)) {
        var error;
        // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.
        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          if (typeof typeSpecs[typeSpecName] !== 'function') {
            var err = Error(
              (componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' +
              'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.'
            );
            err.name = 'Invariant Violation';
            throw err;
          }
          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
        } catch (ex) {
          error = ex;
        }
        if (error && !(error instanceof Error)) {
          printWarning(
            (componentName || 'React class') + ': type specification of ' +
            location + ' `' + typeSpecName + '` is invalid; the type checker ' +
            'function must return `null` or an `Error` but returned a ' + typeof error + '. ' +
            'You may have forgotten to pass an argument to the type checker ' +
            'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' +
            'shape all require an argument).'
          );
        }
        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error.message] = true;

          var stack = getStack ? getStack() : '';

          printWarning(
            'Failed ' + location + ' type: ' + error.message + (stack != null ? stack : '')
          );
        }
      }
    }
  }
}

/**
 * Resets warning cache when testing.
 *
 * @private
 */
checkPropTypes.resetWarningCache = function() {
  if (true) {
    loggedTypeFailures = {};
  }
}

module.exports = checkPropTypes;


/***/ }),

/***/ "./node_modules/prop-types/factoryWithTypeCheckers.js":
/*!************************************************************!*\
  !*** ./node_modules/prop-types/factoryWithTypeCheckers.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactIs = __webpack_require__(/*! react-is */ "./node_modules/react-is/index.js");
var assign = __webpack_require__(/*! object-assign */ "./node_modules/next/dist/build/polyfills/object-assign.js");

var ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ "./node_modules/prop-types/lib/ReactPropTypesSecret.js");
var checkPropTypes = __webpack_require__(/*! ./checkPropTypes */ "./node_modules/prop-types/checkPropTypes.js");

var has = Function.call.bind(Object.prototype.hasOwnProperty);
var printWarning = function() {};

if (true) {
  printWarning = function(text) {
    var message = 'Warning: ' + text;
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };
}

function emptyFunctionThatReturnsNull() {
  return null;
}

module.exports = function(isValidElement, throwOnDirectAccess) {
  /* global Symbol */
  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

  /**
   * Returns the iterator method function contained on the iterable object.
   *
   * Be sure to invoke the function with the iterable as context:
   *
   *     var iteratorFn = getIteratorFn(myIterable);
   *     if (iteratorFn) {
   *       var iterator = iteratorFn.call(myIterable);
   *       ...
   *     }
   *
   * @param {?object} maybeIterable
   * @return {?function}
   */
  function getIteratorFn(maybeIterable) {
    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
    if (typeof iteratorFn === 'function') {
      return iteratorFn;
    }
  }

  /**
   * Collection of methods that allow declaration and validation of props that are
   * supplied to React components. Example usage:
   *
   *   var Props = require('ReactPropTypes');
   *   var MyArticle = React.createClass({
   *     propTypes: {
   *       // An optional string prop named "description".
   *       description: Props.string,
   *
   *       // A required enum prop named "category".
   *       category: Props.oneOf(['News','Photos']).isRequired,
   *
   *       // A prop named "dialog" that requires an instance of Dialog.
   *       dialog: Props.instanceOf(Dialog).isRequired
   *     },
   *     render: function() { ... }
   *   });
   *
   * A more formal specification of how these methods are used:
   *
   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
   *   decl := ReactPropTypes.{type}(.isRequired)?
   *
   * Each and every declaration produces a function with the same signature. This
   * allows the creation of custom validation functions. For example:
   *
   *  var MyLink = React.createClass({
   *    propTypes: {
   *      // An optional string or URI prop named "href".
   *      href: function(props, propName, componentName) {
   *        var propValue = props[propName];
   *        if (propValue != null && typeof propValue !== 'string' &&
   *            !(propValue instanceof URI)) {
   *          return new Error(
   *            'Expected a string or an URI for ' + propName + ' in ' +
   *            componentName
   *          );
   *        }
   *      }
   *    },
   *    render: function() {...}
   *  });
   *
   * @internal
   */

  var ANONYMOUS = '<<anonymous>>';

  // Important!
  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
  var ReactPropTypes = {
    array: createPrimitiveTypeChecker('array'),
    bool: createPrimitiveTypeChecker('boolean'),
    func: createPrimitiveTypeChecker('function'),
    number: createPrimitiveTypeChecker('number'),
    object: createPrimitiveTypeChecker('object'),
    string: createPrimitiveTypeChecker('string'),
    symbol: createPrimitiveTypeChecker('symbol'),

    any: createAnyTypeChecker(),
    arrayOf: createArrayOfTypeChecker,
    element: createElementTypeChecker(),
    elementType: createElementTypeTypeChecker(),
    instanceOf: createInstanceTypeChecker,
    node: createNodeChecker(),
    objectOf: createObjectOfTypeChecker,
    oneOf: createEnumTypeChecker,
    oneOfType: createUnionTypeChecker,
    shape: createShapeTypeChecker,
    exact: createStrictShapeTypeChecker,
  };

  /**
   * inlined Object.is polyfill to avoid requiring consumers ship their own
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
   */
  /*eslint-disable no-self-compare*/
  function is(x, y) {
    // SameValue algorithm
    if (x === y) {
      // Steps 1-5, 7-10
      // Steps 6.b-6.e: +0 != -0
      return x !== 0 || 1 / x === 1 / y;
    } else {
      // Step 6.a: NaN == NaN
      return x !== x && y !== y;
    }
  }
  /*eslint-enable no-self-compare*/

  /**
   * We use an Error-like object for backward compatibility as people may call
   * PropTypes directly and inspect their output. However, we don't use real
   * Errors anymore. We don't inspect their stack anyway, and creating them
   * is prohibitively expensive if they are created too often, such as what
   * happens in oneOfType() for any type before the one that matched.
   */
  function PropTypeError(message) {
    this.message = message;
    this.stack = '';
  }
  // Make `instanceof Error` still work for returned errors.
  PropTypeError.prototype = Error.prototype;

  function createChainableTypeChecker(validate) {
    if (true) {
      var manualPropTypeCallCache = {};
      var manualPropTypeWarningCount = 0;
    }
    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
      componentName = componentName || ANONYMOUS;
      propFullName = propFullName || propName;

      if (secret !== ReactPropTypesSecret) {
        if (throwOnDirectAccess) {
          // New behavior only for users of `prop-types` package
          var err = new Error(
            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
            'Use `PropTypes.checkPropTypes()` to call them. ' +
            'Read more at http://fb.me/use-check-prop-types'
          );
          err.name = 'Invariant Violation';
          throw err;
        } else if ( true && typeof console !== 'undefined') {
          // Old behavior for people using React.PropTypes
          var cacheKey = componentName + ':' + propName;
          if (
            !manualPropTypeCallCache[cacheKey] &&
            // Avoid spamming the console because they are often not actionable except for lib authors
            manualPropTypeWarningCount < 3
          ) {
            printWarning(
              'You are manually calling a React.PropTypes validation ' +
              'function for the `' + propFullName + '` prop on `' + componentName  + '`. This is deprecated ' +
              'and will throw in the standalone `prop-types` package. ' +
              'You may be seeing this warning due to a third-party PropTypes ' +
              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.'
            );
            manualPropTypeCallCache[cacheKey] = true;
            manualPropTypeWarningCount++;
          }
        }
      }
      if (props[propName] == null) {
        if (isRequired) {
          if (props[propName] === null) {
            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
          }
          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
        }
        return null;
      } else {
        return validate(props, propName, componentName, location, propFullName);
      }
    }

    var chainedCheckType = checkType.bind(null, false);
    chainedCheckType.isRequired = checkType.bind(null, true);

    return chainedCheckType;
  }

  function createPrimitiveTypeChecker(expectedType) {
    function validate(props, propName, componentName, location, propFullName, secret) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== expectedType) {
        // `propValue` being instance of, say, date/regexp, pass the 'object'
        // check, but we can offer a more precise error message here rather than
        // 'of type `object`'.
        var preciseType = getPreciseType(propValue);

        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createAnyTypeChecker() {
    return createChainableTypeChecker(emptyFunctionThatReturnsNull);
  }

  function createArrayOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
      }
      var propValue = props[propName];
      if (!Array.isArray(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
      }
      for (var i = 0; i < propValue.length; i++) {
        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
        if (error instanceof Error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createElementTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!isValidElement(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createElementTypeTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!ReactIs.isValidElementType(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement type.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createInstanceTypeChecker(expectedClass) {
    function validate(props, propName, componentName, location, propFullName) {
      if (!(props[propName] instanceof expectedClass)) {
        var expectedClassName = expectedClass.name || ANONYMOUS;
        var actualClassName = getClassName(props[propName]);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createEnumTypeChecker(expectedValues) {
    if (!Array.isArray(expectedValues)) {
      if (true) {
        if (arguments.length > 1) {
          printWarning(
            'Invalid arguments supplied to oneOf, expected an array, got ' + arguments.length + ' arguments. ' +
            'A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).'
          );
        } else {
          printWarning('Invalid argument supplied to oneOf, expected an array.');
        }
      }
      return emptyFunctionThatReturnsNull;
    }

    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      for (var i = 0; i < expectedValues.length; i++) {
        if (is(propValue, expectedValues[i])) {
          return null;
        }
      }

      var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
        var type = getPreciseType(value);
        if (type === 'symbol') {
          return String(value);
        }
        return value;
      });
      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + String(propValue) + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createObjectOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
      }
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
      }
      for (var key in propValue) {
        if (has(propValue, key)) {
          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
          if (error instanceof Error) {
            return error;
          }
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createUnionTypeChecker(arrayOfTypeCheckers) {
    if (!Array.isArray(arrayOfTypeCheckers)) {
       true ? printWarning('Invalid argument supplied to oneOfType, expected an instance of array.') : undefined;
      return emptyFunctionThatReturnsNull;
    }

    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
      var checker = arrayOfTypeCheckers[i];
      if (typeof checker !== 'function') {
        printWarning(
          'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +
          'received ' + getPostfixForTypeWarning(checker) + ' at index ' + i + '.'
        );
        return emptyFunctionThatReturnsNull;
      }
    }

    function validate(props, propName, componentName, location, propFullName) {
      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
        var checker = arrayOfTypeCheckers[i];
        if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
          return null;
        }
      }

      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createNodeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      if (!isNode(props[propName])) {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      for (var key in shapeTypes) {
        var checker = shapeTypes[key];
        if (!checker) {
          continue;
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createStrictShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      // We need to check all keys in case some are required but missing from
      // props.
      var allKeys = assign({}, props[propName], shapeTypes);
      for (var key in allKeys) {
        var checker = shapeTypes[key];
        if (!checker) {
          return new PropTypeError(
            'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +
            '\nBad object: ' + JSON.stringify(props[propName], null, '  ') +
            '\nValid keys: ' +  JSON.stringify(Object.keys(shapeTypes), null, '  ')
          );
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }

    return createChainableTypeChecker(validate);
  }

  function isNode(propValue) {
    switch (typeof propValue) {
      case 'number':
      case 'string':
      case 'undefined':
        return true;
      case 'boolean':
        return !propValue;
      case 'object':
        if (Array.isArray(propValue)) {
          return propValue.every(isNode);
        }
        if (propValue === null || isValidElement(propValue)) {
          return true;
        }

        var iteratorFn = getIteratorFn(propValue);
        if (iteratorFn) {
          var iterator = iteratorFn.call(propValue);
          var step;
          if (iteratorFn !== propValue.entries) {
            while (!(step = iterator.next()).done) {
              if (!isNode(step.value)) {
                return false;
              }
            }
          } else {
            // Iterator will provide entry [k,v] tuples rather than values.
            while (!(step = iterator.next()).done) {
              var entry = step.value;
              if (entry) {
                if (!isNode(entry[1])) {
                  return false;
                }
              }
            }
          }
        } else {
          return false;
        }

        return true;
      default:
        return false;
    }
  }

  function isSymbol(propType, propValue) {
    // Native Symbol.
    if (propType === 'symbol') {
      return true;
    }

    // falsy value can't be a Symbol
    if (!propValue) {
      return false;
    }

    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
    if (propValue['@@toStringTag'] === 'Symbol') {
      return true;
    }

    // Fallback for non-spec compliant Symbols which are polyfilled.
    if (typeof Symbol === 'function' && propValue instanceof Symbol) {
      return true;
    }

    return false;
  }

  // Equivalent of `typeof` but with special handling for array and regexp.
  function getPropType(propValue) {
    var propType = typeof propValue;
    if (Array.isArray(propValue)) {
      return 'array';
    }
    if (propValue instanceof RegExp) {
      // Old webkits (at least until Android 4.0) return 'function' rather than
      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
      // passes PropTypes.object.
      return 'object';
    }
    if (isSymbol(propType, propValue)) {
      return 'symbol';
    }
    return propType;
  }

  // This handles more types than `getPropType`. Only used for error messages.
  // See `createPrimitiveTypeChecker`.
  function getPreciseType(propValue) {
    if (typeof propValue === 'undefined' || propValue === null) {
      return '' + propValue;
    }
    var propType = getPropType(propValue);
    if (propType === 'object') {
      if (propValue instanceof Date) {
        return 'date';
      } else if (propValue instanceof RegExp) {
        return 'regexp';
      }
    }
    return propType;
  }

  // Returns a string that is postfixed to a warning about an invalid type.
  // For example, "undefined" or "of type array"
  function getPostfixForTypeWarning(value) {
    var type = getPreciseType(value);
    switch (type) {
      case 'array':
      case 'object':
        return 'an ' + type;
      case 'boolean':
      case 'date':
      case 'regexp':
        return 'a ' + type;
      default:
        return type;
    }
  }

  // Returns class name of the object, if any.
  function getClassName(propValue) {
    if (!propValue.constructor || !propValue.constructor.name) {
      return ANONYMOUS;
    }
    return propValue.constructor.name;
  }

  ReactPropTypes.checkPropTypes = checkPropTypes;
  ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};


/***/ }),

/***/ "./node_modules/prop-types/index.js":
/*!******************************************!*\
  !*** ./node_modules/prop-types/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

if (true) {
  var ReactIs = __webpack_require__(/*! react-is */ "./node_modules/react-is/index.js");

  // By explicitly using `prop-types` you are opting into new development behavior.
  // http://fb.me/prop-types-in-prod
  var throwOnDirectAccess = true;
  module.exports = __webpack_require__(/*! ./factoryWithTypeCheckers */ "./node_modules/prop-types/factoryWithTypeCheckers.js")(ReactIs.isElement, throwOnDirectAccess);
} else {}


/***/ }),

/***/ "./node_modules/prop-types/lib/ReactPropTypesSecret.js":
/*!*************************************************************!*\
  !*** ./node_modules/prop-types/lib/ReactPropTypesSecret.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;


/***/ }),

/***/ "./node_modules/react-from-dom/esm/helpers.js":
/*!****************************************************!*\
  !*** ./node_modules/react-from-dom/esm/helpers.js ***!
  \****************************************************/
/*! exports provided: styleToObject, noTextChildNodes, possibleStandardNames */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "styleToObject", function() { return styleToObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "noTextChildNodes", function() { return noTextChildNodes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "possibleStandardNames", function() { return possibleStandardNames; });
var __read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var styleToObject = function (input) {
    var attributes = input.split(/ ?; ?/);
    return attributes.reduce(function (acc, d) {
        var _a = __read(d.split(/ ?: ?/), 2), key = _a[0], value = _a[1];
        if (key && value) {
            acc[key.replace(/-(\w)/g, function (_$0, $1) { return $1.toUpperCase(); })] = Number.isNaN(Number(value))
                ? value
                : Number(value);
        }
        return acc;
    }, {});
};
var noTextChildNodes = [
    'br',
    'col',
    'colgroup',
    'dl',
    'hr',
    'iframe',
    'img',
    'input',
    'link',
    'menuitem',
    'meta',
    'ol',
    'param',
    'select',
    'table',
    'tbody',
    'tfoot',
    'thead',
    'tr',
    'ul',
    'wbr',
];
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
// Taken from https://raw.githubusercontent.com/facebook/react/baff5cc2f69d30589a5dc65b089e47765437294b/packages/react-dom/src/shared/possibleStandardNames.js
// tslint:disable:object-literal-sort-keys
var possibleStandardNames = {
    // HTML
    'accept-charset': 'acceptCharset',
    acceptcharset: 'acceptCharset',
    accesskey: 'accessKey',
    allowfullscreen: 'allowFullScreen',
    autocapitalize: 'autoCapitalize',
    autocomplete: 'autoComplete',
    autocorrect: 'autoCorrect',
    autofocus: 'autoFocus',
    autoplay: 'autoPlay',
    autosave: 'autoSave',
    cellpadding: 'cellPadding',
    cellspacing: 'cellSpacing',
    charset: 'charSet',
    class: 'className',
    classid: 'classID',
    classname: 'className',
    colspan: 'colSpan',
    contenteditable: 'contentEditable',
    contextmenu: 'contextMenu',
    controlslist: 'controlsList',
    crossorigin: 'crossOrigin',
    dangerouslysetinnerhtml: 'dangerouslySetInnerHTML',
    datetime: 'dateTime',
    defaultchecked: 'defaultChecked',
    defaultvalue: 'defaultValue',
    enctype: 'encType',
    for: 'htmlFor',
    formmethod: 'formMethod',
    formaction: 'formAction',
    formenctype: 'formEncType',
    formnovalidate: 'formNoValidate',
    formtarget: 'formTarget',
    frameborder: 'frameBorder',
    hreflang: 'hrefLang',
    htmlfor: 'htmlFor',
    httpequiv: 'httpEquiv',
    'http-equiv': 'httpEquiv',
    icon: 'icon',
    innerhtml: 'innerHTML',
    inputmode: 'inputMode',
    itemid: 'itemID',
    itemprop: 'itemProp',
    itemref: 'itemRef',
    itemscope: 'itemScope',
    itemtype: 'itemType',
    keyparams: 'keyParams',
    keytype: 'keyType',
    marginwidth: 'marginWidth',
    marginheight: 'marginHeight',
    maxlength: 'maxLength',
    mediagroup: 'mediaGroup',
    minlength: 'minLength',
    nomodule: 'noModule',
    novalidate: 'noValidate',
    playsinline: 'playsInline',
    radiogroup: 'radioGroup',
    readonly: 'readOnly',
    referrerpolicy: 'referrerPolicy',
    rowspan: 'rowSpan',
    spellcheck: 'spellCheck',
    srcdoc: 'srcDoc',
    srclang: 'srcLang',
    srcset: 'srcSet',
    tabindex: 'tabIndex',
    typemustmatch: 'typeMustMatch',
    usemap: 'useMap',
    // SVG
    accentheight: 'accentHeight',
    'accent-height': 'accentHeight',
    alignmentbaseline: 'alignmentBaseline',
    'alignment-baseline': 'alignmentBaseline',
    allowreorder: 'allowReorder',
    arabicform: 'arabicForm',
    'arabic-form': 'arabicForm',
    attributename: 'attributeName',
    attributetype: 'attributeType',
    autoreverse: 'autoReverse',
    basefrequency: 'baseFrequency',
    baselineshift: 'baselineShift',
    'baseline-shift': 'baselineShift',
    baseprofile: 'baseProfile',
    calcmode: 'calcMode',
    capheight: 'capHeight',
    'cap-height': 'capHeight',
    clippath: 'clipPath',
    'clip-path': 'clipPath',
    clippathunits: 'clipPathUnits',
    cliprule: 'clipRule',
    'clip-rule': 'clipRule',
    colorinterpolation: 'colorInterpolation',
    'color-interpolation': 'colorInterpolation',
    colorinterpolationfilters: 'colorInterpolationFilters',
    'color-interpolation-filters': 'colorInterpolationFilters',
    colorprofile: 'colorProfile',
    'color-profile': 'colorProfile',
    colorrendering: 'colorRendering',
    'color-rendering': 'colorRendering',
    contentscripttype: 'contentScriptType',
    contentstyletype: 'contentStyleType',
    diffuseconstant: 'diffuseConstant',
    dominantbaseline: 'dominantBaseline',
    'dominant-baseline': 'dominantBaseline',
    edgemode: 'edgeMode',
    enablebackground: 'enableBackground',
    'enable-background': 'enableBackground',
    externalresourcesrequired: 'externalResourcesRequired',
    fillopacity: 'fillOpacity',
    'fill-opacity': 'fillOpacity',
    fillrule: 'fillRule',
    'fill-rule': 'fillRule',
    filterres: 'filterRes',
    filterunits: 'filterUnits',
    floodopacity: 'floodOpacity',
    'flood-opacity': 'floodOpacity',
    floodcolor: 'floodColor',
    'flood-color': 'floodColor',
    fontfamily: 'fontFamily',
    'font-family': 'fontFamily',
    fontsize: 'fontSize',
    'font-size': 'fontSize',
    fontsizeadjust: 'fontSizeAdjust',
    'font-size-adjust': 'fontSizeAdjust',
    fontstretch: 'fontStretch',
    'font-stretch': 'fontStretch',
    fontstyle: 'fontStyle',
    'font-style': 'fontStyle',
    fontvariant: 'fontVariant',
    'font-variant': 'fontVariant',
    fontweight: 'fontWeight',
    'font-weight': 'fontWeight',
    glyphname: 'glyphName',
    'glyph-name': 'glyphName',
    glyphorientationhorizontal: 'glyphOrientationHorizontal',
    'glyph-orientation-horizontal': 'glyphOrientationHorizontal',
    glyphorientationvertical: 'glyphOrientationVertical',
    'glyph-orientation-vertical': 'glyphOrientationVertical',
    glyphref: 'glyphRef',
    gradienttransform: 'gradientTransform',
    gradientunits: 'gradientUnits',
    horizadvx: 'horizAdvX',
    'horiz-adv-x': 'horizAdvX',
    horizoriginx: 'horizOriginX',
    'horiz-origin-x': 'horizOriginX',
    imagerendering: 'imageRendering',
    'image-rendering': 'imageRendering',
    kernelmatrix: 'kernelMatrix',
    kernelunitlength: 'kernelUnitLength',
    keypoints: 'keyPoints',
    keysplines: 'keySplines',
    keytimes: 'keyTimes',
    lengthadjust: 'lengthAdjust',
    letterspacing: 'letterSpacing',
    'letter-spacing': 'letterSpacing',
    lightingcolor: 'lightingColor',
    'lighting-color': 'lightingColor',
    limitingconeangle: 'limitingConeAngle',
    markerend: 'markerEnd',
    'marker-end': 'markerEnd',
    markerheight: 'markerHeight',
    markermid: 'markerMid',
    'marker-mid': 'markerMid',
    markerstart: 'markerStart',
    'marker-start': 'markerStart',
    markerunits: 'markerUnits',
    markerwidth: 'markerWidth',
    maskcontentunits: 'maskContentUnits',
    maskunits: 'maskUnits',
    numoctaves: 'numOctaves',
    overlineposition: 'overlinePosition',
    'overline-position': 'overlinePosition',
    overlinethickness: 'overlineThickness',
    'overline-thickness': 'overlineThickness',
    paintorder: 'paintOrder',
    'paint-order': 'paintOrder',
    'panose-1': 'panose1',
    pathlength: 'pathLength',
    patterncontentunits: 'patternContentUnits',
    patterntransform: 'patternTransform',
    patternunits: 'patternUnits',
    pointerevents: 'pointerEvents',
    'pointer-events': 'pointerEvents',
    pointsatx: 'pointsAtX',
    pointsaty: 'pointsAtY',
    pointsatz: 'pointsAtZ',
    preservealpha: 'preserveAlpha',
    preserveaspectratio: 'preserveAspectRatio',
    primitiveunits: 'primitiveUnits',
    refx: 'refX',
    refy: 'refY',
    renderingintent: 'renderingIntent',
    'rendering-intent': 'renderingIntent',
    repeatcount: 'repeatCount',
    repeatdur: 'repeatDur',
    requiredextensions: 'requiredExtensions',
    requiredfeatures: 'requiredFeatures',
    shaperendering: 'shapeRendering',
    'shape-rendering': 'shapeRendering',
    specularconstant: 'specularConstant',
    specularexponent: 'specularExponent',
    spreadmethod: 'spreadMethod',
    startoffset: 'startOffset',
    stddeviation: 'stdDeviation',
    stitchtiles: 'stitchTiles',
    stopcolor: 'stopColor',
    'stop-color': 'stopColor',
    stopopacity: 'stopOpacity',
    'stop-opacity': 'stopOpacity',
    strikethroughposition: 'strikethroughPosition',
    'strikethrough-position': 'strikethroughPosition',
    strikethroughthickness: 'strikethroughThickness',
    'strikethrough-thickness': 'strikethroughThickness',
    strokedasharray: 'strokeDasharray',
    'stroke-dasharray': 'strokeDasharray',
    strokedashoffset: 'strokeDashoffset',
    'stroke-dashoffset': 'strokeDashoffset',
    strokelinecap: 'strokeLinecap',
    'stroke-linecap': 'strokeLinecap',
    strokelinejoin: 'strokeLinejoin',
    'stroke-linejoin': 'strokeLinejoin',
    strokemiterlimit: 'strokeMiterlimit',
    'stroke-miterlimit': 'strokeMiterlimit',
    strokewidth: 'strokeWidth',
    'stroke-width': 'strokeWidth',
    strokeopacity: 'strokeOpacity',
    'stroke-opacity': 'strokeOpacity',
    suppresscontenteditablewarning: 'suppressContentEditableWarning',
    suppresshydrationwarning: 'suppressHydrationWarning',
    surfacescale: 'surfaceScale',
    systemlanguage: 'systemLanguage',
    tablevalues: 'tableValues',
    targetx: 'targetX',
    targety: 'targetY',
    textanchor: 'textAnchor',
    'text-anchor': 'textAnchor',
    textdecoration: 'textDecoration',
    'text-decoration': 'textDecoration',
    textlength: 'textLength',
    textrendering: 'textRendering',
    'text-rendering': 'textRendering',
    underlineposition: 'underlinePosition',
    'underline-position': 'underlinePosition',
    underlinethickness: 'underlineThickness',
    'underline-thickness': 'underlineThickness',
    unicodebidi: 'unicodeBidi',
    'unicode-bidi': 'unicodeBidi',
    unicoderange: 'unicodeRange',
    'unicode-range': 'unicodeRange',
    unitsperem: 'unitsPerEm',
    'units-per-em': 'unitsPerEm',
    unselectable: 'unselectable',
    valphabetic: 'vAlphabetic',
    'v-alphabetic': 'vAlphabetic',
    vectoreffect: 'vectorEffect',
    'vector-effect': 'vectorEffect',
    vertadvy: 'vertAdvY',
    'vert-adv-y': 'vertAdvY',
    vertoriginx: 'vertOriginX',
    'vert-origin-x': 'vertOriginX',
    vertoriginy: 'vertOriginY',
    'vert-origin-y': 'vertOriginY',
    vhanging: 'vHanging',
    'v-hanging': 'vHanging',
    videographic: 'vIdeographic',
    'v-ideographic': 'vIdeographic',
    viewbox: 'viewBox',
    viewtarget: 'viewTarget',
    vmathematical: 'vMathematical',
    'v-mathematical': 'vMathematical',
    wordspacing: 'wordSpacing',
    'word-spacing': 'wordSpacing',
    writingmode: 'writingMode',
    'writing-mode': 'writingMode',
    xchannelselector: 'xChannelSelector',
    xheight: 'xHeight',
    'x-height': 'xHeight',
    xlinkactuate: 'xlinkActuate',
    'xlink:actuate': 'xlinkActuate',
    xlinkarcrole: 'xlinkArcrole',
    'xlink:arcrole': 'xlinkArcrole',
    xlinkhref: 'xlinkHref',
    'xlink:href': 'xlinkHref',
    xlinkrole: 'xlinkRole',
    'xlink:role': 'xlinkRole',
    xlinkshow: 'xlinkShow',
    'xlink:show': 'xlinkShow',
    xlinktitle: 'xlinkTitle',
    'xlink:title': 'xlinkTitle',
    xlinktype: 'xlinkType',
    'xlink:type': 'xlinkType',
    xmlbase: 'xmlBase',
    'xml:base': 'xmlBase',
    xmllang: 'xmlLang',
    'xml:lang': 'xmlLang',
    'xml:space': 'xmlSpace',
    xmlnsxlink: 'xmlnsXlink',
    'xmlns:xlink': 'xmlnsXlink',
    xmlspace: 'xmlSpace',
    ychannelselector: 'yChannelSelector',
    zoomandpan: 'zoomAndPan',
    // event handlers
    onblur: 'onBlur',
    onchange: 'onChange',
    onclick: 'onClick',
    oncontextmenu: 'onContextMenu',
    ondoubleclick: 'onDoubleClick',
    ondrag: 'onDrag',
    ondragend: 'onDragEnd',
    ondragenter: 'onDragEnter',
    ondragexit: 'onDragExit',
    ondragleave: 'onDragLeave',
    ondragover: 'onDragOver',
    ondragstart: 'onDragStart',
    ondrop: 'onDrop',
    onerror: 'onError',
    onfocus: 'onFocus',
    oninput: 'onInput',
    oninvalid: 'onInvalid',
    onkeydown: 'onKeyDown',
    onkeypress: 'onKeyPress',
    onkeyup: 'onKeyUp',
    onload: 'onLoad',
    onmousedown: 'onMouseDown',
    onmouseenter: 'onMouseEnter',
    onmouseleave: 'onMouseLeave',
    onmousemove: 'onMouseMove',
    onmouseout: 'onMouseOut',
    onmouseover: 'onMouseOver',
    onmouseup: 'onMouseUp',
    onscroll: 'onScroll',
    onsubmit: 'onSubmit',
    ontouchcancel: 'onTouchCancel',
    ontouchend: 'onTouchEnd',
    ontouchmove: 'onTouchMove',
    ontouchstart: 'onTouchStart',
    onwheel: 'onWheel',
};
//# sourceMappingURL=helpers.js.map

/***/ }),

/***/ "./node_modules/react-from-dom/esm/index.js":
/*!**************************************************!*\
  !*** ./node_modules/react-from-dom/esm/index.js ***!
  \**************************************************/
/*! exports provided: convertFromNode, convertFromString, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "convertFromNode", function() { return convertFromNode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "convertFromString", function() { return convertFromString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return convert; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helpers */ "./node_modules/react-from-dom/esm/helpers.js");
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (undefined && undefined.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
/* eslint-disable @typescript-eslint/no-use-before-define */


function parseAttributes(node, reactKey) {
    var attributes = {
        key: reactKey,
    };
    /* istanbul ignore else */
    if (node instanceof Element) {
        var nodeClassNames = node.getAttribute('class');
        if (nodeClassNames) {
            attributes.className = nodeClassNames;
        }
        __spread(node.attributes).forEach(function (d) {
            switch (d.name) {
                // this is manually handled above, so break;
                case 'class':
                    break;
                case 'style':
                    attributes[d.name] = Object(_helpers__WEBPACK_IMPORTED_MODULE_1__["styleToObject"])(d.value);
                    break;
                case 'allowfullscreen':
                case 'allowpaymentrequest':
                case 'async':
                case 'autofocus':
                case 'autoplay':
                case 'checked':
                case 'controls':
                case 'default':
                case 'defer':
                case 'disabled':
                case 'formnovalidate':
                case 'hidden':
                case 'ismap':
                case 'itemscope':
                case 'loop':
                case 'multiple':
                case 'muted':
                case 'nomodule':
                case 'novalidate':
                case 'open':
                case 'readonly':
                case 'required':
                case 'reversed':
                case 'selected':
                case 'typemustmatch':
                    attributes[_helpers__WEBPACK_IMPORTED_MODULE_1__["possibleStandardNames"][d.name] || d.name] = true;
                    break;
                default:
                    attributes[_helpers__WEBPACK_IMPORTED_MODULE_1__["possibleStandardNames"][d.name] || d.name] = d.value;
            }
        });
    }
    return attributes;
}
function parseChildren(childNodeList, level, options) {
    var children = __spread(childNodeList).map(function (node, index) {
        return convertFromNode(node, __assign(__assign({}, options), { index: index, level: level + 1 }));
    })
        .filter(Boolean);
    if (!children.length) {
        return null;
    }
    return children;
}
function parseName(nodeName) {
    if (/[a-z]+[A-Z]+[a-z]+/.test(nodeName)) {
        return nodeName;
    }
    return nodeName.toLowerCase();
}
function convertFromNode(input, options) {
    if (options === void 0) { options = {}; }
    if (!input || !(input instanceof Node)) {
        return null;
    }
    var _a = options.actions, actions = _a === void 0 ? [] : _a, _b = options.index, index = _b === void 0 ? 0 : _b, _c = options.level, level = _c === void 0 ? 0 : _c;
    var node = input;
    var key = level + "-" + index;
    var result = [];
    /* istanbul ignore else */
    if (Array.isArray(actions)) {
        actions.forEach(function (action) {
            if (action.condition(node, key, level)) {
                if (typeof action.pre === 'function') {
                    node = action.pre(node, key, level);
                    if (!(node instanceof Node)) {
                        node = input;
                        /* istanbul ignore else */
                        if (true) {
                            // eslint-disable-next-line no-console
                            console.warn('The `pre` method always must return a valid DomNode (instanceof Node) - your modification will be ignored (Hint: if you want to render a React-component, use the `post` method instead)');
                        }
                    }
                }
                if (typeof action.post === 'function') {
                    result.push(action.post(node, key, level));
                }
            }
        });
    }
    if (result.length) {
        return result;
    }
    switch (node.nodeType) {
        case 1: {
            // regular dom-node
            return react__WEBPACK_IMPORTED_MODULE_0__["createElement"](parseName(node.nodeName), parseAttributes(node, key), parseChildren(node.childNodes, level, options));
        }
        case 3: {
            // textnode
            var nodeText = node.nodeValue.toString();
            /* istanbul ignore else */
            if (/^\s+$/.test(nodeText)) {
                return null;
            }
            /* istanbul ignore next */
            if (!node.parentNode) {
                return nodeText;
            }
            var parentNodeName = node.parentNode.nodeName.toLowerCase();
            if (_helpers__WEBPACK_IMPORTED_MODULE_1__["noTextChildNodes"].indexOf(parentNodeName) !== -1) {
                /* istanbul ignore else */
                if (/\S/.test(nodeText)) {
                    // eslint-disable-next-line no-console
                    console.warn("A textNode is not allowed inside '" + parentNodeName + "'. Your text \"" + nodeText + "\" will be ignored");
                }
                return null;
            }
            return nodeText;
        }
        case 8: {
            // html-comment
            return null;
        }
        /* istanbul ignore next */
        default: {
            return null;
        }
    }
}
function convertFromString(input, options) {
    if (options === void 0) { options = {}; }
    if (!input || typeof input !== 'string') {
        return null;
    }
    var _a = options.nodeOnly, nodeOnly = _a === void 0 ? false : _a, _b = options.selector, selector = _b === void 0 ? 'body > *' : _b, _c = options.type, type = _c === void 0 ? 'text/html' : _c;
    try {
        var parser = new DOMParser();
        var doc = parser.parseFromString(input, type);
        var node = doc.querySelector(selector);
        if (!(node instanceof Node)) {
            throw new Error('Error parsing input');
        }
        if (nodeOnly) {
            return node;
        }
        return convertFromNode(node, options);
    }
    catch (error) {
        /* istanbul ignore else */
        if (true) {
            // eslint-disable-next-line no-console
            console.error(error);
        }
    }
    return null;
}
function convert(input, options) {
    if (options === void 0) { options = {}; }
    if (typeof input === 'string') {
        return convertFromString(input, options);
    }
    if (input instanceof Node) {
        return convertFromNode(input, options);
    }
    return null;
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/react-inlinesvg/esm/helpers.js":
/*!*****************************************************!*\
  !*** ./node_modules/react-inlinesvg/esm/helpers.js ***!
  \*****************************************************/
/*! exports provided: STATUS, canUseDOM, supportsInlineSVG, isSupportedEnvironment, randomString */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "STATUS", function() { return STATUS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "canUseDOM", function() { return canUseDOM; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "supportsInlineSVG", function() { return supportsInlineSVG; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isSupportedEnvironment", function() { return isSupportedEnvironment; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "randomString", function() { return randomString; });
/* harmony import */ var exenv__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! exenv */ "./node_modules/exenv/index.js");
/* harmony import */ var exenv__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(exenv__WEBPACK_IMPORTED_MODULE_0__);

var STATUS = {
    FAILED: 'failed',
    LOADED: 'loaded',
    LOADING: 'loading',
    PENDING: 'pending',
    READY: 'ready',
    UNSUPPORTED: 'unsupported',
};
function canUseDOM() {
    return exenv__WEBPACK_IMPORTED_MODULE_0__["canUseDOM"];
}
function supportsInlineSVG() {
    /* istanbul ignore next */
    if (!document) {
        return false;
    }
    var div = document.createElement('div');
    div.innerHTML = '<svg />';
    return !!div.firstChild && div.firstChild.namespaceURI === 'http://www.w3.org/2000/svg';
}
function isSupportedEnvironment() {
    return supportsInlineSVG() && typeof window !== 'undefined' && window !== null;
}
function randomString(length) {
    var letters = 'abcdefghijklmnopqrstuvwxyz';
    var numbers = '1234567890';
    var charset = "" + letters + letters.toUpperCase() + numbers;
    var randomCharacter = function (character) {
        return character[Math.floor(Math.random() * character.length)];
    };
    var R = '';
    for (var i = 0; i < length; i++) {
        R += randomCharacter(charset);
    }
    return R;
}
//# sourceMappingURL=helpers.js.map

/***/ }),

/***/ "./node_modules/react-inlinesvg/esm/index.js":
/*!***************************************************!*\
  !*** ./node_modules/react-inlinesvg/esm/index.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react_from_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-from-dom */ "./node_modules/react-from-dom/esm/index.js");
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./helpers */ "./node_modules/react-inlinesvg/esm/helpers.js");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./types */ "./node_modules/react-inlinesvg/esm/types.js");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_types__WEBPACK_IMPORTED_MODULE_3__);
/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _types__WEBPACK_IMPORTED_MODULE_3__) if(["default"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return _types__WEBPACK_IMPORTED_MODULE_3__[key]; }) }(__WEBPACK_IMPORT_KEY__));
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (undefined && undefined.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};



var cacheStore = Object.create(null);
var InlineSVG = /** @class */ (function (_super) {
    __extends(InlineSVG, _super);
    function InlineSVG(props) {
        var _this = _super.call(this, props) || this;
        _this.isActive = false;
        _this.handleLoad = function (content) {
            /* istanbul ignore else */
            if (_this.isActive) {
                _this.setState({
                    content: content,
                    status: _helpers__WEBPACK_IMPORTED_MODULE_2__["STATUS"].LOADED,
                }, _this.getElement);
            }
        };
        _this.handleError = function (error) {
            var onError = _this.props.onError;
            var status = error.message === 'Browser does not support SVG' ? _helpers__WEBPACK_IMPORTED_MODULE_2__["STATUS"].UNSUPPORTED : _helpers__WEBPACK_IMPORTED_MODULE_2__["STATUS"].FAILED;
            /* istanbul ignore else */
            if (true) {
                // eslint-disable-next-line no-console
                console.error(error);
            }
            /* istanbul ignore else */
            if (_this.isActive) {
                _this.setState({ status: status }, function () {
                    /* istanbul ignore else */
                    if (typeof onError === 'function') {
                        onError(error);
                    }
                });
            }
        };
        _this.request = function () {
            var _a = _this.props, cacheRequests = _a.cacheRequests, src = _a.src;
            try {
                if (cacheRequests) {
                    cacheStore[src] = { content: '', status: _helpers__WEBPACK_IMPORTED_MODULE_2__["STATUS"].LOADING, queue: [] };
                }
                return fetch(src)
                    .then(function (response) {
                    var contentType = response.headers.get('content-type');
                    var _a = __read((contentType || '').split(/ ?; ?/), 1), fileType = _a[0];
                    if (response.status > 299) {
                        throw new Error('Not found');
                    }
                    if (!['image/svg+xml', 'text/plain'].some(function (d) { return fileType.indexOf(d) >= 0; })) {
                        throw new Error("Content type isn't valid: " + fileType);
                    }
                    return response.text();
                })
                    .then(function (content) {
                    _this.handleLoad(content);
                    /* istanbul ignore else */
                    if (cacheRequests) {
                        var cache = cacheStore[src];
                        /* istanbul ignore else */
                        if (cache) {
                            cache.content = content;
                            cache.status = _helpers__WEBPACK_IMPORTED_MODULE_2__["STATUS"].LOADED;
                            cache.queue = cache.queue.filter(function (cb) {
                                cb(content);
                                return false;
                            });
                        }
                    }
                })
                    .catch(function (error) {
                    /* istanbul ignore else */
                    if (cacheRequests) {
                        delete cacheStore[src];
                    }
                    _this.handleError(error);
                });
            }
            catch (error) {
                return _this.handleError(new Error(error.message));
            }
        };
        _this.state = {
            content: '',
            element: null,
            hasCache: !!props.cacheRequests && !!cacheStore[props.src],
            status: _helpers__WEBPACK_IMPORTED_MODULE_2__["STATUS"].PENDING,
        };
        _this.hash = props.uniqueHash || Object(_helpers__WEBPACK_IMPORTED_MODULE_2__["randomString"])(8);
        return _this;
    }
    InlineSVG.prototype.componentDidMount = function () {
        this.isActive = true;
        if (!Object(_helpers__WEBPACK_IMPORTED_MODULE_2__["canUseDOM"])()) {
            return;
        }
        var status = this.state.status;
        var src = this.props.src;
        try {
            /* istanbul ignore else */
            if (status === _helpers__WEBPACK_IMPORTED_MODULE_2__["STATUS"].PENDING) {
                /* istanbul ignore else */
                if (!Object(_helpers__WEBPACK_IMPORTED_MODULE_2__["isSupportedEnvironment"])()) {
                    throw new Error('Browser does not support SVG');
                }
                /* istanbul ignore else */
                if (!src) {
                    throw new Error('Missing src');
                }
                this.load();
            }
        }
        catch (error) {
            this.handleError(error);
        }
    };
    InlineSVG.prototype.componentDidUpdate = function (prevProps, prevState) {
        if (!Object(_helpers__WEBPACK_IMPORTED_MODULE_2__["canUseDOM"])()) {
            return;
        }
        var _a = this.state, hasCache = _a.hasCache, status = _a.status;
        var _b = this.props, onLoad = _b.onLoad, src = _b.src;
        if (prevState.status !== _helpers__WEBPACK_IMPORTED_MODULE_2__["STATUS"].READY && status === _helpers__WEBPACK_IMPORTED_MODULE_2__["STATUS"].READY) {
            /* istanbul ignore else */
            if (onLoad) {
                onLoad(src, hasCache);
            }
        }
        if (prevProps.src !== src) {
            if (!src) {
                this.handleError(new Error('Missing src'));
                return;
            }
            this.load();
        }
    };
    InlineSVG.prototype.componentWillUnmount = function () {
        this.isActive = false;
    };
    InlineSVG.prototype.processSVG = function () {
        var content = this.state.content;
        var preProcessor = this.props.preProcessor;
        if (preProcessor) {
            return preProcessor(content);
        }
        return content;
    };
    InlineSVG.prototype.updateSVGAttributes = function (node) {
        var _this = this;
        var _a = this.props, _b = _a.baseURL, baseURL = _b === void 0 ? '' : _b, uniquifyIDs = _a.uniquifyIDs;
        var replaceableAttributes = ['id', 'href', 'xlink:href', 'xlink:role', 'xlink:arcrole'];
        var linkAttributes = ['href', 'xlink:href'];
        var isDataValue = function (name, value) {
            return linkAttributes.indexOf(name) >= 0 && (value ? value.indexOf('#') < 0 : false);
        };
        if (!uniquifyIDs) {
            return node;
        }
        __spread(node.children).map(function (d) {
            if (d.attributes && d.attributes.length) {
                var attributes_1 = Object.values(d.attributes).map(function (a) {
                    var attr = a;
                    var match = a.value.match(/url\((.*?)\)/);
                    if (match && match[1]) {
                        attr.value = a.value.replace(match[0], "url(" + baseURL + match[1] + "__" + _this.hash + ")");
                    }
                    return attr;
                });
                replaceableAttributes.forEach(function (r) {
                    var attribute = attributes_1.find(function (a) { return a.name === r; });
                    if (attribute && !isDataValue(r, attribute.value)) {
                        attribute.value = attribute.value + "__" + _this.hash;
                    }
                });
            }
            if (d.children.length) {
                return _this.updateSVGAttributes(d);
            }
            return d;
        });
        return node;
    };
    InlineSVG.prototype.getNode = function () {
        var _a = this.props, description = _a.description, title = _a.title;
        try {
            var svgText = this.processSVG();
            var node = Object(react_from_dom__WEBPACK_IMPORTED_MODULE_1__["default"])(svgText, { nodeOnly: true });
            if (!node || !(node instanceof SVGSVGElement)) {
                throw new Error('Could not convert the src to a DOM Node');
            }
            var svg = this.updateSVGAttributes(node);
            if (description) {
                var originalDesc = svg.querySelector('desc');
                if (originalDesc && originalDesc.parentNode) {
                    originalDesc.parentNode.removeChild(originalDesc);
                }
                var descElement = document.createElement('desc');
                descElement.innerHTML = description;
                svg.prepend(descElement);
            }
            if (title) {
                var originalTitle = svg.querySelector('title');
                if (originalTitle && originalTitle.parentNode) {
                    originalTitle.parentNode.removeChild(originalTitle);
                }
                var titleElement = document.createElement('title');
                titleElement.innerHTML = title;
                svg.prepend(titleElement);
            }
            return svg;
        }
        catch (error) {
            return this.handleError(error);
        }
    };
    InlineSVG.prototype.getElement = function () {
        try {
            var node = this.getNode();
            var element = Object(react_from_dom__WEBPACK_IMPORTED_MODULE_1__["default"])(node);
            if (!element || !react__WEBPACK_IMPORTED_MODULE_0__["isValidElement"](element)) {
                throw new Error('Could not convert the src to a React element');
            }
            this.setState({
                element: element,
                status: _helpers__WEBPACK_IMPORTED_MODULE_2__["STATUS"].READY,
            });
        }
        catch (error) {
            this.handleError(new Error(error.message));
        }
    };
    InlineSVG.prototype.load = function () {
        var _this = this;
        /* istanbul ignore else */
        if (this.isActive) {
            this.setState({
                content: '',
                element: null,
                status: _helpers__WEBPACK_IMPORTED_MODULE_2__["STATUS"].LOADING,
            }, function () {
                var _a = _this.props, cacheRequests = _a.cacheRequests, src = _a.src;
                var cache = cacheRequests && cacheStore[src];
                if (cache) {
                    /* istanbul ignore else */
                    if (cache.status === _helpers__WEBPACK_IMPORTED_MODULE_2__["STATUS"].LOADING) {
                        cache.queue.push(_this.handleLoad);
                    }
                    else if (cache.status === _helpers__WEBPACK_IMPORTED_MODULE_2__["STATUS"].LOADED) {
                        _this.handleLoad(cache.content);
                    }
                    return;
                }
                var dataURI = src.match(/data:image\/svg[^,]*?(;base64)?,(.*)/);
                var inlineSrc;
                if (dataURI) {
                    inlineSrc = dataURI[1] ? atob(dataURI[2]) : decodeURIComponent(dataURI[2]);
                }
                else if (src.indexOf('<svg') >= 0) {
                    inlineSrc = src;
                }
                if (inlineSrc) {
                    _this.handleLoad(inlineSrc);
                    return;
                }
                _this.request();
            });
        }
    };
    InlineSVG.prototype.render = function () {
        var _a = this.state, element = _a.element, status = _a.status;
        var _b = this.props, baseURL = _b.baseURL, cacheRequests = _b.cacheRequests, _c = _b.children, children = _c === void 0 ? null : _c, description = _b.description, innerRef = _b.innerRef, _d = _b.loader, loader = _d === void 0 ? null : _d, onError = _b.onError, onLoad = _b.onLoad, preProcessor = _b.preProcessor, src = _b.src, title = _b.title, uniqueHash = _b.uniqueHash, uniquifyIDs = _b.uniquifyIDs, rest = __rest(_b, ["baseURL", "cacheRequests", "children", "description", "innerRef", "loader", "onError", "onLoad", "preProcessor", "src", "title", "uniqueHash", "uniquifyIDs"]);
        if (!Object(_helpers__WEBPACK_IMPORTED_MODULE_2__["canUseDOM"])()) {
            return loader;
        }
        if (element) {
            return react__WEBPACK_IMPORTED_MODULE_0__["cloneElement"](element, __assign({ ref: innerRef }, rest));
        }
        if ([_helpers__WEBPACK_IMPORTED_MODULE_2__["STATUS"].UNSUPPORTED, _helpers__WEBPACK_IMPORTED_MODULE_2__["STATUS"].FAILED].indexOf(status) > -1) {
            return children;
        }
        return loader;
    };
    InlineSVG.defaultProps = {
        cacheRequests: true,
        uniquifyIDs: false,
    };
    return InlineSVG;
}(react__WEBPACK_IMPORTED_MODULE_0__["PureComponent"]));
/* harmony default export */ __webpack_exports__["default"] = (InlineSVG);

//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/react-inlinesvg/esm/types.js":
/*!***************************************************!*\
  !*** ./node_modules/react-inlinesvg/esm/types.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

//# sourceMappingURL=types.js.map

/***/ }),

/***/ "./node_modules/react-is/cjs/react-is.development.js":
/*!***********************************************************!*\
  !*** ./node_modules/react-is/cjs/react-is.development.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */





if (true) {
  (function() {
'use strict';

// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var hasSymbol = typeof Symbol === 'function' && Symbol.for;
var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;
var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;
var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;
var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;
var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;
var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;
var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary
// (unstable) APIs that have been removed. Can we remove the symbols?

var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;
var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;
var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;
var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 0xead8;
var REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;
var REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;
var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for('react.block') : 0xead9;
var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 0xead5;
var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for('react.responder') : 0xead6;
var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 0xead7;

function isValidElementType(type) {
  return typeof type === 'string' || typeof type === 'function' || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
  type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
}

function typeOf(object) {
  if (typeof object === 'object' && object !== null) {
    var $$typeof = object.$$typeof;

    switch ($$typeof) {
      case REACT_ELEMENT_TYPE:
        var type = object.type;

        switch (type) {
          case REACT_ASYNC_MODE_TYPE:
          case REACT_CONCURRENT_MODE_TYPE:
          case REACT_FRAGMENT_TYPE:
          case REACT_PROFILER_TYPE:
          case REACT_STRICT_MODE_TYPE:
          case REACT_SUSPENSE_TYPE:
            return type;

          default:
            var $$typeofType = type && type.$$typeof;

            switch ($$typeofType) {
              case REACT_CONTEXT_TYPE:
              case REACT_FORWARD_REF_TYPE:
              case REACT_LAZY_TYPE:
              case REACT_MEMO_TYPE:
              case REACT_PROVIDER_TYPE:
                return $$typeofType;

              default:
                return $$typeof;
            }

        }

      case REACT_PORTAL_TYPE:
        return $$typeof;
    }
  }

  return undefined;
} // AsyncMode is deprecated along with isAsyncMode

var AsyncMode = REACT_ASYNC_MODE_TYPE;
var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
var ContextConsumer = REACT_CONTEXT_TYPE;
var ContextProvider = REACT_PROVIDER_TYPE;
var Element = REACT_ELEMENT_TYPE;
var ForwardRef = REACT_FORWARD_REF_TYPE;
var Fragment = REACT_FRAGMENT_TYPE;
var Lazy = REACT_LAZY_TYPE;
var Memo = REACT_MEMO_TYPE;
var Portal = REACT_PORTAL_TYPE;
var Profiler = REACT_PROFILER_TYPE;
var StrictMode = REACT_STRICT_MODE_TYPE;
var Suspense = REACT_SUSPENSE_TYPE;
var hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated

function isAsyncMode(object) {
  {
    if (!hasWarnedAboutDeprecatedIsAsyncMode) {
      hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint

      console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');
    }
  }

  return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
}
function isConcurrentMode(object) {
  return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
}
function isContextConsumer(object) {
  return typeOf(object) === REACT_CONTEXT_TYPE;
}
function isContextProvider(object) {
  return typeOf(object) === REACT_PROVIDER_TYPE;
}
function isElement(object) {
  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
}
function isForwardRef(object) {
  return typeOf(object) === REACT_FORWARD_REF_TYPE;
}
function isFragment(object) {
  return typeOf(object) === REACT_FRAGMENT_TYPE;
}
function isLazy(object) {
  return typeOf(object) === REACT_LAZY_TYPE;
}
function isMemo(object) {
  return typeOf(object) === REACT_MEMO_TYPE;
}
function isPortal(object) {
  return typeOf(object) === REACT_PORTAL_TYPE;
}
function isProfiler(object) {
  return typeOf(object) === REACT_PROFILER_TYPE;
}
function isStrictMode(object) {
  return typeOf(object) === REACT_STRICT_MODE_TYPE;
}
function isSuspense(object) {
  return typeOf(object) === REACT_SUSPENSE_TYPE;
}

exports.AsyncMode = AsyncMode;
exports.ConcurrentMode = ConcurrentMode;
exports.ContextConsumer = ContextConsumer;
exports.ContextProvider = ContextProvider;
exports.Element = Element;
exports.ForwardRef = ForwardRef;
exports.Fragment = Fragment;
exports.Lazy = Lazy;
exports.Memo = Memo;
exports.Portal = Portal;
exports.Profiler = Profiler;
exports.StrictMode = StrictMode;
exports.Suspense = Suspense;
exports.isAsyncMode = isAsyncMode;
exports.isConcurrentMode = isConcurrentMode;
exports.isContextConsumer = isContextConsumer;
exports.isContextProvider = isContextProvider;
exports.isElement = isElement;
exports.isForwardRef = isForwardRef;
exports.isFragment = isFragment;
exports.isLazy = isLazy;
exports.isMemo = isMemo;
exports.isPortal = isPortal;
exports.isProfiler = isProfiler;
exports.isStrictMode = isStrictMode;
exports.isSuspense = isSuspense;
exports.isValidElementType = isValidElementType;
exports.typeOf = typeOf;
  })();
}


/***/ }),

/***/ "./node_modules/react-is/index.js":
/*!****************************************!*\
  !*** ./node_modules/react-is/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/react-is.development.js */ "./node_modules/react-is/cjs/react-is.development.js");
}


/***/ }),

/***/ "./node_modules/react/cjs/react.development.js":
/*!*****************************************************!*\
  !*** ./node_modules/react/cjs/react.development.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v16.13.1
 * react.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */





if (true) {
  (function() {
'use strict';

var _assign = __webpack_require__(/*! object-assign */ "./node_modules/next/dist/build/polyfills/object-assign.js");
var checkPropTypes = __webpack_require__(/*! prop-types/checkPropTypes */ "./node_modules/prop-types/checkPropTypes.js");

var ReactVersion = '16.13.1';

// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var hasSymbol = typeof Symbol === 'function' && Symbol.for;
var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;
var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;
var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;
var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;
var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;
var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;
var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary
var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;
var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;
var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 0xead8;
var REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;
var REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;
var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for('react.block') : 0xead9;
var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 0xead5;
var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for('react.responder') : 0xead6;
var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 0xead7;
var MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
var FAUX_ITERATOR_SYMBOL = '@@iterator';
function getIteratorFn(maybeIterable) {
  if (maybeIterable === null || typeof maybeIterable !== 'object') {
    return null;
  }

  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];

  if (typeof maybeIterator === 'function') {
    return maybeIterator;
  }

  return null;
}

/**
 * Keeps track of the current dispatcher.
 */
var ReactCurrentDispatcher = {
  /**
   * @internal
   * @type {ReactComponent}
   */
  current: null
};

/**
 * Keeps track of the current batch's configuration such as how long an update
 * should suspend for if it needs to.
 */
var ReactCurrentBatchConfig = {
  suspense: null
};

/**
 * Keeps track of the current owner.
 *
 * The current owner is the component who should own any components that are
 * currently being constructed.
 */
var ReactCurrentOwner = {
  /**
   * @internal
   * @type {ReactComponent}
   */
  current: null
};

var BEFORE_SLASH_RE = /^(.*)[\\\/]/;
function describeComponentFrame (name, source, ownerName) {
  var sourceInfo = '';

  if (source) {
    var path = source.fileName;
    var fileName = path.replace(BEFORE_SLASH_RE, '');

    {
      // In DEV, include code for a common special case:
      // prefer "folder/index.js" instead of just "index.js".
      if (/^index\./.test(fileName)) {
        var match = path.match(BEFORE_SLASH_RE);

        if (match) {
          var pathBeforeSlash = match[1];

          if (pathBeforeSlash) {
            var folderName = pathBeforeSlash.replace(BEFORE_SLASH_RE, '');
            fileName = folderName + '/' + fileName;
          }
        }
      }
    }

    sourceInfo = ' (at ' + fileName + ':' + source.lineNumber + ')';
  } else if (ownerName) {
    sourceInfo = ' (created by ' + ownerName + ')';
  }

  return '\n    in ' + (name || 'Unknown') + sourceInfo;
}

var Resolved = 1;
function refineResolvedLazyComponent(lazyComponent) {
  return lazyComponent._status === Resolved ? lazyComponent._result : null;
}

function getWrappedName(outerType, innerType, wrapperName) {
  var functionName = innerType.displayName || innerType.name || '';
  return outerType.displayName || (functionName !== '' ? wrapperName + "(" + functionName + ")" : wrapperName);
}

function getComponentName(type) {
  if (type == null) {
    // Host root, text node or just invalid type.
    return null;
  }

  {
    if (typeof type.tag === 'number') {
      error('Received an unexpected object in getComponentName(). ' + 'This is likely a bug in React. Please file an issue.');
    }
  }

  if (typeof type === 'function') {
    return type.displayName || type.name || null;
  }

  if (typeof type === 'string') {
    return type;
  }

  switch (type) {
    case REACT_FRAGMENT_TYPE:
      return 'Fragment';

    case REACT_PORTAL_TYPE:
      return 'Portal';

    case REACT_PROFILER_TYPE:
      return "Profiler";

    case REACT_STRICT_MODE_TYPE:
      return 'StrictMode';

    case REACT_SUSPENSE_TYPE:
      return 'Suspense';

    case REACT_SUSPENSE_LIST_TYPE:
      return 'SuspenseList';
  }

  if (typeof type === 'object') {
    switch (type.$$typeof) {
      case REACT_CONTEXT_TYPE:
        return 'Context.Consumer';

      case REACT_PROVIDER_TYPE:
        return 'Context.Provider';

      case REACT_FORWARD_REF_TYPE:
        return getWrappedName(type, type.render, 'ForwardRef');

      case REACT_MEMO_TYPE:
        return getComponentName(type.type);

      case REACT_BLOCK_TYPE:
        return getComponentName(type.render);

      case REACT_LAZY_TYPE:
        {
          var thenable = type;
          var resolvedThenable = refineResolvedLazyComponent(thenable);

          if (resolvedThenable) {
            return getComponentName(resolvedThenable);
          }

          break;
        }
    }
  }

  return null;
}

var ReactDebugCurrentFrame = {};
var currentlyValidatingElement = null;
function setCurrentlyValidatingElement(element) {
  {
    currentlyValidatingElement = element;
  }
}

{
  // Stack implementation injected by the current renderer.
  ReactDebugCurrentFrame.getCurrentStack = null;

  ReactDebugCurrentFrame.getStackAddendum = function () {
    var stack = ''; // Add an extra top frame while an element is being validated

    if (currentlyValidatingElement) {
      var name = getComponentName(currentlyValidatingElement.type);
      var owner = currentlyValidatingElement._owner;
      stack += describeComponentFrame(name, currentlyValidatingElement._source, owner && getComponentName(owner.type));
    } // Delegate to the injected renderer-specific implementation


    var impl = ReactDebugCurrentFrame.getCurrentStack;

    if (impl) {
      stack += impl() || '';
    }

    return stack;
  };
}

/**
 * Used by act() to track whether you're inside an act() scope.
 */
var IsSomeRendererActing = {
  current: false
};

var ReactSharedInternals = {
  ReactCurrentDispatcher: ReactCurrentDispatcher,
  ReactCurrentBatchConfig: ReactCurrentBatchConfig,
  ReactCurrentOwner: ReactCurrentOwner,
  IsSomeRendererActing: IsSomeRendererActing,
  // Used by renderers to avoid bundling object-assign twice in UMD bundles:
  assign: _assign
};

{
  _assign(ReactSharedInternals, {
    // These should not be included in production.
    ReactDebugCurrentFrame: ReactDebugCurrentFrame,
    // Shim for React DOM 16.0.0 which still destructured (but not used) this.
    // TODO: remove in React 17.0.
    ReactComponentTreeHook: {}
  });
}

// by calls to these methods by a Babel plugin.
//
// In PROD (or in packages without access to React internals),
// they are left as they are instead.

function warn(format) {
  {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    printWarning('warn', format, args);
  }
}
function error(format) {
  {
    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }

    printWarning('error', format, args);
  }
}

function printWarning(level, format, args) {
  // When changing this logic, you might want to also
  // update consoleWithStackDev.www.js as well.
  {
    var hasExistingStack = args.length > 0 && typeof args[args.length - 1] === 'string' && args[args.length - 1].indexOf('\n    in') === 0;

    if (!hasExistingStack) {
      var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
      var stack = ReactDebugCurrentFrame.getStackAddendum();

      if (stack !== '') {
        format += '%s';
        args = args.concat([stack]);
      }
    }

    var argsWithFormat = args.map(function (item) {
      return '' + item;
    }); // Careful: RN currently depends on this prefix

    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it
    // breaks IE9: https://github.com/facebook/react/issues/13610
    // eslint-disable-next-line react-internal/no-production-logging

    Function.prototype.apply.call(console[level], console, argsWithFormat);

    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      var argIndex = 0;
      var message = 'Warning: ' + format.replace(/%s/g, function () {
        return args[argIndex++];
      });
      throw new Error(message);
    } catch (x) {}
  }
}

var didWarnStateUpdateForUnmountedComponent = {};

function warnNoop(publicInstance, callerName) {
  {
    var _constructor = publicInstance.constructor;
    var componentName = _constructor && (_constructor.displayName || _constructor.name) || 'ReactClass';
    var warningKey = componentName + "." + callerName;

    if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
      return;
    }

    error("Can't call %s on a component that is not yet mounted. " + 'This is a no-op, but it might indicate a bug in your application. ' + 'Instead, assign to `this.state` directly or define a `state = {};` ' + 'class property with the desired state in the %s component.', callerName, componentName);

    didWarnStateUpdateForUnmountedComponent[warningKey] = true;
  }
}
/**
 * This is the abstract API for an update queue.
 */


var ReactNoopUpdateQueue = {
  /**
   * Checks whether or not this composite component is mounted.
   * @param {ReactClass} publicInstance The instance we want to test.
   * @return {boolean} True if mounted, false otherwise.
   * @protected
   * @final
   */
  isMounted: function (publicInstance) {
    return false;
  },

  /**
   * Forces an update. This should only be invoked when it is known with
   * certainty that we are **not** in a DOM transaction.
   *
   * You may want to call this when you know that some deeper aspect of the
   * component's state has changed but `setState` was not called.
   *
   * This will not invoke `shouldComponentUpdate`, but it will invoke
   * `componentWillUpdate` and `componentDidUpdate`.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {?function} callback Called after component is updated.
   * @param {?string} callerName name of the calling function in the public API.
   * @internal
   */
  enqueueForceUpdate: function (publicInstance, callback, callerName) {
    warnNoop(publicInstance, 'forceUpdate');
  },

  /**
   * Replaces all of the state. Always use this or `setState` to mutate state.
   * You should treat `this.state` as immutable.
   *
   * There is no guarantee that `this.state` will be immediately updated, so
   * accessing `this.state` after calling this method may return the old value.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} completeState Next state.
   * @param {?function} callback Called after component is updated.
   * @param {?string} callerName name of the calling function in the public API.
   * @internal
   */
  enqueueReplaceState: function (publicInstance, completeState, callback, callerName) {
    warnNoop(publicInstance, 'replaceState');
  },

  /**
   * Sets a subset of the state. This only exists because _pendingState is
   * internal. This provides a merging strategy that is not available to deep
   * properties which is confusing. TODO: Expose pendingState or don't use it
   * during the merge.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} partialState Next partial state to be merged with state.
   * @param {?function} callback Called after component is updated.
   * @param {?string} Name of the calling function in the public API.
   * @internal
   */
  enqueueSetState: function (publicInstance, partialState, callback, callerName) {
    warnNoop(publicInstance, 'setState');
  }
};

var emptyObject = {};

{
  Object.freeze(emptyObject);
}
/**
 * Base class helpers for the updating state of a component.
 */


function Component(props, context, updater) {
  this.props = props;
  this.context = context; // If a component has string refs, we will assign a different object later.

  this.refs = emptyObject; // We initialize the default updater but the real one gets injected by the
  // renderer.

  this.updater = updater || ReactNoopUpdateQueue;
}

Component.prototype.isReactComponent = {};
/**
 * Sets a subset of the state. Always use this to mutate
 * state. You should treat `this.state` as immutable.
 *
 * There is no guarantee that `this.state` will be immediately updated, so
 * accessing `this.state` after calling this method may return the old value.
 *
 * There is no guarantee that calls to `setState` will run synchronously,
 * as they may eventually be batched together.  You can provide an optional
 * callback that will be executed when the call to setState is actually
 * completed.
 *
 * When a function is provided to setState, it will be called at some point in
 * the future (not synchronously). It will be called with the up to date
 * component arguments (state, props, context). These values can be different
 * from this.* because your function may be called after receiveProps but before
 * shouldComponentUpdate, and this new state, props, and context will not yet be
 * assigned to this.
 *
 * @param {object|function} partialState Next partial state or function to
 *        produce next partial state to be merged with current state.
 * @param {?function} callback Called after state is updated.
 * @final
 * @protected
 */

Component.prototype.setState = function (partialState, callback) {
  if (!(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null)) {
    {
      throw Error( "setState(...): takes an object of state variables to update or a function which returns an object of state variables." );
    }
  }

  this.updater.enqueueSetState(this, partialState, callback, 'setState');
};
/**
 * Forces an update. This should only be invoked when it is known with
 * certainty that we are **not** in a DOM transaction.
 *
 * You may want to call this when you know that some deeper aspect of the
 * component's state has changed but `setState` was not called.
 *
 * This will not invoke `shouldComponentUpdate`, but it will invoke
 * `componentWillUpdate` and `componentDidUpdate`.
 *
 * @param {?function} callback Called after update is complete.
 * @final
 * @protected
 */


Component.prototype.forceUpdate = function (callback) {
  this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');
};
/**
 * Deprecated APIs. These APIs used to exist on classic React classes but since
 * we would like to deprecate them, we're not going to move them over to this
 * modern base class. Instead, we define a getter that warns if it's accessed.
 */


{
  var deprecatedAPIs = {
    isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
    replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']
  };

  var defineDeprecationWarning = function (methodName, info) {
    Object.defineProperty(Component.prototype, methodName, {
      get: function () {
        warn('%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]);

        return undefined;
      }
    });
  };

  for (var fnName in deprecatedAPIs) {
    if (deprecatedAPIs.hasOwnProperty(fnName)) {
      defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
    }
  }
}

function ComponentDummy() {}

ComponentDummy.prototype = Component.prototype;
/**
 * Convenience component with default shallow equality check for sCU.
 */

function PureComponent(props, context, updater) {
  this.props = props;
  this.context = context; // If a component has string refs, we will assign a different object later.

  this.refs = emptyObject;
  this.updater = updater || ReactNoopUpdateQueue;
}

var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
pureComponentPrototype.constructor = PureComponent; // Avoid an extra prototype jump for these methods.

_assign(pureComponentPrototype, Component.prototype);

pureComponentPrototype.isPureReactComponent = true;

// an immutable object with a single mutable value
function createRef() {
  var refObject = {
    current: null
  };

  {
    Object.seal(refObject);
  }

  return refObject;
}

var hasOwnProperty = Object.prototype.hasOwnProperty;
var RESERVED_PROPS = {
  key: true,
  ref: true,
  __self: true,
  __source: true
};
var specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;

{
  didWarnAboutStringRefs = {};
}

function hasValidRef(config) {
  {
    if (hasOwnProperty.call(config, 'ref')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;

      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }

  return config.ref !== undefined;
}

function hasValidKey(config) {
  {
    if (hasOwnProperty.call(config, 'key')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;

      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }

  return config.key !== undefined;
}

function defineKeyPropWarningGetter(props, displayName) {
  var warnAboutAccessingKey = function () {
    {
      if (!specialPropKeyWarningShown) {
        specialPropKeyWarningShown = true;

        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName);
      }
    }
  };

  warnAboutAccessingKey.isReactWarning = true;
  Object.defineProperty(props, 'key', {
    get: warnAboutAccessingKey,
    configurable: true
  });
}

function defineRefPropWarningGetter(props, displayName) {
  var warnAboutAccessingRef = function () {
    {
      if (!specialPropRefWarningShown) {
        specialPropRefWarningShown = true;

        error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName);
      }
    }
  };

  warnAboutAccessingRef.isReactWarning = true;
  Object.defineProperty(props, 'ref', {
    get: warnAboutAccessingRef,
    configurable: true
  });
}

function warnIfStringRefCannotBeAutoConverted(config) {
  {
    if (typeof config.ref === 'string' && ReactCurrentOwner.current && config.__self && ReactCurrentOwner.current.stateNode !== config.__self) {
      var componentName = getComponentName(ReactCurrentOwner.current.type);

      if (!didWarnAboutStringRefs[componentName]) {
        error('Component "%s" contains the string ref "%s". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://fb.me/react-strict-mode-string-ref', getComponentName(ReactCurrentOwner.current.type), config.ref);

        didWarnAboutStringRefs[componentName] = true;
      }
    }
  }
}
/**
 * Factory method to create a new React element. This no longer adheres to
 * the class pattern, so do not use new to call it. Also, instanceof check
 * will not work. Instead test $$typeof field against Symbol.for('react.element') to check
 * if something is a React Element.
 *
 * @param {*} type
 * @param {*} props
 * @param {*} key
 * @param {string|object} ref
 * @param {*} owner
 * @param {*} self A *temporary* helper to detect places where `this` is
 * different from the `owner` when React.createElement is called, so that we
 * can warn. We want to get rid of owner and replace string `ref`s with arrow
 * functions, and as long as `this` and owner are the same, there will be no
 * change in behavior.
 * @param {*} source An annotation object (added by a transpiler or otherwise)
 * indicating filename, line number, and/or other information.
 * @internal
 */


var ReactElement = function (type, key, ref, self, source, owner, props) {
  var element = {
    // This tag allows us to uniquely identify this as a React Element
    $$typeof: REACT_ELEMENT_TYPE,
    // Built-in properties that belong on the element
    type: type,
    key: key,
    ref: ref,
    props: props,
    // Record the component responsible for creating this element.
    _owner: owner
  };

  {
    // The validation flag is currently mutative. We put it on
    // an external backing store so that we can freeze the whole object.
    // This can be replaced with a WeakMap once they are implemented in
    // commonly used development environments.
    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make
    // the validation flag non-enumerable (where possible, which should
    // include every environment we run tests in), so the test framework
    // ignores it.

    Object.defineProperty(element._store, 'validated', {
      configurable: false,
      enumerable: false,
      writable: true,
      value: false
    }); // self and source are DEV only properties.

    Object.defineProperty(element, '_self', {
      configurable: false,
      enumerable: false,
      writable: false,
      value: self
    }); // Two elements created in two different places should be considered
    // equal for testing purposes and therefore we hide it from enumeration.

    Object.defineProperty(element, '_source', {
      configurable: false,
      enumerable: false,
      writable: false,
      value: source
    });

    if (Object.freeze) {
      Object.freeze(element.props);
      Object.freeze(element);
    }
  }

  return element;
};
/**
 * Create and return a new ReactElement of the given type.
 * See https://reactjs.org/docs/react-api.html#createelement
 */

function createElement(type, config, children) {
  var propName; // Reserved names are extracted

  var props = {};
  var key = null;
  var ref = null;
  var self = null;
  var source = null;

  if (config != null) {
    if (hasValidRef(config)) {
      ref = config.ref;

      {
        warnIfStringRefCannotBeAutoConverted(config);
      }
    }

    if (hasValidKey(config)) {
      key = '' + config.key;
    }

    self = config.__self === undefined ? null : config.__self;
    source = config.__source === undefined ? null : config.__source; // Remaining properties are added to a new props object

    for (propName in config) {
      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        props[propName] = config[propName];
      }
    }
  } // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.


  var childrenLength = arguments.length - 2;

  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    var childArray = Array(childrenLength);

    for (var i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }

    {
      if (Object.freeze) {
        Object.freeze(childArray);
      }
    }

    props.children = childArray;
  } // Resolve default props


  if (type && type.defaultProps) {
    var defaultProps = type.defaultProps;

    for (propName in defaultProps) {
      if (props[propName] === undefined) {
        props[propName] = defaultProps[propName];
      }
    }
  }

  {
    if (key || ref) {
      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;

      if (key) {
        defineKeyPropWarningGetter(props, displayName);
      }

      if (ref) {
        defineRefPropWarningGetter(props, displayName);
      }
    }
  }

  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
}
function cloneAndReplaceKey(oldElement, newKey) {
  var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
  return newElement;
}
/**
 * Clone and return a new ReactElement using element as the starting point.
 * See https://reactjs.org/docs/react-api.html#cloneelement
 */

function cloneElement(element, config, children) {
  if (!!(element === null || element === undefined)) {
    {
      throw Error( "React.cloneElement(...): The argument must be a React element, but you passed " + element + "." );
    }
  }

  var propName; // Original props are copied

  var props = _assign({}, element.props); // Reserved names are extracted


  var key = element.key;
  var ref = element.ref; // Self is preserved since the owner is preserved.

  var self = element._self; // Source is preserved since cloneElement is unlikely to be targeted by a
  // transpiler, and the original source is probably a better indicator of the
  // true owner.

  var source = element._source; // Owner will be preserved, unless ref is overridden

  var owner = element._owner;

  if (config != null) {
    if (hasValidRef(config)) {
      // Silently steal the ref from the parent.
      ref = config.ref;
      owner = ReactCurrentOwner.current;
    }

    if (hasValidKey(config)) {
      key = '' + config.key;
    } // Remaining properties override existing props


    var defaultProps;

    if (element.type && element.type.defaultProps) {
      defaultProps = element.type.defaultProps;
    }

    for (propName in config) {
      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        if (config[propName] === undefined && defaultProps !== undefined) {
          // Resolve default props
          props[propName] = defaultProps[propName];
        } else {
          props[propName] = config[propName];
        }
      }
    }
  } // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.


  var childrenLength = arguments.length - 2;

  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    var childArray = Array(childrenLength);

    for (var i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }

    props.children = childArray;
  }

  return ReactElement(element.type, key, ref, self, source, owner, props);
}
/**
 * Verifies the object is a ReactElement.
 * See https://reactjs.org/docs/react-api.html#isvalidelement
 * @param {?object} object
 * @return {boolean} True if `object` is a ReactElement.
 * @final
 */

function isValidElement(object) {
  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
}

var SEPARATOR = '.';
var SUBSEPARATOR = ':';
/**
 * Escape and wrap key so it is safe to use as a reactid
 *
 * @param {string} key to be escaped.
 * @return {string} the escaped key.
 */

function escape(key) {
  var escapeRegex = /[=:]/g;
  var escaperLookup = {
    '=': '=0',
    ':': '=2'
  };
  var escapedString = ('' + key).replace(escapeRegex, function (match) {
    return escaperLookup[match];
  });
  return '$' + escapedString;
}
/**
 * TODO: Test that a single child and an array with one item have the same key
 * pattern.
 */


var didWarnAboutMaps = false;
var userProvidedKeyEscapeRegex = /\/+/g;

function escapeUserProvidedKey(text) {
  return ('' + text).replace(userProvidedKeyEscapeRegex, '$&/');
}

var POOL_SIZE = 10;
var traverseContextPool = [];

function getPooledTraverseContext(mapResult, keyPrefix, mapFunction, mapContext) {
  if (traverseContextPool.length) {
    var traverseContext = traverseContextPool.pop();
    traverseContext.result = mapResult;
    traverseContext.keyPrefix = keyPrefix;
    traverseContext.func = mapFunction;
    traverseContext.context = mapContext;
    traverseContext.count = 0;
    return traverseContext;
  } else {
    return {
      result: mapResult,
      keyPrefix: keyPrefix,
      func: mapFunction,
      context: mapContext,
      count: 0
    };
  }
}

function releaseTraverseContext(traverseContext) {
  traverseContext.result = null;
  traverseContext.keyPrefix = null;
  traverseContext.func = null;
  traverseContext.context = null;
  traverseContext.count = 0;

  if (traverseContextPool.length < POOL_SIZE) {
    traverseContextPool.push(traverseContext);
  }
}
/**
 * @param {?*} children Children tree container.
 * @param {!string} nameSoFar Name of the key path so far.
 * @param {!function} callback Callback to invoke with each child found.
 * @param {?*} traverseContext Used to pass information throughout the traversal
 * process.
 * @return {!number} The number of children in this subtree.
 */


function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
  var type = typeof children;

  if (type === 'undefined' || type === 'boolean') {
    // All of the above are perceived as null.
    children = null;
  }

  var invokeCallback = false;

  if (children === null) {
    invokeCallback = true;
  } else {
    switch (type) {
      case 'string':
      case 'number':
        invokeCallback = true;
        break;

      case 'object':
        switch (children.$$typeof) {
          case REACT_ELEMENT_TYPE:
          case REACT_PORTAL_TYPE:
            invokeCallback = true;
        }

    }
  }

  if (invokeCallback) {
    callback(traverseContext, children, // If it's the only child, treat the name as if it was wrapped in an array
    // so that it's consistent if the number of children grows.
    nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
    return 1;
  }

  var child;
  var nextName;
  var subtreeCount = 0; // Count of children found in the current subtree.

  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;

  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      child = children[i];
      nextName = nextNamePrefix + getComponentKey(child, i);
      subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
    }
  } else {
    var iteratorFn = getIteratorFn(children);

    if (typeof iteratorFn === 'function') {

      {
        // Warn about using Maps as children
        if (iteratorFn === children.entries) {
          if (!didWarnAboutMaps) {
            warn('Using Maps as children is deprecated and will be removed in ' + 'a future major release. Consider converting children to ' + 'an array of keyed ReactElements instead.');
          }

          didWarnAboutMaps = true;
        }
      }

      var iterator = iteratorFn.call(children);
      var step;
      var ii = 0;

      while (!(step = iterator.next()).done) {
        child = step.value;
        nextName = nextNamePrefix + getComponentKey(child, ii++);
        subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
      }
    } else if (type === 'object') {
      var addendum = '';

      {
        addendum = ' If you meant to render a collection of children, use an array ' + 'instead.' + ReactDebugCurrentFrame.getStackAddendum();
      }

      var childrenString = '' + children;

      {
        {
          throw Error( "Objects are not valid as a React child (found: " + (childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString) + ")." + addendum );
        }
      }
    }
  }

  return subtreeCount;
}
/**
 * Traverses children that are typically specified as `props.children`, but
 * might also be specified through attributes:
 *
 * - `traverseAllChildren(this.props.children, ...)`
 * - `traverseAllChildren(this.props.leftPanelChildren, ...)`
 *
 * The `traverseContext` is an optional argument that is passed through the
 * entire traversal. It can be used to store accumulations or anything else that
 * the callback might find relevant.
 *
 * @param {?*} children Children tree object.
 * @param {!function} callback To invoke upon traversing each child.
 * @param {?*} traverseContext Context for traversal.
 * @return {!number} The number of children in this subtree.
 */


function traverseAllChildren(children, callback, traverseContext) {
  if (children == null) {
    return 0;
  }

  return traverseAllChildrenImpl(children, '', callback, traverseContext);
}
/**
 * Generate a key string that identifies a component within a set.
 *
 * @param {*} component A component that could contain a manual key.
 * @param {number} index Index that is used if a manual key is not provided.
 * @return {string}
 */


function getComponentKey(component, index) {
  // Do some typechecking here since we call this blindly. We want to ensure
  // that we don't block potential future ES APIs.
  if (typeof component === 'object' && component !== null && component.key != null) {
    // Explicit key
    return escape(component.key);
  } // Implicit key determined by the index in the set


  return index.toString(36);
}

function forEachSingleChild(bookKeeping, child, name) {
  var func = bookKeeping.func,
      context = bookKeeping.context;
  func.call(context, child, bookKeeping.count++);
}
/**
 * Iterates through children that are typically specified as `props.children`.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrenforeach
 *
 * The provided forEachFunc(child, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} forEachFunc
 * @param {*} forEachContext Context for forEachContext.
 */


function forEachChildren(children, forEachFunc, forEachContext) {
  if (children == null) {
    return children;
  }

  var traverseContext = getPooledTraverseContext(null, null, forEachFunc, forEachContext);
  traverseAllChildren(children, forEachSingleChild, traverseContext);
  releaseTraverseContext(traverseContext);
}

function mapSingleChildIntoContext(bookKeeping, child, childKey) {
  var result = bookKeeping.result,
      keyPrefix = bookKeeping.keyPrefix,
      func = bookKeeping.func,
      context = bookKeeping.context;
  var mappedChild = func.call(context, child, bookKeeping.count++);

  if (Array.isArray(mappedChild)) {
    mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, function (c) {
      return c;
    });
  } else if (mappedChild != null) {
    if (isValidElement(mappedChild)) {
      mappedChild = cloneAndReplaceKey(mappedChild, // Keep both the (mapped) and old keys if they differ, just as
      // traverseAllChildren used to do for objects as children
      keyPrefix + (mappedChild.key && (!child || child.key !== mappedChild.key) ? escapeUserProvidedKey(mappedChild.key) + '/' : '') + childKey);
    }

    result.push(mappedChild);
  }
}

function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {
  var escapedPrefix = '';

  if (prefix != null) {
    escapedPrefix = escapeUserProvidedKey(prefix) + '/';
  }

  var traverseContext = getPooledTraverseContext(array, escapedPrefix, func, context);
  traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
  releaseTraverseContext(traverseContext);
}
/**
 * Maps children that are typically specified as `props.children`.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrenmap
 *
 * The provided mapFunction(child, key, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} func The map function.
 * @param {*} context Context for mapFunction.
 * @return {object} Object containing the ordered map of results.
 */


function mapChildren(children, func, context) {
  if (children == null) {
    return children;
  }

  var result = [];
  mapIntoWithKeyPrefixInternal(children, result, null, func, context);
  return result;
}
/**
 * Count the number of children that are typically specified as
 * `props.children`.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrencount
 *
 * @param {?*} children Children tree container.
 * @return {number} The number of children.
 */


function countChildren(children) {
  return traverseAllChildren(children, function () {
    return null;
  }, null);
}
/**
 * Flatten a children object (typically specified as `props.children`) and
 * return an array with appropriately re-keyed children.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrentoarray
 */


function toArray(children) {
  var result = [];
  mapIntoWithKeyPrefixInternal(children, result, null, function (child) {
    return child;
  });
  return result;
}
/**
 * Returns the first child in a collection of children and verifies that there
 * is only one child in the collection.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrenonly
 *
 * The current implementation of this function assumes that a single child gets
 * passed without a wrapper, but the purpose of this helper function is to
 * abstract away the particular structure of children.
 *
 * @param {?object} children Child collection structure.
 * @return {ReactElement} The first and only `ReactElement` contained in the
 * structure.
 */


function onlyChild(children) {
  if (!isValidElement(children)) {
    {
      throw Error( "React.Children.only expected to receive a single React element child." );
    }
  }

  return children;
}

function createContext(defaultValue, calculateChangedBits) {
  if (calculateChangedBits === undefined) {
    calculateChangedBits = null;
  } else {
    {
      if (calculateChangedBits !== null && typeof calculateChangedBits !== 'function') {
        error('createContext: Expected the optional second argument to be a ' + 'function. Instead received: %s', calculateChangedBits);
      }
    }
  }

  var context = {
    $$typeof: REACT_CONTEXT_TYPE,
    _calculateChangedBits: calculateChangedBits,
    // As a workaround to support multiple concurrent renderers, we categorize
    // some renderers as primary and others as secondary. We only expect
    // there to be two concurrent renderers at most: React Native (primary) and
    // Fabric (secondary); React DOM (primary) and React ART (secondary).
    // Secondary renderers store their context values on separate fields.
    _currentValue: defaultValue,
    _currentValue2: defaultValue,
    // Used to track how many concurrent renderers this context currently
    // supports within in a single renderer. Such as parallel server rendering.
    _threadCount: 0,
    // These are circular
    Provider: null,
    Consumer: null
  };
  context.Provider = {
    $$typeof: REACT_PROVIDER_TYPE,
    _context: context
  };
  var hasWarnedAboutUsingNestedContextConsumers = false;
  var hasWarnedAboutUsingConsumerProvider = false;

  {
    // A separate object, but proxies back to the original context object for
    // backwards compatibility. It has a different $$typeof, so we can properly
    // warn for the incorrect usage of Context as a Consumer.
    var Consumer = {
      $$typeof: REACT_CONTEXT_TYPE,
      _context: context,
      _calculateChangedBits: context._calculateChangedBits
    }; // $FlowFixMe: Flow complains about not setting a value, which is intentional here

    Object.defineProperties(Consumer, {
      Provider: {
        get: function () {
          if (!hasWarnedAboutUsingConsumerProvider) {
            hasWarnedAboutUsingConsumerProvider = true;

            error('Rendering <Context.Consumer.Provider> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Provider> instead?');
          }

          return context.Provider;
        },
        set: function (_Provider) {
          context.Provider = _Provider;
        }
      },
      _currentValue: {
        get: function () {
          return context._currentValue;
        },
        set: function (_currentValue) {
          context._currentValue = _currentValue;
        }
      },
      _currentValue2: {
        get: function () {
          return context._currentValue2;
        },
        set: function (_currentValue2) {
          context._currentValue2 = _currentValue2;
        }
      },
      _threadCount: {
        get: function () {
          return context._threadCount;
        },
        set: function (_threadCount) {
          context._threadCount = _threadCount;
        }
      },
      Consumer: {
        get: function () {
          if (!hasWarnedAboutUsingNestedContextConsumers) {
            hasWarnedAboutUsingNestedContextConsumers = true;

            error('Rendering <Context.Consumer.Consumer> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Consumer> instead?');
          }

          return context.Consumer;
        }
      }
    }); // $FlowFixMe: Flow complains about missing properties because it doesn't understand defineProperty

    context.Consumer = Consumer;
  }

  {
    context._currentRenderer = null;
    context._currentRenderer2 = null;
  }

  return context;
}

function lazy(ctor) {
  var lazyType = {
    $$typeof: REACT_LAZY_TYPE,
    _ctor: ctor,
    // React uses these fields to store the result.
    _status: -1,
    _result: null
  };

  {
    // In production, this would just set it on the object.
    var defaultProps;
    var propTypes;
    Object.defineProperties(lazyType, {
      defaultProps: {
        configurable: true,
        get: function () {
          return defaultProps;
        },
        set: function (newDefaultProps) {
          error('React.lazy(...): It is not supported to assign `defaultProps` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');

          defaultProps = newDefaultProps; // Match production behavior more closely:

          Object.defineProperty(lazyType, 'defaultProps', {
            enumerable: true
          });
        }
      },
      propTypes: {
        configurable: true,
        get: function () {
          return propTypes;
        },
        set: function (newPropTypes) {
          error('React.lazy(...): It is not supported to assign `propTypes` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');

          propTypes = newPropTypes; // Match production behavior more closely:

          Object.defineProperty(lazyType, 'propTypes', {
            enumerable: true
          });
        }
      }
    });
  }

  return lazyType;
}

function forwardRef(render) {
  {
    if (render != null && render.$$typeof === REACT_MEMO_TYPE) {
      error('forwardRef requires a render function but received a `memo` ' + 'component. Instead of forwardRef(memo(...)), use ' + 'memo(forwardRef(...)).');
    } else if (typeof render !== 'function') {
      error('forwardRef requires a render function but was given %s.', render === null ? 'null' : typeof render);
    } else {
      if (render.length !== 0 && render.length !== 2) {
        error('forwardRef render functions accept exactly two parameters: props and ref. %s', render.length === 1 ? 'Did you forget to use the ref parameter?' : 'Any additional parameter will be undefined.');
      }
    }

    if (render != null) {
      if (render.defaultProps != null || render.propTypes != null) {
        error('forwardRef render functions do not support propTypes or defaultProps. ' + 'Did you accidentally pass a React component?');
      }
    }
  }

  return {
    $$typeof: REACT_FORWARD_REF_TYPE,
    render: render
  };
}

function isValidElementType(type) {
  return typeof type === 'string' || typeof type === 'function' || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
  type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
}

function memo(type, compare) {
  {
    if (!isValidElementType(type)) {
      error('memo: The first argument must be a component. Instead ' + 'received: %s', type === null ? 'null' : typeof type);
    }
  }

  return {
    $$typeof: REACT_MEMO_TYPE,
    type: type,
    compare: compare === undefined ? null : compare
  };
}

function resolveDispatcher() {
  var dispatcher = ReactCurrentDispatcher.current;

  if (!(dispatcher !== null)) {
    {
      throw Error( "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://fb.me/react-invalid-hook-call for tips about how to debug and fix this problem." );
    }
  }

  return dispatcher;
}

function useContext(Context, unstable_observedBits) {
  var dispatcher = resolveDispatcher();

  {
    if (unstable_observedBits !== undefined) {
      error('useContext() second argument is reserved for future ' + 'use in React. Passing it is not supported. ' + 'You passed: %s.%s', unstable_observedBits, typeof unstable_observedBits === 'number' && Array.isArray(arguments[2]) ? '\n\nDid you call array.map(useContext)? ' + 'Calling Hooks inside a loop is not supported. ' + 'Learn more at https://fb.me/rules-of-hooks' : '');
    } // TODO: add a more generic warning for invalid values.


    if (Context._context !== undefined) {
      var realContext = Context._context; // Don't deduplicate because this legitimately causes bugs
      // and nobody should be using this in existing code.

      if (realContext.Consumer === Context) {
        error('Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be ' + 'removed in a future major release. Did you mean to call useContext(Context) instead?');
      } else if (realContext.Provider === Context) {
        error('Calling useContext(Context.Provider) is not supported. ' + 'Did you mean to call useContext(Context) instead?');
      }
    }
  }

  return dispatcher.useContext(Context, unstable_observedBits);
}
function useState(initialState) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useState(initialState);
}
function useReducer(reducer, initialArg, init) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useReducer(reducer, initialArg, init);
}
function useRef(initialValue) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useRef(initialValue);
}
function useEffect(create, deps) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useEffect(create, deps);
}
function useLayoutEffect(create, deps) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useLayoutEffect(create, deps);
}
function useCallback(callback, deps) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useCallback(callback, deps);
}
function useMemo(create, deps) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useMemo(create, deps);
}
function useImperativeHandle(ref, create, deps) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useImperativeHandle(ref, create, deps);
}
function useDebugValue(value, formatterFn) {
  {
    var dispatcher = resolveDispatcher();
    return dispatcher.useDebugValue(value, formatterFn);
  }
}

var propTypesMisspellWarningShown;

{
  propTypesMisspellWarningShown = false;
}

function getDeclarationErrorAddendum() {
  if (ReactCurrentOwner.current) {
    var name = getComponentName(ReactCurrentOwner.current.type);

    if (name) {
      return '\n\nCheck the render method of `' + name + '`.';
    }
  }

  return '';
}

function getSourceInfoErrorAddendum(source) {
  if (source !== undefined) {
    var fileName = source.fileName.replace(/^.*[\\\/]/, '');
    var lineNumber = source.lineNumber;
    return '\n\nCheck your code at ' + fileName + ':' + lineNumber + '.';
  }

  return '';
}

function getSourceInfoErrorAddendumForProps(elementProps) {
  if (elementProps !== null && elementProps !== undefined) {
    return getSourceInfoErrorAddendum(elementProps.__source);
  }

  return '';
}
/**
 * Warn if there's no key explicitly set on dynamic arrays of children or
 * object keys are not valid. This allows us to keep track of children between
 * updates.
 */


var ownerHasKeyUseWarning = {};

function getCurrentComponentErrorInfo(parentType) {
  var info = getDeclarationErrorAddendum();

  if (!info) {
    var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;

    if (parentName) {
      info = "\n\nCheck the top-level render call using <" + parentName + ">.";
    }
  }

  return info;
}
/**
 * Warn if the element doesn't have an explicit key assigned to it.
 * This element is in an array. The array could grow and shrink or be
 * reordered. All children that haven't already been validated are required to
 * have a "key" property assigned to it. Error statuses are cached so a warning
 * will only be shown once.
 *
 * @internal
 * @param {ReactElement} element Element that requires a key.
 * @param {*} parentType element's parent's type.
 */


function validateExplicitKey(element, parentType) {
  if (!element._store || element._store.validated || element.key != null) {
    return;
  }

  element._store.validated = true;
  var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);

  if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
    return;
  }

  ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a
  // property, it may be the creator of the child that's responsible for
  // assigning it a key.

  var childOwner = '';

  if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
    // Give the component that originally created this child.
    childOwner = " It was passed a child from " + getComponentName(element._owner.type) + ".";
  }

  setCurrentlyValidatingElement(element);

  {
    error('Each child in a list should have a unique "key" prop.' + '%s%s See https://fb.me/react-warning-keys for more information.', currentComponentErrorInfo, childOwner);
  }

  setCurrentlyValidatingElement(null);
}
/**
 * Ensure that every element either is passed in a static location, in an
 * array with an explicit keys property defined, or in an object literal
 * with valid key property.
 *
 * @internal
 * @param {ReactNode} node Statically passed child of any type.
 * @param {*} parentType node's parent's type.
 */


function validateChildKeys(node, parentType) {
  if (typeof node !== 'object') {
    return;
  }

  if (Array.isArray(node)) {
    for (var i = 0; i < node.length; i++) {
      var child = node[i];

      if (isValidElement(child)) {
        validateExplicitKey(child, parentType);
      }
    }
  } else if (isValidElement(node)) {
    // This element was passed in a valid location.
    if (node._store) {
      node._store.validated = true;
    }
  } else if (node) {
    var iteratorFn = getIteratorFn(node);

    if (typeof iteratorFn === 'function') {
      // Entry iterators used to provide implicit keys,
      // but now we print a separate warning for them later.
      if (iteratorFn !== node.entries) {
        var iterator = iteratorFn.call(node);
        var step;

        while (!(step = iterator.next()).done) {
          if (isValidElement(step.value)) {
            validateExplicitKey(step.value, parentType);
          }
        }
      }
    }
  }
}
/**
 * Given an element, validate that its props follow the propTypes definition,
 * provided by the type.
 *
 * @param {ReactElement} element
 */


function validatePropTypes(element) {
  {
    var type = element.type;

    if (type === null || type === undefined || typeof type === 'string') {
      return;
    }

    var name = getComponentName(type);
    var propTypes;

    if (typeof type === 'function') {
      propTypes = type.propTypes;
    } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
    // Inner props are checked in the reconciler.
    type.$$typeof === REACT_MEMO_TYPE)) {
      propTypes = type.propTypes;
    } else {
      return;
    }

    if (propTypes) {
      setCurrentlyValidatingElement(element);
      checkPropTypes(propTypes, element.props, 'prop', name, ReactDebugCurrentFrame.getStackAddendum);
      setCurrentlyValidatingElement(null);
    } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {
      propTypesMisspellWarningShown = true;

      error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', name || 'Unknown');
    }

    if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {
      error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');
    }
  }
}
/**
 * Given a fragment, validate that it can only be provided with fragment props
 * @param {ReactElement} fragment
 */


function validateFragmentProps(fragment) {
  {
    setCurrentlyValidatingElement(fragment);
    var keys = Object.keys(fragment.props);

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];

      if (key !== 'children' && key !== 'key') {
        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);

        break;
      }
    }

    if (fragment.ref !== null) {
      error('Invalid attribute `ref` supplied to `React.Fragment`.');
    }

    setCurrentlyValidatingElement(null);
  }
}
function createElementWithValidation(type, props, children) {
  var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to
  // succeed and there will likely be errors in render.

  if (!validType) {
    var info = '';

    if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
      info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and named imports.";
    }

    var sourceInfo = getSourceInfoErrorAddendumForProps(props);

    if (sourceInfo) {
      info += sourceInfo;
    } else {
      info += getDeclarationErrorAddendum();
    }

    var typeString;

    if (type === null) {
      typeString = 'null';
    } else if (Array.isArray(type)) {
      typeString = 'array';
    } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {
      typeString = "<" + (getComponentName(type.type) || 'Unknown') + " />";
      info = ' Did you accidentally export a JSX literal instead of a component?';
    } else {
      typeString = typeof type;
    }

    {
      error('React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);
    }
  }

  var element = createElement.apply(this, arguments); // The result can be nullish if a mock or a custom function is used.
  // TODO: Drop this when these are no longer allowed as the type argument.

  if (element == null) {
    return element;
  } // Skip key warning if the type isn't valid since our key validation logic
  // doesn't expect a non-string/function type and can throw confusing errors.
  // We don't want exception behavior to differ between dev and prod.
  // (Rendering will throw with a helpful message and as soon as the type is
  // fixed, the key warnings will appear.)


  if (validType) {
    for (var i = 2; i < arguments.length; i++) {
      validateChildKeys(arguments[i], type);
    }
  }

  if (type === REACT_FRAGMENT_TYPE) {
    validateFragmentProps(element);
  } else {
    validatePropTypes(element);
  }

  return element;
}
var didWarnAboutDeprecatedCreateFactory = false;
function createFactoryWithValidation(type) {
  var validatedFactory = createElementWithValidation.bind(null, type);
  validatedFactory.type = type;

  {
    if (!didWarnAboutDeprecatedCreateFactory) {
      didWarnAboutDeprecatedCreateFactory = true;

      warn('React.createFactory() is deprecated and will be removed in ' + 'a future major release. Consider using JSX ' + 'or use React.createElement() directly instead.');
    } // Legacy hook: remove it


    Object.defineProperty(validatedFactory, 'type', {
      enumerable: false,
      get: function () {
        warn('Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.');

        Object.defineProperty(this, 'type', {
          value: type
        });
        return type;
      }
    });
  }

  return validatedFactory;
}
function cloneElementWithValidation(element, props, children) {
  var newElement = cloneElement.apply(this, arguments);

  for (var i = 2; i < arguments.length; i++) {
    validateChildKeys(arguments[i], newElement.type);
  }

  validatePropTypes(newElement);
  return newElement;
}

{

  try {
    var frozenObject = Object.freeze({});
    var testMap = new Map([[frozenObject, null]]);
    var testSet = new Set([frozenObject]); // This is necessary for Rollup to not consider these unused.
    // https://github.com/rollup/rollup/issues/1771
    // TODO: we can remove these if Rollup fixes the bug.

    testMap.set(0, 0);
    testSet.add(0);
  } catch (e) {
  }
}

var createElement$1 =  createElementWithValidation ;
var cloneElement$1 =  cloneElementWithValidation ;
var createFactory =  createFactoryWithValidation ;
var Children = {
  map: mapChildren,
  forEach: forEachChildren,
  count: countChildren,
  toArray: toArray,
  only: onlyChild
};

exports.Children = Children;
exports.Component = Component;
exports.Fragment = REACT_FRAGMENT_TYPE;
exports.Profiler = REACT_PROFILER_TYPE;
exports.PureComponent = PureComponent;
exports.StrictMode = REACT_STRICT_MODE_TYPE;
exports.Suspense = REACT_SUSPENSE_TYPE;
exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;
exports.cloneElement = cloneElement$1;
exports.createContext = createContext;
exports.createElement = createElement$1;
exports.createFactory = createFactory;
exports.createRef = createRef;
exports.forwardRef = forwardRef;
exports.isValidElement = isValidElement;
exports.lazy = lazy;
exports.memo = memo;
exports.useCallback = useCallback;
exports.useContext = useContext;
exports.useDebugValue = useDebugValue;
exports.useEffect = useEffect;
exports.useImperativeHandle = useImperativeHandle;
exports.useLayoutEffect = useLayoutEffect;
exports.useMemo = useMemo;
exports.useReducer = useReducer;
exports.useRef = useRef;
exports.useState = useState;
exports.version = ReactVersion;
  })();
}


/***/ }),

/***/ "./node_modules/react/index.js":
/*!*************************************!*\
  !*** ./node_modules/react/index.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/react.development.js */ "./node_modules/react/cjs/react.development.js");
}


/***/ }),

/***/ "./node_modules/regenerator-runtime/runtime.js":
/*!*****************************************************!*\
  !*** ./node_modules/regenerator-runtime/runtime.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var runtime = (function (exports) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function define(obj, key, value) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
    return obj[key];
  }
  try {
    // IE 8 has a broken Object.defineProperty that only works on DOM objects.
    define({}, "");
  } catch (err) {
    define = function(obj, key, value) {
      return obj[key] = value;
    };
  }

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  exports.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunction.displayName = define(
    GeneratorFunctionPrototype,
    toStringTagSymbol,
    "GeneratorFunction"
  );

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      define(prototype, method, function(arg) {
        return this._invoke(method, arg);
      });
    });
  }

  exports.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  exports.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      define(genFun, toStringTagSymbol, "GeneratorFunction");
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  exports.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return PromiseImpl.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return PromiseImpl.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  exports.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    if (PromiseImpl === void 0) PromiseImpl = Promise;

    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList),
      PromiseImpl
    );

    return exports.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  define(Gp, toStringTagSymbol, "Generator");

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  exports.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };

  // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.
  return exports;

}(
  // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
   true ? module.exports : undefined
));

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  Function("r", "regeneratorRuntime = r")(runtime);
}


/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isOldIE = function isOldIE() {
  var memo;
  return function memorize() {
    if (typeof memo === 'undefined') {
      // Test for IE <= 9 as proposed by Browserhacks
      // @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
      // Tests for existence of standard globals is to allow style-loader
      // to operate correctly into non-standard environments
      // @see https://github.com/webpack-contrib/style-loader/issues/177
      memo = Boolean(window && document && document.all && !window.atob);
    }

    return memo;
  };
}();

var getTarget = function getTarget() {
  var memo = {};
  return function memorize(target) {
    if (typeof memo[target] === 'undefined') {
      var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself

      if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
        try {
          // This will throw an exception if access to iframe is blocked
          // due to cross-origin restrictions
          styleTarget = styleTarget.contentDocument.head;
        } catch (e) {
          // istanbul ignore next
          styleTarget = null;
        }
      }

      memo[target] = styleTarget;
    }

    return memo[target];
  };
}();

var stylesInDom = [];

function getIndexByIdentifier(identifier) {
  var result = -1;

  for (var i = 0; i < stylesInDom.length; i++) {
    if (stylesInDom[i].identifier === identifier) {
      result = i;
      break;
    }
  }

  return result;
}

function modulesToDom(list, options) {
  var idCountMap = {};
  var identifiers = [];

  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = options.base ? item[0] + options.base : item[0];
    var count = idCountMap[id] || 0;
    var identifier = "".concat(id, " ").concat(count);
    idCountMap[id] = count + 1;
    var index = getIndexByIdentifier(identifier);
    var obj = {
      css: item[1],
      media: item[2],
      sourceMap: item[3]
    };

    if (index !== -1) {
      stylesInDom[index].references++;
      stylesInDom[index].updater(obj);
    } else {
      stylesInDom.push({
        identifier: identifier,
        updater: addStyle(obj, options),
        references: 1
      });
    }

    identifiers.push(identifier);
  }

  return identifiers;
}

function insertStyleElement(options) {
  var style = document.createElement('style');
  var attributes = options.attributes || {};

  if (typeof attributes.nonce === 'undefined') {
    var nonce =  true ? __webpack_require__.nc : undefined;

    if (nonce) {
      attributes.nonce = nonce;
    }
  }

  Object.keys(attributes).forEach(function (key) {
    style.setAttribute(key, attributes[key]);
  });

  if (typeof options.insert === 'function') {
    options.insert(style);
  } else {
    var target = getTarget(options.insert || 'head');

    if (!target) {
      throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
    }

    target.appendChild(style);
  }

  return style;
}

function removeStyleElement(style) {
  // istanbul ignore if
  if (style.parentNode === null) {
    return false;
  }

  style.parentNode.removeChild(style);
}
/* istanbul ignore next  */


var replaceText = function replaceText() {
  var textStore = [];
  return function replace(index, replacement) {
    textStore[index] = replacement;
    return textStore.filter(Boolean).join('\n');
  };
}();

function applyToSingletonTag(style, index, remove, obj) {
  var css = remove ? '' : obj.media ? "@media ".concat(obj.media, " {").concat(obj.css, "}") : obj.css; // For old IE

  /* istanbul ignore if  */

  if (style.styleSheet) {
    style.styleSheet.cssText = replaceText(index, css);
  } else {
    var cssNode = document.createTextNode(css);
    var childNodes = style.childNodes;

    if (childNodes[index]) {
      style.removeChild(childNodes[index]);
    }

    if (childNodes.length) {
      style.insertBefore(cssNode, childNodes[index]);
    } else {
      style.appendChild(cssNode);
    }
  }
}

function applyToTag(style, options, obj) {
  var css = obj.css;
  var media = obj.media;
  var sourceMap = obj.sourceMap;

  if (media) {
    style.setAttribute('media', media);
  } else {
    style.removeAttribute('media');
  }

  if (sourceMap && btoa) {
    css += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");
  } // For old IE

  /* istanbul ignore if  */


  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    while (style.firstChild) {
      style.removeChild(style.firstChild);
    }

    style.appendChild(document.createTextNode(css));
  }
}

var singleton = null;
var singletonCounter = 0;

function addStyle(obj, options) {
  var style;
  var update;
  var remove;

  if (options.singleton) {
    var styleIndex = singletonCounter++;
    style = singleton || (singleton = insertStyleElement(options));
    update = applyToSingletonTag.bind(null, style, styleIndex, false);
    remove = applyToSingletonTag.bind(null, style, styleIndex, true);
  } else {
    style = insertStyleElement(options);
    update = applyToTag.bind(null, style, options);

    remove = function remove() {
      removeStyleElement(style);
    };
  }

  update(obj);
  return function updateStyle(newObj) {
    if (newObj) {
      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {
        return;
      }

      update(obj = newObj);
    } else {
      remove();
    }
  };
}

module.exports = function (list, options) {
  options = options || {}; // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
  // tags it will allow on a page

  if (!options.singleton && typeof options.singleton !== 'boolean') {
    options.singleton = isOldIE();
  }

  list = list || [];
  var lastIdentifiers = modulesToDom(list, options);
  return function update(newList) {
    newList = newList || [];

    if (Object.prototype.toString.call(newList) !== '[object Array]') {
      return;
    }

    for (var i = 0; i < lastIdentifiers.length; i++) {
      var identifier = lastIdentifiers[i];
      var index = getIndexByIdentifier(identifier);
      stylesInDom[index].references--;
    }

    var newLastIdentifiers = modulesToDom(newList, options);

    for (var _i = 0; _i < lastIdentifiers.length; _i++) {
      var _identifier = lastIdentifiers[_i];

      var _index = getIndexByIdentifier(_identifier);

      if (stylesInDom[_index].references === 0) {
        stylesInDom[_index].updater();

        stylesInDom.splice(_index, 1);
      }
    }

    lastIdentifiers = newLastIdentifiers;
  };
};

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./node_modules/webpack/buildin/harmony-module.js":
/*!*******************************************!*\
  !*** (webpack)/buildin/harmony-module.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function(originalModule) {
	if (!originalModule.webpackPolyfill) {
		var module = Object.create(originalModule);
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		Object.defineProperty(module, "exports", {
			enumerable: true
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function(module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),

/***/ "./pages/_app.js":
/*!***********************!*\
  !*** ./pages/_app.js ***!
  \***********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var _www_shared_styles_global_index_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../www/shared/styles/global/index.css */ "./www/shared/styles/global/index.css");
/* harmony import */ var _www_shared_styles_global_index_css__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_www_shared_styles_global_index_css__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _www_app__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../www/app */ "./www/app/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _www_app__WEBPACK_IMPORTED_MODULE_1__["default"]; });




;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./www/app/App.js":
/*!************************!*\
  !*** ./www/app/App.js ***!
  \************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ "./node_modules/@babel/runtime/helpers/esm/extends.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! next/head */ "./node_modules/next/dist/next-server/lib/head.js");
/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(next_head__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _shared_components_layout__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../shared/components/layout */ "./www/shared/components/layout/index.js");
/* harmony import */ var _shared_media_favicons_favicon_ico__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../shared/media/favicons/favicon.ico */ "./www/shared/media/favicons/favicon.ico");

var _jsxFileName = "C:\\Users\\paulo\\Desktop\\Work\\Projects\\Personal\\Web\\paulobmarcos\\www\\app\\App.js";
var __jsx = react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement;






const App = ({
  Component,
  pageProps
}) => __jsx(react__WEBPACK_IMPORTED_MODULE_1___default.a.Fragment, null, __jsx(next_head__WEBPACK_IMPORTED_MODULE_3___default.a, {
  __self: undefined,
  __source: {
    fileName: _jsxFileName,
    lineNumber: 10,
    columnNumber: 5
  }
}, __jsx("title", {
  __self: undefined,
  __source: {
    fileName: _jsxFileName,
    lineNumber: 11,
    columnNumber: 7
  }
}, "Next Boilerplate"), __jsx("link", {
  rel: "shortcut icon",
  type: "image/x-icon",
  href: _shared_media_favicons_favicon_ico__WEBPACK_IMPORTED_MODULE_5__["default"],
  __self: undefined,
  __source: {
    fileName: _jsxFileName,
    lineNumber: 12,
    columnNumber: 7
  }
})), __jsx(_shared_components_layout__WEBPACK_IMPORTED_MODULE_4__["default"], {
  __self: undefined,
  __source: {
    fileName: _jsxFileName,
    lineNumber: 14,
    columnNumber: 5
  }
}, __jsx(Component, Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, pageProps, {
  __self: undefined,
  __source: {
    fileName: _jsxFileName,
    lineNumber: 15,
    columnNumber: 7
  }
}))));

_c = App;
App.propTypes = {
  Component: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.elementType.isRequired,
  pageProps: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.object.isRequired
};
/* harmony default export */ __webpack_exports__["default"] = (App);

var _c;

$RefreshReg$(_c, "App");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./www/app/index.js":
/*!**************************!*\
  !*** ./www/app/index.js ***!
  \**************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var _App__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./App */ "./www/app/App.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _App__WEBPACK_IMPORTED_MODULE_0__["default"]; });



;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./www/shared/components/grain/Grain.js":
/*!**********************************************!*\
  !*** ./www/shared/components/grain/Grain.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! classnames */ "./node_modules/classnames/index.js");
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(classnames__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _utils_browsers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../utils/browsers */ "./www/shared/utils/browsers.js");
/* harmony import */ var _Grain_module_css__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Grain.module.css */ "./www/shared/components/grain/Grain.module.css");
/* harmony import */ var _Grain_module_css__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_Grain_module_css__WEBPACK_IMPORTED_MODULE_4__);
var _jsxFileName = "C:\\Users\\paulo\\Desktop\\Work\\Projects\\Personal\\Web\\paulobmarcos\\www\\shared\\components\\grain\\Grain.js",
    _s = $RefreshSig$();

var __jsx = react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement;






const Grain = ({
  className
}) => {
  _s();

  const _useState = Object(react__WEBPACK_IMPORTED_MODULE_0__["useState"])(0),
        zIndex = _useState[0],
        setZIndex = _useState[1];

  Object(react__WEBPACK_IMPORTED_MODULE_0__["useEffect"])(() => {
    setZIndex(_utils_browsers__WEBPACK_IMPORTED_MODULE_3__["default"].isSafari() ? -1 : 0);
  }, [setZIndex]);
  return __jsx("div", {
    className: classnames__WEBPACK_IMPORTED_MODULE_2___default()(_Grain_module_css__WEBPACK_IMPORTED_MODULE_4___default.a.grain, className),
    style: {
      zIndex
    },
    __self: undefined,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 16,
      columnNumber: 5
    }
  });
};

_s(Grain, "ryM9d2m96LOq/8EqfCFFs90WAw8=");

_c = Grain;
Grain.propTypes = {
  className: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string
};
/* harmony default export */ __webpack_exports__["default"] = (Grain);

var _c;

$RefreshReg$(_c, "Grain");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./www/shared/components/grain/Grain.module.css":
/*!******************************************************!*\
  !*** ./www/shared/components/grain/Grain.module.css ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var api = __webpack_require__(/*! ../../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
            var content = __webpack_require__(/*! !../../../../node_modules/css-loader/dist/cjs.js??ref--5-oneOf-2-1!../../../../node_modules/next/dist/compiled/postcss-loader??__nextjs_postcss!./Grain.module.css */ "./node_modules/css-loader/dist/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/index.js?!./www/shared/components/grain/Grain.module.css");

            content = content.__esModule ? content.default : content;

            if (typeof content === 'string') {
              content = [[module.i, content, '']];
            }

var options = {};

options.insert = function(element){// These elements should always exist. If they do not,
// this code should fail.
var anchorElement=document.querySelector('#__next_css__DO_NOT_USE__');var parentNode=anchorElement.parentNode;// Normally <head>
// Each style tag should be placed right before our
// anchor. By inserting before and not after, we do not
// need to track the last inserted element.
parentNode.insertBefore(element,anchorElement);};
options.singleton = false;

var update = api(content, options);


if (true) {
  if (!content.locals || module.hot.invalidate) {
    var isEqualLocals = function isEqualLocals(a, b) {
  if (!a && b || a && !b) {
    return false;
  }

  var p;

  for (p in a) {
    if (a[p] !== b[p]) {
      return false;
    }
  }

  for (p in b) {
    if (!a[p]) {
      return false;
    }
  }

  return true;
};
    var oldLocals = content.locals;

    module.hot.accept(
      /*! !../../../../node_modules/css-loader/dist/cjs.js??ref--5-oneOf-2-1!../../../../node_modules/next/dist/compiled/postcss-loader??__nextjs_postcss!./Grain.module.css */ "./node_modules/css-loader/dist/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/index.js?!./www/shared/components/grain/Grain.module.css",
      function () {
        content = __webpack_require__(/*! !../../../../node_modules/css-loader/dist/cjs.js??ref--5-oneOf-2-1!../../../../node_modules/next/dist/compiled/postcss-loader??__nextjs_postcss!./Grain.module.css */ "./node_modules/css-loader/dist/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/index.js?!./www/shared/components/grain/Grain.module.css");

              content = content.__esModule ? content.default : content;

              if (typeof content === 'string') {
                content = [[module.i, content, '']];
              }

              if (!isEqualLocals(oldLocals, content.locals)) {
                module.hot.invalidate();

                return;
              }

              oldLocals = content.locals;

              update(content);
      }
    )
  }

  module.hot.dispose(function() {
    update();
  });
}

module.exports = content.locals || {};

/***/ }),

/***/ "./www/shared/components/grain/index.js":
/*!**********************************************!*\
  !*** ./www/shared/components/grain/index.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var _Grain__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Grain */ "./www/shared/components/grain/Grain.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _Grain__WEBPACK_IMPORTED_MODULE_0__["default"]; });



;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./www/shared/components/header/Header.js":
/*!************************************************!*\
  !*** ./www/shared/components/header/Header.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _moxy_next_link__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @moxy/next-link */ "./node_modules/@moxy/next-link/es/index.js");
/* harmony import */ var _link__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../link */ "./www/shared/components/link/index.js");
/* harmony import */ var _icons__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../icons */ "./www/shared/components/icons/index.js");
/* harmony import */ var _Header_module_css__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Header.module.css */ "./www/shared/components/header/Header.module.css");
/* harmony import */ var _Header_module_css__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_Header_module_css__WEBPACK_IMPORTED_MODULE_4__);
var _jsxFileName = "C:\\Users\\paulo\\Desktop\\Work\\Projects\\Personal\\Web\\paulobmarcos\\www\\shared\\components\\header\\Header.js";
var __jsx = react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement;






const Header = () => __jsx("header", {
  className: _Header_module_css__WEBPACK_IMPORTED_MODULE_4___default.a.header,
  __self: undefined,
  __source: {
    fileName: _jsxFileName,
    lineNumber: 9,
    columnNumber: 3
  }
}, __jsx("div", {
  className: _Header_module_css__WEBPACK_IMPORTED_MODULE_4___default.a.content,
  __self: undefined,
  __source: {
    fileName: _jsxFileName,
    lineNumber: 10,
    columnNumber: 5
  }
}, __jsx("div", {
  className: _Header_module_css__WEBPACK_IMPORTED_MODULE_4___default.a.name,
  __self: undefined,
  __source: {
    fileName: _jsxFileName,
    lineNumber: 11,
    columnNumber: 7
  }
}, __jsx(_link__WEBPACK_IMPORTED_MODULE_2__["default"], {
  external: true,
  href: "#hero",
  "data-headerlink": "paulo",
  __self: undefined,
  __source: {
    fileName: _jsxFileName,
    lineNumber: 12,
    columnNumber: 9
  }
}, __jsx("b", {
  __self: undefined,
  __source: {
    fileName: _jsxFileName,
    lineNumber: 13,
    columnNumber: 11
  }
}, "Paulo"), " Marcos")), __jsx("div", {
  className: _Header_module_css__WEBPACK_IMPORTED_MODULE_4___default.a.links,
  __self: undefined,
  __source: {
    fileName: _jsxFileName,
    lineNumber: 16,
    columnNumber: 7
  }
}, __jsx(_link__WEBPACK_IMPORTED_MODULE_2__["default"], {
  external: true,
  href: "#expertise",
  "data-headerlink": "expertise",
  __self: undefined,
  __source: {
    fileName: _jsxFileName,
    lineNumber: 17,
    columnNumber: 9
  }
}, "Expertise"), __jsx(_link__WEBPACK_IMPORTED_MODULE_2__["default"], {
  external: true,
  href: "#experience",
  "data-headerlink": "experience",
  __self: undefined,
  __source: {
    fileName: _jsxFileName,
    lineNumber: 18,
    columnNumber: 9
  }
}, "Experience"), __jsx(_link__WEBPACK_IMPORTED_MODULE_2__["default"], {
  external: true,
  href: "#portfolio",
  "data-headerlink": "portfolio",
  __self: undefined,
  __source: {
    fileName: _jsxFileName,
    lineNumber: 19,
    columnNumber: 9
  }
}, "Portfolio"), __jsx(_link__WEBPACK_IMPORTED_MODULE_2__["default"], {
  external: true,
  href: "#contacts",
  "data-headerlink": "contacts",
  __self: undefined,
  __source: {
    fileName: _jsxFileName,
    lineNumber: 20,
    columnNumber: 9
  }
}, "Contacts")), __jsx("div", {
  className: _Header_module_css__WEBPACK_IMPORTED_MODULE_4___default.a.social,
  __self: undefined,
  __source: {
    fileName: _jsxFileName,
    lineNumber: 22,
    columnNumber: 7
  }
}, __jsx(_moxy_next_link__WEBPACK_IMPORTED_MODULE_1__["default"], {
  external: true,
  newTab: true,
  href: "https://github.com/paulobmarcos",
  __self: undefined,
  __source: {
    fileName: _jsxFileName,
    lineNumber: 23,
    columnNumber: 9
  }
}, __jsx(_icons__WEBPACK_IMPORTED_MODULE_3__["GithubIcon"], {
  __self: undefined,
  __source: {
    fileName: _jsxFileName,
    lineNumber: 23,
    columnNumber: 74
  }
})), __jsx(_moxy_next_link__WEBPACK_IMPORTED_MODULE_1__["default"], {
  external: true,
  newTab: true,
  href: "https://www.linkedin.com/in/paulobmarcos",
  __self: undefined,
  __source: {
    fileName: _jsxFileName,
    lineNumber: 24,
    columnNumber: 9
  }
}, __jsx(_icons__WEBPACK_IMPORTED_MODULE_3__["LinkedinIcon"], {
  __self: undefined,
  __source: {
    fileName: _jsxFileName,
    lineNumber: 24,
    columnNumber: 83
  }
})))));

_c = Header;
Header.propTypes = {};
/* harmony default export */ __webpack_exports__["default"] = (Header);

var _c;

$RefreshReg$(_c, "Header");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./www/shared/components/header/Header.module.css":
/*!********************************************************!*\
  !*** ./www/shared/components/header/Header.module.css ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var api = __webpack_require__(/*! ../../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
            var content = __webpack_require__(/*! !../../../../node_modules/css-loader/dist/cjs.js??ref--5-oneOf-2-1!../../../../node_modules/next/dist/compiled/postcss-loader??__nextjs_postcss!./Header.module.css */ "./node_modules/css-loader/dist/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/index.js?!./www/shared/components/header/Header.module.css");

            content = content.__esModule ? content.default : content;

            if (typeof content === 'string') {
              content = [[module.i, content, '']];
            }

var options = {};

options.insert = function(element){// These elements should always exist. If they do not,
// this code should fail.
var anchorElement=document.querySelector('#__next_css__DO_NOT_USE__');var parentNode=anchorElement.parentNode;// Normally <head>
// Each style tag should be placed right before our
// anchor. By inserting before and not after, we do not
// need to track the last inserted element.
parentNode.insertBefore(element,anchorElement);};
options.singleton = false;

var update = api(content, options);


if (true) {
  if (!content.locals || module.hot.invalidate) {
    var isEqualLocals = function isEqualLocals(a, b) {
  if (!a && b || a && !b) {
    return false;
  }

  var p;

  for (p in a) {
    if (a[p] !== b[p]) {
      return false;
    }
  }

  for (p in b) {
    if (!a[p]) {
      return false;
    }
  }

  return true;
};
    var oldLocals = content.locals;

    module.hot.accept(
      /*! !../../../../node_modules/css-loader/dist/cjs.js??ref--5-oneOf-2-1!../../../../node_modules/next/dist/compiled/postcss-loader??__nextjs_postcss!./Header.module.css */ "./node_modules/css-loader/dist/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/index.js?!./www/shared/components/header/Header.module.css",
      function () {
        content = __webpack_require__(/*! !../../../../node_modules/css-loader/dist/cjs.js??ref--5-oneOf-2-1!../../../../node_modules/next/dist/compiled/postcss-loader??__nextjs_postcss!./Header.module.css */ "./node_modules/css-loader/dist/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/index.js?!./www/shared/components/header/Header.module.css");

              content = content.__esModule ? content.default : content;

              if (typeof content === 'string') {
                content = [[module.i, content, '']];
              }

              if (!isEqualLocals(oldLocals, content.locals)) {
                module.hot.invalidate();

                return;
              }

              oldLocals = content.locals;

              update(content);
      }
    )
  }

  module.hot.dispose(function() {
    update();
  });
}

module.exports = content.locals || {};

/***/ }),

/***/ "./www/shared/components/header/index.js":
/*!***********************************************!*\
  !*** ./www/shared/components/header/index.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var _Header__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Header */ "./www/shared/components/header/Header.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _Header__WEBPACK_IMPORTED_MODULE_0__["default"]; });



;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./www/shared/components/icons/index.js":
/*!**********************************************!*\
  !*** ./www/shared/components/icons/index.js ***!
  \**********************************************/
/*! exports provided: ArrowLeftIcon, ArrowRightIcon, CvIcon, GithubIcon, LinkedinIcon, MailIcon */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ArrowLeftIcon", function() { return ArrowLeftIcon; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ArrowRightIcon", function() { return ArrowRightIcon; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CvIcon", function() { return CvIcon; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GithubIcon", function() { return GithubIcon; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinkedinIcon", function() { return LinkedinIcon; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MailIcon", function() { return MailIcon; });
/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ "./node_modules/@babel/runtime/helpers/esm/extends.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var react_inlinesvg__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-inlinesvg */ "./node_modules/react-inlinesvg/esm/index.js");
/* harmony import */ var _media_svgs_arrow_left_svg__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../media/svgs/arrow-left.svg */ "./www/shared/media/svgs/arrow-left.svg");
/* harmony import */ var _media_svgs_arrow_left_svg__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_media_svgs_arrow_left_svg__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _media_svgs_arrow_right_svg__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../media/svgs/arrow-right.svg */ "./www/shared/media/svgs/arrow-right.svg");
/* harmony import */ var _media_svgs_arrow_right_svg__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_media_svgs_arrow_right_svg__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _media_svgs_cv_svg__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../media/svgs/cv.svg */ "./www/shared/media/svgs/cv.svg");
/* harmony import */ var _media_svgs_cv_svg__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_media_svgs_cv_svg__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _media_svgs_github_svg__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../media/svgs/github.svg */ "./www/shared/media/svgs/github.svg");
/* harmony import */ var _media_svgs_github_svg__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_media_svgs_github_svg__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _media_svgs_linkedin_svg__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../media/svgs/linkedin.svg */ "./www/shared/media/svgs/linkedin.svg");
/* harmony import */ var _media_svgs_linkedin_svg__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_media_svgs_linkedin_svg__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var _media_svgs_mail_svg__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../media/svgs/mail.svg */ "./www/shared/media/svgs/mail.svg");
/* harmony import */ var _media_svgs_mail_svg__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(_media_svgs_mail_svg__WEBPACK_IMPORTED_MODULE_8__);

var _jsxFileName = "C:\\Users\\paulo\\Desktop\\Work\\Projects\\Personal\\Web\\paulobmarcos\\www\\shared\\components\\icons\\index.js";
var __jsx = react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement;









const ArrowLeftIcon = props => __jsx(react_inlinesvg__WEBPACK_IMPORTED_MODULE_2__["default"], Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, props, {
  src: _media_svgs_arrow_left_svg__WEBPACK_IMPORTED_MODULE_3___default.a,
  __self: undefined,
  __source: {
    fileName: _jsxFileName,
    lineNumber: 11,
    columnNumber: 34
  }
}));

_c = ArrowLeftIcon;

const ArrowRightIcon = props => __jsx(react_inlinesvg__WEBPACK_IMPORTED_MODULE_2__["default"], Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, props, {
  src: _media_svgs_arrow_right_svg__WEBPACK_IMPORTED_MODULE_4___default.a,
  __self: undefined,
  __source: {
    fileName: _jsxFileName,
    lineNumber: 12,
    columnNumber: 35
  }
}));

_c2 = ArrowRightIcon;

const CvIcon = props => __jsx(react_inlinesvg__WEBPACK_IMPORTED_MODULE_2__["default"], Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, props, {
  src: _media_svgs_cv_svg__WEBPACK_IMPORTED_MODULE_5___default.a,
  __self: undefined,
  __source: {
    fileName: _jsxFileName,
    lineNumber: 13,
    columnNumber: 27
  }
}));

_c3 = CvIcon;

const GithubIcon = props => __jsx(react_inlinesvg__WEBPACK_IMPORTED_MODULE_2__["default"], Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, props, {
  src: _media_svgs_github_svg__WEBPACK_IMPORTED_MODULE_6___default.a,
  __self: undefined,
  __source: {
    fileName: _jsxFileName,
    lineNumber: 14,
    columnNumber: 31
  }
}));

_c4 = GithubIcon;

const LinkedinIcon = props => __jsx(react_inlinesvg__WEBPACK_IMPORTED_MODULE_2__["default"], Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, props, {
  src: _media_svgs_linkedin_svg__WEBPACK_IMPORTED_MODULE_7___default.a,
  __self: undefined,
  __source: {
    fileName: _jsxFileName,
    lineNumber: 15,
    columnNumber: 33
  }
}));

_c5 = LinkedinIcon;

const MailIcon = props => __jsx(react_inlinesvg__WEBPACK_IMPORTED_MODULE_2__["default"], Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, props, {
  src: _media_svgs_mail_svg__WEBPACK_IMPORTED_MODULE_8___default.a,
  __self: undefined,
  __source: {
    fileName: _jsxFileName,
    lineNumber: 16,
    columnNumber: 29
  }
}));

_c6 = MailIcon;


var _c, _c2, _c3, _c4, _c5, _c6;

$RefreshReg$(_c, "ArrowLeftIcon");
$RefreshReg$(_c2, "ArrowRightIcon");
$RefreshReg$(_c3, "CvIcon");
$RefreshReg$(_c4, "GithubIcon");
$RefreshReg$(_c5, "LinkedinIcon");
$RefreshReg$(_c6, "MailIcon");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./www/shared/components/layout/Layout.js":
/*!************************************************!*\
  !*** ./www/shared/components/layout/Layout.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _grain__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../grain */ "./www/shared/components/grain/index.js");
/* harmony import */ var _header__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../header */ "./www/shared/components/header/index.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../utils */ "./www/shared/utils/index.js");
/* harmony import */ var _Layout_module_css__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Layout.module.css */ "./www/shared/components/layout/Layout.module.css");
/* harmony import */ var _Layout_module_css__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_Layout_module_css__WEBPACK_IMPORTED_MODULE_5__);
var _jsxFileName = "C:\\Users\\paulo\\Desktop\\Work\\Projects\\Personal\\Web\\paulobmarcos\\www\\shared\\components\\layout\\Layout.js",
    _s = $RefreshSig$();

var __jsx = react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement;







const Layout = ({
  children
}) => {
  _s();

  const contentRef = Object(react__WEBPACK_IMPORTED_MODULE_0__["useRef"])();
  const progressRef = Object(react__WEBPACK_IMPORTED_MODULE_0__["useRef"])();
  const percentageRef = Object(react__WEBPACK_IMPORTED_MODULE_0__["useRef"])();
  const handleScroll = Object(react__WEBPACK_IMPORTED_MODULE_0__["useCallback"])(() => {
    const _contentRef$current = contentRef.current,
          clientHeight = _contentRef$current.clientHeight,
          scrollHeight = _contentRef$current.scrollHeight,
          scrollTop = _contentRef$current.scrollTop;
    const percentage = (clientHeight + scrollTop) / scrollHeight;
    Object(_utils__WEBPACK_IMPORTED_MODULE_4__["changeStyle"])(percentageRef.current, 'transform', "scaleY(".concat(percentage, ")"));
  }, []);
  Object(react__WEBPACK_IMPORTED_MODULE_0__["useEffect"])(() => {
    const content = contentRef.current;
    content.addEventListener('scroll', handleScroll, {
      passive: true
    });
    handleScroll();
    return () => {
      content.removeEventListener('scroll', handleScroll, {
        passive: true
      });
    };
  }, [handleScroll]);
  return __jsx("div", {
    className: _Layout_module_css__WEBPACK_IMPORTED_MODULE_5___default.a.layout,
    __self: undefined,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 34,
      columnNumber: 5
    }
  }, __jsx(_grain__WEBPACK_IMPORTED_MODULE_2__["default"], {
    className: _Layout_module_css__WEBPACK_IMPORTED_MODULE_5___default.a.grain,
    __self: undefined,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 35,
      columnNumber: 7
    }
  }), __jsx("div", {
    className: _Layout_module_css__WEBPACK_IMPORTED_MODULE_5___default.a.frame,
    __self: undefined,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 36,
      columnNumber: 7
    }
  }), __jsx("div", {
    ref: progressRef,
    className: _Layout_module_css__WEBPACK_IMPORTED_MODULE_5___default.a.progress,
    __self: undefined,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 37,
      columnNumber: 7
    }
  }, __jsx("div", {
    ref: percentageRef,
    className: _Layout_module_css__WEBPACK_IMPORTED_MODULE_5___default.a.percentage,
    __self: undefined,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 38,
      columnNumber: 9
    }
  })), __jsx("div", {
    id: "layoutContent",
    ref: contentRef,
    className: _Layout_module_css__WEBPACK_IMPORTED_MODULE_5___default.a.content,
    __self: undefined,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 40,
      columnNumber: 7
    }
  }, __jsx(_header__WEBPACK_IMPORTED_MODULE_3__["default"], {
    __self: undefined,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 44,
      columnNumber: 9
    }
  }), children));
};

_s(Layout, "APPHt3OMqZyUKJ6wmynoRSq6Xxg=");

_c = Layout;
Layout.propTypes = {
  children: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.any
};
/* harmony default export */ __webpack_exports__["default"] = (Layout);

var _c;

$RefreshReg$(_c, "Layout");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./www/shared/components/layout/Layout.module.css":
/*!********************************************************!*\
  !*** ./www/shared/components/layout/Layout.module.css ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var api = __webpack_require__(/*! ../../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
            var content = __webpack_require__(/*! !../../../../node_modules/css-loader/dist/cjs.js??ref--5-oneOf-2-1!../../../../node_modules/next/dist/compiled/postcss-loader??__nextjs_postcss!./Layout.module.css */ "./node_modules/css-loader/dist/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/index.js?!./www/shared/components/layout/Layout.module.css");

            content = content.__esModule ? content.default : content;

            if (typeof content === 'string') {
              content = [[module.i, content, '']];
            }

var options = {};

options.insert = function(element){// These elements should always exist. If they do not,
// this code should fail.
var anchorElement=document.querySelector('#__next_css__DO_NOT_USE__');var parentNode=anchorElement.parentNode;// Normally <head>
// Each style tag should be placed right before our
// anchor. By inserting before and not after, we do not
// need to track the last inserted element.
parentNode.insertBefore(element,anchorElement);};
options.singleton = false;

var update = api(content, options);


if (true) {
  if (!content.locals || module.hot.invalidate) {
    var isEqualLocals = function isEqualLocals(a, b) {
  if (!a && b || a && !b) {
    return false;
  }

  var p;

  for (p in a) {
    if (a[p] !== b[p]) {
      return false;
    }
  }

  for (p in b) {
    if (!a[p]) {
      return false;
    }
  }

  return true;
};
    var oldLocals = content.locals;

    module.hot.accept(
      /*! !../../../../node_modules/css-loader/dist/cjs.js??ref--5-oneOf-2-1!../../../../node_modules/next/dist/compiled/postcss-loader??__nextjs_postcss!./Layout.module.css */ "./node_modules/css-loader/dist/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/index.js?!./www/shared/components/layout/Layout.module.css",
      function () {
        content = __webpack_require__(/*! !../../../../node_modules/css-loader/dist/cjs.js??ref--5-oneOf-2-1!../../../../node_modules/next/dist/compiled/postcss-loader??__nextjs_postcss!./Layout.module.css */ "./node_modules/css-loader/dist/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/index.js?!./www/shared/components/layout/Layout.module.css");

              content = content.__esModule ? content.default : content;

              if (typeof content === 'string') {
                content = [[module.i, content, '']];
              }

              if (!isEqualLocals(oldLocals, content.locals)) {
                module.hot.invalidate();

                return;
              }

              oldLocals = content.locals;

              update(content);
      }
    )
  }

  module.hot.dispose(function() {
    update();
  });
}

module.exports = content.locals || {};

/***/ }),

/***/ "./www/shared/components/layout/index.js":
/*!***********************************************!*\
  !*** ./www/shared/components/layout/index.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var _Layout__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Layout */ "./www/shared/components/layout/Layout.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _Layout__WEBPACK_IMPORTED_MODULE_0__["default"]; });



;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./www/shared/components/link/Link.js":
/*!********************************************!*\
  !*** ./www/shared/components/link/Link.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ "./node_modules/@babel/runtime/helpers/esm/extends.js");
/* harmony import */ var _babel_runtime_helpers_esm_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/objectWithoutProperties */ "./node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! classnames */ "./node_modules/classnames/index.js");
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(classnames__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _moxy_next_link__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @moxy/next-link */ "./node_modules/@moxy/next-link/es/index.js");
/* harmony import */ var _Link_module_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Link.module.css */ "./www/shared/components/link/Link.module.css");
/* harmony import */ var _Link_module_css__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_Link_module_css__WEBPACK_IMPORTED_MODULE_6__);


var _jsxFileName = "C:\\Users\\paulo\\Desktop\\Work\\Projects\\Personal\\Web\\paulobmarcos\\www\\shared\\components\\link\\Link.js";
var __jsx = react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement;






const Link = (_ref) => {
  let className = _ref.className,
      rest = Object(_babel_runtime_helpers_esm_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_1__["default"])(_ref, ["className"]);

  return __jsx(_moxy_next_link__WEBPACK_IMPORTED_MODULE_5__["default"], Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({
    className: classnames__WEBPACK_IMPORTED_MODULE_4___default()(_Link_module_css__WEBPACK_IMPORTED_MODULE_6___default.a.link, className)
  }, rest, {
    __self: undefined,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 9,
      columnNumber: 3
    }
  }));
};

_c = Link;
Link.propTypes = {
  className: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.string
};
/* harmony default export */ __webpack_exports__["default"] = (Link);

var _c;

$RefreshReg$(_c, "Link");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./www/shared/components/link/Link.module.css":
/*!****************************************************!*\
  !*** ./www/shared/components/link/Link.module.css ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var api = __webpack_require__(/*! ../../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
            var content = __webpack_require__(/*! !../../../../node_modules/css-loader/dist/cjs.js??ref--5-oneOf-2-1!../../../../node_modules/next/dist/compiled/postcss-loader??__nextjs_postcss!./Link.module.css */ "./node_modules/css-loader/dist/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/index.js?!./www/shared/components/link/Link.module.css");

            content = content.__esModule ? content.default : content;

            if (typeof content === 'string') {
              content = [[module.i, content, '']];
            }

var options = {};

options.insert = function(element){// These elements should always exist. If they do not,
// this code should fail.
var anchorElement=document.querySelector('#__next_css__DO_NOT_USE__');var parentNode=anchorElement.parentNode;// Normally <head>
// Each style tag should be placed right before our
// anchor. By inserting before and not after, we do not
// need to track the last inserted element.
parentNode.insertBefore(element,anchorElement);};
options.singleton = false;

var update = api(content, options);


if (true) {
  if (!content.locals || module.hot.invalidate) {
    var isEqualLocals = function isEqualLocals(a, b) {
  if (!a && b || a && !b) {
    return false;
  }

  var p;

  for (p in a) {
    if (a[p] !== b[p]) {
      return false;
    }
  }

  for (p in b) {
    if (!a[p]) {
      return false;
    }
  }

  return true;
};
    var oldLocals = content.locals;

    module.hot.accept(
      /*! !../../../../node_modules/css-loader/dist/cjs.js??ref--5-oneOf-2-1!../../../../node_modules/next/dist/compiled/postcss-loader??__nextjs_postcss!./Link.module.css */ "./node_modules/css-loader/dist/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/index.js?!./www/shared/components/link/Link.module.css",
      function () {
        content = __webpack_require__(/*! !../../../../node_modules/css-loader/dist/cjs.js??ref--5-oneOf-2-1!../../../../node_modules/next/dist/compiled/postcss-loader??__nextjs_postcss!./Link.module.css */ "./node_modules/css-loader/dist/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/index.js?!./www/shared/components/link/Link.module.css");

              content = content.__esModule ? content.default : content;

              if (typeof content === 'string') {
                content = [[module.i, content, '']];
              }

              if (!isEqualLocals(oldLocals, content.locals)) {
                module.hot.invalidate();

                return;
              }

              oldLocals = content.locals;

              update(content);
      }
    )
  }

  module.hot.dispose(function() {
    update();
  });
}

module.exports = content.locals || {};

/***/ }),

/***/ "./www/shared/components/link/index.js":
/*!*********************************************!*\
  !*** ./www/shared/components/link/index.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var _Link__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Link */ "./www/shared/components/link/Link.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _Link__WEBPACK_IMPORTED_MODULE_0__["default"]; });



;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./www/shared/media/favicons/favicon.ico":
/*!***********************************************!*\
  !*** ./www/shared/media/favicons/favicon.ico ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("/_next/static/chunks/media/images/favicon.ico");

/***/ }),

/***/ "./www/shared/media/svgs/arrow-left.svg":
/*!**********************************************!*\
  !*** ./www/shared/media/svgs/arrow-left.svg ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "<svg version=\"1.1\" id=\"Capa_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" viewBox=\"0 0 123.959 123.959\" style=\"enable-background:new 0 0 123.959 123.959;\" xml:space=\"preserve\"><g><path d=\"M85.742,1.779l-56,56c-2.3,2.3-2.3,6.1,0,8.401l56,56c3.801,3.8,10.2,1.1,10.2-4.2v-112 C95.942,0.679,89.543-2.021,85.742,1.779z\"></path></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g></svg>"

/***/ }),

/***/ "./www/shared/media/svgs/arrow-right.svg":
/*!***********************************************!*\
  !*** ./www/shared/media/svgs/arrow-right.svg ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "<svg version=\"1.1\" id=\"Capa_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" viewBox=\"0 0 123.958 123.959\" style=\"enable-background:new 0 0 123.958 123.959;\" xml:space=\"preserve\"><g><path d=\"M38.217,1.779c-3.8-3.8-10.2-1.1-10.2,4.2v112c0,5.3,6.4,8,10.2,4.2l56-56c2.3-2.301,2.3-6.101,0-8.401L38.217,1.779z\"></path></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g></svg>"

/***/ }),

/***/ "./www/shared/media/svgs/cv.svg":
/*!**************************************!*\
  !*** ./www/shared/media/svgs/cv.svg ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "<svg version=\"1.1\" id=\"Capa_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" viewBox=\"0 0 45.057 45.057\" style=\"enable-background:new 0 0 45.057 45.057;\" xml:space=\"preserve\"><g><g id=\"_x35_8_24_\"><g><path d=\"M19.558,25.389c-0.067,0.176-0.155,0.328-0.264,0.455c-0.108,0.129-0.24,0.229-0.396,0.301 c-0.156,0.072-0.347,0.107-0.57,0.107c-0.313,0-0.572-0.068-0.78-0.203c-0.208-0.137-0.374-0.316-0.498-0.541 c-0.124-0.223-0.214-0.477-0.27-0.756c-0.057-0.279-0.084-0.564-0.084-0.852c0-0.289,0.027-0.572,0.084-0.853 c0.056-0.281,0.146-0.533,0.27-0.756c0.124-0.225,0.29-0.404,0.498-0.541c0.208-0.137,0.468-0.203,0.78-0.203 c0.271,0,0.494,0.051,0.666,0.154c0.172,0.105,0.31,0.225,0.414,0.361c0.104,0.137,0.176,0.273,0.216,0.414 c0.04,0.139,0.068,0.25,0.084,0.33h2.568c-0.112-1.08-0.49-1.914-1.135-2.502c-0.644-0.588-1.558-0.887-2.741-0.895 c-0.664,0-1.263,0.107-1.794,0.324c-0.532,0.215-0.988,0.52-1.368,0.912c-0.38,0.392-0.672,0.863-0.876,1.416 c-0.204,0.551-0.307,1.165-0.307,1.836c0,0.631,0.097,1.223,0.288,1.77c0.192,0.549,0.475,1.021,0.847,1.422 s0.825,0.717,1.361,0.949c0.536,0.23,1.152,0.348,1.849,0.348c0.624,0,1.18-0.105,1.668-0.312 c0.487-0.209,0.897-0.482,1.229-0.822s0.584-0.723,0.756-1.146c0.172-0.422,0.259-0.852,0.259-1.283h-2.593 C19.68,25.023,19.627,25.214,19.558,25.389z\"></path><polygon points=\"26.62,24.812 26.596,24.812 25.192,19.616 22.528,19.616 25.084,28.184 28.036,28.184 30.713,19.616 28,19.616 \"></polygon><path d=\"M33.431,0H5.179v45.057h34.699V6.251L33.431,0z M36.878,42.056H8.179V3h23.706v4.76h4.992L36.878,42.056L36.878,42.056z\"></path></g></g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g></svg>"

/***/ }),

/***/ "./www/shared/media/svgs/github.svg":
/*!******************************************!*\
  !*** ./www/shared/media/svgs/github.svg ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "<svg id=\"Bold\" enable-background=\"new 0 0 24 24\" viewBox=\"0 0 24 24\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"m12 .5c-6.63 0-12 5.28-12 11.792 0 5.211 3.438 9.63 8.205 11.188.6.111.82-.254.82-.567 0-.28-.01-1.022-.015-2.005-3.338.711-4.042-1.582-4.042-1.582-.546-1.361-1.335-1.725-1.335-1.725-1.087-.731.084-.716.084-.716 1.205.082 1.838 1.215 1.838 1.215 1.07 1.803 2.809 1.282 3.495.981.108-.763.417-1.282.76-1.577-2.665-.295-5.466-1.309-5.466-5.827 0-1.287.465-2.339 1.235-3.164-.135-.298-.54-1.497.105-3.121 0 0 1.005-.316 3.3 1.209.96-.262 1.98-.392 3-.398 1.02.006 2.04.136 3 .398 2.28-1.525 3.285-1.209 3.285-1.209.645 1.624.24 2.823.12 3.121.765.825 1.23 1.877 1.23 3.164 0 4.53-2.805 5.527-5.475 5.817.42.354.81 1.077.81 2.182 0 1.578-.015 2.846-.015 3.229 0 .309.21.678.825.56 4.801-1.548 8.236-5.97 8.236-11.173 0-6.512-5.373-11.792-12-11.792z\"></path></svg>"

/***/ }),

/***/ "./www/shared/media/svgs/linkedin.svg":
/*!********************************************!*\
  !*** ./www/shared/media/svgs/linkedin.svg ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "<svg id=\"Bold\" enable-background=\"new 0 0 24 24\" viewBox=\"0 0 24 24\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"m23.994 24v-.001h.006v-8.802c0-4.306-.927-7.623-5.961-7.623-2.42 0-4.044 1.328-4.707 2.587h-.07v-2.185h-4.773v16.023h4.97v-7.934c0-2.089.396-4.109 2.983-4.109 2.549 0 2.587 2.384 2.587 4.243v7.801z\"></path><path d=\"m.396 7.977h4.976v16.023h-4.976z\"></path><path d=\"m2.882 0c-1.591 0-2.882 1.291-2.882 2.882s1.291 2.909 2.882 2.909 2.882-1.318 2.882-2.909c-.001-1.591-1.292-2.882-2.882-2.882z\"></path></svg>"

/***/ }),

/***/ "./www/shared/media/svgs/mail.svg":
/*!****************************************!*\
  !*** ./www/shared/media/svgs/mail.svg ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "<svg version=\"1.1\" id=\"Capa_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" viewBox=\"0 0 230.17 230.17\" style=\"enable-background:new 0 0 230.17 230.17;\" xml:space=\"preserve\"><g><path d=\"M230,49.585c0-0.263,0.181-0.519,0.169-0.779l-70.24,67.68l70.156,65.518c0.041-0.468-0.085-0.94-0.085-1.418V49.585z\"></path><path d=\"M149.207,126.901l-28.674,27.588c-1.451,1.396-3.325,2.096-5.2,2.096c-1.836,0-3.672-0.67-5.113-2.013l-28.596-26.647 L11.01,195.989c1.717,0.617,3.56,1.096,5.49,1.096h197.667c2.866,0,5.554-0.873,7.891-2.175L149.207,126.901z\"></path><path d=\"M115.251,138.757L222.447,35.496c-2.427-1.443-5.252-2.411-8.28-2.411H16.5c-3.943,0-7.556,1.531-10.37,3.866 L115.251,138.757z\"></path><path d=\"M0,52.1v128.484c0,1.475,0.339,2.897,0.707,4.256l69.738-67.156L0,52.1z\"></path></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g></svg>"

/***/ }),

/***/ "./www/shared/styles/global/index.css":
/*!********************************************!*\
  !*** ./www/shared/styles/global/index.css ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var api = __webpack_require__(/*! ../../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
            var content = __webpack_require__(/*! !../../../../node_modules/css-loader/dist/cjs.js??ref--5-oneOf-5-1!../../../../node_modules/next/dist/compiled/postcss-loader??__nextjs_postcss!./index.css */ "./node_modules/css-loader/dist/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/index.js?!./www/shared/styles/global/index.css");

            content = content.__esModule ? content.default : content;

            if (typeof content === 'string') {
              content = [[module.i, content, '']];
            }

var options = {};

options.insert = function(element){// These elements should always exist. If they do not,
// this code should fail.
var anchorElement=document.querySelector('#__next_css__DO_NOT_USE__');var parentNode=anchorElement.parentNode;// Normally <head>
// Each style tag should be placed right before our
// anchor. By inserting before and not after, we do not
// need to track the last inserted element.
parentNode.insertBefore(element,anchorElement);};
options.singleton = false;

var update = api(content, options);


if (true) {
  if (!content.locals || module.hot.invalidate) {
    var isEqualLocals = function isEqualLocals(a, b) {
  if (!a && b || a && !b) {
    return false;
  }

  var p;

  for (p in a) {
    if (a[p] !== b[p]) {
      return false;
    }
  }

  for (p in b) {
    if (!a[p]) {
      return false;
    }
  }

  return true;
};
    var oldLocals = content.locals;

    module.hot.accept(
      /*! !../../../../node_modules/css-loader/dist/cjs.js??ref--5-oneOf-5-1!../../../../node_modules/next/dist/compiled/postcss-loader??__nextjs_postcss!./index.css */ "./node_modules/css-loader/dist/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/index.js?!./www/shared/styles/global/index.css",
      function () {
        content = __webpack_require__(/*! !../../../../node_modules/css-loader/dist/cjs.js??ref--5-oneOf-5-1!../../../../node_modules/next/dist/compiled/postcss-loader??__nextjs_postcss!./index.css */ "./node_modules/css-loader/dist/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/index.js?!./www/shared/styles/global/index.css");

              content = content.__esModule ? content.default : content;

              if (typeof content === 'string') {
                content = [[module.i, content, '']];
              }

              if (!isEqualLocals(oldLocals, content.locals)) {
                module.hot.invalidate();

                return;
              }

              oldLocals = content.locals;

              update(content);
      }
    )
  }

  module.hot.dispose(function() {
    update();
  });
}

module.exports = content.locals || {};

/***/ }),

/***/ "./www/shared/utils/browsers.js":
/*!**************************************!*\
  !*** ./www/shared/utils/browsers.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* eslint-disable */
// CODE FROM: https://stackoverflow.com/questions/9847580/how-to-detect-safari-chrome-ie-firefox-and-opera-browser
// Opera 8.0+
var isOpera = () => !!window.opr && !!opr.addons || !!window.opera || navigator.userAgent.indexOf(' OPR/') >= 0; // Firefox 1.0+


var isFirefox = () => typeof InstallTrigger !== 'undefined'; // Safari 3.0+ "[object HTMLElementConstructor]" 


var isSafari = () => /constructor/i.test(window.HTMLElement) || function (p) {
  return p.toString() === "[object SafariRemoteNotification]";
}(!window['safari'] || typeof safari !== 'undefined' && safari.pushNotification); // Internet Explorer 6-11


var isIE = () =>
/*@cc_on!@*/
 false || !!document.documentMode; // Edge 20+


var isEdge = () => !isIE && !!window.StyleMedia; // Chrome 1 - 79


var isChrome = () => !!window.chrome && (!!window.chrome.webstore || !!window.chrome.runtime); // Edge (based on chromium) detection


var isEdgeChromium = () => isChrome && navigator.userAgent.indexOf("Edg") != -1; // Blink engine detection


var isBlink = () => (isChrome || isOpera) && !!window.CSS;

const browser = {
  isOpera,
  isFirefox,
  isSafari,
  isIE,
  isEdge,
  isChrome,
  isEdgeChromium,
  isBlink
};
/* harmony default export */ __webpack_exports__["default"] = (browser);

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./www/shared/utils/change-style.js":
/*!******************************************!*\
  !*** ./www/shared/utils/change-style.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {const changeStyle = (element, property, newVal) => {
  // Improves Perfomance. Change value only when needed.
  if (element.style[property] !== newVal) {
    element.style[property] = newVal;
  }
};

/* harmony default export */ __webpack_exports__["default"] = (changeStyle);

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./www/shared/utils/get-range.js":
/*!***************************************!*\
  !*** ./www/shared/utils/get-range.js ***!
  \***************************************/
/*! exports provided: getRangePercentage, getRangeValue */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getRangePercentage", function() { return getRangePercentage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getRangeValue", function() { return getRangeValue; });
/* harmony import */ var lodash_clamp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/clamp */ "./node_modules/lodash/clamp.js");
/* harmony import */ var lodash_clamp__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_clamp__WEBPACK_IMPORTED_MODULE_0__);


const getRangePercentage = (current, min, max, options = {}) => {
  const progress = (current - min) / (max - min);

  if (options.clamp) {
    return lodash_clamp__WEBPACK_IMPORTED_MODULE_0___default()(progress, 0, 1);
  }

  return progress;
};

const getRangeValue = (percentage, min, max) => {
  const progress = (max - min) * percentage + min;
  return progress;
};



;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./www/shared/utils/index.js":
/*!***********************************!*\
  !*** ./www/shared/utils/index.js ***!
  \***********************************/
/*! exports provided: getRangePercentage, getRangeValue, browsers, changeStyle, useForceUpdate */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var _get_range__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./get-range */ "./www/shared/utils/get-range.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getRangePercentage", function() { return _get_range__WEBPACK_IMPORTED_MODULE_0__["getRangePercentage"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getRangeValue", function() { return _get_range__WEBPACK_IMPORTED_MODULE_0__["getRangeValue"]; });

/* harmony import */ var _browsers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./browsers */ "./www/shared/utils/browsers.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "browsers", function() { return _browsers__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _change_style__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./change-style */ "./www/shared/utils/change-style.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "changeStyle", function() { return _change_style__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _useForceUpdate__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./useForceUpdate */ "./www/shared/utils/useForceUpdate.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "useForceUpdate", function() { return _useForceUpdate__WEBPACK_IMPORTED_MODULE_3__["default"]; });






;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./www/shared/utils/useForceUpdate.js":
/*!********************************************!*\
  !*** ./www/shared/utils/useForceUpdate.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
var _s = $RefreshSig$();



const useForceUpdate = () => {
  _s();

  const _useState = Object(react__WEBPACK_IMPORTED_MODULE_0__["useState"])(false),
        setState = _useState[1];

  const toggleState = Object(react__WEBPACK_IMPORTED_MODULE_0__["useCallback"])(() => setState(state => !state), []);
  return toggleState;
};

_s(useForceUpdate, "A7YDtz68AuWIb9BRt4wYd8I8pno=");

/* harmony default export */ __webpack_exports__["default"] = (useForceUpdate);

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ 0:
/*!*******************************************************************************************************************************************!*\
  !*** multi next-client-pages-loader?page=%2F_app&absolutePagePath=private-next-pages%2F_app.js ./node_modules/next/dist/client/router.js ***!
  \*******************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! next-client-pages-loader?page=%2F_app&absolutePagePath=private-next-pages%2F_app.js! */"./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?page=%2F_app&absolutePagePath=private-next-pages%2F_app.js!./");
module.exports = __webpack_require__(/*! C:\Users\paulo\Desktop\Work\Projects\Personal\Web\paulobmarcos\node_modules\next\dist\client\router.js */"./node_modules/next/dist/client/router.js");


/***/ })

},[[0,"webpack"]]]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXJyYXlMaWtlVG9BcnJheS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXJyYXlXaXRoSG9sZXMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2FzeW5jVG9HZW5lcmF0b3IuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kcy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pdGVyYWJsZVRvQXJyYXlMaW1pdC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvbm9uSXRlcmFibGVSZXN0LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9zbGljZWRUb0FycmF5LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2YuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3IvaW5kZXguanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AbW94eS9uZXh0LWxpbmsvZXMvTmV4dExpbmsuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AbW94eS9uZXh0LWxpbmsvZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9jbGFzc25hbWVzL2luZGV4LmpzIiwid2VicGFjazovL19OX0UvLi93d3cvc2hhcmVkL2NvbXBvbmVudHMvZ3JhaW4vR3JhaW4ubW9kdWxlLmNzcyIsIndlYnBhY2s6Ly9fTl9FLy4vd3d3L3NoYXJlZC9jb21wb25lbnRzL2hlYWRlci9IZWFkZXIubW9kdWxlLmNzcyIsIndlYnBhY2s6Ly9fTl9FLy4vd3d3L3NoYXJlZC9jb21wb25lbnRzL2xheW91dC9MYXlvdXQubW9kdWxlLmNzcyIsIndlYnBhY2s6Ly9fTl9FLy4vd3d3L3NoYXJlZC9jb21wb25lbnRzL2xpbmsvTGluay5tb2R1bGUuY3NzIiwid2VicGFjazovL19OX0UvLi93d3cvc2hhcmVkL3N0eWxlcy9nbG9iYWwvaW5kZXguY3NzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZXhlbnYvaW5kZXguanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9mdW5jdGlvbi1iaW5kL2ltcGxlbWVudGF0aW9uLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZnVuY3Rpb24tYmluZC9pbmRleC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2hhcy9zcmMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX1N5bWJvbC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUNsYW1wLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlR2V0VGFnLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19mcmVlR2xvYmFsLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRSYXdUYWcuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX29iamVjdFRvU3RyaW5nLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19yb290LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2NsYW1wLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzT2JqZWN0LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzT2JqZWN0TGlrZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc1N5bWJvbC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC90b051bWJlci5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC9wb2x5ZmlsbHMvb2JqZWN0LWFzc2lnbi5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC9wb2x5ZmlsbHMvb2JqZWN0LmFzc2lnbi9pbmRleC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvbmV4dC1jbGllbnQtcGFnZXMtbG9hZGVyLmpzIiwid2VicGFjazovL19OX0UvLi4vLi4vY2xpZW50L2xpbmsudHN4Iiwid2VicGFjazovL19OX0UvLi4vLi4vY2xpZW50L25vcm1hbGl6ZS10cmFpbGluZy1zbGFzaC50cyIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uL2NsaWVudC9yb3V0ZXIudHMiLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9jbGllbnQvd2l0aC1yb3V0ZXIudHN4Iiwid2VicGFjazovL19OX0UvLi4vLi4vLi4vbmV4dC1zZXJ2ZXIvbGliL2FtcC1jb250ZXh0LnRzIiwid2VicGFjazovL19OX0UvLi4vLi4vLi4vbmV4dC1zZXJ2ZXIvbGliL2FtcC50cyIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL25leHQtc2VydmVyL2xpYi9oZWFkLW1hbmFnZXItY29udGV4dC50cyIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL25leHQtc2VydmVyL2xpYi9oZWFkLnRzeCIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL25leHQtc2VydmVyL2xpYi9taXR0LnRzIiwid2VicGFjazovL19OX0UvLi4vLi4vLi4vbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci1jb250ZXh0LnRzIiwid2VicGFjazovL19OX0UvLi4vLi4vLi4vLi4vbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci9yb3V0ZXIudHMiLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi8uLi8uLi9uZXh0LXNlcnZlci9saWIvcm91dGVyL3V0aWxzL2Zvcm1hdC11cmwudHMiLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi8uLi8uLi9uZXh0LXNlcnZlci9saWIvcm91dGVyL3V0aWxzL2lzLWR5bmFtaWMudHMiLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi8uLi8uLi9uZXh0LXNlcnZlci9saWIvcm91dGVyL3V0aWxzL3BhcnNlLXJlbGF0aXZlLXVybC50cyIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uLy4uLy4uL25leHQtc2VydmVyL2xpYi9yb3V0ZXIvdXRpbHMvcXVlcnlzdHJpbmcudHMiLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi8uLi8uLi9uZXh0LXNlcnZlci9saWIvcm91dGVyL3V0aWxzL3JvdXRlLW1hdGNoZXIudHMiLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi8uLi8uLi9uZXh0LXNlcnZlci9saWIvcm91dGVyL3V0aWxzL3JvdXRlLXJlZ2V4LnRzIiwid2VicGFjazovL19OX0UvLi4vLi4vLi4vbmV4dC1zZXJ2ZXIvbGliL3NpZGUtZWZmZWN0LnRzeCIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL25leHQtc2VydmVyL2xpYi91dGlscy50cyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvbGluay5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMtZXhhY3QvYnVpbGQvaGVscGVycy9pc1BsYWluT2JqZWN0LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy1leGFjdC9idWlsZC9pbmRleC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvY2hlY2tQcm9wVHlwZXMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2ZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9pbmRleC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QtZnJvbS1kb20vZXNtL2hlbHBlcnMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC1mcm9tLWRvbS9lc20vaW5kZXguanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC1pbmxpbmVzdmcvZXNtL2hlbHBlcnMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC1pbmxpbmVzdmcvZXNtL2luZGV4LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QtaW5saW5lc3ZnL2VzbS90eXBlcy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWlzL2Nqcy9yZWFjdC1pcy5kZXZlbG9wbWVudC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWlzL2luZGV4LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QvY2pzL3JlYWN0LmRldmVsb3BtZW50LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QvaW5kZXguanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qcyIsIndlYnBhY2s6Ly9fTl9FLyh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qcyIsIndlYnBhY2s6Ly9fTl9FLyh3ZWJwYWNrKS9idWlsZGluL2hhcm1vbnktbW9kdWxlLmpzIiwid2VicGFjazovL19OX0UvKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzIiwid2VicGFjazovL19OX0UvLi9wYWdlcy9fYXBwLmpzIiwid2VicGFjazovL19OX0UvLi93d3cvYXBwL0FwcC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vd3d3L2FwcC9pbmRleC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vd3d3L3NoYXJlZC9jb21wb25lbnRzL2dyYWluL0dyYWluLmpzIiwid2VicGFjazovL19OX0UvLi93d3cvc2hhcmVkL2NvbXBvbmVudHMvZ3JhaW4vR3JhaW4ubW9kdWxlLmNzcz9jY2M0Iiwid2VicGFjazovL19OX0UvLi93d3cvc2hhcmVkL2NvbXBvbmVudHMvZ3JhaW4vaW5kZXguanMiLCJ3ZWJwYWNrOi8vX05fRS8uL3d3dy9zaGFyZWQvY29tcG9uZW50cy9oZWFkZXIvSGVhZGVyLmpzIiwid2VicGFjazovL19OX0UvLi93d3cvc2hhcmVkL2NvbXBvbmVudHMvaGVhZGVyL0hlYWRlci5tb2R1bGUuY3NzPzQ4N2QiLCJ3ZWJwYWNrOi8vX05fRS8uL3d3dy9zaGFyZWQvY29tcG9uZW50cy9oZWFkZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vX05fRS8uL3d3dy9zaGFyZWQvY29tcG9uZW50cy9pY29ucy9pbmRleC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vd3d3L3NoYXJlZC9jb21wb25lbnRzL2xheW91dC9MYXlvdXQuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL3d3dy9zaGFyZWQvY29tcG9uZW50cy9sYXlvdXQvTGF5b3V0Lm1vZHVsZS5jc3M/OWFiNCIsIndlYnBhY2s6Ly9fTl9FLy4vd3d3L3NoYXJlZC9jb21wb25lbnRzL2xheW91dC9pbmRleC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vd3d3L3NoYXJlZC9jb21wb25lbnRzL2xpbmsvTGluay5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vd3d3L3NoYXJlZC9jb21wb25lbnRzL2xpbmsvTGluay5tb2R1bGUuY3NzPzIyMDMiLCJ3ZWJwYWNrOi8vX05fRS8uL3d3dy9zaGFyZWQvY29tcG9uZW50cy9saW5rL2luZGV4LmpzIiwid2VicGFjazovL19OX0UvLi93d3cvc2hhcmVkL21lZGlhL2Zhdmljb25zL2Zhdmljb24uaWNvIiwid2VicGFjazovL19OX0UvLi93d3cvc2hhcmVkL21lZGlhL3N2Z3MvYXJyb3ctbGVmdC5zdmciLCJ3ZWJwYWNrOi8vX05fRS8uL3d3dy9zaGFyZWQvbWVkaWEvc3Zncy9hcnJvdy1yaWdodC5zdmciLCJ3ZWJwYWNrOi8vX05fRS8uL3d3dy9zaGFyZWQvbWVkaWEvc3Zncy9jdi5zdmciLCJ3ZWJwYWNrOi8vX05fRS8uL3d3dy9zaGFyZWQvbWVkaWEvc3Zncy9naXRodWIuc3ZnIiwid2VicGFjazovL19OX0UvLi93d3cvc2hhcmVkL21lZGlhL3N2Z3MvbGlua2VkaW4uc3ZnIiwid2VicGFjazovL19OX0UvLi93d3cvc2hhcmVkL21lZGlhL3N2Z3MvbWFpbC5zdmciLCJ3ZWJwYWNrOi8vX05fRS8uL3d3dy9zaGFyZWQvc3R5bGVzL2dsb2JhbC9pbmRleC5jc3M/Yjk5YyIsIndlYnBhY2s6Ly9fTl9FLy4vd3d3L3NoYXJlZC91dGlscy9icm93c2Vycy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vd3d3L3NoYXJlZC91dGlscy9jaGFuZ2Utc3R5bGUuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL3d3dy9zaGFyZWQvdXRpbHMvZ2V0LXJhbmdlLmpzIiwid2VicGFjazovL19OX0UvLi93d3cvc2hhcmVkL3V0aWxzL2luZGV4LmpzIiwid2VicGFjazovL19OX0UvLi93d3cvc2hhcmVkL3V0aWxzL3VzZUZvcmNlVXBkYXRlLmpzIl0sIm5hbWVzIjpbImxpc3RlbmVycyIsIkludGVyc2VjdGlvbk9ic2VydmVyIiwid2luZG93IiwicHJlZmV0Y2hlZCIsImNhY2hlZE9ic2VydmVyIiwiZW50cmllcyIsImVudHJ5IiwiY2IiLCJyb290TWFyZ2luIiwibGlzdGVuVG9JbnRlcnNlY3Rpb25zIiwib2JzZXJ2ZXIiLCJnZXRPYnNlcnZlciIsImNvbnNvbGUiLCJyb3V0ZXIiLCJlcnIiLCJocmVmIiwiZXZlbnQiLCJ0YXJnZXQiLCJlIiwibm9kZU5hbWUiLCJpc01vZGlmaWVkRXZlbnQiLCJzY3JvbGwiLCJhcyIsInJlcGxhY2UiLCJzdWNjZXNzIiwiZG9jdW1lbnQiLCJoYXNXYXJuZWQiLCJSZWFjdCIsInByb3BzIiwicCIsInBhdGhuYW1lIiwicmVzb2x2ZWRIcmVmIiwiY2hpbGRFbG0iLCJpc1ByZWZldGNoZWQiLCJwcmVmZXRjaCIsImNoaWxkcmVuIiwiY2hpbGQiLCJDaGlsZHJlbiIsImNoaWxkUHJvcHMiLCJyZWYiLCJlbCIsInNldENoaWxkRWxtIiwib25DbGljayIsImxpbmtDbGlja2VkIiwicHJpb3JpdHkiLCJ3YXJuIiwiUHJvcFR5cGVzIiwicmVxdWlyZSIsImV4YWN0IiwiTGluayIsInNoYWxsb3ciLCJwYXNzSHJlZiIsInZhbHVlIiwicGF0aCIsIm5vcm1hbGl6ZVBhdGhUcmFpbGluZ1NsYXNoIiwicHJvY2VzcyIsInNpbmdsZXRvblJvdXRlciIsInJlYWR5Q2FsbGJhY2tzIiwicmVhZHkiLCJ1cmxQcm9wZXJ0eUZpZWxkcyIsInJvdXRlckV2ZW50cyIsImNvcmVNZXRob2RGaWVsZHMiLCJPYmplY3QiLCJnZXQiLCJSb3V0ZXIiLCJmaWVsZCIsImdldFJvdXRlciIsImV2ZW50RmllbGQiLCJfc2luZ2xldG9uUm91dGVyIiwibWVzc2FnZSIsIlJvdXRlckNvbnRleHQiLCJjcmVhdGVSb3V0ZXIiLCJfcm91dGVyIiwiaW5zdGFuY2UiLCJDb21wb3NlZENvbXBvbmVudCIsImdldEluaXRpYWxQcm9wcyIsIldpdGhSb3V0ZXJXcmFwcGVyIiwibmFtZSIsIkFtcFN0YXRlQ29udGV4dCIsImFtcEZpcnN0IiwiaHlicmlkIiwiaGFzUXVlcnkiLCJpc0luQW1wTW9kZSIsIkhlYWRNYW5hZ2VyQ29udGV4dCIsImluQW1wTW9kZSIsImhlYWQiLCJsaXN0IiwiZnJhZ21lbnRMaXN0IiwiTUVUQVRZUEVTIiwia2V5cyIsInRhZ3MiLCJtZXRhVHlwZXMiLCJtZXRhQ2F0ZWdvcmllcyIsImgiLCJpc1VuaXF1ZSIsImtleSIsImkiLCJsZW4iLCJtZXRhdHlwZSIsImNhdGVnb3J5IiwiY2F0ZWdvcmllcyIsImhlYWRFbGVtZW50cyIsImhlYWRFbGVtZW50Q2hpbGRyZW4iLCJoZWFkRWxlbWVudCIsImRlZmF1bHRIZWFkIiwidW5pcXVlIiwiYyIsImFtcFN0YXRlIiwiaGVhZE1hbmFnZXIiLCJIZWFkIiwiYWxsIiwib24iLCJvZmYiLCJlbWl0IiwiaGFuZGxlciIsImJhc2VQYXRoIiwiY2FuY2VsbGVkIiwidXJsIiwibG9jYXRpb25PcmlnaW4iLCJyZXNvbHZlZCIsImhhc0Jhc2VQYXRoIiwiYmFzZSIsInVybEFzU3RyaW5nIiwiZmluYWxVcmwiLCJQQUdFX0xPQURfRVJST1IiLCJTeW1ib2wiLCJhZGRCYXNlUGF0aCIsInJlc29sdmVIcmVmIiwic2V0VGltZW91dCIsIm1hbnVhbFNjcm9sbFJlc3RvcmF0aW9uIiwiY3JlZGVudGlhbHMiLCJyZXMiLCJhdHRlbXB0cyIsImZldGNoUmV0cnkiLCJpc1NlcnZlclJlbmRlciIsIm1hcmtMb2FkaW5nRXJyb3IiLCJjb25zdHJ1Y3RvciIsInJvdXRlIiwicXVlcnkiLCJhc1BhdGgiLCJjb21wb25lbnRzIiwic2RjIiwic3ViIiwiY2xjIiwicGFnZUxvYWRlciIsIl9icHMiLCJldmVudHMiLCJfd3JhcEFwcCIsImlzU3NyIiwiaXNGYWxsYmFjayIsIl9pbkZsaWdodFJvdXRlIiwic3RhdGUiLCJfX05fU1NHIiwiaW5pdGlhbFByb3BzIiwiX19OX1NTUCIsIkNvbXBvbmVudCIsIl9fTkVYVF9EQVRBX18iLCJ1cGRhdGUiLCJtb2QiLCJkYXRhIiwibmV3RGF0YSIsInJlbG9hZCIsImJhY2siLCJwdXNoIiwib3B0aW9ucyIsInByZXBhcmVVcmxBcyIsImlzTG9jYWxVUkwiLCJTVCIsInBlcmZvcm1hbmNlIiwiY2xlYW5lZEFzIiwiZGVsQmFzZVBhdGgiLCJwYXJzZWQiLCJ0cnlQYXJzZVJlbGF0aXZlVXJsIiwibWV0aG9kIiwicm91dGVSZWdleCIsInJvdXRlTWF0Y2giLCJtaXNzaW5nUGFyYW1zIiwicGFyYW0iLCJhc1BhdGhuYW1lIiwicm91dGVJbmZvIiwiYXBwQ29tcCIsImNoYW5nZVN0YXRlIiwiX19OIiwiYnVpbGRDYW5jZWxsYXRpb25FcnJvciIsInBhZ2UiLCJlcnJvciIsImNhY2hlZFJvdXRlSW5mbyIsImlzVmFsaWRFbGVtZW50VHlwZSIsImRhdGFIcmVmIiwic2V0IiwiYmVmb3JlUG9wU3RhdGUiLCJvbmx5QUhhc2hDaGFuZ2UiLCJuZXdIYXNoIiwib2xkVXJsTm9IYXNoIiwib2xkSGFzaCIsInNjcm9sbFRvSGFzaCIsImhhc2giLCJpZEVsIiwibmFtZUVsIiwidXJsSXNOZXciLCJQcm9taXNlIiwiY2FuY2VsIiwiY29tcG9uZW50UmVzdWx0IiwiX2dldERhdGEiLCJmbiIsIl9nZXRTdGF0aWNEYXRhIiwiZmV0Y2hOZXh0RGF0YSIsIl9nZXRTZXJ2ZXJEYXRhIiwiQXBwVHJlZSIsImN0eCIsImFib3J0Q29tcG9uZW50TG9hZCIsIm5vdGlmeSIsInNsYXNoZWRQcm90b2NvbHMiLCJwcm90b2NvbCIsInVybE9iaiIsImhvc3QiLCJhdXRoIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiaG9zdG5hbWUiLCJTdHJpbmciLCJxdWVyeXN0cmluZyIsInNlYXJjaCIsIlRFU1RfUk9VVEUiLCJEVU1NWV9CQVNFIiwicmVzb2x2ZWRCYXNlIiwib3JpZ2luIiwic2VhcmNoUGFyYW1zIiwiQXJyYXkiLCJyZXN1bHQiLCJpdGVtIiwic2VhcmNoUGFyYW1zTGlzdCIsInJlIiwiZGVjb2RlIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwicGFyYW1zIiwic2x1Z05hbWUiLCJnIiwiZ3JvdXBzIiwibSIsInN0ciIsIm9wdGlvbmFsIiwicmVwZWF0Iiwic2VnbWVudHMiLCJub3JtYWxpemVkUm91dGUiLCJncm91cEluZGV4IiwicGFyYW1ldGVyaXplZFJvdXRlIiwic2VnbWVudCIsInBhcnNlUGFyYW1ldGVyIiwicG9zIiwiZXNjYXBlUmVnZXgiLCJpc1NlcnZlciIsIl9oYXNIZWFkTWFuYWdlciIsImVtaXRDaGFuZ2UiLCJjb21wb25lbnREaWRNb3VudCIsImNvbXBvbmVudERpZFVwZGF0ZSIsImNvbXBvbmVudFdpbGxVbm1vdW50IiwicmVuZGVyIiwidXNlZCIsInBvcnQiLCJnZXRMb2NhdGlvbk9yaWdpbiIsIkFwcCIsImdldERpc3BsYXlOYW1lIiwibG9hZEdldEluaXRpYWxQcm9wcyIsInBhZ2VQcm9wcyIsImlzUmVzU2VudCIsInVybE9iamVjdEtleXMiLCJTUCIsImZhdmljb24iLCJwcm9wVHlwZXMiLCJlbGVtZW50VHlwZSIsImlzUmVxdWlyZWQiLCJvYmplY3QiLCJHcmFpbiIsImNsYXNzTmFtZSIsInVzZVN0YXRlIiwiekluZGV4Iiwic2V0WkluZGV4IiwidXNlRWZmZWN0IiwiYnJvd3NlcnMiLCJpc1NhZmFyaSIsImNsYXNzTmFtZXMiLCJzdHlsZXMiLCJncmFpbiIsInN0cmluZyIsIkhlYWRlciIsImhlYWRlciIsImNvbnRlbnQiLCJsaW5rcyIsInNvY2lhbCIsIkFycm93TGVmdEljb24iLCJhcnJvd0xlZnRTdmciLCJBcnJvd1JpZ2h0SWNvbiIsImFycm93UmlnaHRTdmciLCJDdkljb24iLCJjdlN2ZyIsIkdpdGh1Ykljb24iLCJnaXRodWJTdmciLCJMaW5rZWRpbkljb24iLCJsaW5rZWRpblN2ZyIsIk1haWxJY29uIiwibWFpbFN2ZyIsIkxheW91dCIsImNvbnRlbnRSZWYiLCJ1c2VSZWYiLCJwcm9ncmVzc1JlZiIsInBlcmNlbnRhZ2VSZWYiLCJoYW5kbGVTY3JvbGwiLCJ1c2VDYWxsYmFjayIsImN1cnJlbnQiLCJjbGllbnRIZWlnaHQiLCJzY3JvbGxIZWlnaHQiLCJzY3JvbGxUb3AiLCJwZXJjZW50YWdlIiwiY2hhbmdlU3R5bGUiLCJhZGRFdmVudExpc3RlbmVyIiwicGFzc2l2ZSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJsYXlvdXQiLCJmcmFtZSIsInByb2dyZXNzIiwiYW55IiwicmVzdCIsImxpbmsiLCJpc09wZXJhIiwib3ByIiwiYWRkb25zIiwib3BlcmEiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJpbmRleE9mIiwiaXNGaXJlZm94IiwiSW5zdGFsbFRyaWdnZXIiLCJ0ZXN0IiwiSFRNTEVsZW1lbnQiLCJ0b1N0cmluZyIsInNhZmFyaSIsInB1c2hOb3RpZmljYXRpb24iLCJpc0lFIiwiZG9jdW1lbnRNb2RlIiwiaXNFZGdlIiwiU3R5bGVNZWRpYSIsImlzQ2hyb21lIiwiY2hyb21lIiwid2Vic3RvcmUiLCJydW50aW1lIiwiaXNFZGdlQ2hyb21pdW0iLCJpc0JsaW5rIiwiQ1NTIiwiYnJvd3NlciIsImVsZW1lbnQiLCJwcm9wZXJ0eSIsIm5ld1ZhbCIsInN0eWxlIiwiZ2V0UmFuZ2VQZXJjZW50YWdlIiwibWluIiwibWF4IiwiY2xhbXAiLCJnZXRSYW5nZVZhbHVlIiwidXNlRm9yY2VVcGRhdGUiLCJzZXRTdGF0ZSIsInRvZ2dsZVN0YXRlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7QUFDQTs7QUFFQSx3Q0FBd0MsU0FBUztBQUNqRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsbUM7Ozs7Ozs7Ozs7O0FDVkE7QUFDQTtBQUNBOztBQUVBLGlDOzs7Ozs7Ozs7OztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBLG1DOzs7Ozs7Ozs7OztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlDOzs7Ozs7Ozs7Ozs7QUNmQTtBQUFBO0FBQWU7QUFDZjtBQUNBLG1CQUFtQixzQkFBc0I7QUFDekM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDOzs7Ozs7Ozs7Ozs7QUNoQkE7QUFBQTtBQUFBO0FBQTBFO0FBQzNEO0FBQ2Y7QUFDQSxlQUFlLDZFQUE0QjtBQUMzQzs7QUFFQTtBQUNBOztBQUVBLGVBQWUsNkJBQTZCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEM7Ozs7Ozs7Ozs7OztBQ2xCQTtBQUFBO0FBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFh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TUFBTSxRQUFRLFlBQVksT0FBTyxNQUFNLE1BQU0sUUFBUSxZQUFZLFdBQVcsTUFBTSxNQUFNLE1BQU0sUUFBUSxZQUFZLE9BQU8sTUFBTSxNQUFNLEtBQUssWUFBWSxPQUFPLFNBQVMsTUFBTSxLQUFLLHNCQUFzQixxQkFBcUIscUJBQXFCLHFCQUFxQixxQkFBcUIsdUJBQXVCLE9BQU8sTUFBTSxNQUFNLEtBQUssWUFBWSxPQUFPLE1BQU0sTUFBTSxLQUFLLFVBQVUsT0FBTyxPQUFPLE1BQU0sTUFBTSxzQkFBc0IscUJBQXFCLE9BQU8sTUFBTSxNQUFNLE1BQU0sVUFBVSxNQUFNLE9BQU8sTUFBTSxLQUFLLHNCQUFzQix1QkFBdUIsT0FBTyxNQUFNLE1BQU0sS0FBSyxZQUFZLE9BQU8sT0FBTyxNQUFNLEtBQUssc0JBQXNCLHFCQUFxQixPQUFPLEtBQUssUUFBUSxPQUFPLE1BQU0sS0FBSyxVQUFVLE9BQU8sTUFBTSxNQUFNLEtBQUssWUFBWSxPQUFPLEtBQUssUUFBUSxPQUFPLE1BQU0sS0FBSyxVQUFVLE1BQU0sTUFBTSxNQUFNLEtBQUssVUFBVSxNQUFNLFFBQVEsWUFBWSxPQUFPLEtBQUssWUFBWSxhQUFhLE9BQU8sS0FBSyxZQUFZLE9BQU8sS0FBSyxZQUFZLGFBQWEsYUFBYSxhQUFhLE9BQU8sS0FBSyxZQUFZLE9BQU8sS0FBSyxVQUFVLE9BQU8sS0FBSyxXQUFXLFVBQVUsT0FBTyxNQUFNLFlBQVksYUFBYSxPQUFPLEtBQUssWUFBWSxXQUFXLFlBQVksT0FBTyx1QkFBdUIsd0JBQXdCLE1BQU0sVUFBVSxZQUFZLGFBQWEsT0FBTyxLQUFLLFVBQVUsVUFBVSxPQUFPLEtBQUssVUFBVSxNQUFNLFlBQVksUUFBUSxRQUFRLFlBQVksWUFBWSxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsT0FBTyxRQUFRLE9BQU8sUUFBUSxPQUFPLFFBQVEsUUFBUSxRQUFRLE9BQU8sUUFBUSxPQUFPLFFBQVEsUUFBUSxRQUFRLFFBQVEsWUFBWSxPQUFPLE1BQU0sUUFBUSxTQUFTLE1BQU0sS0FBSyxVQUFVLG9C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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLDZCQUE2QjtBQUM3QixRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsS0FBSztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULDRCQUE0QjtBQUM1QixPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLElBQXFDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsVUFBVSxLQUFxQztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixzQkFBc0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLElBQXFDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCLDJCQUEyQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU0sS0FBcUMsNEZBQTRGLFNBQU07QUFDN0k7QUFDQTs7QUFFQSxtQkFBbUIsZ0NBQWdDO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixnQ0FBZ0M7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7O0FDOWtCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSSxJQUFxQztBQUN6QyxnQkFBZ0IsbUJBQU8sQ0FBQyxrREFBVTs7QUFFbEM7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFPLENBQUMsdUZBQTJCO0FBQ3RELENBQUMsTUFBTSxFQUlOOzs7Ozs7Ozs7Ozs7O0FDbEJEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYjs7QUFFQTs7Ozs7Ozs7Ozs7OztBQ1hBO0FBQUE7QUFBQTtBQUFBO0FBQUEsY0FBYyxTQUFJLElBQUksU0FBSTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsTUFBTSxnQkFBZ0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsc0JBQXNCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNPO0FBQ1AscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCx5QkFBeUIsRUFBRTtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssSUFBSTtBQUNUO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1COztBQUVuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBGQUEwRixhQUFhO0FBQ3ZHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhGQUE4RixlQUFlO0FBQzdHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUssRUFBRTs7QUFFUCxpREFBaUQ7QUFDakQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDhNQUE4TTs7QUFFOU07QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFdBQVc7QUFDeEIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxXQUFXO0FBQ3hCLGFBQWEsVUFBVTtBQUN2QixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxXQUFXO0FBQ3hCLGFBQWEsT0FBTztBQUNwQixhQUFhLFVBQVU7QUFDdkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFdBQVc7QUFDeEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsVUFBVTtBQUN2QixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLHlCQUF5Qjs7QUFFekIsMEJBQTBCO0FBQzFCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0JBQWdCO0FBQzNCO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUJBQXlCOztBQUV6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtREFBbUQ7O0FBRW5EOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FB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QUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBLHdDQUF3QyxXQUFXO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DLGNBQWM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDLGtCQUFrQjtBQUNuRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw4Q0FBOEMsUUFBUTtBQUN0RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUEsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSw4Q0FBOEMsUUFBUTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLDhDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLDhDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztB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L19hcHAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikge1xuICBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHtcbiAgICBhcnIyW2ldID0gYXJyW2ldO1xuICB9XG5cbiAgcmV0dXJuIGFycjI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2FycmF5TGlrZVRvQXJyYXk7IiwiZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9hcnJheVdpdGhIb2xlczsiLCJmdW5jdGlvbiBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIGtleSwgYXJnKSB7XG4gIHRyeSB7XG4gICAgdmFyIGluZm8gPSBnZW5ba2V5XShhcmcpO1xuICAgIHZhciB2YWx1ZSA9IGluZm8udmFsdWU7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmVqZWN0KGVycm9yKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoaW5mby5kb25lKSB7XG4gICAgcmVzb2x2ZSh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKF9uZXh0LCBfdGhyb3cpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9hc3luY1RvR2VuZXJhdG9yKGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgZ2VuID0gZm4uYXBwbHkoc2VsZiwgYXJncyk7XG5cbiAgICAgIGZ1bmN0aW9uIF9uZXh0KHZhbHVlKSB7XG4gICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJuZXh0XCIsIHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gX3Rocm93KGVycikge1xuICAgICAgICBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwidGhyb3dcIiwgZXJyKTtcbiAgICAgIH1cblxuICAgICAgX25leHQodW5kZWZpbmVkKTtcbiAgICB9KTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfYXN5bmNUb0dlbmVyYXRvcjsiLCJmdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmaW5lUHJvcGVydHk7IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2V4dGVuZHMoKSB7XG4gIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfTtcblxuICByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn0iLCJpbXBvcnQgb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSBmcm9tIFwiLi9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkge1xuICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgdmFyIHRhcmdldCA9IG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCk7XG4gIHZhciBrZXksIGk7XG5cbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBrZXkgPSBzb3VyY2VTeW1ib2xLZXlzW2ldO1xuICAgICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7XG4gICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkge1xuICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgdmFyIHRhcmdldCA9IHt9O1xuICB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gIHZhciBrZXksIGk7XG5cbiAgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBrZXkgPSBzb3VyY2VLZXlzW2ldO1xuICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59IiwiZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHtcbiAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHtcbiAgICBcImRlZmF1bHRcIjogb2JqXG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdDsiLCJ2YXIgX3R5cGVvZiA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL3R5cGVvZlwiKTtcblxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkge1xuICBpZiAodHlwZW9mIFdlYWtNYXAgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIG51bGw7XG4gIHZhciBjYWNoZSA9IG5ldyBXZWFrTWFwKCk7XG5cbiAgX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkge1xuICAgIHJldHVybiBjYWNoZTtcbiAgfTtcblxuICByZXR1cm4gY2FjaGU7XG59XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikge1xuICBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIGlmIChvYmogPT09IG51bGwgfHwgX3R5cGVvZihvYmopICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvYmogIT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybiB7XG4gICAgICBcImRlZmF1bHRcIjogb2JqXG4gICAgfTtcbiAgfVxuXG4gIHZhciBjYWNoZSA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpO1xuXG4gIGlmIChjYWNoZSAmJiBjYWNoZS5oYXMob2JqKSkge1xuICAgIHJldHVybiBjYWNoZS5nZXQob2JqKTtcbiAgfVxuXG4gIHZhciBuZXdPYmogPSB7fTtcbiAgdmFyIGhhc1Byb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgdmFyIGRlc2MgPSBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IG51bGw7XG5cbiAgICAgIGlmIChkZXNjICYmIChkZXNjLmdldCB8fCBkZXNjLnNldCkpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5ld09ialtrZXldID0gb2JqW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgbmV3T2JqW1wiZGVmYXVsdFwiXSA9IG9iajtcblxuICBpZiAoY2FjaGUpIHtcbiAgICBjYWNoZS5zZXQob2JqLCBuZXdPYmopO1xuICB9XG5cbiAgcmV0dXJuIG5ld09iajtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZDsiLCJmdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB7XG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcInVuZGVmaW5lZFwiIHx8ICEoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChhcnIpKSkgcmV0dXJuO1xuICB2YXIgX2FyciA9IFtdO1xuICB2YXIgX24gPSB0cnVlO1xuICB2YXIgX2QgPSBmYWxzZTtcbiAgdmFyIF9lID0gdW5kZWZpbmVkO1xuXG4gIHRyeSB7XG4gICAgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkge1xuICAgICAgX2Fyci5wdXNoKF9zLnZhbHVlKTtcblxuICAgICAgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2QgPSB0cnVlO1xuICAgIF9lID0gZXJyO1xuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdICE9IG51bGwpIF9pW1wicmV0dXJuXCJdKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChfZCkgdGhyb3cgX2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIF9hcnI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2l0ZXJhYmxlVG9BcnJheUxpbWl0OyIsImZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX25vbkl0ZXJhYmxlUmVzdDsiLCJ2YXIgYXJyYXlXaXRoSG9sZXMgPSByZXF1aXJlKFwiLi9hcnJheVdpdGhIb2xlc1wiKTtcblxudmFyIGl0ZXJhYmxlVG9BcnJheUxpbWl0ID0gcmVxdWlyZShcIi4vaXRlcmFibGVUb0FycmF5TGltaXRcIik7XG5cbnZhciB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSA9IHJlcXVpcmUoXCIuL3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5XCIpO1xuXG52YXIgbm9uSXRlcmFibGVSZXN0ID0gcmVxdWlyZShcIi4vbm9uSXRlcmFibGVSZXN0XCIpO1xuXG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHtcbiAgcmV0dXJuIGFycmF5V2l0aEhvbGVzKGFycikgfHwgaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IG5vbkl0ZXJhYmxlUmVzdCgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9zbGljZWRUb0FycmF5OyIsImZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblxuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBfdHlwZW9mKG9iaik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3R5cGVvZjsiLCJ2YXIgYXJyYXlMaWtlVG9BcnJheSA9IHJlcXVpcmUoXCIuL2FycmF5TGlrZVRvQXJyYXlcIik7XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHtcbiAgaWYgKCFvKSByZXR1cm47XG4gIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbiAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lO1xuICBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTtcbiAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBhcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5OyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInJlZ2VuZXJhdG9yLXJ1bnRpbWVcIik7XG4iLCJpbXBvcnQgUmVhY3QsIHsgZm9yd2FyZFJlZiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgTGluayBmcm9tICduZXh0L2xpbmsnO1xuZXhwb3J0IGNvbnN0IE5leHRMaW5rID0gZm9yd2FyZFJlZigoe1xuICBjaGlsZHJlbixcbiAgY2xhc3NOYW1lLFxuICBocmVmLFxuICBuZXdUYWIsXG4gIHByZWZldGNoLFxuICBhcyxcbiAgc2Nyb2xsLFxuICBleHRlcm5hbCxcbiAgLi4ucHJvcHNcbn0sIHJlZikgPT4ge1xuICBjb25zdCBBbmNob3IgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImFcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgcmVmOiByZWYsXG4gICAgY2xhc3NOYW1lOiBjbGFzc05hbWUsXG4gICAgdGFyZ2V0OiBuZXdUYWIgPyAnX2JsYW5rJyA6IHVuZGVmaW5lZCxcbiAgICByZWw6IG5ld1RhYiA/ICdub29wZW5lciBub3JlZmVycmVyJyA6IHVuZGVmaW5lZCxcbiAgICBocmVmOiBleHRlcm5hbCA/IGhyZWYgOiB1bmRlZmluZWRcbiAgfSwgcHJvcHMpLCBjaGlsZHJlbik7XG5cbiAgaWYgKGV4dGVybmFsKSB7XG4gICAgcmV0dXJuIEFuY2hvcjtcbiAgfVxuXG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChMaW5rLCB7XG4gICAgaHJlZjogaHJlZixcbiAgICBwcmVmZXRjaDogcHJlZmV0Y2ggJiYgdW5kZWZpbmVkLFxuICAgIGFzOiBhcyxcbiAgICBzY3JvbGw6IHNjcm9sbCxcbiAgICBwYXNzSHJlZjogdHJ1ZVxuICB9LCBBbmNob3IpO1xufSk7XG5OZXh0TGluay5wcm9wVHlwZXMgPSB7XG4gIGhyZWY6IFByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcbiAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlLmlzUmVxdWlyZWQsXG4gIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgbmV3VGFiOiBQcm9wVHlwZXMuYm9vbCxcbiAgZXh0ZXJuYWw6IFByb3BUeXBlcy5ib29sLFxuICBwcmVmZXRjaDogUHJvcFR5cGVzLmJvb2wsXG4gIGFzOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBzY3JvbGw6IFByb3BUeXBlcy5ib29sXG59O1xuZXhwb3J0IGRlZmF1bHQgTmV4dExpbms7IiwiZXhwb3J0IHsgZGVmYXVsdCB9IGZyb20gJy4vTmV4dExpbmsnOyIsIi8qIVxuICBDb3B5cmlnaHQgKGMpIDIwMTcgSmVkIFdhdHNvbi5cbiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlIChNSVQpLCBzZWVcbiAgaHR0cDovL2plZHdhdHNvbi5naXRodWIuaW8vY2xhc3NuYW1lc1xuKi9cbi8qIGdsb2JhbCBkZWZpbmUgKi9cblxuKGZ1bmN0aW9uICgpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdHZhciBoYXNPd24gPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblxuXHRmdW5jdGlvbiBjbGFzc05hbWVzICgpIHtcblx0XHR2YXIgY2xhc3NlcyA9IFtdO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBhcmcgPSBhcmd1bWVudHNbaV07XG5cdFx0XHRpZiAoIWFyZykgY29udGludWU7XG5cblx0XHRcdHZhciBhcmdUeXBlID0gdHlwZW9mIGFyZztcblxuXHRcdFx0aWYgKGFyZ1R5cGUgPT09ICdzdHJpbmcnIHx8IGFyZ1R5cGUgPT09ICdudW1iZXInKSB7XG5cdFx0XHRcdGNsYXNzZXMucHVzaChhcmcpO1xuXHRcdFx0fSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGFyZykgJiYgYXJnLmxlbmd0aCkge1xuXHRcdFx0XHR2YXIgaW5uZXIgPSBjbGFzc05hbWVzLmFwcGx5KG51bGwsIGFyZyk7XG5cdFx0XHRcdGlmIChpbm5lcikge1xuXHRcdFx0XHRcdGNsYXNzZXMucHVzaChpbm5lcik7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoYXJnVHlwZSA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0Zm9yICh2YXIga2V5IGluIGFyZykge1xuXHRcdFx0XHRcdGlmIChoYXNPd24uY2FsbChhcmcsIGtleSkgJiYgYXJnW2tleV0pIHtcblx0XHRcdFx0XHRcdGNsYXNzZXMucHVzaChrZXkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBjbGFzc2VzLmpvaW4oJyAnKTtcblx0fVxuXG5cdGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuXHRcdGNsYXNzTmFtZXMuZGVmYXVsdCA9IGNsYXNzTmFtZXM7XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBjbGFzc05hbWVzO1xuXHR9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGRlZmluZS5hbWQgPT09ICdvYmplY3QnICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyByZWdpc3RlciBhcyAnY2xhc3NuYW1lcycsIGNvbnNpc3RlbnQgd2l0aCBucG0gcGFja2FnZSBuYW1lXG5cdFx0ZGVmaW5lKCdjbGFzc25hbWVzJywgW10sIGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiBjbGFzc05hbWVzO1xuXHRcdH0pO1xuXHR9IGVsc2Uge1xuXHRcdHdpbmRvdy5jbGFzc05hbWVzID0gY2xhc3NOYW1lcztcblx0fVxufSgpKTtcbiIsIi8vIEltcG9ydHNcbnZhciBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qc1wiKTtcbmV4cG9ydHMgPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18odHJ1ZSk7XG4vLyBNb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIkBrZXlmcmFtZXMgR3JhaW5fZ3JhaW5fX2hWRlIwIHtcXG4gIDAlLFxcbiAgMTAwJSB7IHRyYW5zZm9ybTogdHJhbnNsYXRlKDAsIDApOyB9XFxuXFxuICAxMCUgeyB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgtNSUsIC0xMCUpOyB9XFxuICAyMCUgeyB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgtMTUlLCA1JSk7IH1cXG4gIDMwJSB7IHRyYW5zZm9ybTogdHJhbnNsYXRlKDclLCAtMjUlKTsgfVxcbiAgNDAlIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGUoLTUlLCAyNSUpOyB9XFxuICA1MCUgeyB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgtMTUlLCAxMCUpOyB9XFxuICA2MCUgeyB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgxNSUsIDAlKTsgfVxcbiAgNzAlIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGUoMCUsIDE1JSk7IH1cXG4gIDgwJSB7IHRyYW5zZm9ybTogdHJhbnNsYXRlKDMlLCAzMCUpOyB9XFxuICA5MCUgeyB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgtMTAlLCAxMCUpOyB9XFxufVxcblxcbi5HcmFpbl9ncmFpbl9faFZGUjAge1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgei1pbmRleDogMDtcXG59XFxuXFxuLkdyYWluX2dyYWluX19oVkZSMDo6YWZ0ZXIge1xcbiAgY29udGVudDogXFxcIlxcXCI7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB0b3A6IC0xMDAlO1xcbiAgbGVmdDogLTEwMCU7XFxuICB3aWR0aDogMzAwJTtcXG4gIGhlaWdodDogMzAwJTtcXG4gIG9wYWNpdHk6IDAuNDtcXG4gIGJhY2tncm91bmQtaW1hZ2U6IHVybChcXFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFWNEFBQUZlQWdNQUFBQ3dSWitKQUFBQURGQk1WRVZ5Y25MWDE5Y3FLaXFIaDRlNkhiUHhBQUFBQkhSU1RsTUVFQkFaRG43b0xBQUFjYzlKUkVGVWVBRUZ3UTlBRTRYK0FQRHYzWFl3am44RDc0YVI0a0RSMjJDQ1BqQTExTnRnZ3NNL3QzSGp6MEJBeXhvb2laV0YrTzgybUNDV2dnMzBXVTl2ZytrWW90Z2JhdjdRQmtvWnZmY2FCbXE4bmcyTEYySytoa21SV2YwK0g4QWhhQVA1cEU0dnJLRmpnUE15dnhFcThqc0RnWm9iQkRaYkFmUHVtWjZVdHFGWXJOU05PRnBqeEZyZjNEK0dZUjJxczBROXlPd2ZJZUxMckFaV0xrME15cTJmTTlSUTlPM2grNGZYa3dPT2w0dVRZY1lQSjJyK3FsNVBoZXdRS3JObFNwTFJ2VWZTUEhyOWMwQ2NWNUVOa2tGMTFJWW4rWjJsbE84d01vdXlxcTZsOElHb1dSZWtwd0VlaWRUQ1JGaXFYNUJkMmhDQWNqZHpFRFJjY3N1U0ZYb3RSZ3JZK3JTbEcrUnFwWk5xUVhKbmIycmdCTDEwQkljRW1udnh3cWx3dzhKaDhZZHIyWGRrT3IzMEZsK3hVQjU1RXUvaVg1N0ZNcVBHN3hpOWMrNUFvSWsrMUlkc01SOFBwcHNwcjZDV09hWDQ1OEtMa0F5MmRDVC9tNlNtUjRzVmpKNGxtRy9TbzZLOFpzQTA2RW5RZlRiT1hvNHN0M2poN0s0N1pNZEFDenJpWkdMUXJtNzFScS91KzVGWFI5bU5peW5OM3MzMlk5OWttWTg1Z2Vpc1JUbkRIemhTZmNsY0NRNHluYjJIZlVVZWI2ZnZVTkc2MFRkV1NvWkZRR3dVRVhEdWp5c1hQL3lwU2k4bTRsKy9ocWdPVzhPN2JHaXdoOGFLSTdwMG0vK3R0a24wTmNJc2Zad2pNRG9mU0VDMGY5cHNoQ2hObFQ5cGQ5SFF6MnBXQnBpS28wNTBUTTJwaWpudmZIT1BPT2NnNkZNcHZmQ0hheS8rT1RMMWxORmlaTzdITnBYdlpJVk1IQkRzMDVhV3FCYUFzdXdkMFhxSERVcFRnd3JWT01zSFQ2N1RydTdvVEtYU1BVVVBhU2NOaGN3SDh0YjIxZkxIdDZ6QXZ1bndCMmFBenF4Vng3Vm5QNkVGZXZWSjRvcDNMMFptUnRSZG54aEpsYlVSV1ZSRXBmYTF3SGNIZnhoZnFteVRpbDZtMWhTdXdWa25Qcm1PVnJ2MFdMdW1XUi9OSXFWd3pvREI0MGZ2NUUyV2lpa2hpOTdpS0xpS2I5VDh2WGQ3dXpnL0ZacUpCa2dDQWdJSGJ2NFlSL2JGSTRGMGVpOS9NWEoyenJnME1pTDNzS0ZMcXdZblloeEhTekIwR012eDJNSi9XZnJ6ckNBT1ZncWt4RjUrRkdGaEtVOFRFVEZaeVRtVzRPZU5nRjdpOVdVaVFtdDhjU2pPV2R2NjVWSzY4blJ6ZHFmWmtqK0hMWHBDa0dMQjFCUkxPTEN1dk82SDc1V3RNV2dXNVRNRnBZVTRFeC9GWHoxSWUrQ0cwd0Q2TWlJcG1tcHB6dXorYm9TUjZrejBobGxKNTV4VlVrZFlJYjFMdWF2c2k2aUh2UmNiTUU4Z0gzMnJZUmpaWStWbDA4TGNxWit5eUtDS21uM3Jpakc5Qk5ITGNaS1NLOUx5WGNnbjlXSUJEelpmRVZiZmFreVlkczhEb1kyZXVvK0xTV2x1QjZJdVdCMHdGTEE4SitqemRZdFNhdzBZVlJsN00vQXpUVzNETE4raDF4dHc1U20rTkhnOWhwRWFsK09YZytvNGtWNm1xdk9NMGxsVUQ0TWU2czFoNE1GYlh3dUYzbEQzZi9vdVpJa2VEbUJuenFaRjllNllHcHBickEvM3JuWWlyY09aQjRpcjZua0dIZmVaQXFxdCtEYjc5UDJHT2RacnpIZTZjNFphUmIzODE3NnY5RHlsRkx1UHRWYzgxc0RoeHJxYnRKK0J3THFtc2pBMytTUUIyVFdHUEd5OWFCdmFnMytoblBLaWF6U1dDTzdadk51a21uQmN3YzdwRUdRRFJiMWEyL1ZEem5pY05lcWRsVS9hZEo4K2VsYy9xczRuWmpSemxCQjNrTzNiWXdkZ2NWc3pKWko2SUxBdVp5dnVKdTlSU21NemtrSStRZlhsdU10QURDc1hYVCtQOFVROFFTZ3FMWXZkRWp3aWRyMXgyUkdWYllKOTRkQ1FPZ3V6UDlBT1dVSlpIMFlSYmQyTjlJS0VuWUg4UHhCTzBMUGtjbFh3TGorRXZ2bEtneWo0cFpqdjkwWkw3TzdpSE5UNEdPa29GSGJyZDM1REJXM21BbG1oN0Q0ejM1MGJjOXloM0RPalFXTGJySS82U3FlbkVkVlhOTWt3RjJzalhZVDcwa2ZLZlRJMjhHZ2RnYUo4M3FaOFdVVXlQR2RjNEJVR2J4UDgrWFVWNHUzT0dCRnhldVJCb0I2S0JmdllxbjlkdG51YmVaKzJWbkI3eUd2SnlaT0hOWE1odmFVTVF4Q3hPc0k2clB2NlhPeklpTVh3Wnp0TUMxaEx3SEozS2lEYVRWa3lZekpvT3pCM0xkTnd0QTRjMUN4SkxTZXF4ZUxNOWllTWZjSlBZaHUwSHlPd1M4M0hWZEZUV2RHOWpFZ2Q4Y1luZWxxWkZlN3ZvcDkwRHhocUk5dXphZEsrVWtJd2dyNDV3UjQrZGZQbnVtUUJSbmlnNTZvNk80Q0JFdHlXNVVxcDRCdG9zc3lSL3JDVVJ3T09CYTRCR0FabkFjM3NZclpwM3lwSlBZbWlOVitqakM0TGJiR0s4diszS2xhNXVlZ2dFVUVzWTBJQ0kydm9sMjZhNytGSTBtTmUxeDBDMEkzYjlzUDVBMWRWTW5WRDdTTnBFdHFvanhaVi8vdGVKUTlkZTE5dENpRytZM1RmckhKTjRFRXJ6RkVjcnNjMWNkeEZyLzlubUlTMFFPdmZmWUNuYmd6YXA0U3JsRm1aRzdUbENCcmdqZGMya3pSOGhwdmM4UFNjRlZObW5SbkNlVWx6UGlLbURibHBrNVNvZE5acVI2eGJ1UGY5WTVxaCt6MEZTdFh0VTNoMCs0TlNSZEl3dGlOSUdaR0J3MlpLaXZlemd1MjFqalB5SW1xNm5VN0N3RERBaHVwNVVHcU9MNXk0NWxvUkg1NDVYQUxoNGI4d1o2ejhDRHRKeUxKdnQzaEE1dDZ5NHY4WTNkU0NiMGlseG53Q1VFOHN2VUtqaVJsY1U2MnRtdm0wa3JKVW81WGljTXhlNTlLV084UFhKYkZOdVU1OWxMOExzSnlaMmIrMHJkMS8rdno1NFhBSW1xMVduamxodTJNWVpQKzRjL3UyVVI4K1hDRzR6QkMvdjZ4T3dXYzFoOUxBWUNtbWpHakpzRzdmRjd1R24ycVpYOWFobzVQV3pINDVGMXNlZCtUOGhwNm1ZYW4yVG5jeVdIOHhaYVp5ZXJUVjVab0tGMWdKaGtPeWYydzJWTVM4N3RYdjNUcTgycnRkeCttRmsxNGk3WkFldzJqUS9XTW5kcjVuWGRUUGltTlRWbEN5WHlyUU1iczFiOWdvVXFqRnJlZjYyalAwaWZDcEE2QUI1MUFxbUY3Y3JaRkFLWHBBWDh4ZkdQdnZJYVl5RDBOTjQzRWQxOXNERGUrUGdXUElNTStpUkMramZTZEMrb21PWnhvSnJ4Y3JBcEQwaTQzVTJyMDRPdmlidmxpR01iSDkzY3Ava0FwRWlBSFlPWkZmL0dUdVNzOEdNQmtoaWdsUWlMOGNpcXRmcEowcTVuR2gvTU5mSlYvbjlOVmVmWG1yam1QQ2hYaERReXhQamxQenZTSzlqVW4vUXRQeEVGOWJaZjZVQ3dkRFVLdzNyanZON2trVkp5eHg4MkNuSXRSTm1tQjZWamhpeThUb284emVva2EvMEFXQjRyWm9UTmN3Z2o3aDY0bjYyMWZmOERYdm9NR25kWnlKQm1XYnhFV0FTQmVnRmFRRndCVXRzOE1TRHJKTlVwbms0Q3I2eEt3emh4NDNBQ0FsNU5qOFFxVDRhSVBpdlBCMUxpMWl3NnoyTFBCRzUxZklCZGZOaGxpMlZvYUZHYzZjT0RtVHpKY3Y5S0NIV01VdHBSNjM1T2RVYk0wUW5PeFpKRzlpTVVlb0hvK21PYlRKV0lsbnNSZTdoWXdIZUMyQ1pFOEZYQitFV0RLSXJwV2xhNzk5L1ZpeXZ2N2phTUVSRzgyLzRTMzVlQ3ptRXZHT0lZdXBVV09LYkNuaDdpRFJ3QXU1WmdRMmF2NUZZUHpTcFFoQ2czQy9LQ1pBWlVKWTNiRVo3VUUrQnBJSUhwb2M2WjlQNDkxa0VDM1lZTmUrc3Z0cjRtZnpKYTl5VkZuRXYyRXNXV3hoNjQ1WmJaNDVBc3lCbGEweFhyYmJsb1I1MlNGTnplQ0dtVWdiTDdMOXJLdUQ4TDBRWTB2ZlFlZjZISkZEVjJvYllRTXBaYjJ0TDMzdXhNOEtJejJDaVRhS0dDbnEySzB5Y1JmZllGaEE1R0xOUjRTNXJwOUhvbmpaL1JUUmhuSHFaLzRjcm1PTE5kUGVTekh3UDI2dDlkempJMEhyYUd1WDQvKzJQdElsdndoenZoM3l3Q1lNSlBlK2xjcUdQTE80U0pQdVdYejdnWkdscmhJYW1kK1N4NGhSQmhmdW5vWmJXTUU2QVdFeW9qMml4TnQ0WGx5NzVzUGdjLzI3aUhQWE9oZEdyQ1Y4c1hpbmtyQ2VJMk9DZnhsY1dkaTdkZE5icFVDZFRaV2MrclpOUHV5THNDR0lJUW94OWZFZGl5UU43TSsvNU9zK3dCazBYdThBRmd6YmYzUEtTbUNZTmVyRGpxTFQycmFUay8zSTBLcFlSUk5OQzU0UWRtdldIdUVjUFZFb0dWN2xHVmFxLzVDQ2FZeFVjYnAzY09qc1ZHUXdIeEkyZ1dmKys3RVpSK3E1YThXR0cwc0RBREZFOVdiS243cGMvSGlkVUE5NkpLbEdhU1FrcDdUUDlZK3phM0l2YU1BY05nVGFWNDF1TVlQUW1QN1lEUkxEZGdBd2FGZ3RWSWtlcGRCRWkrYldwR0RpOGUwdUxVYng1M085SnJwV1MxVFZReTB0Z05wRHltb09wSUI2UHZTUE45emRQdzlDbHlMS0hCejF1SmQxckFVSHBkODEzUkNGYUpqcFlIK29WdDBKVU9TSzlTSDI3M3VBMmhVMVF0SkVRc1NiZjNuTVk4czdsalErUXpGREJLMld6UXVtNVdoM3hnTW10d0dEMlhITGxBcmxCazRNNHJaZkZBZTk4VGdTYUdONVJiNXRzL2RoRU0weDk4MDM5TFMrRkN4bFNIRlZ6YkJFcVBVUTZEdlNPVElFdWZRRkZwWnZOUDJTeFdPZHRXWWhZQXNiYVdnT1VRQ3VYVjVnMUdyK1hxdE5GSW5aVGVmSi84MW5Qb21weExocnlHc2ZEdFJHbE8zSTRoQ0xzb1RyelFCUWg1azNTakhsTFJoTFRsdU5pY2lOUElYeGZBQjMzdkY2VUdsR1FvMVZTZ1FsOU9sT042L2dQekpFaFgyMTVjWDBoNGhXanYvbHlWSm10bk0rbE96YTBWVFVjUEMzMHVpc21wdTVWMUxUVGVrajc5b1lMM2pDL3FVUGx1UmYycWFJNCtZUkl1UUp0UmVUT2NldUpNM1ZsVzFLNzVlUzIySk95RVVKWnhSWEo1NFpRakVma2kzQWxWbkI1M2hIOUltL091VXM3T3BOMVJjSElYVDB6Yk9OSmI4U3AwM0s2MEUvNk1YUTI3ZmhZUEMxbVZON3FEZ3ZMUWxyL1ZrNkc1dTlRN0FTb29PTkRvRWxGbHNiZkRTcExlMjFkUW1HNFExQnlsY09NVGZPZW9NKzQ1M1kvMTJ6OWNxSEdkdC9NYkpZcHJyZngrMkpXTmtVK1p0ZUd5akswbk9nVksxMkFpOWx4RTZmUDZ1NHhhUGpENEp3Q0crb3hZUHBUak1nUDZMaGpDVmVjc1VUU0Z6WVlJcHIrVnoxcU11SzNHMU5DclU5a1dxUlVTMy8xcldaNUFYbXFVVktJMmd0V3ZBMmc0ZlpzaG9oSHdPQm5sNHFaOXRmazdhOWRaV05GR0VhQjA5NW91VERSNjg2czZpcVRNN0RaK0FtdTRYV25UN29EUFZIYmk4NGRudk8ySllvMWVPNEZ5TTBLUTNNMDNvSno5ai9iWVJZTElSZ1pLdUppNzA1QUY4VGMvcHJXYlFXdGExMnQ0WktGZm5oODdiQUhyNWlGOGFlZE51TEpLTGpxWXhXYk0zeWJxTFlpS3lHckt2ZjVmN1pZRTFxcksxU2Z6dGF3cERZa1VoRDdrZ1lpcERpRlNHbmNycjJtdWhqdzR2dWMvRFdrVDV4UDdIam5qeDgrSHZPd0k0VGpsSFZOMy9nSDVFRWc1N3FvcEh6UVd5Y3lXUEw4aU1iR09rSXRzYkc1cDJ4MkRpZFVCUWZZY0FUWFl2UHZoQWRRRFBaWG9jNks2U3JOV0owN3UxUGJrVURRTjFGQ0t5SEtMbVVYbElocW9vS3IyVmExV1BWdUlYbUc4Um9KTmRVanVHOEl0M01lNUZNa1lyTHpqZ2hhL3lTUW5WT2FSWGlDeElTYWVHSTJuWEY5ZkFUdTB6TkVGcmFKUXFjTWcwWU1TbndGNjNFR2sxallSY2xSR3QzNDVraDFlQXcwd0YxUktKbzBEUGpJUmh5YTdJd3dVQjluNm51TS9UNG9iTFhPeTArVXVjZDVLK3RVYkxlVFJPenhDSjhNUmRZOWowZEROZ1d6eGZJcnFuTlZia3pwU0I5K3NFc21jNmt6MllqMUplejY1bWdyRkFIN25FdkZUWWNRaC96RjlGYmxhZS9FZ1RuQmtuZWM1TG1kMm9ldk9MRXVzaElqLzZ5YnFzMnYyckcrTkhVS09aUDRBMi9yZVNTTGR1b0dHUkhXOVZTeVZtQW9NN1hEblVhVEJ0eWlsTEQwd1NXb2RqZS9kZC9JRHB4eStjZGNOdVpKdkFzdnVodVhVY3FXWWxUZUkySWpzaHdZbFNZTk5OU3lyejlNMTZWa3piU1A4ZjdKLzJ6N3U3S3hoUW42alJnQWxQVlBPR1hqUkJHdnZYeGtHSEdnRmcwcnpwTXFXNCthOUtvenM3YWlMK2JYUi9FNWljaXlrQlBXK3NZNUROQ3AzQnYvdklvT21KbWNMRHZGek1udExZZEdId3JkV0JqbG00UitnMzJmQnBEeWRBYURRYVk4bi9BTkFMdWIvRU9JUksrSVdSZVZUQjk4TE5OdlNvc2dXSXBDclY4bHBWVEpGUTRWTTJDZGpwTFkwb1RGbXFXU202WkNNR3JBNTEvbmo3R01YWDlBWFgxTzYwTXQ3dzlRd2lKR20xK3JBaDFZcFkrRUFHa2p0Y2lsQk1ZVVhpMFlOQmVyeEJOZFNGMlIyYzBiQ2RHdDlvcWtuTXZieFE2Qlp6UWdHSFNIZXNCR0hpcnFSVC9ldW9GVjN2dUVZK3ZKUCt4bWF0ZnF0MDVBKzlHQjdRYUVlcUdYaG5PQUloZENJTzVlSzJTamg3dTVwbXBvNDVnWXVISGZpVWJkOWJlN05UdFlBY0pKZlp1Y1dpVStWMWFlTmtnZ3NEU3JoWSs5SThBTWVaYjNLMitobnR4OHdVNmxEQnI2YWdid1lMOEpSZlltUUhTNmtwb2xBYytTNytON1ZiQjg4UWtrZU1UaHJ4SWpvRzJOaThlblp2WUVENTNndXZwRENYOTc2N2dwWDJzQkVNUEkzRTg2bmozaXRZWXlVMWgyY3hhLzRGd09GbDZCUE5WVzUycVM0VytOWlhCbXRVMkdqamdxbENiZm9lTlRpNmVPd3ZEU0JxWmJjUzBDSzNHRHRwTjhkSWJvcXFCR3B2UkZtQ3F4blpsS2UrN212NWdTUUw1cjVNRS9NQlFpRy9lM2dBNW1jUUY1MWtFVlFET0IrTkt4Qktsb2NYd2JsWGp5czJEUm1hcDcxOEVUaW9KUFU0TWhiWnJNVE5GQnZzV1dNNktPT2FNZVNvdEhqMFRpaWd6dHRpdUhicVh0bU1NV3pLQmdhMlN3UHlYOVRkNzhqWThONW9iZGJCMFlhT2NsMG1SNy9QV0tCa1lDbTB1OWpDYk9SbitJd3VPQWRBRXIvVmViWDhUY3pxWllQcUZhLzlBaHVuelNtMHVoa2ZIcXlVdDNVaHBGcWFvMkVvdWJPaXZlYkpEelQ0K1hqSngwbHNTTkJYU2NoejJmOUVBSU8zZS9BVDl0UlNHQXRWS3BhNXZZQXVxMEdRNEc1cWp0VVhQZW9vYzBxVEdhVktnMzFOTDZnbjhkM1cxQ0YrMmEyUEN6eWZScFhSb3VtSWl5djY2dDJaa1VlWnRGN3YvNTJQbUtoRkR1VVZLN1JlOEJ3bXNqWEdqZ3p4WWx0T0lNdmZBNXk5ejhRbDBVa2l6dnBqWmM1VjFPT2NnZXhoQkZlTWdWVEdaUGVveURSTkxQMWZ4SkNac2xuVDJHL2pqSTJZZEJ3WWtPNU1xMWVaaHdROVlKQ05OcE0xeWl3d0toL0I0OFNhNkM4aVZpSnJXMWJYYW1VRjNQcEZuVW83RnJoejhnbkJSQVVPcTFzSmVBSkJqMVZ2VmZRQ1dHY3dGV1M0VmtxeWRiWjhjeDFFa1d5VVR1eHE4eXlFZnUrb0lvd0RsSGxzTnVCTXIzYWZkbWd5cjNhdElUUTFOdGVrUjgrSmVWUzF5bFFiSTFyeitRWDBPMFlic1VnZXJXdXJSV0p4M2hPcHhvMHhOYTlQUFJweVpuSm1HcUFCd2xLUHUrdXVSVjZwcmh1MEtxR0thVlQ4NjBXbWtEVFVETExBa1RtdE1hSGNzaUh1WlIxM0hOT3Jnd0M4VmlOV2d6REE2T3A0Ni9FZUhTL2NpL29peG8zdlhVNEY0YkRDTmMzSjVPUkNQQmNNWDNVaDJuLzVON1lLR1VENTJpMUJjaEVGM0ZjSGJhbXVmOHBBM1JKVThVQ0ZZUXM2NmNwb1gxNW1JOE9MSVJpeDlhTjFZQ1BacXFLampLZG42SUt1MXhkamx2cThoUkV5ZWs3WTNTemp4WlcxcFpLUk52UytnMnJUT0dEWGQrcC9jNW84UkI5cFI3aGNORlZRVTgwQVRGL0ZoWEwrdi9Xa0J6L2lHek0wRThVZmpNS1pmSzlVR2ExZkszZ3hzT0hMYTlQS3VHOWltQ2VhYitlalJPUi9SbHo3VEo5a2JzQzJKTzhZSDl3Qnp4SnBQYUxoQWMrQkVhNFZQdHFFaFZhcFZNQUJpb2xhMFJONjU5NkJ2SmpmWGRqVjdvN3B0QWJjQkphaHovaGUxK2FLVVhYK1k5ZWpVRHAxc0RjNWM0d2d6UHVYVG45SVh1N1pxMkxSWTVoZ0hubkw3aHpFQjhmTjVsUGxZTXkrZTFYeGFLdEE5a0lLVkZMS1haTzBiY0VERkhTR0trdUtkWFZFODdnTHFmLzdsbm94YjZOSS91Q2wwdHJLR0trSzlBNEtpNU5ZaW56NGNKK1VQc2cyaGMvUHVjTUtlQytiN3E4NHBXS2tkVDhNemJqQ2FPV3BkWHFjVUxCakJObVVYcEI4d2N5a3pvMFhrTGJmNzJGV1JFL1V5dGppdjhBbytncHEvQnBLMVFWSGswWFVMdmlua3NYVllxVHorZjF5d3BsTnliQmplN0dsQ1BOUnJqTTdlR3JiU1ZIb3J2eUVOaGs5ZkVJT0ZNZTJnZy9PUjNtenZzM255SU9WL0xZVHVQeWUwNGRJWlBLSnZvNmpDTjdDWktpczdMZGJFb0JWRms5bm1sbmd3U2wwSUFNMEh0RmgyN2FDek1MbzhrRGtkeDZVbUgvcStrSEh5b203VUs0WjNhVk1tKytFMjIwdlZrcnF6SzhyWmVkRWtVWUJyTWNYSEhTN3JzMkFob1VZUTEwSEN4cDZpeE9sOU5scUtjaFFiVWtBclZjUDhEU0RWQVRtNmZJd0dqRmhRUDU1dklHbDBvWE1WUGhPU1lXTWFwcmIzekI0RnBMVHVuK3B2QTNsOGMyQmRZS01TVXlFOEl6THMyQ09FdVhNOFR1R1ZIM2huaEhJZnRaSm85cXVmSUhTb1hWc0tKT2RmTXZnYUwwR0FiWXR2LzcvTng0SkxpZHpmRUwxQTBnaklvOWd5dFVZSjZ2QWczQi9yNTBCeXV1N2QwdER3b1EyUHBRenFDVnNZWVN4VDNRa1dzdlVZQmMzTnFnNDJYTkp2ak5CcEVxTnE3eFJKQ2taNjVuYlRicmpWcExOOUVTUVU5eTg1RDRRUWpRWW8vN3lwTWt1VkNscGxZZWhjYUg3aUpVNHI3SFh2aGo5N1VYa2VCVDk2eUVLSnlMdzlvajE0bVRFK2c2R240cXFDaCsya0tsclUwakNsaml4YnR6VGdsQWVMSTJ6bHdaNWxuYnBlMVQxdWNCOXJrRUk1ZXE1amZmTlZtaEhvU2VIU2VkL1FxMTd4NWZ5NUkxdXpqSjRsa0xLdnZvdURrR1FkN3NUalUvTTIwbnArNkdJVk5mdzlkdTQ1OE1Bdk5VK3dkWWhndzc5QzR6bmJzczNBK0RXQ200WVFVL2dySTFLNDlmWCtqZ01ydnRMMUxiU1JlV2ZuQlN0L0JQN2ZyOTlKZjdnb0szSTRoWEJnQ2VhV2J2aitvcnVSbktjYkp6bjJDZXphbFc0NkYrNVJJelhYZnc2bnlVQTY3TTltbEc4YVJ4c3JLZDNCaGhDWElLNnpGSFJEdjB4YzI3Tmw3cjhXdHNHWGVIQ0hzcTh4R1VjUHg0N3hRVFBZNXNSbTRYejhOay84OHFOVnExMGY0T0tTcTRKRzM5Z0RIQkorQTR1UHBjME50UDZIVmNkdmU2UHM5bnJOZ1RCYlFZYndWZ0tLQ0VwaE0zRWVsYlA4V08zU0YwQ1VkRnhaUmovMUo0ZUhkYlphMUxQQXduZUI0Y1c4QmhaeXlGMjVmYW5MYjF4Y1ZsWTFyaWZWb1FaUzdGNThrVmVpc3ZKUGg3UDNuY0o3TWVXWis0TWdFZXFVTExoNGlOdHpvc1VZS2xKRG1yaEs1TGRxczdUVlBnYTdZYkdwenlCamtaYVE4RktpWDNOWEYybFpvSFBFbVpmSFh2MjJwVGJuaDZMQTNDNnRVbksrWjlkY1QramZsVm5BdXhXcGdRTUtCbHJId2ZNelQzR3dhTEowSXkwb3N2UE9FQ1BUamV0RjRiRFVOZHdCZWd5VC9rYnFvN2ttUXpJVndqWWdXYzE1cnpZRFJldmxQWVkxaUU5U0tDWk1qdy9YeWVmRVR5RnExcGtHV0hNWURpVXgxSFNzejA4d3dDcVBOZ2g5eWYza3ZWZGNvczU1TWlYd1dHZWNtWVl0aE10RXE2T1lHOGkvbVhmd2Y1QnJMZWxFY0ZISTUzUURQdmoyWjhhNmoyNlBLRzgveWNkakxBeFdjcm1MUDhMTUhZSEV6TUVuZmhyZDR3WW95SXFVNkdQaHlBdTJlQmtUbW5WcHlFWXBNTjZRa1Q4TGUvZ2JkNTRnTU9TSkM4UzRoWXY1anNvUEhBQ1dDMysxRGhSQzJPZGN0bFk5Rlloamd2NVRBeDNWeFZMT1MyTlBWbGhpdlhoNEYwQ1ovN2prblJpcFdxN0FnaGkwc2JaNzNMVmNhTk1vcXdvRm14OGV2a1FaemtxMmRNcFJVWks0YTE1TUU1Ty9Zb01YeTdTRy9qQkxsMVlWTlBHby8vdE9SZUFuL0RtdXVqaVpnMGluYlRlU2JyNTdEcVJRNnE5eU5jU0k5dVpjQ3dHQnByRlNlL1owcU9hMXk0TVQyV2l1TlpDUUYvNGhDY2JHbVNDS3FSUHFyalA1WkVuejZpRjlLSjJtY0JubWZWeEQvdHdwU2ppTXAzVGZMbS9CRUtLeitlZUk5TWJpZGhVUGxHalhnNEdBajNkcFd3NldJMVc2eW56SEFjeXdiNmdyTG0rWUplTkxRL2JtRGpXMGYxZTFkZHV0ODBpaHFuSXRXMnhaM2FpTmgrVGZEODBOU1EwZ0NKNmxZcUxUOU45dFB6RG1FSzl3dTRjWk10ZTB1aEdrQ1EvMW1tdFhBWVMybGZVRXloWGdjMzM1cE1vSGpKN0FIdkZZU1lDVjIwTWtaTys3TUIxL2hCZ2kxeTJjTEd0a05qbXNWZTl2eUhKYmNKb25wREdHcldsUzhvWGZyNGtMRkhBa0gwdVhRekpBeDBTakhGc0xsRTJUZ3VWd3R1R0djS2N3WGdNckY5SGhpVXM1ckRqOXYxOFNCSlloY1VBWGhOSVlrWjlTWVBxdmxSVG4xSVFESTkxS3lPdWZrREVSVlJTNW96czlhQStaSTFNNlZCSXZnRFduQjJaR2VoUnJEVEZWQVMxSGQ2amlHaDdjYi9aWUdYT3pxbm1nQ3NOTXVnZHEyQmxrRU02UlJpTVZoUGMwVTBTM0R5MUpqTnBVbmtuTnRjc2I5cVlGck9ybjBwS3dESzM4Zk10aEJXek1KOTBBUGliZ1Zoa1VJcSszT011OGVmZlRqK2tGWWp2bzFXeXBBMXZCN0MxMVpHeG9JQmgvTXEyMWRFcCtQWmdlSGZRRXpmdE0vSFJBanZpMllHL0JEQ1FqWWJXRlZubXplelc5SHhlWWZCVlZXaC9ZUEhCRUU5VlhLNm1YNTNXWWdhazJpM0hnSTlMSEVDZ21lU0Q3bzZWbzRLTVI5ZUxKb2N1ZFZZaTFmdW5rZ2hZUHlzNzRqYlo3ODd4LzYyQXBGTWJJZkd3bTN4S3N2QmYvZVU3emEwUzc3aHpPMDVEOXM5N24yWTFsU1NwZWtuTVRBU1RFbkFzSFU5dHI1UFlmTE9RNmV1ZFp0VzEwdyt0VkdRbmpPM3hXUTVxY3o0MFBadmlzZk1xZnJWRzdRejdPNHh1TzRlcWdZcXdrL1ZtOFIyVXFiMXVoOVJjN3hZQk9XWC9hdVF0RDVxczNiVFdOQitaeE5aKzhvMWZPbTRqZmxIdkFtazN2ZktienR4Y2JwbE1UMUhCL3VVRWQ1Z0JGb1RodS90ZUswNkY5THhNZnpIbWJPMHpNR0ZidlF6U3Q1ZThDR2p4QTZJZEhLeWt4ZkRyVlpvaEhJSFNCaGY3anZZbW5melQ4MUYrclYrdlJLVFlHcmUrNHdTeTk1OGZaNVoxVGNxeXltTnBic29oa05ta1o5SVZhSWF0blNoTkdjQnNtSktKV3JYZmIzYTNwNC9SMVY4U3REa2tuaUFBK3RmalFmZ2NFTm5VaitFblgweDZjUHFoR01rak43MWI4b0taMVNCbTduVmh0ZWpQdmhoaWR6TzIvV3B5dlpaa3MrcWNVWGxTcEp5VFU1N2N4QzRTY0R2N1F6VGNMbE9XRHZrMkdBWmZ1YWlVQWhDS1ZxTy9xWmVRZExwWW1FVm9iU3kydEV1S25neWJHa1k0QlU3VzFxNkRvVlQ2WEdVVGVJUHJ1bUdNTzBGRlFOZnVObzA3S0RXMjExTndSSVQ2My94TW11UWZSU0lzRDNXYzNhbmFNQXZJbUFMaERBV0RxTCtQQlhDc21zVUQvUUJvYjgxbTRZdldSbXpCWHVLZzZrM3Z6MlhXUFV1VWR4a0UzdmpUekROOEd1bnFtTnhOdVVmeEwvMXY4NVFOamd2Sk5BMDNLY0RIeWU5SzFjOTRIYXdBVEFnTzlERmRKR0VSRUUxby92V2lyQ0R2ZHBNNnRQNkUyd0l3eERJRGFZM2doTlFSTVJMeFNFNU5EaWZ4NG43V1VwdUtkQkFEUkZuRGRXdkN5TUlTTk5hTGM2ZGNQU0ZPUFBDMjIxbzhxbndRMDBxQnlHbTIwMjVNeXZ5RWllM05rblhKc2xBN2VncU9OdHNod2pDZFRKclBvYnJpZlRzczZzb0RrYXl0Z2JNMnBtMnQrR2ViUGZ5SHd6V0k0QnNVNEJuL3Fjclh1Q3lEVVNqVXR2MlRkV3ZycVl6RjhSVi9qV0tIbGM2VkdyT09aRm1SYjlWdGw2K1pFV2xJU04ycHFBcTFCL1BQZk5sWWloY2JMaUo1RS9lQVl6bzhTQnVVTVUzODU5alozYkEwOFhwN0gyYVhwL25MTzRKcktHVk5idzQ5Zzk0RmVDYkJJK2ZFRVlVaktWbGN0am01WGI3SUdaZVh1R3l3cHhWTFRnbStpa21IUlpQQ2dibyt3K0liODRFNXNielhmMFp4MnhvbHVoTU8zM0c5b2pqWFQrTW9TYzRQVXdWUUZxWHdWWW9leTVVNTBod3RkVThIQXB2UWdKMTljRHAvc1FtUEtIK2pkc2FhTkYydUR5NTJwUkxYbC91d0txbEJpWGYzMTZycXpTUWVMWEw5ditNRVFybS90aEpDL0hQQ0FyenE5V1JXWlYyeStJcHNxbkY0VzY4RkVvbGptajhYblRwemZIc1JBYjViVWIxU3djREtwMXIxeVJ5NDNjYUhNR1NLc0hnOGRacVBHdzlmUjhwUlZBZHJNOCtmVXM1bW5NUmYyZVJ1MGV6QUNkdEo5blBOREwzckkyc3NxTHlYc0tjdHM2SmRhdDJsK3AxZVp6eEsyTWhyZ01pK2R5cEt6VUMveE9HUFVxMDlTeEhOeVZHdGs1RU44Tkg1Z1VKZ2dQUUxPT09vUzg1L1J1NXJKc2VuRnBrcUl0RlVTdWs1WHg5UGcvbEtNVWFwVm5jcE1Td2xscGUrV2VMRkpTc2dybVZLUTZocTZUV3hZV2dBWFR0OXQ5emJzT2hMTnU2OHFCN05vclpUQ0dOZTVpUW4wREVVd3lvak1qaDE1UExxOURZa0w3bVZTY0l6SHBESWxCS0xYQ1ZBak1DOW1MZlJGYU9tTFcvZzNseklrQXpwQ2pPYzdSRDFDcG5VN2ExRHV2dHVUYnhYYW00OUNCdGhOR0MyV2JlclhRQ0psdy9BVEpteXNGQ0dlWElGRGp3Vjl6L25oMXVmS3JmZkQ2WGt5YWFrSkM4SncwdzJRV0hWTk9idzkzNUVNcFFRbWVhc2hBQnBKNmNnYnVNbmVIS084U2pxbTBFTVBOQjhSQ0pFNzRnZXhheTJ6V090MWh6cjA5VXpzV2tScElkRFRYaHNyMGE0cHhVSTNMSE10L3YybGNCV2kxbGdiYzdDZzdwMms3eTB6QjZ2ZENvZFljTE5WdGlFMnQ4SGc1NDZ0ZWs3RmRiL2I4Ty96OWE4ekUzWGl6aWJqZ1pVSTdXRVk3VnJwOE54SlpiQm5yN0FLN0ptUFhocld0YXBDUXdYQjUya2tCMXRrb2l2WTdqWU9rLzhoSnI5M044S3grN3lsUUhuall3TzdZRVp4T1lxZTVxa0RmRXlncEpsTWVQdjJpNEZodjgzdGpBdVozVmxLQnhtL3RwRFpEOWk1ZDVhYXA2OVBMTWh1VmQ4NzRnTUdFMFlCdjFIZDRFWDJidTUrcVYreTliWGNrT2FGeVhEczluOXIvbVBidVdxeTJPMWllekRjenVGVDdRYmk3V1kydVA5SGhBN1duV3N1alNFN3l4NGlDKzNOczNjWEZsSms4bEh1eUhpc0tpVDJBNW10dkZIQWlvUDRPZm9URmNpY1QrekhwdFp2S3IrakllVThCRVRsTlRqYS91NXAxWFM1SEtmNnF5TStQUFlnWDAyTUEwMWNsWkdZakQ0WmxYL3lkT0JINHgrdTJpcXBUWHNoMjNpZXQ0cStRK01zeFg0NE8zZTV2NCtwa2NHTVlWMlB6Y3lWOTZ6NnpJaDJ1OTUwY1NBTlowZGt3aHJ2NXJ2ejRWSzJkNTkyb29YS1ZVUVp2UDZVdEppWm1DZ3QvTWdIL1R6V2JWelN2QTdjU083N3UxMFQ0Zm1iRDZNV2czWTV1Ym01ZkpnM2k5MllFMjA1NzJERDU4MWNzNVRBTHIrR0FsQ21Cbk00RlpjYlBvVGxQTmJqR05VekN6VlA3RjFHUzh4a2tSRVJtRWZ2TjJPSXI0RkFHdkFMUlY4VUY0ZlRES2ZETFJIR0VQMmJCTjJpdWMxakhmWmpQQ0pNdEozRmhwclZWa1pkMElBMHdwRWNqeHljZ1JNeFUwRmp6MitWdElGYmhEQ3hMeWRSbE1BaTROekhpUjJxV2d5WFZYZU1wNlY4R0JTREdKVVVkU2p2Vks2NUo5SVM2UytXSE9vWFUxN2Jsa2VBWGhpWTZRM2FmRHV0UU1TSWRRd2tHTWRiT1hqUGZoYjJUSzdlcGNmeW5TSk9OOEloVlZjRVVaMGlSc1FRQk44OEV4WTJXT0N5U2JOZFNJdnEzY2kzdEZ3TUVaSzZzYmRFRms2RTVKcjAzZlBrbGdHa1l3MDZHSGttdUpkbUdMaGxuWWRjaUFudSt5OUQ4WUM4RXRpRTFvcC9wMG1rTUt6aEN4NkZIV29OR1dnZFBDT1FaVDdqZFd6MmY0S1ZDQTNPQ05ta2FvMjZobE9HbTN4QjlzcGVwZUtlemI5Y3BOeExPRlN1aEF5bnNoUTRQWWYrV0lMQWY0b3p3dU5ScWR4RWZJanRJUkw3SlZ0VlkrWG85S0p2WHp2OFBQWGwrZHBabTMrakdWYisyNG1hWlV3K3BiV2RsNnl1b1ZmOHZSZTd0OUJTRlYwV05kRGJIL2VRWGhheHBaenBzNkROVW9DYysvWi9yT0N6SWxyMFpXMGIrekRRTDJsZ1UzaTFZMVA1Rm1QQXRLMDFISjN0MUFVUGo4emJEWTM3OWo1dE9WOCttYjlqTlI3VEV0aWVsWFowaDNybFFrWGV5WVRtVGdNWnUzV1lDQTVOZW14dkwvMkZBUlFldDBkZWRWWUpoMXFyZkh2N01KUUpPUkVwOTZvc0JSTkFDUkFmRnVwL3g1VStvWDA2ZnpEYnZaTGRzK1dpNXU4bFU1OXFJcXltdlQ4dzhidXk1TE5sbVRhYzd4NWdONm1HYy9HekN4NG1VbnQrWXVDOUc5WUt0UE1RYnRFbGRWYk5XU0xFelVIRS9FdFQyekVOTEhWdmtMR0VmNUxEVjNYUXNldTEyWHN6WW9SN21RaFYzbjh0K2lEYW16czJ0SUFPR2xxa3pLQW8zczVaR1VFTExvNU4zYTdHUC9pRmhpTTNQbnlQcHpiaW1ISmJlQkNoM3llNlozSUs1enYrQ1ZLN2FtaEx3Z3ZRdE82Vm1BWDQ1Y0ZzcFdCdlhMOUF5VFJsNkV5Vk9YSmFmUGI5SVVGemtNK1Z2UVVaNTkyTVdGM2hRUWhrWnI0UTd6VUFpSmsyZzdsQlQ0NDdHVHlBaGhnTkh6cVVrdHA5aXBaVytXTE8rU2RWZVRVcUk2TEc4aDRvRUpBeG5lb08zSFlxU2xJenBDUFFtZWsxbnFDcXMxczNNM1BwcjBHdkxHTkZlUUtVbVgvWHZESVo3bnpRc2F2TkVYUmVSYmJ4TktPOWRDVzZ5cS9iNDQ1RVpOdkNhWDNyKzB3R2RZOTltZUlOUDBRakcxd0VzTnJMdVNWTStNRkMxZ3BuenFNUVdIMm9DcmZNcGZNanRNbzFETTg1dDR3cU5aWW5IQkJUWHFVSW41bkxWMXRvN3pScmI0UzR1bHNFc3hNMzdORXJXU0xiSzJCcWVWQkg5TlZld3hMS0FPUlZ6a2lKOVFjNDNrTFNZNEZtYjBDVXBRTGhoYkZzWkYwOEpaWmJHSk5Sd2pIZFBJaFhDR3V6OWpVNk44c3Q1a1plVzBwd3ZGcVgrN2V0NjJlSjZteHllTzMzQmVmRmdCdERQZk91Nm8xS2tKU2JwQkxDWFFrWHdoYnBBVE9OaVF6ekZhM29YK0gydnpQRVJQODRIOVJmY2N6eWhZNERsZTBGcy9HdDQ1ZStITGIzdkdPZW9TYTA2YnVlN2Vzb3lXaW1BOXZjdGpmMUwreXZSRlN1MzhGak4xV1oxSkhiYlVCaUFWUFVtS0ZLZUR3Y0NaZFB2Nmo4OXVtMGRjbm5ONEhGYmtqbjVSMDU0RzdRQWZ6eFZISm82KzJ2OCs0TW83YTg4TEFCc1RiZDJFN1o5ZkMrWjAyMmU3SnFtQ3k4MzB1YmZ5MjlhVFk5L0t3aVlvTWZDNDNYV1hadlk1NEpQOEM1bUQrY01ZTnJucGJmMjQrSjFGNkdFTStUSEpDNk9TL0FINFoxU1psV05qOERCZVFsOWJvd1BOaGp3ZEJhQlRRY3lONmJYQk05UG1QaUo2OEVaQk1oWUQ1aVZHaVZPblhRdGlIZGw1enJYVGZ3RFR1YXpiZHRXVEhoaHJjeG1OSTliVTRKS3BaV2tQUlBORFFTMjN0WWNvbTVXZkFPK1FCanNDaTh2bUcrd0JPUDRZUmdlTXdlbVJnNS9UTEtHdXFEZHdBSWYxWEwyalB6SlprbU5xYmZ0dDVPaFlQeFhjNG4rNHBPSkZJRjUrV01jMUU4OGhhM05KYkpvU0UyOTMybXlWaHVQOVN2Vkt4VzlRMFJLeFRyS1FCYzVNYzIrbHpNWi96a3FKOEpndGpPQ0RWbnp5R0VvdmpMQ2ZxZ0s3dVdBNk03Z2RmQ0dsb0V3TmJ6SVdSR3JFamtScDE2bEFWRmJqSXNQdzhnN01SYnRiUXBQQ3F1Q1JjUHl4akVBalBHcVJ5UjlzSnREWUdmRkUwWllhN2xBaG00MVUraFl0bVcyRCt6VlRYVWtLUlp5cXg5L2xiU1hRVlVuSDNJUm05VXg1Mmk0WGt1Wk5hMGt3U3c0Ty9xMFpCb0JZTnl2M1pod0tTUWw1RzFtRXFOZ0VDRUw5cG1FeW94eCsxL3BtWVhjL2o4Q2lTUE0rRFlycFhZcDZoV1B3QzcyTnJ1VytjaEpwQXJLdElGRzFIdXFBaXQ3L3Qxc2M4MEpnWnI5Q2UzRk9XejBHNGk0dlhFcTBGSzJwQTJLMG5RVjZPUmFrMjdVOU1GdmtNREw4STdxN1l5NkNHNjdCYnJIZUZtaFZVa1dDU2ZPN2JoemNJTVh1akJvd21iemlvWHhkVFF2aTR4TVR5QkNVeDZIK0ExbytrZi9YSE1XVXZJeHE1SUVXV0dSNnhkZjRqcHo2TDF2YnV4SkpQbmZTYXd1ZFExZmV0dzhNdGdvTWpnRFB4TFM1dm80dnVYcEdtMWlyVjFVVmcwSkFielY0ckUxNTVYN25NM0VsRXRCRUhsZUFIbkttSUxoNGFkWXV6WHNmK3p4dDQrYkZ2OVh1bjUzSDd0MGVZYkw2clQrc01XTWFlR1grVk8vZkZ1Kzh1QktCV1B2SXJxSFlIRzA3TmpwRDJDemprL3poMWVURkR5bm5DSnFVMGNlay9vODUvOFFCeG0wSFVCVkFXMnEyYmxTYWg0Ly81RGZ6UXVPZkhvdFJOOGZOM1NIYmN0dFlwTnZyeXcwN29UNjBoMWxGTnAyeFplUXpvOHJZcWkrUE12OVMwSWt6Z0R6K1JWVlI5ckxRcHV6OVgvaGZ1dXEza0kvZGIvQVFYQnVyTlNDS0lPZEI1MUxyUzZ3QmJwWERtOGRVaEJ4YUNaZkpwVTNjMjFqOXZuRU9IbUEwYTFHMGZVQ1pYbk83cEwrK3JqWlRlNkVaKzlQV1psUU5RV25SanRyUWlXTTh4UGtiWDNmeWZ3dXMrTVFGMmtMNHZoNFkyYWszc2RVaDBQTlRWYmNGbTR5Q2NpY2FWUmtSQkJIMVNaRzVyWjdJSDRMbVhMWDZQOFE1VkFraG5BZHhIbTJ6VXRKOXBDcVZydGF5aTRReFE5b0RrLzFQcXBuOUtnTkZJdVdJOWg1VjY0UWdCczFDQWxLVEhNSHVCT3d6cTF3dkxxVWpUMk5kV2VOKzVYbTdkUnErVk5qTEVjVTR2My8yYXVVY0FKQ2hzcTFBazhSTnFaV2pKbXYyZVdvVHp3RU1HcHIzQ2dwZVhNQVU3NXJjYTBqRTBHTEVQTUNIcXpRcCsvVThBZzQxbFZDQjVuNnB2TUdrZlYycW43dGVpMUdDZ001TVM3QWt4S0ZxV3pCa1RQOTlLSWRrdGF5b0FaMzUra0M3TWdPcnNGVjFPT0xQVG9STkJXV3RVU2F6UWlVUzJOTUNmWTQ1OFJycGhpYWkrd2dtNzZ6N0NRdlkvV2FOVS9lVXBKVHQ1UUVIcnQ0TGNUSjFEUFRMU1pFS0RXT2NHN0o4NDVrbEE5a2FrWDc3ZXhTYVR1M25WVytqdk0xcnZ4NFJrU2ppWlNLQ2xDWm9qQkVOamJHaDIrNW92TjRPdWlJL0tkS0oxNnhLYmN1dkRMaHdZTC8vTmU3QlBiK0xST3g2L1NSQ2JyUjFxSTFHL0d5K0ZSaWxXaXgvNzYycnNyVDVQYmpxMnBiRGdySXZWZHdtREdHdVFrM25JbHd2T1lGRlNLM3ZLVFgyYXBYS1liWms5Q1BvV2VGTlZkNWNyTGN3OFZqamwzYm94WE84djhPYkQ3ZTlmenhFN0RNV0xPWHdZT3BZdzk4Y2puRUEvb3MwbTFPZWZJejhmeFhvYkhOVEhaakMvVWx1cTM3aDl0a0VtaDBZZ1lqeko0VGozL1FaTEhWZW5LK2FOc0xMOHB5NWpiRlRwYVpUdC95YkdxZlhHd09PZEd6U00yTmwwdFNsSWtkYmhqTjQya0piRmxFSXVGNjA0SmJnY0p0YnJXOVlhVEhtRjhyMjJzbThqNS9xYmNBd08rQ3l3ZXVubzRYM1czODYrSHl2REN5ZEZsbnFFMWRNaXlDb3k1Y3Y2UHAxSDMzNlFaaGtYUEY2RTJ6WlV4YkFYdUk3QVM0U2dMYWFRbWtLNEJNcE5ndWVjM01Vd0VpOTFmOVd4TEZzU0lXdjNBVFA4UVZVU2dHRkhJdUVOOThYMno1Q2ZOWGZ2dVFoVTRWcnZHOVQ4d3ljZ3JGb1ZYaUtNTmdRclpLR05KbzUyTitpMzlUVXBsV2NtL1F6QmhvTjd3WGk1SDdFQlk3T1dtKzU4V3F6T0VLNm5FUmpqMDZ3bk5tRzBjdUNwYXpCc3g1T21mTHBmdWcwcUUxV1lFUEMyTnFoTXNkYk40dUNuRGc0TkRYNmtnb0ZoMW1HVEZHTW1zWFVFVEFGamRmTnZMUm1KV1VjMTNZd29qNGxnUCthRTdmbkUxd3BLV2ZObFJaNS9vRzg5NXNHMW8zK3A5M1ZTeEo5aUQybGJRQk04OTZqNFRneFRmT3JBSHN4Z1lSdUYzL1dyN3J1Nk9JZzE1UXZQM2l3VGxrUTFwTVd5dVYyNG9SOGlMYU9OcFA2TDU1TGdVdHRnWlVGbmRlNklHekRJU0tDeERGbEh1N2NkWDNtSllJeDlOcCtXOGZYOUI0bWxGekMzenN3QkNTaU0rZnUyZGErZGNuYysvNnhoRGFEYmNhWW01alQwZGxoemZSNkRlTkIySG1Id0VHaE1WSkNTQUJ2WGFsb0l0YUgwQ2k1Njd1bzN2aWRIMWZRMDQzS1loREMzdDJzcUZYUDJwS251Yzg2OUI2eHVsNHFWMWZ6T2ZleHAxd25LdllGUmRtek9xVkY5WVF4OXFvdmN0NEpnZTNhT0VZOU5pK1lva01hUEZLd0Y1N2VLdEMrdldVWHZ1bk9iZzNtUnhucXFaY1FWZTgwSEY4dkpyVWliazF5MDVhOHJJbk5Fcng0bkw0VE5ways0MGsrc1JmWUNNdDg1OE1xb2MrN2hYMHpDNGR0WmNYaklVV2JFdzZoN2FrQVNBaWVXbHdNWHd0NXZEUTVtRHVjMDlFWVVtNW83SGxHc0w1eEo2RjdUUENSUHZ6U3FKRDFxcmJINWo5TmxNU2N2WmlDZjRIU3ZObENVcVFHU2YvWXdmZmpqSEZGNnZYWmUxZ0x1VVYwc0gxTHlOSG1qQW9FMUhBWEI2VXhxV3RJODFxZjdUTXp6eFQ4Yk9hYU9DY09HcW5ZSXhVaG14M3pnblh2MGNjTnF5b2JCb3lkSTFGL0ZmckZLeTdHVTdKZ1JzRlAvdGhxZ1VvMkJOVmRSWWErbWQxRTBkZitMTkg1emhIQ3FPQXp5Zm8yelUyNVpZckZ3NHhmTVlxZ2dPVDhDZVBOcDcxQXA0ck1wTURMSmltMURUNXc3QVRjRWF1VmU0QkNNUFphSHZsdHI1ZFFrM0kxMG5PRi9LYzZCL1FGRmF0aVBwcEtCSGF6L1FuQnpQQVdjWHVYNzVBdFFmSHBvbTBqallhbG9xRGQzczhGdW80SFN3U2ZGNGZSREhYd2JaaEJOUnBwdGVTNlZ4TWpickJKVHFWTHdlUlpqWmJaeTJsRVNsWjVGZHhzY3RYWUVVV2d1eHZ3MXhwQmdRYlR6b3VuMVJCeHlSa2dadWx2R0NlbUd3c3BkTy9rZ1UwekI1Myt3d1pqMnZaS2s1UnFDM3J2dDhxQk9aMzgxQjVlbjA0VXI1WFBET2VxdWgxT0MwekFIQjBzVitOSUkyMFdoTmFWUTVBWjBlY0tqbHlJMkUvVEcwY0lWVkJDa2ErMGlrM0I2ZmNQUUFqeEk4b0p4TmpKNTUrR05uTm1kU01saEd0TE0vQmtJM1d3VlY1VVFtdTFSbll0VGRORWJoVlFCQU02eDBNbWNqa0ROMkRYQWN4Q3A5Mmdnb21mUFM4TmN6OUYwN05xWVBDS0wrdWJkajVJeVZaRmJHVW9oUUxKbDY0ZUdvaHNKd01abWxzNVY5elJWVnRxeThWZjg0Vm4wMmw5TjFYTldkaGVhQVFFSnFwV2RyUkRDNWZ4aWhwOEVISnZ2M3Y3OVBGeFFKVnZ6QU1ETUs1eWdIRmgvNTIzUGY3VzF6cDkyTmtlNVRmaGZ0WGtyQzcvbFNTbExMYUx6Tmk1NnBtc1U1cFZIY3MxM2ZwMG5lL3lMdS9CTi9aUFBMTlVNWHY0WWdRZlpTMjUvRE16eXZYL1dCeVc0SnJWUHU4dFVucGVrRmtITlU2TjkxYjRYZ3U0cmNQWWt6cTdscjZyTjR4M0UwYkNvdG1WcHMwYjRXVGZ3N3lXQ0JOWjVaQjJiMS85d1k4LzV1ODZVZkttZUkzN1RYbkNxQXRHV2JWamFlMEVZTCtzNTdZTTE2RTJCSXFWSFV6SVNtTXlaM3dQNDF4VjBMUEFtM0JRZm82UzZlQUloN1R6TWdUcmsxRmFzbEVnMHdFdmgrcVdEOHQyc0JYMXZ5ZUJ5S3p6elZYSmNRTTZpSUx6QnVLRzB5OTg0RVFzMzRTdWVCaFlnNHhTRUhCc2o3U0dueFRkdS9xdHZSQVF1UGk0NE5xRUtTWVFXOTNpM1l5bFFYRkk0RmV0ODBNTUFqLzg2SzljMThIT0xmTDdtcWFTcDJQRlUyRUdkczFZTXFLMDlJYnVtbXZuOTNtN2c2RjRBTkZaSnQwOURxYTdHNGVDYmZnc2hia00xMGxsTlEvSmozOVQwSzFnVTJSWlJIbmxRQy9zVmMwMlpNMURsM1haYmNhOG92elA4SFg3RHR5MTJHbnVSb1U5VEJTaHQ0SVFYVHVrVzZieGlDdXVXRmlGekkvUjgydnpuU3F2OFlxY2dsZldRV0pKbytOU0R2YnptZTA3dFYvMnVlQzUvTUdsb3ZXKzBYMjdJQWlkMzVXaFVsc2VaWjNPOGdiK280cllGYStPY1BhYVgzUlRGWW1yYUMrbHZnZ0tEdkx1b0ZnTExzQVJHaVZqTnpia1hkOEV4cGFhYlNjeTdLa005ZyswV3lPcjNwcXZMaDVrRmhHdnpjbHRObnl3Y2JFUDRsWEVHb2VsOGIyUFlJZW1tcC9aMmw2MWh1d2ZFUnMxd1VyaVZrTUNmYzMwd0NGTkJ2eEJ4R1NsbVVJL1M5REhIZnkxUkd2cjZqazNURzJ1KzRjeW5VVDArZE0zbGs2dnVXUUo4dlgvb3pFWkxYcnh5Vjdmbk5VY3VjZU94RXR2RjkxQ1lXYzg3bXpBM2Q3SW8vQ3RHZW1iQ0dGc1BySEpVeU0yZnpuZlRPcFZPSWNwdjdJMTRiM2p6bWpqRHVHOUZPUldRQlhrditDM3lneG1JdGo5RVA1TTJZb2FCTTRQbkkyTzA3clQ4MkRRNWZsR3FxQ25zWm0yMVpZbjQzdit6alZxWnRKdUpOcndRYTlaeHAxS3E2djZyUXVBTzNibU4rTzdSakcxYlhuTHcyYjZUaVUrUkhFZXJRKzdoRUFHS2VaVW5pSEJwcDFHUWJ1eGpiZzcvaG00ZjFodm96UHZMR3BYcjF5NWpZVXNjNGczM2ZXTmcvRS9RdG5BK2tPcyszalVyVnc2K21zZ2hKT2FlNzgzNXBLU3JxWFBRUE1tQ2VmZEdQOVpKVzc2dUhFNkdVd0JoTWtVZGZzb0w4dUh1b1MzOHV1UElwbzZ1Zm8wa05UYi9KekFMUjRhK1lTb0svM2YzbWJ3azdYK1U0NkJLKzRxVzE2dklESkswcktEWkZPeTVubVcwVVpmRXhiby8vQXEwcXJMT25Cczl0cFFIUkhZUWJuaWVFTU83dWd0UFdrb2svQ2JuT1cwWTAxS3hKOTJCL3c5T2lOeTVsSXBTRWU3TXpuUDl4aUlaZU5zWWlwdlpJQmdsVVd6UmNJUGw3R1RQaVF1MWRNdDNncHU5N2Y5R3dJaXk2WFcwSFE5M21zNWcwZUhWemhveFl3TTJrVkdkdmZ6M0g2NElMZ29mbEpxTmxhOVdjVDFDK2pDSDRmcWV4RlNkcDBHY0ZHYU9vU0VieUI2SlcwM0wwU3hxOWlUZDJROGRFczFWLzhuRzlqc2Y2TnlnUk9weWs1dTNMajRVY1gveWsydGh3Tk5qendnOHppUmt0OXhDTk0wMjV2d1RCcExnSVlXT3dUUldiOEJzRUFNMWdkS0R4Zlk3amtaUUZ1M1VPSHhkQVZ5RlBZbk5kTGtrN0F6UjZ3SWtveS9HTWhWYVRieFpGLzRXbVRpS3NId2c3UDZZT3BHZFNwQWFOU2FCK0xUK0FLSlVxQzA4R3pLSktoWnYyY05BM2lLMVJOU09Nd0JONkt0amdnemU1SlV0alQ1M0dWeTIvRjlNZGtmNnROZEtrY0laSXpCK0xaRFN5T25hTkVkQVBQK0NiTXJpcFEvcEFjNkZQTlBCOFNVeXZFSFFxRTFhSTc5Z0RlbnQ0clVQdkJUVG5vRkpKS29ldWcwSXdlc2VpWExpYjFnM2U4eGF1MzVPMzNMUm0xMzFyTVI0UHJxRHlmNG5hbUtOYVdoYmFBUURMMWRXdzkrVFZKUzJtNytSZmVuT09JbW9URzdndzZpNjk4WGNVc09EcjhlbGlFRTE4VHF6WmMrdEFiYkF2L2J0ZmFuYzZsODVsTDZoMzVmVk4vVDBlM3lNcjM4MW9FdFBPQlcyVHRKM1UzWWtBeUpERmNMWDQraEpSK0VUemtxR21KNWVSVHhpUGVYUzBQT241VXdPOWovWlFpSEpTRkN0a29IM2lmeEtxNnIyK2Y0U0RJU3BkbWNaUlU5Yll6b3FBeVRNK3NuelJ1cXg5dFA0ajQrcVcycGg5Mlg0OXozeGcwSjdxT3lyU0RNL1VsdC9OOEJQaTkwVzVidVY5czc1Y1BvblBNZmsyVlF0ODAvSjRzaFJzV2RZTmNoR1Nuc1h2eE84MGI5b1RXUGp5eUFGWFVPVGZsZmE3LzRkMDB3VDRkNlJubk9jWXc4NDJzazMzbi9kSDMvZG9SR3VSQ0FhVk1RVEoxRmdpMmo2LzNqSUxuSW04Wk1GZC9XcU56ZEM2WTI4eUJMMUpWcjluaVpQTWZKZ1QrTGk3cXRrZGs2dnJGd2JuTm1Rd2VQamlOam1XTlIySGlhamE0WkRpa01iNGd2eStldlRwSnRWd1RnUE9ZMTRtbmdISGY1U2ZXMWo1WWc3OUhxM1kzVEt0MUpUS2hoQXhqTUxxamd2cjBXQjJBSWF3amltRUlmREJKMk53SnBCWGdQeGp2eFJaN0xRVDQ0SktNQ2taRldjUTRUVkJORGl6czJnODFsYzN0dTRwU2pEOGZHdXVLNXpBelc0NlgxS0RNT2gvZ2dZQWRBN1dnWldwRVpaS2x2ZmV3MWpTY0NnTXM3WWxaTHhZMEk5c0JLTXp3ejlxQ0pIQmhsaWw3d2lPRlB0Z0MwNDZhRm5adCtFYW9YZld5TnRQR3N3U0ZqV1FtaWhLU3FBUTVpU0ZYbktiR0hUVFpHWXNwZERQZHZXQWtMMlFjSk5RWVd1WUpiTTJWckp0Z0dMYWpGSkhhQlVLQnl2VVc3TzI5amxKRGRJcmpIL2N6ejlIVTI4TTlXUXRYMmZ6REFBSE1nMHVMeXNWeDNXNUlOOElWMFJpeUVBU0dnNjhlNVU1TGsrMDRDVzZCbVZ5YXk5VytML0JxbldKaXl0VWtPZmlwUWd0UjQ5TjZ5WU12QzEreFIrY0JUdHBmeWZLcjNlb2lOaTFNZm8wbjN4ZHFaWjJwRTJyWlVmTkhiM3puVUdzb05jRC9RS3E0N1Znb3p0RW0xNHIyMTVPSUJNeitscHVWaHJDZ3NiMUQ2M1lkMDh4dFJhV3FicjlrYmV1MVRqQ3Uxd0htNUhveDVZWGxIc2ZvWkZtcFBoaVQ2SkJwVVQyNTYwVTY3T08zRDQyS25HT3Zva09kc0dVSjFaanhQTjdjcGtjejBkNzQ2eno3dVZ1YitHWWtUb0h0WTQ5aVUyeG5idFpDa3QwN05MdWR3anVOUGhBRm0yYnkxYmMyRlZtRkVRK05tMDZkTzZrUHBCRWtuUmZRTk9lRlhuVzJKVFUvOVhjSkpJaGlCNWtLS2g2a0dPTUlMeFI2MDFUTVJjcjV1LzlvY0hob0VhZUxZZFVjVWUxK0NHeFRDa1lESjJjRlNucDI5eFIzb2JjM2k3Y3hqQ1ViYlNwWW8zcWxnVWpJcEM0TzBnSHVSSUJKdW1TM0xSK2lJTU5DVU01OFp3S1c3WTdKcDcrNlp0RmE2Vk9pTjFyMDdSclVQdzNGb1FsbmRrR3BVRzdGVzBUVFB3aFZFWnROMi9hMkloaklqWENWa1h3VFkvbXVYZkt1UllPdmkwT0tvY0d2bFFiaGlkcXQvN2tnMDltQVI4TklKOTN2c1BwYnZtS0tpSXV3N3pOQjFmL1czQXJNVWU5bmk4SkxoZkQ1dHplK3hjZ3ZPL2RXSDNxNDZKcGNWQ21HRk15VlhzSXZvZVkrckpkVnl4bFFybW1Od2NMdHFLQ2EwTnBreDlsTXdCa0JKUGlBdENZTGNXbGFma3pCdlNFTnlyT2k1UUJXekd0Q1JIK3BDc1JSNWtlSDJxUXg2UjBKV1BLWDQwTVdBMGIySm40eTd0S09RY1J0Q0dzcFlsSmlNbkF3cXFDa0YzdGExekZHK0NhQlFCQW8xbmd6TmN4Vm13N0dhUDZ0SDVXRzk3bENRSkRxa3pKaW9IWC92TGR6RFR4QnVFc1EwQ2p2TDVMRlB0dys1ZFdlenkwb3hiTldXZW1XOXdWZVF2OFRZd29YQVQrYWk3UU5JNjIwaEV0SHRqaE9oUnFKKzdYVkRCU2hBRWhaV2N1MVVGMHZSOVJpRWMyMkZwQjk5a0d0cEtSMUJNUndOaWI0Q3JZZmpHeHJqM01TMTZPVUpWMEY3OGV1NWI2Q3hlcWtlb21aamtsdGFZYjQ4QVI1TWMwcU1mRmVyKzc3ZEJyNHdSWjZNSDNLdGZ1ZDRwemM2ZStiWXY0UU1BOTV0TVRRL0laSmZzM1ZtU1o0ZUhvMStzT3QxaTJKQm56MDMxSUZMdC9XdWZiVlF3dlFzREtsQ2NkVWM5MFowMVowWmhDblo4a2haSUMzNXpYZjh2Q0RUM2tpdWV0SW4xb3d1L095L29vN0R1VElKY3dNVTVGRytBaWpwNVJQUFBqUUN1NGJ0WGxpbmZQUytDQ25QYlljSGJGeEdoOHFjVDVFQWtMZVpsQU1IWjFqMGdVWTltaXo1ZEpZVVQ1dU9IeEY5Vnd3cm9WMzBXZzZsWGY5dmV0VktMcmltTFRiNTMrRnFKNUM0M0tPZnlBWWNjcGZpWmM4d0tiVWxqTG4rbTNtN3RXZ0tMangwQkJuOU91ZGlLbG9BT216bHVPWHpPdkpYVXlNUVNsUjJHK014ZkRtWmdKM0NJMFd6YnVVRUtBTDY4NVd2NHVjK1lLTllkZnhNU2lnSDdhVzRyNUpwWktXanlKUElZOVh1QUpxR2VmaWRUSWhwZ1pOeUdRbVVmR2dBRnRQTFNhMGpsNUhIQlJNaERoVGdMODgxYW80N2t5VFk4UWZRZGlKYWZScjYxTGF6dEZ0b0dlTTFWZDdxQS9kR0J6TXFEKzR3cE8rUUxpTHdqMEZCVUc0anVIclVqYVpYWGNpaWQ0b2tFWTNkNm9aWW4yM0dnaVhDUUhEdEFQb3orZTkvaTBMYmFkaWRnblk1TFJobHByVUZKWG53UDJ4c0VuVmdqZGJyN0wwbEdpTVRDOExCZjJkemw1QllrUVVvb21haThHZW9WUnFaM1JYUGJFMGtJUG0zdHl3TEVtQzR0aGxSbDNKMmw0ZnRTeWtzSExXa3dxR2pqUVdXT0R5MGprMndGOUlaYllaQS82RG5HYWJrZW9oUlVXdFJBcDJnc2xTRWxpUEJsOXNWODRqd0lpZGtKNC9pM3NBTDVJeWR3RCtjOG5MRHV6U21WRGhGcHJNTkhRQVRaRCszNXVwVmRrakdraTJ0TGlpWGJNNmZ4cERocGMrOTY0Mm8wamRQR2kzVmY4VS9aanU5YkNaU0wyallLd0krbDlGQ3JNTTVWSHk5WElXNWluMWNibUhhM2ZQb1QrbEo4V0gwSVRCWXlndlJRNjFyUmVSMzY1SzJPd3RSc1pZZHZYd3FNbWJHdnBhT0NUeU12Lzl0UUxzOWVzMlNNdEhwaG00WjFOaGNRT1h2RHBDV1ptaDZPMFJESnN5aTd4aC9qbktmdy9OakhGdG50L3NIeEE1cG5BQWdKanNFZDdhYkJWQkxhcmZqNW5vOU5mTm9vU1lqT2M1ejlCc2plTW9oZHp2OWJBUWZyNUFST3RZVFZCaXpINlN5MGJ4RWZXdmZmcEVQWG50cWpvRXU1Uy9QU2F4MTJVUDB6c1hQa2cxOFUrdlIxWVkvNk1SS3p4UDVRd0lMbXdscnJmZVlhakMrZWxhUkx5Z3B6eC81SzBuSy9DVVlZQVFxblNvV2VYZnpGeFUzRU9VUTRxbVE0S0hkOXg1RDlJeVF0dG91TElKMUpLajdwRjMwRnNaMXkyam1iZXYwVkRINmVFRDhhemRHSTRNSzBSZnRpNUUwRXR3bTZWK1plRTBiY09TNnhYQ2hjS0tZbVN5Tkt4d2VYeVIrYzlsd2xHVDBERVZrNzdRQjM1SDFJL09NcG9JNzBpZGloR0NJVGYxdTlCbUNoT3dOSUlyWHRLSEtvS1VqSFEyTDZrdVJMUldkcFF3Zm5mWE8zQm56bFNNQ1d0YzZiZ1hxQnFtZnBWTkpoV3FFeU11azBQMmF1RFdJUUZZbmpQeTFpV1Vzejg4eWRmZHlrODkzYkRMVjdteit3TlpxbDgrT1A4c1hQNkNMVVlpanVlRm1aUjVtTWNyc2VEcGJYUDJwYWUxc2NMcVZ5YjNVOUhiYUxXTDZSaHZPb29KZ2hmWkhoUDRFRm9DeEZ6dXo4M1dCbXVXVDRVZndhRWwyV3I5YkUxbzZVSjhwd1R1SFZ5VXlLTFRKWkxNVEZzSWphNzAveTRSS0NXNmxFRmtKczZPOWswVnp1TDVQSHllZ0xWYjh5S0lXUTAwYVpWWVV4Ukd4OUNSS0hOc296bG9pVTFQOERubVkyRTBlV2QwaElPUzQzekxqN2J3UTJ3Vm9oUEVuMWNDa3V4RDNJV1cwVzVuN2tQWmRNSnZtbTBmWTNPMVBCbmhEOFYyK0Irczl0NDZZS0ZSbER1Yjc1cTNRY2dLd3JGeDUrdzdVOVMrY0trVXVLdnFxYmZsNU0xOXhQMTlIcUUvcDJSVzIyR2I5N3JoeUJwR0ExYUl6VVZIUVBFWjlma3JuL2pnVDVVanVBMVpSVmt1amJNd2JLVEwxZUpxMnFsQVYybnpPOFRqcnc2ZmUrd2pPc0pmZkp4eng4eS81T3YvdGM0T3VFUWNzUzNJOUdoMXFKNHA4U3lZcGNHaEhFbmdJWXBoZHdSSFIwM05PTmtBUCs4N2dDR3JnUjhwV3M0NnN1Uzh3OTFwY3llQnpScm9XZE4wUUptbGt4L20zeisvU3E0OVAwVGM3NGNrcWNUZkl2Qnc1c3AwbjZsSVd5NnhZY1kyTDFsV1FpODhMRVVZSHc0ckxCOEd2VVR3bm1BNU56SGNsYUs2VFJ6ODRhdUVrZVpxbFIwMmY2U0ZjZlNyTm1JVmlKU1JxWkVKMmhnMWY3YXJHb05OQm9lM296clVYRm1Jd1oyYnQvbHV0R05HNHFMcGhDMU1NcUJBVGoxOFJwanRUZkZBVDRHQ2w3eVZ2WVdlT1BpYW9wdDlHd2grQ2xudGZSRC9IYzgwb1dGUzh3K1creWFCTE1nOFRuMWtXQWRkMXczdURlZ0I4V3g4Z1A2Y1BCSGJMRnBNNWRuUDBHSVJMWTBFNkJVVmticldpYnNKa2FZWTZqc0g4R245allZd25EUWdpRGNFckZIdEdNVTZKTG9MMzJTanZzdFBpRExmRDAwK1I1bXdTS01EZENVaWhPOW4yTVRRL3BOZ05vMk81eGYzalhPNDJMa3BCWUYrTEZRcmUwbG52ZGN0MkxoTFkrNnE0ZEwyaFcwYUplcEZJOCs2Q21UaUJ3SEpVL1RBamk2WmFZVCs1U1JDb0d2MXc1dzRwZ2xEcVZQNER6TXZZTVowdktUbVdUREhpQ3c5TnVrbmtjLy9SekFCK2tIWnpwd1IrMHNrRXNyQU5IT2FkUFp1L1BqQ1lNK1ZCUGdqWHZYckU5eHJZcnBQeThWdTFXZThDdWRBYnpRcXp1aHZlaWxxZWkwV1UrcXVRQ3c1WDZJTVRVNUlnUnMyeE0zTVdSUXhQWU1IR0EzRWJ2L0FYdGdGcUhoSFRPSDBUbW0yck05MFlweWljWERROVRvZlE3UTAvVTloUlkwS1FnN2FwRHVGT2d1cFFZSmNtTy8zelJSRDd6bnNYa3BTR0VkQVZXQjVPWW5RdnlnalVuRkd1YndyUURMRzdlT1B4NFU0ZUlTYVQrUWdXY3h6TWZEVmVWdmxJZWFGZldwTDRTSXJqcTVPeDliMGs2Wm1CTXBwVUREemlpSTBxUXFKMTYvdmN5WTB2R25CL2ZNaTBFcjJ2STRDNnN5M2VjdXRueXVFak5pK0x2N2dEUFFVOU1uZkdnTWxaTXZPbEt4ckJlcGJ0bjk2ZXZQMHNoTWs0d1VNMjlMT0p2V1NTSDBCNmczcXpQbDV4WnBxZ0ZSSit6TVdMWnl6cVVEenVXMlR4dG94ZjNJdW1IaDd2T1p6am95WGIrWW9lR2pSdzd5bXk5cStpeXRlMmk1dllHTVFQYkZuQXQwb1VOMDI5TDg4TnZ4blNLWWw4bzVibDFqWnJ3YTJjSldQU01iTGdhcm1ydENraXBHYWNsNTBENWEwZnJ2M20zalFYbWZIa09NYzd1Tm40YUsvbnpDbDBMQm83UGtTSGdqM2t6TTFwL21Bd25nSXVIZUc5ZHhBbEN4dk9pUDIrTVB6NEdqTjNYeEthMzJiZnlVdSt0YVJEZ1NYTkxzNWhZaVUwckhCYnB3akhROWoreDdHcVRmY0taWkNzZXkvbXdYdVladFVpalZ1N3d3TndlMXNJY2szdUNEYkJwM0M5SHNYSE9ZZUwrY3MzdW1iLzEyUFp0dWNPaGQ0ZjEweEp3eTM1a2pzT2lmc0RTejFzdHpnYkl4SUJwNENYcUkrOGs2RDNQNXd4QzZ4SlBxajFEMFBnTG9nc2dSemNmL2l4R1Y2VnBxaStsaXlldmNiNk9WclkwOE94M0luL0V4aGFXRkdybVFtSzY0dlZlWFhUcGlna0ZnT0tLd3oydVk0eXpDbHlPYkxpcnA0eFdxRk9KVHZuTGZjclNodU5hL3FRS2ovZkEzeGRHTEFJOHR5TkM4S2NxZ0c0bm5YcFEwb3kyY280cHh4RFIzOVBOaXc0VitzMmNtQVRLRy9ySzVUQTN6MklOc1k5TGl3WU1UWGZ2bHFKNTZGYStLa2ZvWXEzRGZZQmdGc25rSm5oaXhXd3FMSjEvQ052NzZDZ1FwbWgxWm1jOGRTV1R6VytyUmp0TGNDK3JESWw1dFJVb0p4bFlROWNVd3MzSStoenAwVkhWbXZUZzQxaWdtTVhrc2pUQ1J4YlNPdzgyR0ROcnBCazBBQS9uQlhNSk52eFJHUjFjUmpjb21XcjFoWnJvcCtEL1QwdjFaMkM4Y2huMDlJQXdtQkI2Q0lCUlU0ZHV6MWlCRFJCa1pQSkNidXZUNzZyb2FLVk1WNjJOSUFteTZHaytGRFlLVTZxV0JmbnZlblUzYWQ2NUVZemQ1QUpNbXpJMjdueVBVUDY2ajI5TTlsZEZIYU9RM0hVWXcvOW5qSlVwNG8rUklaL1NmN2oyUk9zZEZreVZJRloxUzR0WWQ2VGNJOWprci9iTWxYbmRzMUxlUVJlR3lUOUp3N0Z6dXBPclJINDlmYjI1M01wQjRaZDVUVFU4REtldzI4YkpQYitmL1JncGRUcDNwYU9PUy8xZzN5bi9hQktkMGZSM2ZNUXU5L0pGR1BLRTlpM2orbXVJRFFXNSt1bE9iT3Z0U3J2aWxvWXYwckFUMFJaWGsxRmpQbzIrM2Q3L2VYSmsyS3ZWRFlsdWlnVWJObHRBb3MzMHVscHUvZzhTKzhhSGdzc1oxcnhxY21FSTkzdGR2N0RKV0tqZ25UamFVUDhqL0Job1VUUlBDYW5FVlI5TGRxMnZTZlI5a0RpV2hjK2o5LzZrU1hsWHRkZE9PcFZWUGdBZE9lWmpoWGFnL2FDRGJNRU1ZM3FzOGFkRWJ3K0lValBqaUJyT2ZhSGg2cTMzZWNOcFpoNXJ6WURaYW0vOEYyNmdWMERZQlcrM0oyYVFXTytJZHh6dnU3cGVTejVlcElRQWRhdVNOZGx5M2hhS2h4MENPZHlxRTJIMmtNc3EwK1dTYTZNalgvTFU1aFVNaWxCTWI4amhrL2NtTy8va1RvMmdNRU9YVzY0UXM5ZlVCbU9uL1ZiK09kaHUwYWwyekVINm00akdHcE1tcEZoUEdSTkRyV3VWb3BCV0FkSDFHOC9yTjVrUmtFMkJxUnZZR0ZzZERjTDRQcnNKSmZLd1YwSGMxZ0VCa1BTa0crckdWbkJUNHpWN2lZUm9SMk55SVJkN3lGZCtuOG8xLzhXVEZWQXFlcGsxbmVxeUNJOGdzREhrRVFHaXJDRFpzL2pCQklOcU5HOWR1RWFpVk5CeTV5TWVtYWdzcURsdDVSVEo2WTRPWXlpYyt2SGJiUlJBc2Zla0tnOG5ydVB5cExUSzBCS0FYZThXS0dpRjFhV2ZWRG4yekRvZEE3dVRKK2o4QnR1elpSTjlKWUNET2lWazNqKzV4QkxIRjQ0QmxZcjdzTlZDZGZHMjFCYjNpakZJVENYanFOZXNYU0NyQnBzaG9rN0pyeUt0L216UnpwTDFzM2Nxb2hpazlscis3Q3BFNytDamJja0xWVEVrQlh2WHJSek9vRERLQWlxOW9xOG13aUdOT3VNQ3laWVZ2ZTVhSG1jbnM2eEhienhZV0tlWVdsZ0kvZ09sanhvU2xlSk1qWmRaU2ZuMU1oQjc3c1p4L2lqNC94RHlmWDVKZUpSWGVpanJYenRLcDg5TEVjR1JzYW1vd2JaWXdrZDYwOVYzZHY3Q2p5ODJpZ083ZFNScE1iUitzSC9LbnpyQjlWeTJXZ2Q2WW5BSlIrWG54VmJ2U2s5c0o5LzUyM0xCTVhmRHA5NDRCd3h3aXdGVnJ1RDhkQ1RwTFRJUEpQSWl0VElaekN1bHcwN2JaUXFweW0vK0I3bHFlT1EwbFd0NnZqbjdhMVIvSDFRNDkxQXVlZk5QdVNYWnRkVjZxUmRnUy9kQ3ZCVXJLT2UzT2RNTGlsS0NDczVaSHlVVXZTZ2xuclRGeFhPTHBxcXNOL3RMK2EyQmZNbHlXaHhESFJSaUpWOEZnNWJubExESmtsL2cxemtXUEgzdkY4bm02aEIrRU8zTnFibGdONWU0emg3Ulplcy8zSnNETDBTOVVpS1ErMFJwbWMyVjgrR3hQQ3BWTElxVXJHWExJbnU1QmRLWE93R0VHUW04bG9RMUN6dTZ5MG5URWN2RjlXNkE5MGt0QndvVHBUY0FmMlFYT1dWTXFNVXVvckxPbzhPd3NFcVFGeTJqTlhKUE9sbnBaSWlWTXJUZkNycjVHNElITldCWEtGQkdvc3FJaC94REhwSEJnZW9nUVlpemVGWUZsLzlRYlBXOVBTR1pZeEZvT2orUEVsQnBUT0dldmkrRFNDNW1vR3hkSERwVVh2bmtqUWcwOU1tQTh3VUYwbGtiYXM2V1NoNkI5MFRWTklBOEhGbzhYeFZNZkdmOHNLVkR5VUpjVkdmcTVNNDd2ZGRNU0x0QjJNaFNENGR6ZmFBZ1JHZlM2TFdpR0FwcmpzQ0tnM1BNVk9SVkptUVBKUHkxdmxaV3BpajFEUmpsZzJON1Q1Z01LdW9FQ1A0NHFlN0ZabTAxaXRMcDVZN2dVemdkSlA3cTc5eldHTWZ5Tm1KMTVtbzgzaFBYOGZCN1daSEUybmkySnNic0lzYll2RFhCS2ppMVJWRkV5Vm9Wa2JkVVN0bmd2aHdSV0pXZ3VCYnErMFhBSVlUZnpxa2l0anRFcTcrOVNJVFRBcXU2ZDJwR3Jha2F0T1Z1WVRZWkpFM1Yzb3lhdUFLUGFQR0lMNCtaQXNCRFRHb1YremlubDRsT1YzL2JDYVNxb0hQbkNWZ29OTWN2VUx6cSt3OXIzNllBcG1vY0pGWFRUZmE0S1VZMmlhSzBZMGk0V1h3L3JSTEtIa1FmbEdVU29zYVBQdStxTHB5SnNNR0hrSlRNaWlITVRodmxZeUQzRjYrOXlFWUUvOXQ5US9qZUpkbkhadmt3dVViSzBvMmxVSCszdllFbzMrZ013TmJaNnVDTDVSVVJKb0tVOVVzRHJEdVVvNUVFUHZiWTFFMjFMa2FxT1c0ZjJxck1vOVdSd240b3JrOSszZm0yWWo0bGlLaW83ZFJITE85eEVHUjMrK2RDdzl1Y2t6enhtNFZOVGh0N2wvais2YTkyWEtrU0p6YTlRZEFlSFA4d1hUQmJ4SU5LYnZOM3lrSTVTbnF3NzdXVFNGaVcyMC9sL003N0pMNzd2RXU2NzlnazhReHRqQUtHZnhSc0NZbFJETUI1Yi9jVlEzdXc5VXBqdnhUMUJMRGpPYkw5YjQ1dXpocjJzNGR2WEhueXA5amVEdzhUd0lHUk9YUHhKc1ZxMEZua1RoSjZpeGdoS2luN2R2TWJoWko3S3JjVkRGcXJBN2pLZ21QcEk1S0ZQR3ZBb0lHbGpXb1BFY2RZSzd3azkxNzVpY1V2Z0NHdi9GcGF5TXd1NXlRejVYenh3dy8weXlrRSs0cFg4YzV6WW5RLy83UUpCUFE1NGJLWk5xMVpXeVBGWFJDS01nNlZJdGk3SEdjUkhmOWhVQ3VXVjNSRUlDMDhpTHpZV2JGRm1FUkVWQXU0K0hGQm9yOHpIclg5S2xhT1NvV0JYZHpFUFhnaFhET2FxcXZRVG4yMEhiemZYQ2dFZ2xBZGdpR2FvMkxyKzl2RktrMjJYd3VNV3VodjVidUpvOEMwdU5lYnRSU3lpamtSZUhlejFXZURWOGZrWEcyT2N1K256cTdHeHVJYmhvQ0lFbG1VbDRySlM4S0tDb2d5LzRDZVZvSGVQZVZways5ZWlDWXEzaUg2TTBsa3VzRUM0Vm9adWI0emEwYXVFWmNZd1FQbytZTmlWWjhWdlNHMnp1b3FZNEo0SW9MSHhRZzFvcUFTVXkvbHhRc2NFeUU4bXIrcWRZQUF4NG9ZdEtjTUpueEIrdG4xcUNyVDZhbC9BNGVadGZsaUdLS2xzcnlzT0hTT090MjlBUDNNRTJWWXpCanNmWTh1MUxCaVB0S3NqZGlVdGtsZ25oSGo2V09ROVV2WFhrZ1F4d2lYdWU1Y2xnVWtHZmRGY3czZTc5QWsvODJlSkZkVy9HMGtQNW0wVERHZmRweFVZY3p4dzhlTUVINXNhNm5oQk9qMmNhakZVTXJpTEZFUWVOZjBRajIrdVlTcEVrZzg2VkpuTjk3bnlYT2VNWWlZaDF5VGZNUVU2azFJSzdNYS91TGhkN0U4NnY3c2tBKzhZRjNac1NSL0hHYy9qSFhwMHNKRlhlVC82UHFvRUk2K3M2THJ6NVRzNE1LclBaeUZvZnV0Z0FyN1p4ZXo2Vi9EczNhdnptbFgxeHR2amRxWE90UmNyaDUvUUQxclZOSWlyNzdxMDZUZTF1c29kMlZzc245ZnM2U2dYWkMwWDM2eGNwVWNubC9FTStyY3ppdDFBak14aDhFanFlTTNOTWVRazFwSy9tYmx5bERtTGxKMUp3TFFaZXpmUnVKbXI1QkdWOS9mUWJjYy9YUHpCd200R0l1MjNRcldmdklOWCtoOTRvcG9yajgza3Fua3VMYVY2dktGMkxTTUFOb1lrUk8yazczRUNIUTRMdlozUE5iTm5URU01bVhCeGtBRmphQ3hkSEdGVWRLdnhrUnBDU2lHVjgzN1VuM2djdVRMVURZRGEvcnEzTjNTSnBJSU9vb2tvSUdYN3hCWE9ZYmZ1UWNUQVBDYWNiMHcweDFRamVxZnp4YkZuS09McEp3dUhMM0dJem43d1FrVmpqREVOVWVVUFNUZk0rV2JlWG1XNGRBQjFIVVFkMFBwQkQ4RUF6Rm9ZL1IrbDhhKzV0RjZaeFppWkFMTVhPWnphTUtJMWRKN1ZkVDVITnphczFGWVNDRWhUdDhoNG41UmhVTk1obi96Mk4rTG9VQ1MzYklxWmlLZTZOWVdQNkErQmQyNklxUGs1WENpYVE4TXl0UmhLMGVDRTFhamRuZWcraTYrT010RjQ0R0ZFR1g2cGNrck9oRjZWc2lLWjFUMGJGL1ZUSkdYL20vbmEza2dUL2ZuYUMrci9NSnRvNEkvRCt4enNqek5oYlNpRm16K0E0Tml5SFhveG5zaW9BUURadVVLRG5abjdibnpkNVd0aGtvTmNtQnNsc3E3WmNBZnFXYTlBajJMYTFEUjlIdWVDbUVnZWJSaWtHN0xYUlpDTzMzZHRRdFE3eVYrVjBVd2dRNUFCSjNVS2tSc2ptUXMvOTY0cER2VHA1cThBaU5BdXlwYjgrYy9yS216UVgwd2ZzbHI0bktWaHY3cHhSRk92SVVnOVZoR2llSkx6V1Ywa01hTVA0d3RNdnMvWHZQN05nZlkzZmdjRjV0N3ZtcW51Vk00VC8xYzgzd0hxbkErMG5mTFIwR2FaeGM0aFVsaVVPek1wK3FkaEpKTjVRVnZRaFhhYnpuKzVNbUQwTzdVcVdGTkY1dW5udGtzNytjTFBnbWU0Mzl0UDJvb1BlWDZIY29PNU5tRk4yRG1SdjNiNkk0VUxxYUFkd0pnTC92ejNvWTBLK1FIVE55czIvT0RCdW9DNk9Fdkd6TFZBUC9QellINlBNSDdibis4VUM3M1VScFcyNy9HaHozOVl6dk9JdE5CWFRtNys4dGNTcVNTYy8zM1RxajZBb0t3TjkwVGY5bWo1cEwrUWEraXJsVThITnY3UnNhNGtHUTB3R1lqMTBmKzE4QkRrZTF1aFdRckpqYk55VFhRYUc3dkhwNkNqaWlSaDRoenIwU1AvL0hQbS9VYU1WdkcvRWxvNmVDOFh0RDd4Nm83M3gyS3pZbkpVRENUTVlzUko4WHZqTjUwbG5IaWF1b041dmpIckxoQjRxcWhGQnFEODcycG53OUM3ZERZVmhERklJY1VBbWZ1ZUVOb001cE5BUHZOWDRqUDZzVGxoN3FDT1RRcnBLZVZHNDNEa2I2VU9WVUJOWmhVZ2d6cG52dEJMWVRKWWpNZC9ycEo0dUFCV0Y2WDdjcWdJdW1BeEp6SGRmSW9aVWN5QmlTRElnWVlyVDhWK2tOZGZUYmVycmhtNm4zUGpDU3JiY0hjSnBpeWJsMkRjZGR1YTAyOXJZR0pWSElOVENSTk9SY3JGa0hDTUVsWlJKM1FOcHBhRE13Wm5mQmR6NjMwUERYZ1ZmbjAya21Fc01HSWJsZ3ozamViL1h4NUcrRnM1M1RXREVPK3ppRVV6cm1jZ3VSQmtDSWtad2dxSVJhOGxuMmdKcnQ0YUlCa2lWWmRNeFdSaWV3aTBkT1JUU0k1ZW4wYUpCWDJYbjNveFNQR0FxZXoxaTBkaDhjaG5aNFYyaDBIbUIvNHE0UjNCVGV5NUs4VUNYd3E1SzEwdC90WkRGVXhyQWdQZHZURXl0WFlsOXk3ZHJ0MnVweUhLYlAxMk16YWswR3RJMU9vL28vNE03WWxWYVhVTndUUXBCdXhxWmNzeEYvcW5HSVN2MXprUldoNUZ4RFY3YlBuUzVHc2JxejVua1VsTTN6clZCUkpaWVFWaDBLMWN1ZlBaNHNNZU1xTEVNWWxoZWVObnIwc3JEa3pWR0t5a1pYeCtkbENlMDhpQ3E5Ykd0VXBCYlhoUGQ4MkZQTEJVRXJyRHpueGdZbVltL0dnZC9MUkR5NXFNd2JremZLZXV1U3hwQ3dNc09UK3k1V2FjM1A5c3VZUktUQmI4eS8veWJoTXY1ZWFWMWR5QnYrdXNLeFF4ZDVVTHVtaTl4UVVMZWpONVVCZi85RTJwQVZPZHFRUXlzYjJvTEVjdWgzTEpsMkdIakh0cWR3dlRxMTBqdFVIR2F4K2Y3bHo5UGozUEhTa29IZ3phVUg2V0ZrdzhNUnJxUFRmZEdIeDhoTzNWWFVtekhKMVI4ejlyTW5MK2pEVlFxZW9Da0ZRRnFxb3ltU1VDS2xwMi9lZGZNOHZLNFR4cjF3andQYXNMditDTXNnejBndkZEOHkyajBCb0dRNGFBcUY1azNjTnV2V0JyZjFieHdweC9rU2I1ZWRNUUlNdkZEcFBLYnVoZmlpei8yQkxLNEYzQW9RMng2OXRWSThKdnR1S3pNMjlZNHd0WEU2MUN0aDdQdHJ6eHpZOVdUQy9ISHhOTXQ0NEpjdWYybG03Vkk1c2kyRU1WZ1daMTdGc05GdnpBcWExSlNubGpzb0FvNk15aUlUZ2Z6cXU0dWlPTFJCeVlETlhqU2J5UWhCZzVKOHh6S3NRbmRUazNGbkJFQVh0aG1UNndYeTA1MFRJRUlqS2VSOHF5bk00QjIrZHJXS0FUMGozcUVOSnFvYjJ1Y1BQYUJDSFRZbWtiQTl6aElGU25WVFdDTDQ3R2VHQmpaY0RJbTBzakpXY3FjWEhMMGpoczRpUmN5TmhTczV1T1IwUVlzZUl2bnJodUlYclFLZHlWY1NUQTl4YzI4RWd3eG9CdWhHVVpWbjhETVlMN2pBVkwyQzNNNmUxVkJ0NXlvbHUvTHFZV0RCVm9Tb0hUUmd4bG9HWStNdGhzVUNWWmt1MmNzSDB0ZGxmYXlqTWxCMjhjMDFnWEtVS0lET2VjRlNReFAra1UvUlgyMk94VmJ2a3NGL2x1MjhVNDA3eVdVSWVjNXlyMDJkdSthUzVRcWdIUWd0SlFKeEE4ek5RemdHRHpuUjlsWjlFek5yU09mb1J2aENlQlhsUUExTFZKVjIwNkFYdGRDTHY3V1hjVXRTSm14aUVsK1l2NXBrL1p3Q0xsVkRpaUxOV2JUUWdmNy9vNVNaVXdxc1NJeXdZdFZocjJFS0lBdXNqTk1iRWwxenJseXV5c3VhWlhlbmZoSXBYNzlkc0xBYU02aHJaN1p0dmtKUXEyN1Bxb1ZibXB6SXJRK3VBQ01kcGJIVU9wdzU5K0dWR1dyMFZGTHd6TnQxL3NNRk9WY0pxWW1HaHBMc0J6WmhKaTRGODRIUk5mZkJ5YjgrQ2xpUTlOcS9FdmJjeGpidGNyUnRCMzN0SG4zWjNkZG1WQ2tkdnVpRWpWYW92NDVrcnlxWVpHbXpTckZHcnNaMitUN0M1QkdTVkUzSmU5cDgwS1ZucUd4ZTB0emEzNDBzSkh5ZUM3OURmbER4S0E1Z2R4WFNmTTlpdEhKdGtQYTU5L3ljczlIczZjT2xraXlQcDUrbm1ON1orTWxQZ20xenhVRWZ6TVJXTVhyZHNVSUZySm05VDI0UTVNakx5VTQ3bVVqRFVieVdKVExzZlpVVVhPajhsd3Y2RkFQV0Q3YjJjd2s4R3U3L0M3MjluNUlwYVlVZWV0WlFvb0hnbDgySjg3UTZQOFhHbE5uR2pYcXZUQkhwN0h1bTc1S2VGS2w1L2dVR2NyZlRsMFV3NURRcUNwY051SnVsQWRPZjUrQlJFdWhaSmZNMEF0NkhzaTFMNVNTR3kzTmt0RkN2MGJZdW9VZy9FWjBPcHpZd0doK1ZSR1ljNmNjcXI5dFRvWWhJQmFucFpFVkZGa3F1S0E3MVplTFNNZFg0aERaanVGWU04NG0rWFdnOWNueSthaGZraGdlYXpqejBBaXF2cEVXWmpwZFV6RWl1a2c0SnVkVlRibEJ1dVlpWGhoWkcyQ3RzR2hnR0JWRlprMHhtTlhYd090dmlxZVZtNFQ4dExLY29RZWlvdXk0MDhaZnZRZktVOFpPcWxkclFnMGM2RHlDb2JyM1RMblVwbVhFaStINlRRbmt2a1pMbWhvWmxibGp6WHFiMUZ6aHhyOUNEMVBuMmx4Nkc3YlVXeXJSL1FYcmJwRFE5ek5mOW01SnZ0ejljVnZlSVVvSENISDhZME1MTTgvWmZwQXY3amJBMHU0Ynd2elVSNWI5b2hHTnNjMTVaNGxuUmlEcE9OL3U3c3lzNzhTaXhZTHJMVm5BdmNFT0VzOVpGNkRISWdpb0pCbjdaa2l2VXFybHlndjN1U1RhN0tvOTgxdGFXZkZpYlE3OG1FSDNjbElhM240QU90MkxidXg0TmIva1d0UmorWTRxMlBUWXZXUk5YL2FQQVNyalgrZzNCT0FDeTNDbFdHdXJqaS9CRk01amphOXZFTGpscTB1MVFvOGMvWnBuMVZKYW9OQmNJSnRUL21BQ1hDbEJLT2VkYk5WMFZRakJLL0RzRVU3UC83aXVKNUMyMHVNd2JxQm1QUm1jM1BwYVFZWVVEdkw5cVVFeGlGQWhPS3h3RUdBeW1aK3g3RlJZdzEvUEtwcnhYRFJjOFk5WGt1dXRsODZwYmoweEVzOHlNVm5jZ3BKdy9ON0dVanZCSnRVLzFHb2tLa2tGT1REai8wdVhkNWdmUjZFT1hXZm1GbG8xN3d1aTFOYjBFQkFhS3JPek1FYlBRZE96WVRYbnRxS2VUSUE2aFBlOUNuWWdpbCtyTnYwaEJCcWMvdnVEcjA0NHliQyt1QVZSMk9YSEZ0ZHU0WFFzVkpKVTh2WEh4V1FqT2YyRWNyNWV0M0ZGTDhkbEJNVW1hbzVZVzAwdWk0ZDhNY1hvU3F6Rll6VGhzUVlMakNrS3pUTGMxWncxMnB6WFBETUpGOWVlV0cxOTE3WVAxblJ2QzZvM0NYZWxUbTYzYnFKRll6Rm12MEdOcThkR0k2Zkl4YUx5UHQwNjl6NkN4cDU5NXhyRm0vb1puTjRvR3lVTE5XVzF3b283VGJtbTdaSWJ0TmVwWXJMTzY0dGRjK2NDR25hVm1MTDV1VDhlZklJNG9OUHB5TzVQRDY0OEhOR3ZOZmsyREVONkpNalFSQzY0S2hpbllpaFVURkdWVU1GaGNXdmZBU29DSXZoeDBJOEF2bGcwNE1wZytKUDFNcE4wbk04ajcwTWV2SHJzV3hyd05aOGt3cVhib21VdEloQlNLRWcrSFpRcG00djVsQkhjMElaS0tYNWsvUkgrbFdrRUFLUEh2OTVpNUxUdzV5TVFBdC9oamlJT2lzRVdNNGhUUVNMME5WTTRpN2RMU2FIeTFFTitrcStwZUt3V1FPOG8rb2d2UndwRmZMUTVEY2lBWWNlWVByelR3VDlweHZsZzNweGtrK3BSSExIRXF1WWhYNG5UaHF1OU16RUdKZU1UeEJrd1FXRUlWK2ZjVjNpdnMzMEcvSUdJUEtyWFM5MzVtM3Z1cTR2MjhZTFhSOWFVTWNUUUxFeEQzem90MEhxdGZsWXlyVjQyakwxZDROdHY3UG1panE5NmdWdlFTVUxETnFTVWxKT1lXTWpSM0RMYzZQbnNsTDFzdVpSZ1ZKODFvdVFTbjBXUkgyMmI4MWVmYm5kUXBabGVSanBlYlc5elcxdWlhYzVtTThWWnEzNWtHMmUyek9YRzhkK1BYWVJQOE1YQlFZUHE0ZnpxdHFrdDNWRGZYb2pOdWEraEswT1hlRnhqRndnMm8rYS9tdEpybnJvQTJTMlpuVFZwaWhaYVlZQlBlbHl6Z1R0eEtyZWlWd1JlaXdWYUhoQk9LTFFKTTA2OXI3bnd3YWplYVR1bURUcWtUNzhkUE5OZGN4dUZ4L1RXTlhIaUIyZWN6dGpYd2svUTJOWExueWtNNy83WHhlajIrcmp3d0h0ZmJBSnUweU0zMnRjTG5kSmtDMmZwL0hKN0ZKUGg5amloUStqSHF4OFlmL1o2QlBlcnVVemx4d1ZCS1hsYk5LdWQ2T0hzQ3h4dU0vYmtJWmo0dkhuTzlZdTV6WDM4UVdhZ0Y5VlkzSktmcytla2VCWUJRRk5ZenJkbDVLL1gvcmFHSUVMZ3J2Sm9hV284UGM2bDh2U0NMZE9WYXdrVlUxN3hMcTd2OC9FeE9FaDVHNVZiYzNBamxCT1JnVHFSa2Rjd2RoQWRSS0hucUozOTZuQllOSUpLaWdDL2RNZFgyM1pRZHRDeE1VR2JESnZhdHZlOEJheXcwMUdmWUFpbWZFMER3Q1UwZFRHT0x6eHNZdzUySHgvM29hNW0zcHBvWmJlMHMvWnV0SEY3NzVrNTNUblZnazdWTnJKeGU5YlJLd2VLQU9WWFdZa3hEVFRIWmNXUFhSYUhIZzl3OXRBaWJmWGh4c0RqcnlqalZYR2w4L29GNE95YUdlRnhYd01JamFNaEJHZWxPMUMrVUVMRXcyeWRtTFNYemhUaGtnb1lrcVNTK0xqNU41QzlSTVFLV3pobXFES2RUOG1QRGxVSjJBekRXeE1uNktVUWJYWjQzcU1UVTBUNytLTHRPUE51UjQ0Mm55M2lwZ2xORXhtSGlZMDJKSkh5SlFJeGZSdTdmYzAweFllWnk3RmlmWVozZEdkY3N0Y1F2cE1qdVdhSmtIWFIwejY2aGNpSllKUHBUcXVHbURwYmRmLzNUL1RJckx0d25qZ2I1VUd5OVlEdUVBVERwaTJjQ2NNaFlVcFpqdEtlclhwelBBejAvOCtxNkxzU1JwbElPN0NySVRqY1NqNjVmZ0tsMG5DamI3cDVpUW5lSHM5Qkt2eXBaSzd5MnZURHY1V3NROWpEOHplTGtXZXBQbTZrZlJmWHhORFlrVEZBV3BkYVJGcmVyT1RvQTZUSmR6aTBTSng5WmRQeGRXWG5lemVZRFZxbnpXTHdBcGc4ZlpucS93c0ZnalBMajdNY25YZUp5aUdOaHpCMWdYZTdpNElYay9GZDhHNjlVM2ZQU0h6UGtaMCtvVmlDRnM1TmY3UnVtUlcxTEZsTE1yNDk5eUdEWXV0UzRTQ3ZFTHhqeEVQbVJVeGhhdXhtWUNwL3lxdTNIdlJOVEwwN2s2bUxYS3JKa1h4aEl3YnpNR1BoRy9FOWpVemtmK2U3ckpsOWRKTmIzVUVGc2ZzRzlFZ1hzQlhkcGMzcWZPeGR4SjY2Y0RLSFdoOWNBbHgwVUVxTm4wMU5ubGR5c1lZTWtra2pld2IvT0lsNTBYK3hLY2ZWRExxOXJKMGtrbThWR01wOGRTdm1ra3NZMUZKTSt0Rk5MMGVaUFg3S3RHR21GdHk4QUt5Z2V3MVFqVG5ROS8vcFF0d1NpS2NqZjcxblBWSSswYk5xTTI1Y1loYVJ6OHdNb0VmUFp4dzZVNXRBZ0JRdGROb1RjNVpIZ1J6UE5oWU5tRlRxaFZFQ29xZVpNUkVCQk8zcmhLS0FRQTJZWnRHbFE4V214Rm1DOUV4aENBNU9xdXVQdW9tMWx0SzFhSEkxc3FpeituNllHOUQwSVBiOS8vOVBIMlMzNlRCQWNuQWYvL3VjUVBNeDhsSHFKbmp1WmdLSHFMdWRVVktSdWh6cVcySWE1SUdDQ3hNQk5ldjJ3aHVzbjlFeVRERVFoUUFSL2JyODgzSDQ3aGg5NGVraWUxajIvZ283V3Q0YzIrV0tSZVFqSTFJdjVqNHpnVDIyTDRUSnNQdlR0YjVQTjI4V1Q1RUtRR1JpcGJLa2p0TGdZYm9xZ3lkM1FaVithRGRtVURFbFE1ZXZ5NmprZnRNOVRXelZSVEdoRnpRNnBYRmJkMGt0RWxzT2ZVZHQ5SkVtcGhOb2VTS2VGd0UrcjRMRDI0S1BzdDVHZlR3T0dRZUpRTHQ1eStKTGpzdzF5RXZKTWxlMXFrc2szUVByb1VYMEEvOWtYMG1CWENJMUh6T1hKa28ydGZJREkrbjN6RTV6REJXZFpHeEx6MC8wNW1ZVHdlbHdncVplUmhiSVR2ZmlDR01sOGNHdEp6T2tyWG1aWUhIVUpTRndqa1B2TWEvZkIvdG5OQjlMWDVla1lnTmVzT013aFNoUjZka2Jrc3VIaFpXWGZZTjRTaVFrcE8yYmRNcDhhTlhTQkhGR3laMk9Oa2w5ZWJQV0pKZTJMNU95MUxXdlVPNzhlU1RndlFEbjBxZ2VDYUttaG5vNDZYdHFNSXdOV0ZKaUVjZHNiUmRqaEd5bk51TWY1cThnMmVnQ2o0eTJ0eXdpaTEraVB0bEZkK09zRktuUitEYzRZaGFXRXVGR2laVlJQc3NCaTVJZW9qWFhiSVJqZm55RjI3ZHJjS3h3K0FGYzVkMEw3VHJtcmNlV2RSbjdrblc4Zmc2NVZhOThCWlBZVnVrdERtR1hPNXBHcEEvS3k3M3dteGxYN1p1YlJzajQrSXM0VWFSa3p6bno2V0VQV0pkVTI0OVV1b0p2MjdrZHVHUG82MWx2NThqT1FnWVZIa3oya0V2akE1Ly9UaWFNeVJsVm1wVnF3L1ZvMHNETC9paXllaS9KVUtFa3FGbzI3UmdJNkJxOFhyeGNOVmQyNXlnemIrMXVPZXZoUEdVS2QwMHhad2xTMmY4MStMcXd1cDFOM01UOTNsSURqQU10WDd0azlmOGd3amRvd3QrNEJCVzc2emk4Vlh4eW5jQ1BjNFk3T2pGRUFnS3pvVkVaTDNGRno1aXJrVU1VaDI5VERMOW9hbm82a21jOTU5bE9TTUprNm5Zb3U5LzdKaUk4a2hwZ2lGMEh5ZERFU1ZGOG44cStyME5PcjVvU3ZCd1FYRGZsaTRVNnY4eTQ0dlYvemJrSUJoR2lWeXJyMjVyUTNoT1A3OUJqTnRuakVDYkM3S2x3Y1cxN3BDa2VGOEUzYzBFWEtBN05EUjFQb2pCV2dkVGdhdnl3UFBscHd0SkpxQ0Zvak9yNUpiN2lyUmxSaVpkbVdVZ3RLTmJyRTFLVlpVY042SDdHc0s4WXVYOXVqWWNCUUZHRW85bDZnemhScDF1UmZwNUVtRUExLzVyNUtlQ1V0NUVVemIxb3JVRkd3VERYZkNwajI1MWVUTUFEM3prWVNqV3NtT1pra1BTK3lQMHJIYkJRQ01DQlltM3U5QkorMG5VU3ZBR0lWMlRKQ0dRbk90MGNTMHZ0ZC9jS0EzSHdPcWNPOXJINlF3Tk5xMjlGaDl0Rmk1cHptRWE0VDZuZnZDUzN5RTg2dStFVXBobGlacWswNExtMkNLbVp1cHIrcEx0OWJ1TFVnYlpkbmxmZVZPSk5DdGZ1U0dzeXdJYVFmWGpZZURzWmNvNEpnVzk0MXpRcWU3WEhibSt1UGVsL3ZZeTl4ZnovdGowYlNQazlNN09WdnJjK2xyYk9vVU5na2d5NTJaTDdTazNJNjMrajVtWDJ0NTd0QWZadVhmbWVkZithUzFONUI4NE82dnl6eHdrNUtsakU3Mklmb21SMzBxQko1aXd5dkVJK3BIQTQxdHliT3QvcS82aHc4NDF3cUoxczhJUVJLd01RR2dGQXJLdUl1YTVlNDN2c3VsZnY5MXdva2MyTnFONUtlYVFzV2RjVVUrVjlKeDU1NTFFN2Y0OGNpM25YclRTQ01MZGxKeWt6MkxPYW1mcHVEb0cyNFhwMEZPNzEweUhtTDFpbUVkSll1aHdEcy9seEN1eU1LcHpXNlhXb3d0ajhlWnZCdDcvbzJDTUkyWVNsOHZWRjVqdzBQNlpHOXlkMmpwMy8reFpTeHRtRVFvTnB0ek9WNUhHcXk5Y3ZrZmxURmhLU0dVOWkzNFZrWDIwUi82ckZKZ0FTWW5xa0VhZ0JTSXRxQ0hBVWNZaE5pYmw0ciswejkxUC96ZHJ0NE1vcGRCZzR0a2toUS9SK2tCbllwNFpZUHE4RExDLzkxY3lKdU1wYXZhZnh4M25CdkNtb25TUHVEaXpWMm5RdVA3UGx3eXg3RzJOdVhXVDRRM0NoR0JFa0pMQmJCZVVjZlZ2UFBib1hFbll0WFR0eTNEWUx4SUFmVEM4ZUVCRWlTSm92VzlKL1J6K1E1T2dEOXp2RzRsVjcrQWl3U2YrQ0ZtL2NibXFzY0xZNm1Fa3pSZ0RlYjkxQ21paHZLRTB2T2tMYmFwV3JVK0V5VjZudEpaZGJhMnBwUisvbUxWUVA4QWxzOEhCMjdEbGozM1laQlV0NE1vcTFZd1V1OG5YWG8xUVk2dHlUMlU1S3k5ZWVzSTRDVHBKUnNjTFRuaHJWeVFEbWYwZnpVeW16c1ZXTkZGaGdZT3owdUpxRWFXRFFKc3luZUhpKzA2cEZqVVhPQUs0bDZyak40OEVlRjFWVzJrcHFtYldxREJDN3ZydEtlYzh6REJhR2hiVzZKMU13enUwb1hXVUxjcmpzbWd4WEw5L0hLRzZBcVpUWk1ycGFLdjlwRFA5aHlzNXh5Nkh3d2JBeEx3dGkwMDYzTlR2NThLTGhZSjh1R0RhTGFqR1FNalUyT09BbXo0MHJuS1NicW14ZGlSc29xQ3lPZTlubEp2aFkwcHlWMVdEQndUM1VWazUveTZkdlNkcmlDRlFKK2ozblA5UzF6NnF1bTBtNElFdHF6Z3BrOHVwN3NhdjdKUnRHb2pIZG5VSC8xN2FJL2lrWnJGSXpEQ01TMGk2RTZuTGdkS255d3dCVVQ4ZkFReGRVNUllTUJPNm9PbCtacWVtWnAwMis4b2E2MjRmS3FPTHhKazFETktyYWprc2hqV2RTUEhmMTRGaGpidmV0U3gyeXdTbnoyck8rZFBuRUdUK1E1eWNyYnhyUEV0SWpxYVF5N0M1aHZncnVRMDFKcFUrcmpEenhJM3cxbVQ0ZDdyZVhZbVVUNzVjczZibGVWOXR3aWQ0MmdDWEwwQWhJdmZna3lvRmt2SGhTcVFFSy9lZUYxbThObTZJSlppNFJvd095a3Btc2gwSnhubk1SQWREYnFKbVl2RVRldGZjOUQ2RExVSjFBdGwrbjROL3Uxdjg0aDNqZk1Bd1hoNFE4WEpIUzVJVkZDT1IrQ3prelhQRjNRU2tMYkdDNHROTzNRc0h6QzFUQUlTSEYrZmtOb1FoMnNSYi9nUnYzSytqRlJuSWVvVzhTYzlvalVKMTVHWlRMQzFzM1ZUa2hZLytpTHVGNXpPU0JnTFZOdzN4WllVSnQ3US9HTEJvZWR5Z0paZGJHZWtNQUpCZjl3UXpvOElvZHdZVVJ0a1FQWU5LMGMzT0UraUhGNjFYSDZ4VE85NDFUcFhlWWdRTTJzSEVEVW9jVFJPMGdnRWxJelVobUJna2luc2VFOGRLMzFweHU5OW55b2FsR0IrUG5yd1cvYXRRandtK0hCZHI5K05DT2VleGthV1lBREVlMG9jNEFFN3prOHBjYmRZdWJaak9VRjNWL3JwWnFTZHlidmdqMUxTc0ZLUlY3K01RalBBeDNiTUFjeFVnMDZzSGFkeUNTR1ZoellBMktreHB6NDF1aXpzMGdUNmQ4cTlHYlJlNVU3dm9mR3lER3c0ajJleU0zOVcyZFpuTmRDcjhmU0IvVjNyVmUwUXc5alNBejk1VmJaWENrcWlnM0Zrb2ZpM01DdXpRRXh5MUdPWkFlTGdyNHVYRFdPUjBhaDZKRGZoTGt4THVoZjg1N0orL1ZHaTJ4VTlqN0ZWN1dxNHQ0OVR0aUxFRFYyZG5Idk4xaHQrNWM5UDR3WlVQeFM2OTdCVVhzK3Z0S0RIYytWUThWZEw5aVJqclNTUlU2dmNGbnhxNjhZNmRDWnRlcVEwMThFdCtLM1hmMG5QQkQraFFFdnMxS3cxSnU3Q2ZTZGpBZjZqTGNkdytPYXdMRExqallXQUNEOWN2T0pnbVRNS3dXRGFrN3hCRC9GUHRoUnlHbWZweStCN2V0aXB4cFM1aEIySFk1OGl6N3krOC95R3BmWDRVZmJxbEd5dmo0RE9RN2pGMXFBaHhZVTQxczZxRDBtMGVyUFZuYVRjN000WnNoaXg1OFF6bEpvc0ZSZkxPSWhVeGtUYTZxTk5IUXluekV2YTl0aGpuS3oydXZLM2ZXYjhhc3cyVDRUbWYzSXBpQ3BRU3ZtNHMxUWdncGFUbE5TZFZCRmx5ajRKaHZwemNHdHFFcmRFNlA5NHlkS0dRb1ZoOEFlTUlDNE5pRjVRYXhGMmxWWW50QU5jYWZJaFFFVmVuM0htbFBmZUZBNWNhTGNwRnlycEpMRWQxc0pEUlUyYmJVM2F1aTU4QUNLK29wdVAxUkJYUU9hODJ4NnF6bXVQTGpwY3NZa08wbGNZUTJZS1V2K1AxR0RTQWt2YTJqV2JoQ2c2KzhOaHY4WXFna2dnMXRjRkppc3RGTGR3amVIWHFGTG56K3huOW04cmpRNzJLTS9oYzNPbGV5YURHeFpaQUdyRVNxcU03Sk1zWlpOZUFQc2NhNG5lRlM5bEVCMjhGa0RWR0lCbjRMTDJLaUFZdzM3WUpFYXB0ZWdiTHFSb3g0UXMzZGRiS3lLamhFOFFWYnBhUTBIbnN0OXIvdFZUQmlwZFdZU0lNVjVrNGFrUWs0cE5CMmxOZlFodkVidnpzN0ZEdCtTeTRLdkV5NGJRMlhxYXgwcm1NckJId21qR3Qwb2RTS05tanU3UHlJNDlpM0VEYkdpZ3F0TlVVaWVrbmhIdmF3T1paQmFMQXBwM2lEVmdKYnozazZhQitTYkVsZWZicFhTZDY1cFNpd1dpYlZSYWNvVFRHN3RiSURuUm5UdTY4VDFJQUp2WHNKMGFxbklub1dWbEN4N1J6S3d0MUVXK2l3aDJhYU5QdXJTeTE3aUVNZnVZSk4yNHF4dTZNV1BWL3ZobjFXWG1BWjhlYnNJR25SaG5VZWM2b21ZY2Vrc1QyQlNTdkVQU2RtejNBMWZWczlwd2JZY0RpV0lNMWNNYkN0eWRmUDRPbUxYenZIMm84ZmlNajFHb3FhRG9ydDNCZElCZjJLWTVVdG8rbnhBaHFtWlVKcHIwalVwdnZLUWEvZHgwYlQrSHZhSFFCVWp3RVVia1VHYkJDL1F3Y21uazRWbTV1aEFBSEt6QnovUWs3K3VtTFIzckNQdlpnT0pWNnU5RmJIVTlqc0NWdkFEUHJEcmpBMm00ZmpGbEFQQzRLNXcxVE5iSGwvK3JNK1AzRXlvZWVuNWpJM3pVaWpPUHBUZ3UwZGY0dFRaaWtNVk9CUXlPTklPZ243V3ZLeHBCRFk2VzVSeG9XdFBCOFRaN2IxWGk0U3F4VWg4Vm1uUEJ2cUlyc0pJWndOS2l6emRyS1lGUkF2R3VYUnQyKzJoODludUQ1aGNuZnU4OWN4MGtyRjFsRWo3cE9SaU1iSXMwVWE5MmJERWR2Q2UwSzdXdUJoelltNTRSdVdFYkk2Mng2ZDVVdzA3c3NsaEV1NnJ2cDd4OW54VVhWS0ljN3BkL1hjTEgxUXJFOERXUzZFZk9kZk1XVGxpNWdWa3Y2RHVwRnl3MDlhOW5nU3NlVGZPbDUvVmRqUElUZ0Jza1VrSUh4VzVNZjlwWVV2cWdQOW9EdXR4czZRdkhyVFAxUjF3YUswZDRlTGpJQzJOK1JkeXRwYVoxSWFwZndvYXZSaGt3T21NZ1lIbGxqMkxGQ2ljVVo3bHdtVDdwYUh6Q1EzLzVJemNFNjVhcFJ6RTFCTXpIdjU3K1dyV1c0emZVdWMvbWFEUXpzMHBhTGVJOStqYTY4RzBnckYwODg5aXlhOFIwbUtZVmVWWDNVNXVHM2E5b1Vkbnl1Sys2U0pjNDVLOERNQTBoR3FLcVhlclBPTk9iUndQQkpDcWxXcVZSdUQ0a21KVjV0QnJTbzZtY214bVlvcDkxK1ViamdpYXJuSnF0MkNCb3NtbWp5aVlSamRVUndQcFFTVHh2UllWczJ6ZFRjazQ1MVcrRDkxNjhGT1ZPMk1iRit4dm1xR2ZTVmdJTEZZU3N5N0wxTzE4ZUlZM1FTeTZUS3RCVjE2VGkxWEdVdURDMjFxUGdJTEdiNGtocGpaeVF1cnJ4OEx5Yk9OVncxYnFoMEh5cHppSTRPb1FqOUkwdGRRUDMxMVg2RmdPYWY0TUp3ZjB0MEtSaHRBVmRqMTJUdDZtM2VmU3c1Um5HdHhqU0dpVFNjWG1nYnp5SVNWRzNRM29ZSEF6ekh4T3RmQjF3ZkZKRnh4bjcvVjFPcEtDV3lMZDYybWZJR0t4OW14VGZyN1hYWG1BSVlBRU1oMCtDSGJobzIvVStBU1hlcEdFU3YvZGFiTExzMkZ6My9MdG93T0twUzJCcXNIZVZXYkRMbmZ0aHhLQkcvTlVsemVCU2kzTkxjdWowby9uckM5ZlI3OEtDeVBiOWp2MnN4bVRaMXZrNW9HcVhSakpoZi9Wd0lGQU5zWFMvSW1ub1d3eHdyeEl3K29CdVhYZnFpVTlWdzRkenBRTlA5RDk1UmFNbXZETDRESjJ6RlpQVkUyOUZhbkQrMDVibHY4M3d2Q09KcXBnem9uNUZuQmpxcnVkMGxsR085Y2tGajZSbnp4RVhiNHlON2Fxc1pXRDRaL2ZRL250bjgwWkdvTEgvc1k4NWxVYVZHN0tGaTJsQlRxYUdVR0Z4OUNDcjUvUE0zNzVTdDdvNTJ5L21QbFlkeWNueW40TVNCRm9oalZaZjZIQlRJc3ZNdEVtMUNXdjVwODRRcnZXK0RyOWJQd015ZnVxNG15Y0NQV3hKdzVzVS91am9JaE5WdWVRb1E3YkNFR2F2eUFVY0tQRHJXaEJTSWtRUWpMdExIb1YrcWtRdVBUMTFjZFcvUjFNc0k3UlFSTUZtTWsxbkJNbm1sZEF6eWNiVEdRNVFDQUVaOHRCYlJVOWdlOW1uTXZCTzV1Y1BUQWZxYzUxWG1XajE5VFI3SHpQZThBMkx4TXMveEhKV1pES2ovOUpzWXFHN3R5dVZEVmZET2I4bzJnSm51V045M2RuY3pZT2dueC9uZllucUlxcDA0QUJiMEVtM21tRm5MK2o0Q3dJUDR3T0xrL2FTbDhpTS9UeWdaWmh5WW9jY0JuQmpmOUVqZWoxK2pFanlnYXpDMEZheGpveEVHcTNjWENJRVNyZU56SHFqZjBpTzRCQSsyVUMwL1k4cHZ4NWovQi8rQjNhTnNpTGlsQUFBQUFFbEZUa1N1UW1DQ1xcXCIpO1xcbiAgLyphbmltYXRpb246IGdyYWluIDhzIHN0ZXBzKDEwKSBpbmZpbml0ZTsqL1xcbn1cXG5cIiwgXCJcIix7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJDOi9Vc2Vycy9wYXVsby9EZXNrdG9wL1dvcmsvUHJvamVjdHMvUGVyc29uYWwvV2ViL3BhdWxvYm1hcmNvcy93d3cvc2hhcmVkL2NvbXBvbmVudHMvZ3JhaW4vR3JhaW4ubW9kdWxlLmNzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFBQTtFQUNFO1NBQ08sMEJBQTBCLEVBQUU7O0VBRW5DLE1BQU0sK0JBQStCLEVBQUU7RUFDdkMsTUFBTSw4QkFBOEIsRUFBRTtFQUN0QyxNQUFNLDhCQUE4QixFQUFFO0VBQ3RDLE1BQU0sOEJBQThCLEVBQUU7RUFDdEMsTUFBTSwrQkFBK0IsRUFBRTtFQUN2QyxNQUFNLDZCQUE2QixFQUFFO0VBQ3JDLE1BQU0sNkJBQTZCLEVBQUU7RUFDckMsTUFBTSw2QkFBNkIsRUFBRTtFQUNyQyxNQUFNLCtCQUErQixFQUFFO0FBQ3pDOztBQUVBO0VBQ0Usa0JBQWtCO0VBQ2xCLFVBQVU7QUFDWjs7QUFFQTtFQUNFLFdBQVc7RUFDWCxrQkFBa0I7RUFDbEIsVUFBVTtFQUNWLFdBQVc7RUFDWCxXQUFXO0VBQ1gsWUFBWTtFQUNaLFlBQVk7RUFDWiwrbXNDQUFxRDtFQUNyRCwwQ0FBMEM7QUFDNUNcIixcImZpbGVcIjpcIkdyYWluLm1vZHVsZS5jc3NcIixcInNvdXJjZXNDb250ZW50XCI6W1wiQGtleWZyYW1lcyBncmFpbiB7XFxuICAwJSxcXG4gIDEwMCUgeyB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgwLCAwKTsgfVxcblxcbiAgMTAlIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGUoLTUlLCAtMTAlKTsgfVxcbiAgMjAlIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGUoLTE1JSwgNSUpOyB9XFxuICAzMCUgeyB0cmFuc2Zvcm06IHRyYW5zbGF0ZSg3JSwgLTI1JSk7IH1cXG4gIDQwJSB7IHRyYW5zZm9ybTogdHJhbnNsYXRlKC01JSwgMjUlKTsgfVxcbiAgNTAlIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGUoLTE1JSwgMTAlKTsgfVxcbiAgNjAlIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGUoMTUlLCAwJSk7IH1cXG4gIDcwJSB7IHRyYW5zZm9ybTogdHJhbnNsYXRlKDAlLCAxNSUpOyB9XFxuICA4MCUgeyB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgzJSwgMzAlKTsgfVxcbiAgOTAlIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGUoLTEwJSwgMTAlKTsgfVxcbn1cXG5cXG4uZ3JhaW4ge1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgei1pbmRleDogMDtcXG59XFxuXFxuLmdyYWluOjphZnRlciB7XFxuICBjb250ZW50OiBcXFwiXFxcIjtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHRvcDogLTEwMCU7XFxuICBsZWZ0OiAtMTAwJTtcXG4gIHdpZHRoOiAzMDAlO1xcbiAgaGVpZ2h0OiAzMDAlO1xcbiAgb3BhY2l0eTogMC40O1xcbiAgYmFja2dyb3VuZC1pbWFnZTogdXJsKFxcXCIuLi8uLi9tZWRpYS9pbWFnZXMvZ3JhaW4ucG5nXFxcIik7XFxuICAvKmFuaW1hdGlvbjogZ3JhaW4gOHMgc3RlcHMoMTApIGluZmluaXRlOyovXFxufVxcblwiXX1dKTtcbi8vIEV4cG9ydHNcbmV4cG9ydHMubG9jYWxzID0ge1xuXHRcImdyYWluXCI6IFwiR3JhaW5fZ3JhaW5fX2hWRlIwXCJcbn07XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHM7XG4iLCIvLyBJbXBvcnRzXG52YXIgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanNcIik7XG5leHBvcnRzID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKHRydWUpO1xuLy8gTW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIvKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcbiAgIEN1c3RvbSBtZWRpYSBxdWVyaWVzXFxuXFxuICAgVXNlIGl0IGxpa2Ugc286IEBtZWRpYSAoLS1sYXlvdXQtc21hbGwpIHsgLi4uIH1cXG4gICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xcblxcbi8qIDM3NXB4ICovXFxuXFxuLyogNDgwcHggKi9cXG5cXG4vKiA3NjhweCAqL1xcblxcbi8qIDEwMjRweCAqL1xcblxcbi8qIDEyODBweCAqL1xcblxcbi8qIDE0NDBweCAqL1xcblxcbi8qIDE5MjBweCAqL1xcblxcbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxuICAgQ29sb3JzXFxuICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cXG5cXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcbiAgIFotSW5kZXhlc1xcbiAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXFxuXFxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXG4gICBTaXplc1xcbiAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXFxuXFxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXG4gICAgTGFuZHNjYXBlXFxuICAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXFxuXFxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXG4gICAgUG9ydHJhaXRcXG4gICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cXG5cXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcbiAgIEN1c3RvbSBtZWRpYXNcXG4gICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xcblxcbi8qIE1JWElOUyAqL1xcblxcbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxuICAgU21vb3RoICYgc2hhcnAgbWl4aW5zXFxuICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cXG5cXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcbiAgIEVsbGlwc2lzIG1peGluXFxuXFxuICAgVGhlIGNvbnRhaW5lciBuZWVkcyB0byBoYXZlIGEgd2lkdGggZm9yIGl0IHRvIHdvcmtcXG4gICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xcblxcbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxuICBGb250c1xcbiAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cXG5cXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcbiAgQWxsIHR5cG9ncmFwaHkgdmFyaWFudHNcXG5cXG4gICR1bml0IC0gRWl0aGVyIGVtIG9yIHJlbVxcbiAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cXG5cXG4uSGVhZGVyX2hlYWRlcl9fMzZmRUsge1xcbiAgcG9zaXRpb246IGZpeGVkO1xcbiAgdG9wOiBjYWxjKGNhbGMoMi4ycmVtICogMikgKyAyLjJyZW0pO1xcbiAgdG9wOiBjYWxjKGNhbGMoMi4ycmVtICogMikgKyAyLjJyZW0pO1xcbiAgbGVmdDogMDtcXG4gIHdpZHRoOiAxMDB2dztcXG4gIGhlaWdodDogNHJlbTtcXG4gIGhlaWdodDogNHJlbTtcXG4gIHotaW5kZXg6IDU7XFxuICB6LWluZGV4OiA1O1xcbiAgcGFkZGluZzogMCBjYWxjKDIuMnJlbSAqIDIpO1xcbiAgcGFkZGluZzogMCBjYWxjKDIuMnJlbSAqIDIpO1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbn1cXG5cXG5AbWVkaWEgKG1heC13aWR0aDogNDhlbSkge1xcblxcbiAgLkhlYWRlcl9oZWFkZXJfXzM2ZkVLIHtcXG4gIHBhZGRpbmc6IDAgY2FsYygydncgKiAyKTtcXG4gIH1cXG59XFxuXFxuQG1lZGlhIChtYXgtd2lkdGg6IDQ4ZW0pIHtcXG5cXG4gIC5IZWFkZXJfaGVhZGVyX18zNmZFSyB7XFxuICB0b3A6IGNhbGMoY2FsYygyLjJyZW0gKiAyKSArIDJ2dyk7XFxuICB9XFxufVxcblxcbkBtZWRpYSAobWF4LXdpZHRoOiA0OGVtKSB7XFxuXFxuICAuSGVhZGVyX2hlYWRlcl9fMzZmRUsge1xcbiAgdG9wOiBjYWxjKGNhbGMoMi4ycmVtICogMikgKyAydncpO1xcbiAgfVxcbn1cXG5cXG4uSGVhZGVyX2NvbnRlbnRfX25EUUpmIHtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgbWF4LXdpZHRoOiAxNTByZW07XFxuICBtYXgtd2lkdGg6IDE1MHJlbTtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBmbGV4LWRpcmVjdGlvbjogcm93O1xcbiAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG59XFxuXFxuLkhlYWRlcl9uYW1lX18xNlRZQSB7XFxuICBmbGV4OiAxIDEgMDtcXG4gIGZvbnQtc2l6ZTogMy4ycmVtO1xcbiAgY3Vyc29yOiBkZWZhdWx0XFxufVxcblxcbi5IZWFkZXJfbmFtZV9fMTZUWUEgPiAqIHtcXG4gICAgZm9udC13ZWlnaHQ6IG5vcm1hbDtcXG4gICAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcXG4gIH1cXG5cXG4uSGVhZGVyX25hbWVfXzE2VFlBIGIge1xcbiAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcXG4gIH1cXG5cXG4uSGVhZGVyX3NvY2lhbF9fMkR1N18ge1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGZsZXg6IDEgMSAwO1xcbiAganVzdGlmeS1jb250ZW50OiBmbGV4LWVuZDtcXG4gIC13ZWJraXQtdXNlci1zZWxlY3Q6IG5vbmU7XFxuICAgICAgLW1zLXVzZXItc2VsZWN0OiBub25lO1xcbiAgICAgICAgICB1c2VyLXNlbGVjdDogbm9uZVxcbn1cXG5cXG4uSGVhZGVyX3NvY2lhbF9fMkR1N18gYSB7XFxuICAgIGNvbG9yOiAjZmZmO1xcbiAgICBjb2xvcjogI2ZmZlxcbiAgfVxcblxcbi5IZWFkZXJfc29jaWFsX18yRHU3XyBhOm5vdCg6Zmlyc3QtY2hpbGQpIHtcXG4gICAgICBtYXJnaW4tbGVmdDogM3JlbTtcXG4gICAgfVxcblxcbi5IZWFkZXJfc29jaWFsX18yRHU3XyBhIHN2ZyB7XFxuICAgICAgaGVpZ2h0OiAyLjRyZW07XFxuICAgICAgdHJhbnNpdGlvbjogZmlsbCAwLjJzIGVhc2Utb3V0O1xcbiAgICAgIGZpbGw6ICNmZmY7XFxuICAgICAgZmlsbDogI2ZmZjtcXG4gICAgfVxcblxcbi5IZWFkZXJfc29jaWFsX18yRHU3XyBhOmhvdmVyIHN2ZyB7XFxuICAgICAgZmlsbDogIzY0ZjRhYztcXG4gICAgICBmaWxsOiAjNjRmNGFjO1xcbiAgICB9XFxuXFxuLkhlYWRlcl9saW5rc19fMWo4TFQge1xcbiAgZGlzcGxheTogZmxleDtcXG4gIC13ZWJraXQtdXNlci1zZWxlY3Q6IG5vbmU7XFxuICAgICAgLW1zLXVzZXItc2VsZWN0OiBub25lO1xcbiAgICAgICAgICB1c2VyLXNlbGVjdDogbm9uZVxcbn1cXG5cXG4uSGVhZGVyX2xpbmtzX18xajhMVCA+ICo6bm90KDpmaXJzdC1jaGlsZCkge1xcbiAgICBtYXJnaW4tbGVmdDogNWNoO1xcbiAgfVxcblxcbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxuICAgQ3VzdG9tIG1lZGlhc1xcbiAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXFxuXFxuQG1lZGlhIChtYXgtd2lkdGg6IDY0ZW0pIHtcXG4gIC5IZWFkZXJfbGlua3NfXzFqOExUIHtcXG4gICAgZGlzcGxheTogbm9uZTtcXG4gIH1cXG59XFxuXFxuQG1lZGlhIChtYXgtd2lkdGg6IDMwZW0pIHtcXG4gIC5IZWFkZXJfaGVhZGVyX18zNmZFSyB7XFxuICAgIHRvcDogM3JlbTtcXG4gICAgcGFkZGluZzogMCAyLjVyZW07XFxuICB9XFxuXFxuICAuSGVhZGVyX25hbWVfXzE2VFlBIHtcXG4gICAgZm9udC1zaXplOiA2LjV2dztcXG4gIH1cXG59XFxuXCIsIFwiXCIse1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wiQzovVXNlcnMvcGF1bG8vRGVza3RvcC9Xb3JrL1Byb2plY3RzL1BlcnNvbmFsL1dlYi9wYXVsb2JtYXJjb3Mvd3d3L3NoYXJlZC9zdHlsZXMvaW1wb3J0cy9jdXN0b20tbWVkaWFzLmNzc1wiLFwiQzovVXNlcnMvcGF1bG8vRGVza3RvcC9Xb3JrL1Byb2plY3RzL1BlcnNvbmFsL1dlYi9wYXVsb2JtYXJjb3Mvd3d3L3NoYXJlZC9zdHlsZXMvaW1wb3J0cy92YXJpYWJsZXMuY3NzXCIsXCJDOi9Vc2Vycy9wYXVsby9EZXNrdG9wL1dvcmsvUHJvamVjdHMvUGVyc29uYWwvV2ViL3BhdWxvYm1hcmNvcy93d3cvc2hhcmVkL3N0eWxlcy9pbXBvcnRzL2luZGV4LmNzc1wiLFwiQzovVXNlcnMvcGF1bG8vRGVza3RvcC9Xb3JrL1Byb2plY3RzL1BlcnNvbmFsL1dlYi9wYXVsb2JtYXJjb3Mvd3d3L3NoYXJlZC9zdHlsZXMvaW1wb3J0cy9taXhpbnMvdGV4dC5jc3NcIixcIkM6L1VzZXJzL3BhdWxvL0Rlc2t0b3AvV29yay9Qcm9qZWN0cy9QZXJzb25hbC9XZWIvcGF1bG9ibWFyY29zL3d3dy9zaGFyZWQvc3R5bGVzL2ltcG9ydHMvbWl4aW5zL3R5cG9ncmFwaHkuY3NzXCIsXCJDOi9Vc2Vycy9wYXVsby9EZXNrdG9wL1dvcmsvUHJvamVjdHMvUGVyc29uYWwvV2ViL3BhdWxvYm1hcmNvcy93d3cvc2hhcmVkL2NvbXBvbmVudHMvaGVhZGVyL0hlYWRlci5tb2R1bGUuY3NzXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJBQUFBOzs7OytFQUkrRTs7QUFFdEIsVUFBVTs7QUFDaEIsVUFBVTs7QUFDWCxVQUFVOztBQUNULFdBQVc7O0FBQ1osV0FBVzs7QUFDVixXQUFXOztBQUNULFdBQVc7O0FDVmhFOzsrRUFFK0U7O0FBYS9FOzsrRUFFK0U7O0FBUS9FOzsrRUFFK0U7O0FBaUIvRTs7Z0ZBRWdGOztBQVNoRjs7Z0ZBRWdGOztBQVNoRjs7K0VBRStFOztBQ25FL0UsV0FBVzs7QUNIWDs7K0VBRStFOztBQVkvRTs7OzsrRUFJK0U7O0FDaEIvRTs7OEVBRThFOztBQU85RTs7Ozs4RUFJOEU7O0FDYjlFO0VBQ0UsZUFBZTtFQUNmLG9DQUEwRDtFQUExRCxvQ0FBMEQ7RUFDMUQsT0FBTztFQUNQLFlBQVk7RUFDWixZQUE0QjtFQUE1QixZQUE0QjtFQUM1QixVQUE4QjtFQUE5QixVQUE4QjtFQUM5QiwyQkFBa0M7RUFBbEMsMkJBQWtDO0VBQ2xDLGFBQWE7RUFDYix1QkFBdUI7QUFDekI7O0FKNERBOztFSXRFQTtFQU9FLHdCQUFBO0VBR0Y7QUpnRUE7O0FBSkE7O0VJdEVBO0VBRUUsaUNBQUE7RUFRRjtBSmdFQTs7QUFKQTs7RUl0RUE7RUFFRSxpQ0FBQTtFQVFGO0FKZ0VBOztBSTlEQTtFQUNFLFdBQVc7RUFDWCxpQkFBa0M7RUFBbEMsaUJBQWtDO0VBQ2xDLGFBQWE7RUFDYixtQkFBbUI7RUFDbkIsOEJBQThCO0VBQzlCLG1CQUFtQjtBQUNyQjs7QUFFQTtFQUNFLFdBQVc7RUFDWCxpQkFBaUI7RUFDakI7QUFVRjs7QUFSRTtJQUNFLG1CQUFtQjtJQUNuQixtQkFBbUI7RUFDckI7O0FBRUE7SUFDRSxvQkFBb0I7RUFDdEI7O0FBR0Y7RUFDRSxhQUFhO0VBQ2IsV0FBVztFQUNYLHlCQUF5QjtFQUN6Qix5QkFBaUI7TUFBakIscUJBQWlCO1VBQWpCO0FBbUJGOztBQWpCRTtJQUNFLFdBQXlCO0lBQXpCO0VBZUY7O0FBYkU7TUFDRSxpQkFBaUI7SUFDbkI7O0FBRUE7TUFDRSxjQUFjO01BQ2QsOEJBQThCO01BQzlCLFVBQXdCO01BQXhCLFVBQXdCO0lBQzFCOztBQUVBO01BQ0UsYUFBd0I7TUFBeEIsYUFBd0I7SUFDMUI7O0FBSUo7RUFDRSxhQUFhO0VBQ2IseUJBQWlCO01BQWpCLHFCQUFpQjtVQUFqQjtBQUtGOztBQUhFO0lBQ0UsZ0JBQWdCO0VBQ2xCOztBQUdGOzsrRUFFK0U7O0FBRS9FO0VBQ0U7SUFDRSxhQUFhO0VBQ2Y7QUFDRjs7QUFFQTtFQUNFO0lBQ0UsU0FBUztJQUNULGlCQUFpQjtFQUNuQjs7RUFFQTtJQUNFLGdCQUFnQjtFQUNsQjtBQUNGXCIsXCJmaWxlXCI6XCJIZWFkZXIubW9kdWxlLmNzc1wiLFwic291cmNlc0NvbnRlbnRcIjpbXCIvKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcbiAgIEN1c3RvbSBtZWRpYSBxdWVyaWVzXFxuXFxuICAgVXNlIGl0IGxpa2Ugc286IEBtZWRpYSAoLS1sYXlvdXQtc21hbGwpIHsgLi4uIH1cXG4gICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xcblxcbkBjdXN0b20tbWVkaWEgLS1sYXlvdXQtbHRlLXh4c21hbGwgKHdpZHRoIDw9IDIzLjQzNzVlbSk7IC8qIDM3NXB4ICovXFxuQGN1c3RvbS1tZWRpYSAtLWxheW91dC1sdGUteHNtYWxsICh3aWR0aCA8PSAzMGVtKTsgLyogNDgwcHggKi9cXG5AY3VzdG9tLW1lZGlhIC0tbGF5b3V0LWx0ZS1zbWFsbCAod2lkdGggPD0gNDhlbSk7IC8qIDc2OHB4ICovXFxuQGN1c3RvbS1tZWRpYSAtLWxheW91dC1sdGUtbWVkaXVtICh3aWR0aCA8PSA2NGVtKTsgLyogMTAyNHB4ICovXFxuQGN1c3RvbS1tZWRpYSAtLWxheW91dC1sdGUtbGFyZ2UgKHdpZHRoIDw9IDgwZW0pOyAvKiAxMjgwcHggKi9cXG5AY3VzdG9tLW1lZGlhIC0tbGF5b3V0LWx0ZS14bGFyZ2UgKHdpZHRoIDw9IDkwZW0pOyAvKiAxNDQwcHggKi9cXG5AY3VzdG9tLW1lZGlhIC0tbGF5b3V0LWx0ZS14eGxhcmdlICh3aWR0aCA8PSAxMjBlbSk7IC8qIDE5MjBweCAqL1xcblwiLFwiQGltcG9ydCBcXFwiLi9jdXN0b20tbWVkaWFzXFxcIjtcXG5cXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcbiAgIENvbG9yc1xcbiAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXFxuXFxuOnJvb3Qge1xcbiAgLS1jb2xvci13aGl0ZTogI2ZmZjtcXG4gIC0tY29sb3ItYmxhY2s6ICMwMDA7XFxuICAtLWNvbG9yLWRhcms6ICMwZjBmMTE7XFxuICAtLWNvbG9yLWdyYXk6ICMyZDJlMzI7XFxuICAtLWNvbG9yLWxpZ2h0LWdyYXk6ICNjMWM1ZDQ7XFxuICAtLWNvbG9yLWRhcmstZ3JheTogIzE5MWExZDtcXG4gIC0tY29sb3ItZ3JlZW46ICM2NGY0YWM7XFxuICAtLWNvbG9yLWdyZWVuLWRhcms6ICMyODYxNDQ7XFxufVxcblxcbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxuICAgWi1JbmRleGVzXFxuICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cXG5cXG46cm9vdCB7XFxuICAtLXotaW5kZXgtYmFzZTogMTtcXG4gIC0tei1pbmRleC1oZWFkZXI6IDU7XFxuICAtLXotaW5kZXgtZnJhbWU6IDY7XFxufVxcblxcbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxuICAgU2l6ZXNcXG4gICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xcblxcbjpyb290IHtcXG4gIC0tbGF5b3V0LXdpZHRoOiAxMDB2dztcXG4gIC0tbGF5b3V0LWhlaWdodDogMTAwdmg7XFxuICAtLWxheW91dC1tYXgtd2lkdGg6IDE1MHJlbTtcXG4gIC0tbGF5b3V0LXBhZGRpbmc6IDIuMnJlbTtcXG5cXG4gIC0taGVhZGVyLWhlaWdodDogNHJlbTtcXG4gIC0taGVhZGVyLWZyYW1lLXRvcDogY2FsYyh2YXIoLS1sYXlvdXQtcGFkZGluZykgKiAyKTtcXG5cXG4gIC0tY29udGVudC12aWV3cG9ydC1oZWlnaHQ6IGNhbGMoMTAwdmggLSAodmFyKC0tbGF5b3V0LXBhZGRpbmcpICogMikpO1xcblxcbiAgLS1jYXJvdXNlbC1pdGVtLXdpZHRoOiA2MHZ3O1xcbiAgLS1jYXJvdXNlbC1pdGVtLWhlaWdodDogMzB2dztcXG59XFxuXFxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXG4gICAgTGFuZHNjYXBlXFxuICAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXFxuXFxuQG1lZGlhIChvcmllbnRhdGlvbjogbGFuZHNjYXBlKSB7XFxuICA6cm9vdCB7XFxuICAgIC0tY2Fyb3VzZWwtaXRlbS13aWR0aDogNjB2dztcXG4gICAgLS1jYXJvdXNlbC1pdGVtLWhlaWdodDogMzN2dztcXG4gIH1cXG59XFxuXFxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXG4gICAgUG9ydHJhaXRcXG4gICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cXG5cXG5AbWVkaWEgKG9yaWVudGF0aW9uOiBwb3J0cmFpdCkge1xcbiAgOnJvb3Qge1xcbiAgICAtLWNhcm91c2VsLWl0ZW0td2lkdGg6IDgwdnc7XFxuICAgIC0tY2Fyb3VzZWwtaXRlbS1oZWlnaHQ6IDgwdnc7XFxuICB9XFxufVxcblxcbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxuICAgQ3VzdG9tIG1lZGlhc1xcbiAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXFxuXFxuQG1lZGlhICgtLWxheW91dC1sdGUtc21hbGwpIHtcXG4gIDpyb290IHtcXG4gICAgLS1sYXlvdXQtcGFkZGluZzogMnZ3O1xcbiAgfVxcbn1cXG5cIixcIkBpbXBvcnQgXFxcIi4vY3VzdG9tLW1lZGlhcy5jc3NcXFwiO1xcbkBpbXBvcnQgXFxcIi4vdmFyaWFibGVzLmNzc1xcXCI7XFxuXFxuLyogTUlYSU5TICovXFxuQGltcG9ydCBcXFwiLi9taXhpbnMvdGV4dC5jc3NcXFwiO1xcbkBpbXBvcnQgXFxcIi4vbWl4aW5zL3R5cG9ncmFwaHkuY3NzXFxcIjtcXG5AaW1wb3J0IFxcXCIuL21peGlucy91bnN0eWxlZC1idXR0b24uY3NzXFxcIjtcXG5cIixcIi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxuICAgU21vb3RoICYgc2hhcnAgbWl4aW5zXFxuICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cXG5cXG5AZGVmaW5lLW1peGluIHRleHQtc21vb3RoIHtcXG4gICAgLW1vei1vc3gtZm9udC1zbW9vdGhpbmc6IGdyYXlzY2FsZTsgIC8qIEZvbnQgc21vb3RoaW5nIHR3ZWFrcyBmb3IgTWFjT1N4IGluIEdlY2tvICovXFxuICAgIC13ZWJraXQtZm9udC1zbW9vdGhpbmc6IGFudGlhbGlhc2VkOyAvKiBGb250IHNtb290aGluZyB0d2Vha3MgZm9yIE1hY09TeCBpbiBXZWJraXQgKi9cXG59XFxuXFxuQGRlZmluZS1taXhpbiB0ZXh0LXNoYXJwIHtcXG4gICAgLW1vei1vc3gtZm9udC1zbW9vdGhpbmc6IGluaXRpYWw7ICAgLyogVHVybiBvZmYgZm9udCBzbW9vdGhpbmcgdHdlYWtzIGZvciBNYWNPU3ggaW4gR2Vja28gKi9cXG4gICAgLXdlYmtpdC1mb250LXNtb290aGluZzogaW5pdGlhbDsgICAgLyogVHVybiBvZmYgZm9udCBzbW9vdGhpbmcgdHdlYWtzIGZvciBNYWNPU3ggaW4gV2Via2l0ICovXFxufVxcblxcbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxuICAgRWxsaXBzaXMgbWl4aW5cXG5cXG4gICBUaGUgY29udGFpbmVyIG5lZWRzIHRvIGhhdmUgYSB3aWR0aCBmb3IgaXQgdG8gd29ya1xcbiAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXFxuXFxuQGRlZmluZS1taXhpbiB0ZXh0LWVsbGlwc2lzIHtcXG4gICAgb3ZlcmZsb3c6IGhpZGRlbjsgLyogXFxcIm92ZXJmbG93XFxcIiB2YWx1ZSBtdXN0IGJlIGRpZmZlcmVudCBmcm9tIFxcXCJ2aXNpYmxlXFxcIiAqL1xcbiAgICB0ZXh0LW92ZXJmbG93OiBlbGxpcHNpcztcXG4gICAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcXG4gICAgb3ZlcmZsb3ctd3JhcDogbm9ybWFsO1xcbn1cXG5cXG5AZGVmaW5lLW1peGluIHRleHQtZWxsaXBzaXMtbXVsdGlsaW5lICRtYXgtbGluZS1jb3VudCwgJG1heC1oZWlnaHQge1xcbiAgICBtYXgtaGVpZ2h0OiAkbWF4LWhlaWdodDtcXG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcXG4gICAgLyogc3R5bGVsaW50LWRpc2FibGUgKi9cXG4gICAgZGlzcGxheTogLXdlYmtpdC1ib3g7XFxuICAgIHRleHQtb3ZlcmZsb3c6IGVsbGlwc2lzO1xcbiAgICAtd2Via2l0LWxpbmUtY2xhbXA6ICRtYXgtbGluZS1jb3VudDtcXG4gICAgLXdlYmtpdC1ib3gtb3JpZW50OiB2ZXJ0aWNhbDtcXG4gICAgLyogc3R5bGVsaW50LWVuYWJsZSAqL1xcbn1cXG5cIixcIkBpbXBvcnQgXFxcIi4uL2N1c3RvbS1tZWRpYXNcXFwiO1xcblxcbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxuICBGb250c1xcbiAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cXG5cXG5AZGVmaW5lLW1peGluIF9mb250LWthcmFzdW1hICRmb250V2VpZ2h0OiBub3JtYWwge1xcbiAgZm9udC1mYW1pbHk6IFxcXCJLYXJhc3VtYVxcXCIsIHNhbnMtc2VyaWY7XFxuICBmb250LXdlaWdodDogJChmb250V2VpZ2h0KTtcXG59XFxuXFxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXG4gIEFsbCB0eXBvZ3JhcGh5IHZhcmlhbnRzXFxuXFxuICAkdW5pdCAtIEVpdGhlciBlbSBvciByZW1cXG4gID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXFxuXFxuQGRlZmluZS1taXhpbiB0eXBvZ3JhcGh5LWgxICR1bml0OiByZW0ge1xcbiAgQG1peGluIF9mb250LWthcmFzdW1hIGJvbGRlcjtcXG4gIGZvbnQtc2l6ZTogOCQodW5pdCk7XFxufVxcblxcbkBkZWZpbmUtbWl4aW4gdHlwb2dyYXBoeS1oMiAkdW5pdDogcmVtIHtcXG4gIEBtaXhpbiBfZm9udC1rYXJhc3VtYSBib2xkO1xcbiAgZm9udC1zaXplOiA0LjgkKHVuaXQpO1xcbn1cXG5cXG5AZGVmaW5lLW1peGluIHR5cG9ncmFwaHktYm9keSAkdW5pdDogcmVtIHtcXG4gIEBtaXhpbiBfZm9udC1rYXJhc3VtYTtcXG4gIGZvbnQtc2l6ZTogMS42JCh1bml0KTtcXG59XFxuXFxuQGRlZmluZS1taXhpbiB0eXBvZ3JhcGh5LWJvZHkgJHVuaXQ6IHJlbSB7XFxuICBAbWl4aW4gX2ZvbnQta2FyYXN1bWE7XFxuICBmb250LXNpemU6IDEuNiQodW5pdCk7XFxufVxcblwiLFwiQGltcG9ydCBcXFwiLi4vLi4vc3R5bGVzL2ltcG9ydHMvaW5kZXguY3NzXFxcIjtcXG5cXG4uaGVhZGVyIHtcXG4gIHBvc2l0aW9uOiBmaXhlZDtcXG4gIHRvcDogY2FsYyh2YXIoLS1oZWFkZXItZnJhbWUtdG9wKSArIHZhcigtLWxheW91dC1wYWRkaW5nKSk7XFxuICBsZWZ0OiAwO1xcbiAgd2lkdGg6IDEwMHZ3O1xcbiAgaGVpZ2h0OiB2YXIoLS1oZWFkZXItaGVpZ2h0KTtcXG4gIHotaW5kZXg6IHZhcigtLXotaW5kZXgtaGVhZGVyKTtcXG4gIHBhZGRpbmc6IDAgdmFyKC0taGVhZGVyLWZyYW1lLXRvcCk7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxufVxcblxcbi5jb250ZW50IHtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgbWF4LXdpZHRoOiB2YXIoLS1sYXlvdXQtbWF4LXdpZHRoKTtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBmbGV4LWRpcmVjdGlvbjogcm93O1xcbiAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG59XFxuXFxuLm5hbWUge1xcbiAgZmxleDogMSAxIDA7XFxuICBmb250LXNpemU6IDMuMnJlbTtcXG4gIGN1cnNvcjogZGVmYXVsdDtcXG5cXG4gICYgPiAqIHtcXG4gICAgZm9udC13ZWlnaHQ6IG5vcm1hbDtcXG4gICAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcXG4gIH1cXG5cXG4gICYgYiB7XFxuICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xcbiAgfVxcbn1cXG5cXG4uc29jaWFsIHtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBmbGV4OiAxIDEgMDtcXG4gIGp1c3RpZnktY29udGVudDogZmxleC1lbmQ7XFxuICB1c2VyLXNlbGVjdDogbm9uZTtcXG5cXG4gICYgYSB7XFxuICAgIGNvbG9yOiB2YXIoLS1jb2xvci13aGl0ZSk7XFxuXFxuICAgICY6bm90KDpmaXJzdC1jaGlsZCkge1xcbiAgICAgIG1hcmdpbi1sZWZ0OiAzcmVtO1xcbiAgICB9XFxuXFxuICAgICYgc3ZnIHtcXG4gICAgICBoZWlnaHQ6IDIuNHJlbTtcXG4gICAgICB0cmFuc2l0aW9uOiBmaWxsIDAuMnMgZWFzZS1vdXQ7XFxuICAgICAgZmlsbDogdmFyKC0tY29sb3Itd2hpdGUpO1xcbiAgICB9XFxuXFxuICAgICY6aG92ZXIgc3ZnIHtcXG4gICAgICBmaWxsOiB2YXIoLS1jb2xvci1ncmVlbik7XFxuICAgIH1cXG4gIH1cXG59XFxuXFxuLmxpbmtzIHtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICB1c2VyLXNlbGVjdDogbm9uZTtcXG5cXG4gICYgPiAqOm5vdCg6Zmlyc3QtY2hpbGQpIHtcXG4gICAgbWFyZ2luLWxlZnQ6IDVjaDtcXG4gIH1cXG59XFxuXFxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXG4gICBDdXN0b20gbWVkaWFzXFxuICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cXG5cXG5AbWVkaWEgKC0tbGF5b3V0LWx0ZS1tZWRpdW0pIHtcXG4gIC5saW5rcyB7XFxuICAgIGRpc3BsYXk6IG5vbmU7XFxuICB9XFxufVxcblxcbkBtZWRpYSAoLS1sYXlvdXQtbHRlLXhzbWFsbCkge1xcbiAgLmhlYWRlciB7XFxuICAgIHRvcDogM3JlbTtcXG4gICAgcGFkZGluZzogMCAyLjVyZW07XFxuICB9XFxuXFxuICAubmFtZSB7XFxuICAgIGZvbnQtc2l6ZTogNi41dnc7XFxuICB9XFxufVxcblwiXX1dKTtcbi8vIEV4cG9ydHNcbmV4cG9ydHMubG9jYWxzID0ge1xuXHRcImhlYWRlclwiOiBcIkhlYWRlcl9oZWFkZXJfXzM2ZkVLXCIsXG5cdFwiY29udGVudFwiOiBcIkhlYWRlcl9jb250ZW50X19uRFFKZlwiLFxuXHRcIm5hbWVcIjogXCJIZWFkZXJfbmFtZV9fMTZUWUFcIixcblx0XCJzb2NpYWxcIjogXCJIZWFkZXJfc29jaWFsX18yRHU3X1wiLFxuXHRcImxpbmtzXCI6IFwiSGVhZGVyX2xpbmtzX18xajhMVFwiXG59O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzO1xuIiwiLy8gSW1wb3J0c1xudmFyIF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzXCIpO1xuZXhwb3J0cyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyh0cnVlKTtcbi8vIE1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXG4gICBDdXN0b20gbWVkaWEgcXVlcmllc1xcblxcbiAgIFVzZSBpdCBsaWtlIHNvOiBAbWVkaWEgKC0tbGF5b3V0LXNtYWxsKSB7IC4uLiB9XFxuICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cXG5cXG4vKiAzNzVweCAqL1xcblxcbi8qIDQ4MHB4ICovXFxuXFxuLyogNzY4cHggKi9cXG5cXG4vKiAxMDI0cHggKi9cXG5cXG4vKiAxMjgwcHggKi9cXG5cXG4vKiAxNDQwcHggKi9cXG5cXG4vKiAxOTIwcHggKi9cXG5cXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcbiAgIENvbG9yc1xcbiAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXFxuXFxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXG4gICBaLUluZGV4ZXNcXG4gICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xcblxcbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxuICAgU2l6ZXNcXG4gICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xcblxcbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxuICAgIExhbmRzY2FwZVxcbiAgICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xcblxcbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxuICAgIFBvcnRyYWl0XFxuICAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXFxuXFxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXG4gICBDdXN0b20gbWVkaWFzXFxuICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cXG5cXG4vKiBNSVhJTlMgKi9cXG5cXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcbiAgIFNtb290aCAmIHNoYXJwIG1peGluc1xcbiAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXFxuXFxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXG4gICBFbGxpcHNpcyBtaXhpblxcblxcbiAgIFRoZSBjb250YWluZXIgbmVlZHMgdG8gaGF2ZSBhIHdpZHRoIGZvciBpdCB0byB3b3JrXFxuICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cXG5cXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcbiAgRm9udHNcXG4gID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXFxuXFxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXG4gIEFsbCB0eXBvZ3JhcGh5IHZhcmlhbnRzXFxuXFxuICAkdW5pdCAtIEVpdGhlciBlbSBvciByZW1cXG4gID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXFxuXFxuLkxheW91dF9sYXlvdXRfXzFiMzNRIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHdpZHRoOiAxMDB2dztcXG4gIHdpZHRoOiAxMDB2dztcXG4gIGhlaWdodDogMTAwdmg7XFxuICBoZWlnaHQ6IDEwMHZoO1xcbiAgcGFkZGluZzogMi4ycmVtO1xcbiAgcGFkZGluZzogMi4ycmVtO1xcbiAgY29sb3I6ICNmZmY7XFxuICBjb2xvcjogI2ZmZjtcXG59XFxuXFxuQG1lZGlhIChtYXgtd2lkdGg6IDQ4ZW0pIHtcXG5cXG4gIC5MYXlvdXRfbGF5b3V0X18xYjMzUSB7XFxuICBwYWRkaW5nOiAydnc7XFxuICB9XFxufVxcblxcbi5MYXlvdXRfZnJhbWVfXzNBOW5nIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHRvcDogMDtcXG4gIGxlZnQ6IDA7XFxuICB3aWR0aDogMTAwJTtcXG4gIGhlaWdodDogMTAwJTtcXG4gIGJvcmRlcjogMi4ycmVtIHNvbGlkICNmZmY7XFxuICBib3JkZXI6IDIuMnJlbSBzb2xpZCAjZmZmO1xcbn1cXG5cXG5AbWVkaWEgKG1heC13aWR0aDogNDhlbSkge1xcblxcbiAgLkxheW91dF9mcmFtZV9fM0E5bmcge1xcbiAgYm9yZGVyOiAydncgc29saWQgI2ZmZjtcXG4gIH1cXG59XFxuXFxuQG1lZGlhIChtYXgtd2lkdGg6IDQ4ZW0pIHtcXG5cXG4gIC5MYXlvdXRfZnJhbWVfXzNBOW5nIHtcXG4gIGJvcmRlcjogMnZ3IHNvbGlkICNmZmY7XFxuICB9XFxufVxcblxcbi5MYXlvdXRfY29udGFpbmVyX18yM1JTaSB7XFxuICB3aWR0aDogMTAwJTtcXG4gIGhlaWdodDogMTAwJTtcXG4gIG92ZXJmbG93LXg6IGhpZGRlbjtcXG59XFxuXFxuLkxheW91dF9jb250ZW50X18zV3dkdSB7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICB3aWR0aDogMTAwJTtcXG4gIGhlaWdodDogMTAwJTtcXG4gIG92ZXJmbG93LXk6IGF1dG87XFxuICBzY3JvbGwtYmVoYXZpb3I6IHNtb290aDtcXG5cXG4gIC8qIEhpZGUgU2Nyb2xsYmFyICovXFxuICBzY3JvbGxiYXItd2lkdGg6IG5vbmU7IC8qIEZpcmVmb3ggKi9cXG4gIC1tcy1vdmVyZmxvdy1zdHlsZTogbm9uZSAvKiBJRSwgRWRnZSAqL1xcbn1cXG5cXG4uTGF5b3V0X2NvbnRlbnRfXzNXd2R1Ojotd2Via2l0LXNjcm9sbGJhciB7XFxuICAgIGRpc3BsYXk6IG5vbmU7IC8qIENocm9tZSwgU2FmYXJpLCBPcGVyYSAqL1xcbiAgfVxcblxcbi5MYXlvdXRfcHJvZ3Jlc3NfXzNWdXlBIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHJpZ2h0OiBjYWxjKDIuMnJlbSAvIDIpO1xcbiAgcmlnaHQ6IGNhbGMoMi4ycmVtIC8gMik7XFxuICB3aWR0aDogMC4ycmVtO1xcbiAgaGVpZ2h0OiBjYWxjKDEwMHZoIC0gKDIuMnJlbSAqIDIpKTtcXG4gIGhlaWdodDogY2FsYygxMDB2aCAtICgyLjJyZW0gKiAyKSk7XFxuICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSg1MCUsIDApO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2MxYzVkNDtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNjMWM1ZDRcXG59XFxuXFxuQG1lZGlhIChtYXgtd2lkdGg6IDQ4ZW0pIHtcXG5cXG4gIC5MYXlvdXRfcHJvZ3Jlc3NfXzNWdXlBIHtcXG4gIGhlaWdodDogY2FsYygxMDB2aCAtICgydncgKiAyKSk7XFxuICB9XFxufVxcblxcbkBtZWRpYSAobWF4LXdpZHRoOiA0OGVtKSB7XFxuXFxuICAuTGF5b3V0X3Byb2dyZXNzX18zVnV5QSB7XFxuICByaWdodDogY2FsYygydncgLyAyKTtcXG4gIH1cXG59XFxuXFxuLkxheW91dF9wcm9ncmVzc19fM1Z1eUEgLkxheW91dF9wZXJjZW50YWdlX18tZjB2UyB7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgd2lkdGg6IDEwMCU7XFxuICAgIGhlaWdodDogMTAwJTtcXG4gICAgdHJhbnNmb3JtOiBzY2FsZVkoMSk7XFxuICAgIHRyYW5zZm9ybS1vcmlnaW46IGNlbnRlciB0b3A7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICMxOTFhMWQ7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICMxOTFhMWQ7XFxuICB9XFxuXFxuLkxheW91dF9ncmFpbl9fMjYyc0oge1xcbiAgcG9zaXRpb246IGZpeGVkO1xcbiAgdG9wOiAwO1xcbiAgbGVmdDogMDtcXG4gIHdpZHRoOiAxMDB2dztcXG4gIHdpZHRoOiAxMDB2dztcXG4gIGhlaWdodDogMTAwdmg7XFxuICBoZWlnaHQ6IDEwMHZoO1xcbiAgcGFkZGluZzogMi4ycmVtO1xcbiAgcGFkZGluZzogMi4ycmVtO1xcbn1cXG5cXG5AbWVkaWEgKG1heC13aWR0aDogNDhlbSkge1xcblxcbiAgLkxheW91dF9ncmFpbl9fMjYyc0oge1xcbiAgcGFkZGluZzogMnZ3O1xcbiAgfVxcbn1cXG5cIiwgXCJcIix7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJDOi9Vc2Vycy9wYXVsby9EZXNrdG9wL1dvcmsvUHJvamVjdHMvUGVyc29uYWwvV2ViL3BhdWxvYm1hcmNvcy93d3cvc2hhcmVkL3N0eWxlcy9pbXBvcnRzL2N1c3RvbS1tZWRpYXMuY3NzXCIsXCJDOi9Vc2Vycy9wYXVsby9EZXNrdG9wL1dvcmsvUHJvamVjdHMvUGVyc29uYWwvV2ViL3BhdWxvYm1hcmNvcy93d3cvc2hhcmVkL3N0eWxlcy9pbXBvcnRzL3ZhcmlhYmxlcy5jc3NcIixcIkM6L1VzZXJzL3BhdWxvL0Rlc2t0b3AvV29yay9Qcm9qZWN0cy9QZXJzb25hbC9XZWIvcGF1bG9ibWFyY29zL3d3dy9zaGFyZWQvc3R5bGVzL2ltcG9ydHMvaW5kZXguY3NzXCIsXCJDOi9Vc2Vycy9wYXVsby9EZXNrdG9wL1dvcmsvUHJvamVjdHMvUGVyc29uYWwvV2ViL3BhdWxvYm1hcmNvcy93d3cvc2hhcmVkL3N0eWxlcy9pbXBvcnRzL21peGlucy90ZXh0LmNzc1wiLFwiQzovVXNlcnMvcGF1bG8vRGVza3RvcC9Xb3JrL1Byb2plY3RzL1BlcnNvbmFsL1dlYi9wYXVsb2JtYXJjb3Mvd3d3L3NoYXJlZC9zdHlsZXMvaW1wb3J0cy9taXhpbnMvdHlwb2dyYXBoeS5jc3NcIixcIkM6L1VzZXJzL3BhdWxvL0Rlc2t0b3AvV29yay9Qcm9qZWN0cy9QZXJzb25hbC9XZWIvcGF1bG9ibWFyY29zL3d3dy9zaGFyZWQvY29tcG9uZW50cy9sYXlvdXQvTGF5b3V0Lm1vZHVsZS5jc3NcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIkFBQUE7Ozs7K0VBSStFOztBQUV0QixVQUFVOztBQUNoQixVQUFVOztBQUNYLFVBQVU7O0FBQ1QsV0FBVzs7QUFDWixXQUFXOztBQUNWLFdBQVc7O0FBQ1QsV0FBVzs7QUNWaEU7OytFQUUrRTs7QUFhL0U7OytFQUUrRTs7QUFRL0U7OytFQUUrRTs7QUFpQi9FOztnRkFFZ0Y7O0FBU2hGOztnRkFFZ0Y7O0FBU2hGOzsrRUFFK0U7O0FDbkUvRSxXQUFXOztBQ0hYOzsrRUFFK0U7O0FBWS9FOzs7OytFQUkrRTs7QUNoQi9FOzs4RUFFOEU7O0FBTzlFOzs7OzhFQUk4RTs7QUNiOUU7RUFDRSxrQkFBa0I7RUFDbEIsWUFBMEI7RUFBMUIsWUFBMEI7RUFDMUIsYUFBNEI7RUFBNUIsYUFBNEI7RUFDNUIsZUFBOEI7RUFBOUIsZUFBOEI7RUFDOUIsV0FBeUI7RUFBekIsV0FBeUI7QUFDM0I7O0FKZ0VBOztFSXRFQTtFQUlFLFlBQUE7RUFFRjtBSm9FQTs7QUlsRUE7RUFDRSxrQkFBa0I7RUFDbEIsTUFBTTtFQUNOLE9BQU87RUFDUCxXQUFXO0VBQ1gsWUFBWTtFQUNaLHlCQUFzRDtFQUF0RCx5QkFBc0Q7QUFDeEQ7O0FKdURBOztFSTlEQTtFQU1FLHNCQUFBO0VBQ0Y7QUoyREE7O0FBSkE7O0VJOURBO0VBTUUsc0JBQUE7RUFDRjtBSjJEQTs7QUl6REE7RUFDRSxXQUFXO0VBQ1gsWUFBWTtFQUNaLGtCQUFrQjtBQUNwQjs7QUFFQTtFQUNFLGtCQUFrQjtFQUNsQixXQUFXO0VBQ1gsWUFBWTtFQUNaLGdCQUFnQjtFQUNoQix1QkFBdUI7O0VBRXZCLG1CQUFtQjtFQUNuQixxQkFBcUIsRUFBRSxZQUFZO0VBQ25DLHVCQUF3QixFQUFFLGFBQWE7QUFLekM7O0FBSEU7SUFDRSxhQUFhLEVBQUUsMEJBQTBCO0VBQzNDOztBQUdGO0VBQ0Usa0JBQWtCO0VBQ2xCLHVCQUFzQztFQUF0Qyx1QkFBc0M7RUFDdEMsYUFBYTtFQUNiLGtDQUFpRDtFQUFqRCxrQ0FBaUQ7RUFDakQsNEJBQTRCO0VBQzVCLHlCQUF5QztFQUF6QztBQVVGOztBSmVBOztFSS9CQTtFQUlFLCtCQUFBO0VBWUY7QUptQkE7O0FBSkE7O0VJL0JBO0VBRUUsb0JBQUE7RUFjRjtBSm1CQTs7QUkzQkU7SUFDRSxrQkFBa0I7SUFDbEIsV0FBVztJQUNYLFlBQVk7SUFDWixvQkFBb0I7SUFDcEIsNEJBQTRCO0lBQzVCLHlCQUF3QztJQUF4Qyx5QkFBd0M7RUFDMUM7O0FBR0Y7RUFDRSxlQUFlO0VBQ2YsTUFBTTtFQUNOLE9BQU87RUFDUCxZQUEwQjtFQUExQixZQUEwQjtFQUMxQixhQUE0QjtFQUE1QixhQUE0QjtFQUM1QixlQUE4QjtFQUE5QixlQUE4QjtBQUNoQzs7QUpNQTs7RUliQTtFQU1FLFlBQUE7RUFDRjtBSlVBXCIsXCJmaWxlXCI6XCJMYXlvdXQubW9kdWxlLmNzc1wiLFwic291cmNlc0NvbnRlbnRcIjpbXCIvKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcbiAgIEN1c3RvbSBtZWRpYSBxdWVyaWVzXFxuXFxuICAgVXNlIGl0IGxpa2Ugc286IEBtZWRpYSAoLS1sYXlvdXQtc21hbGwpIHsgLi4uIH1cXG4gICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xcblxcbkBjdXN0b20tbWVkaWEgLS1sYXlvdXQtbHRlLXh4c21hbGwgKHdpZHRoIDw9IDIzLjQzNzVlbSk7IC8qIDM3NXB4ICovXFxuQGN1c3RvbS1tZWRpYSAtLWxheW91dC1sdGUteHNtYWxsICh3aWR0aCA8PSAzMGVtKTsgLyogNDgwcHggKi9cXG5AY3VzdG9tLW1lZGlhIC0tbGF5b3V0LWx0ZS1zbWFsbCAod2lkdGggPD0gNDhlbSk7IC8qIDc2OHB4ICovXFxuQGN1c3RvbS1tZWRpYSAtLWxheW91dC1sdGUtbWVkaXVtICh3aWR0aCA8PSA2NGVtKTsgLyogMTAyNHB4ICovXFxuQGN1c3RvbS1tZWRpYSAtLWxheW91dC1sdGUtbGFyZ2UgKHdpZHRoIDw9IDgwZW0pOyAvKiAxMjgwcHggKi9cXG5AY3VzdG9tLW1lZGlhIC0tbGF5b3V0LWx0ZS14bGFyZ2UgKHdpZHRoIDw9IDkwZW0pOyAvKiAxNDQwcHggKi9cXG5AY3VzdG9tLW1lZGlhIC0tbGF5b3V0LWx0ZS14eGxhcmdlICh3aWR0aCA8PSAxMjBlbSk7IC8qIDE5MjBweCAqL1xcblwiLFwiQGltcG9ydCBcXFwiLi9jdXN0b20tbWVkaWFzXFxcIjtcXG5cXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcbiAgIENvbG9yc1xcbiAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXFxuXFxuOnJvb3Qge1xcbiAgLS1jb2xvci13aGl0ZTogI2ZmZjtcXG4gIC0tY29sb3ItYmxhY2s6ICMwMDA7XFxuICAtLWNvbG9yLWRhcms6ICMwZjBmMTE7XFxuICAtLWNvbG9yLWdyYXk6ICMyZDJlMzI7XFxuICAtLWNvbG9yLWxpZ2h0LWdyYXk6ICNjMWM1ZDQ7XFxuICAtLWNvbG9yLWRhcmstZ3JheTogIzE5MWExZDtcXG4gIC0tY29sb3ItZ3JlZW46ICM2NGY0YWM7XFxuICAtLWNvbG9yLWdyZWVuLWRhcms6ICMyODYxNDQ7XFxufVxcblxcbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxuICAgWi1JbmRleGVzXFxuICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cXG5cXG46cm9vdCB7XFxuICAtLXotaW5kZXgtYmFzZTogMTtcXG4gIC0tei1pbmRleC1oZWFkZXI6IDU7XFxuICAtLXotaW5kZXgtZnJhbWU6IDY7XFxufVxcblxcbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxuICAgU2l6ZXNcXG4gICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xcblxcbjpyb290IHtcXG4gIC0tbGF5b3V0LXdpZHRoOiAxMDB2dztcXG4gIC0tbGF5b3V0LWhlaWdodDogMTAwdmg7XFxuICAtLWxheW91dC1tYXgtd2lkdGg6IDE1MHJlbTtcXG4gIC0tbGF5b3V0LXBhZGRpbmc6IDIuMnJlbTtcXG5cXG4gIC0taGVhZGVyLWhlaWdodDogNHJlbTtcXG4gIC0taGVhZGVyLWZyYW1lLXRvcDogY2FsYyh2YXIoLS1sYXlvdXQtcGFkZGluZykgKiAyKTtcXG5cXG4gIC0tY29udGVudC12aWV3cG9ydC1oZWlnaHQ6IGNhbGMoMTAwdmggLSAodmFyKC0tbGF5b3V0LXBhZGRpbmcpICogMikpO1xcblxcbiAgLS1jYXJvdXNlbC1pdGVtLXdpZHRoOiA2MHZ3O1xcbiAgLS1jYXJvdXNlbC1pdGVtLWhlaWdodDogMzB2dztcXG59XFxuXFxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXG4gICAgTGFuZHNjYXBlXFxuICAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXFxuXFxuQG1lZGlhIChvcmllbnRhdGlvbjogbGFuZHNjYXBlKSB7XFxuICA6cm9vdCB7XFxuICAgIC0tY2Fyb3VzZWwtaXRlbS13aWR0aDogNjB2dztcXG4gICAgLS1jYXJvdXNlbC1pdGVtLWhlaWdodDogMzN2dztcXG4gIH1cXG59XFxuXFxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXG4gICAgUG9ydHJhaXRcXG4gICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cXG5cXG5AbWVkaWEgKG9yaWVudGF0aW9uOiBwb3J0cmFpdCkge1xcbiAgOnJvb3Qge1xcbiAgICAtLWNhcm91c2VsLWl0ZW0td2lkdGg6IDgwdnc7XFxuICAgIC0tY2Fyb3VzZWwtaXRlbS1oZWlnaHQ6IDgwdnc7XFxuICB9XFxufVxcblxcbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxuICAgQ3VzdG9tIG1lZGlhc1xcbiAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXFxuXFxuQG1lZGlhICgtLWxheW91dC1sdGUtc21hbGwpIHtcXG4gIDpyb290IHtcXG4gICAgLS1sYXlvdXQtcGFkZGluZzogMnZ3O1xcbiAgfVxcbn1cXG5cIixcIkBpbXBvcnQgXFxcIi4vY3VzdG9tLW1lZGlhcy5jc3NcXFwiO1xcbkBpbXBvcnQgXFxcIi4vdmFyaWFibGVzLmNzc1xcXCI7XFxuXFxuLyogTUlYSU5TICovXFxuQGltcG9ydCBcXFwiLi9taXhpbnMvdGV4dC5jc3NcXFwiO1xcbkBpbXBvcnQgXFxcIi4vbWl4aW5zL3R5cG9ncmFwaHkuY3NzXFxcIjtcXG5AaW1wb3J0IFxcXCIuL21peGlucy91bnN0eWxlZC1idXR0b24uY3NzXFxcIjtcXG5cIixcIi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxuICAgU21vb3RoICYgc2hhcnAgbWl4aW5zXFxuICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cXG5cXG5AZGVmaW5lLW1peGluIHRleHQtc21vb3RoIHtcXG4gICAgLW1vei1vc3gtZm9udC1zbW9vdGhpbmc6IGdyYXlzY2FsZTsgIC8qIEZvbnQgc21vb3RoaW5nIHR3ZWFrcyBmb3IgTWFjT1N4IGluIEdlY2tvICovXFxuICAgIC13ZWJraXQtZm9udC1zbW9vdGhpbmc6IGFudGlhbGlhc2VkOyAvKiBGb250IHNtb290aGluZyB0d2Vha3MgZm9yIE1hY09TeCBpbiBXZWJraXQgKi9cXG59XFxuXFxuQGRlZmluZS1taXhpbiB0ZXh0LXNoYXJwIHtcXG4gICAgLW1vei1vc3gtZm9udC1zbW9vdGhpbmc6IGluaXRpYWw7ICAgLyogVHVybiBvZmYgZm9udCBzbW9vdGhpbmcgdHdlYWtzIGZvciBNYWNPU3ggaW4gR2Vja28gKi9cXG4gICAgLXdlYmtpdC1mb250LXNtb290aGluZzogaW5pdGlhbDsgICAgLyogVHVybiBvZmYgZm9udCBzbW9vdGhpbmcgdHdlYWtzIGZvciBNYWNPU3ggaW4gV2Via2l0ICovXFxufVxcblxcbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxuICAgRWxsaXBzaXMgbWl4aW5cXG5cXG4gICBUaGUgY29udGFpbmVyIG5lZWRzIHRvIGhhdmUgYSB3aWR0aCBmb3IgaXQgdG8gd29ya1xcbiAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXFxuXFxuQGRlZmluZS1taXhpbiB0ZXh0LWVsbGlwc2lzIHtcXG4gICAgb3ZlcmZsb3c6IGhpZGRlbjsgLyogXFxcIm92ZXJmbG93XFxcIiB2YWx1ZSBtdXN0IGJlIGRpZmZlcmVudCBmcm9tIFxcXCJ2aXNpYmxlXFxcIiAqL1xcbiAgICB0ZXh0LW92ZXJmbG93OiBlbGxpcHNpcztcXG4gICAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcXG4gICAgb3ZlcmZsb3ctd3JhcDogbm9ybWFsO1xcbn1cXG5cXG5AZGVmaW5lLW1peGluIHRleHQtZWxsaXBzaXMtbXVsdGlsaW5lICRtYXgtbGluZS1jb3VudCwgJG1heC1oZWlnaHQge1xcbiAgICBtYXgtaGVpZ2h0OiAkbWF4LWhlaWdodDtcXG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcXG4gICAgLyogc3R5bGVsaW50LWRpc2FibGUgKi9cXG4gICAgZGlzcGxheTogLXdlYmtpdC1ib3g7XFxuICAgIHRleHQtb3ZlcmZsb3c6IGVsbGlwc2lzO1xcbiAgICAtd2Via2l0LWxpbmUtY2xhbXA6ICRtYXgtbGluZS1jb3VudDtcXG4gICAgLXdlYmtpdC1ib3gtb3JpZW50OiB2ZXJ0aWNhbDtcXG4gICAgLyogc3R5bGVsaW50LWVuYWJsZSAqL1xcbn1cXG5cIixcIkBpbXBvcnQgXFxcIi4uL2N1c3RvbS1tZWRpYXNcXFwiO1xcblxcbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxuICBGb250c1xcbiAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cXG5cXG5AZGVmaW5lLW1peGluIF9mb250LWthcmFzdW1hICRmb250V2VpZ2h0OiBub3JtYWwge1xcbiAgZm9udC1mYW1pbHk6IFxcXCJLYXJhc3VtYVxcXCIsIHNhbnMtc2VyaWY7XFxuICBmb250LXdlaWdodDogJChmb250V2VpZ2h0KTtcXG59XFxuXFxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXG4gIEFsbCB0eXBvZ3JhcGh5IHZhcmlhbnRzXFxuXFxuICAkdW5pdCAtIEVpdGhlciBlbSBvciByZW1cXG4gID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXFxuXFxuQGRlZmluZS1taXhpbiB0eXBvZ3JhcGh5LWgxICR1bml0OiByZW0ge1xcbiAgQG1peGluIF9mb250LWthcmFzdW1hIGJvbGRlcjtcXG4gIGZvbnQtc2l6ZTogOCQodW5pdCk7XFxufVxcblxcbkBkZWZpbmUtbWl4aW4gdHlwb2dyYXBoeS1oMiAkdW5pdDogcmVtIHtcXG4gIEBtaXhpbiBfZm9udC1rYXJhc3VtYSBib2xkO1xcbiAgZm9udC1zaXplOiA0LjgkKHVuaXQpO1xcbn1cXG5cXG5AZGVmaW5lLW1peGluIHR5cG9ncmFwaHktYm9keSAkdW5pdDogcmVtIHtcXG4gIEBtaXhpbiBfZm9udC1rYXJhc3VtYTtcXG4gIGZvbnQtc2l6ZTogMS42JCh1bml0KTtcXG59XFxuXFxuQGRlZmluZS1taXhpbiB0eXBvZ3JhcGh5LWJvZHkgJHVuaXQ6IHJlbSB7XFxuICBAbWl4aW4gX2ZvbnQta2FyYXN1bWE7XFxuICBmb250LXNpemU6IDEuNiQodW5pdCk7XFxufVxcblwiLFwiQGltcG9ydCBcXFwiLi4vLi4vc3R5bGVzL2ltcG9ydHMvaW5kZXguY3NzXFxcIjtcXG5cXG4ubGF5b3V0IHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHdpZHRoOiB2YXIoLS1sYXlvdXQtd2lkdGgpO1xcbiAgaGVpZ2h0OiB2YXIoLS1sYXlvdXQtaGVpZ2h0KTtcXG4gIHBhZGRpbmc6IHZhcigtLWxheW91dC1wYWRkaW5nKTtcXG4gIGNvbG9yOiB2YXIoLS1jb2xvci13aGl0ZSk7XFxufVxcblxcbi5mcmFtZSB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB0b3A6IDA7XFxuICBsZWZ0OiAwO1xcbiAgd2lkdGg6IDEwMCU7XFxuICBoZWlnaHQ6IDEwMCU7XFxuICBib3JkZXI6IHZhcigtLWxheW91dC1wYWRkaW5nKSBzb2xpZCB2YXIoLS1jb2xvci13aGl0ZSk7XFxufVxcblxcbi5jb250YWluZXIge1xcbiAgd2lkdGg6IDEwMCU7XFxuICBoZWlnaHQ6IDEwMCU7XFxuICBvdmVyZmxvdy14OiBoaWRkZW47XFxufVxcblxcbi5jb250ZW50IHtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgaGVpZ2h0OiAxMDAlO1xcbiAgb3ZlcmZsb3cteTogYXV0bztcXG4gIHNjcm9sbC1iZWhhdmlvcjogc21vb3RoO1xcblxcbiAgLyogSGlkZSBTY3JvbGxiYXIgKi9cXG4gIHNjcm9sbGJhci13aWR0aDogbm9uZTsgLyogRmlyZWZveCAqL1xcbiAgLW1zLW92ZXJmbG93LXN0eWxlOiBub25lOyAvKiBJRSwgRWRnZSAqL1xcblxcbiAgJjo6LXdlYmtpdC1zY3JvbGxiYXIge1xcbiAgICBkaXNwbGF5OiBub25lOyAvKiBDaHJvbWUsIFNhZmFyaSwgT3BlcmEgKi9cXG4gIH1cXG59XFxuXFxuLnByb2dyZXNzIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHJpZ2h0OiBjYWxjKHZhcigtLWxheW91dC1wYWRkaW5nKSAvIDIpO1xcbiAgd2lkdGg6IDAuMnJlbTtcXG4gIGhlaWdodDogY2FsYygxMDB2aCAtICh2YXIoLS1sYXlvdXQtcGFkZGluZykgKiAyKSk7XFxuICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSg1MCUsIDApO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tY29sb3ItbGlnaHQtZ3JheSk7XFxuXFxuICAmIC5wZXJjZW50YWdlIHtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICB3aWR0aDogMTAwJTtcXG4gICAgaGVpZ2h0OiAxMDAlO1xcbiAgICB0cmFuc2Zvcm06IHNjYWxlWSgxKTtcXG4gICAgdHJhbnNmb3JtLW9yaWdpbjogY2VudGVyIHRvcDtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tY29sb3ItZGFyay1ncmF5KTtcXG4gIH1cXG59XFxuXFxuLmdyYWluIHtcXG4gIHBvc2l0aW9uOiBmaXhlZDtcXG4gIHRvcDogMDtcXG4gIGxlZnQ6IDA7XFxuICB3aWR0aDogdmFyKC0tbGF5b3V0LXdpZHRoKTtcXG4gIGhlaWdodDogdmFyKC0tbGF5b3V0LWhlaWdodCk7XFxuICBwYWRkaW5nOiB2YXIoLS1sYXlvdXQtcGFkZGluZyk7XFxufVxcblwiXX1dKTtcbi8vIEV4cG9ydHNcbmV4cG9ydHMubG9jYWxzID0ge1xuXHRcImxheW91dFwiOiBcIkxheW91dF9sYXlvdXRfXzFiMzNRXCIsXG5cdFwiZnJhbWVcIjogXCJMYXlvdXRfZnJhbWVfXzNBOW5nXCIsXG5cdFwiY29udGFpbmVyXCI6IFwiTGF5b3V0X2NvbnRhaW5lcl9fMjNSU2lcIixcblx0XCJjb250ZW50XCI6IFwiTGF5b3V0X2NvbnRlbnRfXzNXd2R1XCIsXG5cdFwicHJvZ3Jlc3NcIjogXCJMYXlvdXRfcHJvZ3Jlc3NfXzNWdXlBXCIsXG5cdFwicGVyY2VudGFnZVwiOiBcIkxheW91dF9wZXJjZW50YWdlX18tZjB2U1wiLFxuXHRcImdyYWluXCI6IFwiTGF5b3V0X2dyYWluX18yNjJzSlwiXG59O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzO1xuIiwiLy8gSW1wb3J0c1xudmFyIF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzXCIpO1xuZXhwb3J0cyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyh0cnVlKTtcbi8vIE1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXG4gICBDdXN0b20gbWVkaWEgcXVlcmllc1xcblxcbiAgIFVzZSBpdCBsaWtlIHNvOiBAbWVkaWEgKC0tbGF5b3V0LXNtYWxsKSB7IC4uLiB9XFxuICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cXG5cXG4vKiAzNzVweCAqL1xcblxcbi8qIDQ4MHB4ICovXFxuXFxuLyogNzY4cHggKi9cXG5cXG4vKiAxMDI0cHggKi9cXG5cXG4vKiAxMjgwcHggKi9cXG5cXG4vKiAxNDQwcHggKi9cXG5cXG4vKiAxOTIwcHggKi9cXG5cXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcbiAgIENvbG9yc1xcbiAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXFxuXFxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXG4gICBaLUluZGV4ZXNcXG4gICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xcblxcbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxuICAgU2l6ZXNcXG4gICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xcblxcbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxuICAgIExhbmRzY2FwZVxcbiAgICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xcblxcbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxuICAgIFBvcnRyYWl0XFxuICAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXFxuXFxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXG4gICBDdXN0b20gbWVkaWFzXFxuICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cXG5cXG4vKiBNSVhJTlMgKi9cXG5cXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcbiAgIFNtb290aCAmIHNoYXJwIG1peGluc1xcbiAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXFxuXFxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXG4gICBFbGxpcHNpcyBtaXhpblxcblxcbiAgIFRoZSBjb250YWluZXIgbmVlZHMgdG8gaGF2ZSBhIHdpZHRoIGZvciBpdCB0byB3b3JrXFxuICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cXG5cXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcbiAgRm9udHNcXG4gID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXFxuXFxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXG4gIEFsbCB0eXBvZ3JhcGh5IHZhcmlhbnRzXFxuXFxuICAkdW5pdCAtIEVpdGhlciBlbSBvciByZW1cXG4gID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXFxuXFxuLkxpbmtfbGlua19fMnRQemYge1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgY29sb3I6IGluaGVyaXQ7XFxuICBmb250LXdlaWdodDogYm9sZDtcXG4gIHRleHQtZGVjb3JhdGlvbjogbm9uZVxcbn1cXG5cXG4uTGlua19saW5rX18ydFB6Zjo6YmVmb3JlIHtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICBvcGFjaXR5OiAwO1xcbiAgICBjb2xvcjogIzY0ZjRhYztcXG4gICAgY29sb3I6ICM2NGY0YWM7XFxuICAgIHRyYW5zaXRpb246IGFsbCAwLjFzIGVhc2Utb3V0O1xcbiAgfVxcblxcbi5MaW5rX2xpbmtfXzJ0UHpmOjphZnRlciB7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgb3BhY2l0eTogMDtcXG4gICAgY29sb3I6ICM2NGY0YWM7XFxuICAgIGNvbG9yOiAjNjRmNGFjO1xcbiAgICB0cmFuc2l0aW9uOiBhbGwgMC4xcyBlYXNlLW91dDtcXG4gIH1cXG5cXG4uTGlua19saW5rX18ydFB6Zjo6YmVmb3JlIHtcXG4gICAgY29udGVudDogXFxcIjxcXFwiO1xcbiAgICB0b3A6IDA7XFxuICAgIGxlZnQ6IC0xY2g7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWSgtNTAlKTtcXG4gIH1cXG5cXG4uTGlua19saW5rX18ydFB6Zjo6YWZ0ZXIge1xcbiAgICBjb250ZW50OiBcXFwiIC8+XFxcIjtcXG4gICAgdG9wOiAwLjFyZW07XFxuICAgIHJpZ2h0OiAwO1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgxMDAlLCA1MCUpO1xcbiAgICB3aGl0ZS1zcGFjZTogcHJlO1xcbiAgfVxcblxcbi5MaW5rX2xpbmtfXzJ0UHpmOmhvdmVyOjpiZWZvcmUsXFxuICAgIC5MaW5rX2xpbmtfXzJ0UHpmOmhvdmVyOjphZnRlciB7XFxuICAgICAgb3BhY2l0eTogMTtcXG4gICAgfVxcblxcbi5MaW5rX2xpbmtfXzJ0UHpmOmhvdmVyOjpiZWZvcmUge1xcbiAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWSgwKTtcXG4gICAgfVxcblxcbi5MaW5rX2xpbmtfXzJ0UHpmOmhvdmVyOjphZnRlciB7XFxuICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoMTAwJSwgMCk7XFxuICAgIH1cXG5cIiwgXCJcIix7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJDOi9Vc2Vycy9wYXVsby9EZXNrdG9wL1dvcmsvUHJvamVjdHMvUGVyc29uYWwvV2ViL3BhdWxvYm1hcmNvcy93d3cvc2hhcmVkL3N0eWxlcy9pbXBvcnRzL2N1c3RvbS1tZWRpYXMuY3NzXCIsXCJDOi9Vc2Vycy9wYXVsby9EZXNrdG9wL1dvcmsvUHJvamVjdHMvUGVyc29uYWwvV2ViL3BhdWxvYm1hcmNvcy93d3cvc2hhcmVkL3N0eWxlcy9pbXBvcnRzL3ZhcmlhYmxlcy5jc3NcIixcIkM6L1VzZXJzL3BhdWxvL0Rlc2t0b3AvV29yay9Qcm9qZWN0cy9QZXJzb25hbC9XZWIvcGF1bG9ibWFyY29zL3d3dy9zaGFyZWQvc3R5bGVzL2ltcG9ydHMvaW5kZXguY3NzXCIsXCJDOi9Vc2Vycy9wYXVsby9EZXNrdG9wL1dvcmsvUHJvamVjdHMvUGVyc29uYWwvV2ViL3BhdWxvYm1hcmNvcy93d3cvc2hhcmVkL3N0eWxlcy9pbXBvcnRzL21peGlucy90ZXh0LmNzc1wiLFwiQzovVXNlcnMvcGF1bG8vRGVza3RvcC9Xb3JrL1Byb2plY3RzL1BlcnNvbmFsL1dlYi9wYXVsb2JtYXJjb3Mvd3d3L3NoYXJlZC9zdHlsZXMvaW1wb3J0cy9taXhpbnMvdHlwb2dyYXBoeS5jc3NcIixcIkM6L1VzZXJzL3BhdWxvL0Rlc2t0b3AvV29yay9Qcm9qZWN0cy9QZXJzb25hbC9XZWIvcGF1bG9ibWFyY29zL3d3dy9zaGFyZWQvY29tcG9uZW50cy9saW5rL0xpbmsubW9kdWxlLmNzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFBQTs7OzsrRUFJK0U7O0FBRXRCLFVBQVU7O0FBQ2hCLFVBQVU7O0FBQ1gsVUFBVTs7QUFDVCxXQUFXOztBQUNaLFdBQVc7O0FBQ1YsV0FBVzs7QUFDVCxXQUFXOztBQ1ZoRTs7K0VBRStFOztBQWEvRTs7K0VBRStFOztBQVEvRTs7K0VBRStFOztBQWlCL0U7O2dGQUVnRjs7QUFTaEY7O2dGQUVnRjs7QUFTaEY7OytFQUUrRTs7QUNuRS9FLFdBQVc7O0FDSFg7OytFQUUrRTs7QUFZL0U7Ozs7K0VBSStFOztBQ2hCL0U7OzhFQUU4RTs7QUFPOUU7Ozs7OEVBSThFOztBQ2I5RTtFQUNFLGtCQUFrQjtFQUNsQixjQUFjO0VBQ2QsaUJBQWlCO0VBQ2pCO0FBdUNGOztBQXJDRTtJQUVFLGtCQUFrQjtJQUNsQixVQUFVO0lBQ1YsY0FBeUI7SUFBekIsY0FBeUI7SUFDekIsNkJBQTZCO0VBQy9COztBQU5BO0lBRUUsa0JBQWtCO0lBQ2xCLFVBQVU7SUFDVixjQUF5QjtJQUF6QixjQUF5QjtJQUN6Qiw2QkFBNkI7RUFDL0I7O0FBRUE7SUFDRSxZQUFZO0lBQ1osTUFBTTtJQUNOLFVBQVU7SUFDViwyQkFBMkI7RUFDN0I7O0FBRUE7SUFDRSxjQUFjO0lBQ2QsV0FBVztJQUNYLFFBQVE7SUFDUiwrQkFBK0I7SUFDL0IsZ0JBQWdCO0VBQ2xCOztBQUdFOztNQUVFLFVBQVU7SUFDWjs7QUFFQTtNQUNFLHdCQUF3QjtJQUMxQjs7QUFFQTtNQUNFLDZCQUE2QjtJQUMvQlwiLFwiZmlsZVwiOlwiTGluay5tb2R1bGUuY3NzXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxuICAgQ3VzdG9tIG1lZGlhIHF1ZXJpZXNcXG5cXG4gICBVc2UgaXQgbGlrZSBzbzogQG1lZGlhICgtLWxheW91dC1zbWFsbCkgeyAuLi4gfVxcbiAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXFxuXFxuQGN1c3RvbS1tZWRpYSAtLWxheW91dC1sdGUteHhzbWFsbCAod2lkdGggPD0gMjMuNDM3NWVtKTsgLyogMzc1cHggKi9cXG5AY3VzdG9tLW1lZGlhIC0tbGF5b3V0LWx0ZS14c21hbGwgKHdpZHRoIDw9IDMwZW0pOyAvKiA0ODBweCAqL1xcbkBjdXN0b20tbWVkaWEgLS1sYXlvdXQtbHRlLXNtYWxsICh3aWR0aCA8PSA0OGVtKTsgLyogNzY4cHggKi9cXG5AY3VzdG9tLW1lZGlhIC0tbGF5b3V0LWx0ZS1tZWRpdW0gKHdpZHRoIDw9IDY0ZW0pOyAvKiAxMDI0cHggKi9cXG5AY3VzdG9tLW1lZGlhIC0tbGF5b3V0LWx0ZS1sYXJnZSAod2lkdGggPD0gODBlbSk7IC8qIDEyODBweCAqL1xcbkBjdXN0b20tbWVkaWEgLS1sYXlvdXQtbHRlLXhsYXJnZSAod2lkdGggPD0gOTBlbSk7IC8qIDE0NDBweCAqL1xcbkBjdXN0b20tbWVkaWEgLS1sYXlvdXQtbHRlLXh4bGFyZ2UgKHdpZHRoIDw9IDEyMGVtKTsgLyogMTkyMHB4ICovXFxuXCIsXCJAaW1wb3J0IFxcXCIuL2N1c3RvbS1tZWRpYXNcXFwiO1xcblxcbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxuICAgQ29sb3JzXFxuICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cXG5cXG46cm9vdCB7XFxuICAtLWNvbG9yLXdoaXRlOiAjZmZmO1xcbiAgLS1jb2xvci1ibGFjazogIzAwMDtcXG4gIC0tY29sb3ItZGFyazogIzBmMGYxMTtcXG4gIC0tY29sb3ItZ3JheTogIzJkMmUzMjtcXG4gIC0tY29sb3ItbGlnaHQtZ3JheTogI2MxYzVkNDtcXG4gIC0tY29sb3ItZGFyay1ncmF5OiAjMTkxYTFkO1xcbiAgLS1jb2xvci1ncmVlbjogIzY0ZjRhYztcXG4gIC0tY29sb3ItZ3JlZW4tZGFyazogIzI4NjE0NDtcXG59XFxuXFxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXG4gICBaLUluZGV4ZXNcXG4gICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xcblxcbjpyb290IHtcXG4gIC0tei1pbmRleC1iYXNlOiAxO1xcbiAgLS16LWluZGV4LWhlYWRlcjogNTtcXG4gIC0tei1pbmRleC1mcmFtZTogNjtcXG59XFxuXFxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXG4gICBTaXplc1xcbiAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXFxuXFxuOnJvb3Qge1xcbiAgLS1sYXlvdXQtd2lkdGg6IDEwMHZ3O1xcbiAgLS1sYXlvdXQtaGVpZ2h0OiAxMDB2aDtcXG4gIC0tbGF5b3V0LW1heC13aWR0aDogMTUwcmVtO1xcbiAgLS1sYXlvdXQtcGFkZGluZzogMi4ycmVtO1xcblxcbiAgLS1oZWFkZXItaGVpZ2h0OiA0cmVtO1xcbiAgLS1oZWFkZXItZnJhbWUtdG9wOiBjYWxjKHZhcigtLWxheW91dC1wYWRkaW5nKSAqIDIpO1xcblxcbiAgLS1jb250ZW50LXZpZXdwb3J0LWhlaWdodDogY2FsYygxMDB2aCAtICh2YXIoLS1sYXlvdXQtcGFkZGluZykgKiAyKSk7XFxuXFxuICAtLWNhcm91c2VsLWl0ZW0td2lkdGg6IDYwdnc7XFxuICAtLWNhcm91c2VsLWl0ZW0taGVpZ2h0OiAzMHZ3O1xcbn1cXG5cXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcbiAgICBMYW5kc2NhcGVcXG4gICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cXG5cXG5AbWVkaWEgKG9yaWVudGF0aW9uOiBsYW5kc2NhcGUpIHtcXG4gIDpyb290IHtcXG4gICAgLS1jYXJvdXNlbC1pdGVtLXdpZHRoOiA2MHZ3O1xcbiAgICAtLWNhcm91c2VsLWl0ZW0taGVpZ2h0OiAzM3Z3O1xcbiAgfVxcbn1cXG5cXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcbiAgICBQb3J0cmFpdFxcbiAgICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xcblxcbkBtZWRpYSAob3JpZW50YXRpb246IHBvcnRyYWl0KSB7XFxuICA6cm9vdCB7XFxuICAgIC0tY2Fyb3VzZWwtaXRlbS13aWR0aDogODB2dztcXG4gICAgLS1jYXJvdXNlbC1pdGVtLWhlaWdodDogODB2dztcXG4gIH1cXG59XFxuXFxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXG4gICBDdXN0b20gbWVkaWFzXFxuICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cXG5cXG5AbWVkaWEgKC0tbGF5b3V0LWx0ZS1zbWFsbCkge1xcbiAgOnJvb3Qge1xcbiAgICAtLWxheW91dC1wYWRkaW5nOiAydnc7XFxuICB9XFxufVxcblwiLFwiQGltcG9ydCBcXFwiLi9jdXN0b20tbWVkaWFzLmNzc1xcXCI7XFxuQGltcG9ydCBcXFwiLi92YXJpYWJsZXMuY3NzXFxcIjtcXG5cXG4vKiBNSVhJTlMgKi9cXG5AaW1wb3J0IFxcXCIuL21peGlucy90ZXh0LmNzc1xcXCI7XFxuQGltcG9ydCBcXFwiLi9taXhpbnMvdHlwb2dyYXBoeS5jc3NcXFwiO1xcbkBpbXBvcnQgXFxcIi4vbWl4aW5zL3Vuc3R5bGVkLWJ1dHRvbi5jc3NcXFwiO1xcblwiLFwiLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXG4gICBTbW9vdGggJiBzaGFycCBtaXhpbnNcXG4gICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xcblxcbkBkZWZpbmUtbWl4aW4gdGV4dC1zbW9vdGgge1xcbiAgICAtbW96LW9zeC1mb250LXNtb290aGluZzogZ3JheXNjYWxlOyAgLyogRm9udCBzbW9vdGhpbmcgdHdlYWtzIGZvciBNYWNPU3ggaW4gR2Vja28gKi9cXG4gICAgLXdlYmtpdC1mb250LXNtb290aGluZzogYW50aWFsaWFzZWQ7IC8qIEZvbnQgc21vb3RoaW5nIHR3ZWFrcyBmb3IgTWFjT1N4IGluIFdlYmtpdCAqL1xcbn1cXG5cXG5AZGVmaW5lLW1peGluIHRleHQtc2hhcnAge1xcbiAgICAtbW96LW9zeC1mb250LXNtb290aGluZzogaW5pdGlhbDsgICAvKiBUdXJuIG9mZiBmb250IHNtb290aGluZyB0d2Vha3MgZm9yIE1hY09TeCBpbiBHZWNrbyAqL1xcbiAgICAtd2Via2l0LWZvbnQtc21vb3RoaW5nOiBpbml0aWFsOyAgICAvKiBUdXJuIG9mZiBmb250IHNtb290aGluZyB0d2Vha3MgZm9yIE1hY09TeCBpbiBXZWJraXQgKi9cXG59XFxuXFxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXG4gICBFbGxpcHNpcyBtaXhpblxcblxcbiAgIFRoZSBjb250YWluZXIgbmVlZHMgdG8gaGF2ZSBhIHdpZHRoIGZvciBpdCB0byB3b3JrXFxuICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cXG5cXG5AZGVmaW5lLW1peGluIHRleHQtZWxsaXBzaXMge1xcbiAgICBvdmVyZmxvdzogaGlkZGVuOyAvKiBcXFwib3ZlcmZsb3dcXFwiIHZhbHVlIG11c3QgYmUgZGlmZmVyZW50IGZyb20gXFxcInZpc2libGVcXFwiICovXFxuICAgIHRleHQtb3ZlcmZsb3c6IGVsbGlwc2lzO1xcbiAgICB3aGl0ZS1zcGFjZTogbm93cmFwO1xcbiAgICBvdmVyZmxvdy13cmFwOiBub3JtYWw7XFxufVxcblxcbkBkZWZpbmUtbWl4aW4gdGV4dC1lbGxpcHNpcy1tdWx0aWxpbmUgJG1heC1saW5lLWNvdW50LCAkbWF4LWhlaWdodCB7XFxuICAgIG1heC1oZWlnaHQ6ICRtYXgtaGVpZ2h0O1xcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgICAvKiBzdHlsZWxpbnQtZGlzYWJsZSAqL1xcbiAgICBkaXNwbGF5OiAtd2Via2l0LWJveDtcXG4gICAgdGV4dC1vdmVyZmxvdzogZWxsaXBzaXM7XFxuICAgIC13ZWJraXQtbGluZS1jbGFtcDogJG1heC1saW5lLWNvdW50O1xcbiAgICAtd2Via2l0LWJveC1vcmllbnQ6IHZlcnRpY2FsO1xcbiAgICAvKiBzdHlsZWxpbnQtZW5hYmxlICovXFxufVxcblwiLFwiQGltcG9ydCBcXFwiLi4vY3VzdG9tLW1lZGlhc1xcXCI7XFxuXFxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXG4gIEZvbnRzXFxuICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xcblxcbkBkZWZpbmUtbWl4aW4gX2ZvbnQta2FyYXN1bWEgJGZvbnRXZWlnaHQ6IG5vcm1hbCB7XFxuICBmb250LWZhbWlseTogXFxcIkthcmFzdW1hXFxcIiwgc2Fucy1zZXJpZjtcXG4gIGZvbnQtd2VpZ2h0OiAkKGZvbnRXZWlnaHQpO1xcbn1cXG5cXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcbiAgQWxsIHR5cG9ncmFwaHkgdmFyaWFudHNcXG5cXG4gICR1bml0IC0gRWl0aGVyIGVtIG9yIHJlbVxcbiAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cXG5cXG5AZGVmaW5lLW1peGluIHR5cG9ncmFwaHktaDEgJHVuaXQ6IHJlbSB7XFxuICBAbWl4aW4gX2ZvbnQta2FyYXN1bWEgYm9sZGVyO1xcbiAgZm9udC1zaXplOiA4JCh1bml0KTtcXG59XFxuXFxuQGRlZmluZS1taXhpbiB0eXBvZ3JhcGh5LWgyICR1bml0OiByZW0ge1xcbiAgQG1peGluIF9mb250LWthcmFzdW1hIGJvbGQ7XFxuICBmb250LXNpemU6IDQuOCQodW5pdCk7XFxufVxcblxcbkBkZWZpbmUtbWl4aW4gdHlwb2dyYXBoeS1ib2R5ICR1bml0OiByZW0ge1xcbiAgQG1peGluIF9mb250LWthcmFzdW1hO1xcbiAgZm9udC1zaXplOiAxLjYkKHVuaXQpO1xcbn1cXG5cXG5AZGVmaW5lLW1peGluIHR5cG9ncmFwaHktYm9keSAkdW5pdDogcmVtIHtcXG4gIEBtaXhpbiBfZm9udC1rYXJhc3VtYTtcXG4gIGZvbnQtc2l6ZTogMS42JCh1bml0KTtcXG59XFxuXCIsXCJAaW1wb3J0IFxcXCIuLi8uLi9zdHlsZXMvaW1wb3J0cy9pbmRleC5jc3NcXFwiO1xcblxcbi5saW5rIHtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIGNvbG9yOiBpbmhlcml0O1xcbiAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxuICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XFxuXFxuICAmOjpiZWZvcmUsXFxuICAmOjphZnRlciB7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgb3BhY2l0eTogMDtcXG4gICAgY29sb3I6IHZhcigtLWNvbG9yLWdyZWVuKTtcXG4gICAgdHJhbnNpdGlvbjogYWxsIDAuMXMgZWFzZS1vdXQ7XFxuICB9XFxuXFxuICAmOjpiZWZvcmUge1xcbiAgICBjb250ZW50OiBcXFwiPFxcXCI7XFxuICAgIHRvcDogMDtcXG4gICAgbGVmdDogLTFjaDtcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC01MCUpO1xcbiAgfVxcblxcbiAgJjo6YWZ0ZXIge1xcbiAgICBjb250ZW50OiBcXFwiIC8+XFxcIjtcXG4gICAgdG9wOiAwLjFyZW07XFxuICAgIHJpZ2h0OiAwO1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgxMDAlLCA1MCUpO1xcbiAgICB3aGl0ZS1zcGFjZTogcHJlO1xcbiAgfVxcblxcbiAgJjpob3ZlciB7XFxuICAgICY6OmJlZm9yZSxcXG4gICAgJjo6YWZ0ZXIge1xcbiAgICAgIG9wYWNpdHk6IDE7XFxuICAgIH1cXG5cXG4gICAgJjo6YmVmb3JlIHtcXG4gICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoMCk7XFxuICAgIH1cXG5cXG4gICAgJjo6YWZ0ZXIge1xcbiAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlKDEwMCUsIDApO1xcbiAgICB9XFxuICB9XFxufVxcblwiXX1dKTtcbi8vIEV4cG9ydHNcbmV4cG9ydHMubG9jYWxzID0ge1xuXHRcImxpbmtcIjogXCJMaW5rX2xpbmtfXzJ0UHpmXCJcbn07XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHM7XG4iLCIvLyBJbXBvcnRzXG52YXIgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanNcIik7XG5leHBvcnRzID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKHRydWUpO1xuLy8gTW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIvKiEgbm9ybWFsaXplLmNzcyB2OC4wLjEgfCBNSVQgTGljZW5zZSB8IGdpdGh1Yi5jb20vbmVjb2xhcy9ub3JtYWxpemUuY3NzICovXFxuXFxuLyogRG9jdW1lbnRcXG4gICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xcblxcbi8qKlxcbiAqIDEuIENvcnJlY3QgdGhlIGxpbmUgaGVpZ2h0IGluIGFsbCBicm93c2Vycy5cXG4gKiAyLiBQcmV2ZW50IGFkanVzdG1lbnRzIG9mIGZvbnQgc2l6ZSBhZnRlciBvcmllbnRhdGlvbiBjaGFuZ2VzIGluIGlPUy5cXG4gKi9cXG5cXG5odG1sIHtcXG4gIGxpbmUtaGVpZ2h0OiAxLjE1OyAvKiAxICovXFxuICAtd2Via2l0LXRleHQtc2l6ZS1hZGp1c3Q6IDEwMCU7IC8qIDIgKi9cXG59XFxuXFxuLyogU2VjdGlvbnNcXG4gICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xcblxcbi8qKlxcbiAqIFJlbW92ZSB0aGUgbWFyZ2luIGluIGFsbCBicm93c2Vycy5cXG4gKi9cXG5cXG5ib2R5IHtcXG4gIG1hcmdpbjogMDtcXG59XFxuXFxuLyoqXFxuICogUmVuZGVyIHRoZSBgbWFpbmAgZWxlbWVudCBjb25zaXN0ZW50bHkgaW4gSUUuXFxuICovXFxuXFxubWFpbiB7XFxuICBkaXNwbGF5OiBibG9jaztcXG59XFxuXFxuLyoqXFxuICogQ29ycmVjdCB0aGUgZm9udCBzaXplIGFuZCBtYXJnaW4gb24gYGgxYCBlbGVtZW50cyB3aXRoaW4gYHNlY3Rpb25gIGFuZFxcbiAqIGBhcnRpY2xlYCBjb250ZXh0cyBpbiBDaHJvbWUsIEZpcmVmb3gsIGFuZCBTYWZhcmkuXFxuICovXFxuXFxuaDEge1xcbiAgZm9udC1zaXplOiAyZW07XFxuICBtYXJnaW46IDAuNjdlbSAwO1xcbn1cXG5cXG4vKiBHcm91cGluZyBjb250ZW50XFxuICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cXG5cXG4vKipcXG4gKiAxLiBBZGQgdGhlIGNvcnJlY3QgYm94IHNpemluZyBpbiBGaXJlZm94LlxcbiAqIDIuIFNob3cgdGhlIG92ZXJmbG93IGluIEVkZ2UgYW5kIElFLlxcbiAqL1xcblxcbmhyIHtcXG4gIGJveC1zaXppbmc6IGNvbnRlbnQtYm94OyAvKiAxICovXFxuICBoZWlnaHQ6IDA7IC8qIDEgKi9cXG4gIG92ZXJmbG93OiB2aXNpYmxlOyAvKiAyICovXFxufVxcblxcbi8qKlxcbiAqIDEuIENvcnJlY3QgdGhlIGluaGVyaXRhbmNlIGFuZCBzY2FsaW5nIG9mIGZvbnQgc2l6ZSBpbiBhbGwgYnJvd3NlcnMuXFxuICogMi4gQ29ycmVjdCB0aGUgb2RkIGBlbWAgZm9udCBzaXppbmcgaW4gYWxsIGJyb3dzZXJzLlxcbiAqL1xcblxcbnByZSB7XFxuICBmb250LWZhbWlseTogbW9ub3NwYWNlLCBtb25vc3BhY2U7IC8qIDEgKi9cXG4gIGZvbnQtc2l6ZTogMWVtOyAvKiAyICovXFxufVxcblxcbi8qIFRleHQtbGV2ZWwgc2VtYW50aWNzXFxuICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cXG5cXG4vKipcXG4gKiBSZW1vdmUgdGhlIGdyYXkgYmFja2dyb3VuZCBvbiBhY3RpdmUgbGlua3MgaW4gSUUgMTAuXFxuICovXFxuXFxuYSB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcXG59XFxuXFxuLyoqXFxuICogMS4gUmVtb3ZlIHRoZSBib3R0b20gYm9yZGVyIGluIENocm9tZSA1Ny1cXG4gKiAyLiBBZGQgdGhlIGNvcnJlY3QgdGV4dCBkZWNvcmF0aW9uIGluIENocm9tZSwgRWRnZSwgSUUsIE9wZXJhLCBhbmQgU2FmYXJpLlxcbiAqL1xcblxcbmFiYnJbdGl0bGVdIHtcXG4gIGJvcmRlci1ib3R0b206IG5vbmU7IC8qIDEgKi9cXG4gIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lOyAvKiAyICovXFxuICAtd2Via2l0LXRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lIGRvdHRlZDtcXG4gICAgICAgICAgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmUgZG90dGVkOyAvKiAyICovXFxufVxcblxcbi8qKlxcbiAqIEFkZCB0aGUgY29ycmVjdCBmb250IHdlaWdodCBpbiBDaHJvbWUsIEVkZ2UsIGFuZCBTYWZhcmkuXFxuICovXFxuXFxuYixcXG5zdHJvbmcge1xcbiAgZm9udC13ZWlnaHQ6IGJvbGRlcjtcXG59XFxuXFxuLyoqXFxuICogMS4gQ29ycmVjdCB0aGUgaW5oZXJpdGFuY2UgYW5kIHNjYWxpbmcgb2YgZm9udCBzaXplIGluIGFsbCBicm93c2Vycy5cXG4gKiAyLiBDb3JyZWN0IHRoZSBvZGQgYGVtYCBmb250IHNpemluZyBpbiBhbGwgYnJvd3NlcnMuXFxuICovXFxuXFxuY29kZSxcXG5rYmQsXFxuc2FtcCB7XFxuICBmb250LWZhbWlseTogbW9ub3NwYWNlLCBtb25vc3BhY2U7IC8qIDEgKi9cXG4gIGZvbnQtc2l6ZTogMWVtOyAvKiAyICovXFxufVxcblxcbi8qKlxcbiAqIEFkZCB0aGUgY29ycmVjdCBmb250IHNpemUgaW4gYWxsIGJyb3dzZXJzLlxcbiAqL1xcblxcbnNtYWxsIHtcXG4gIGZvbnQtc2l6ZTogODAlO1xcbn1cXG5cXG4vKipcXG4gKiBQcmV2ZW50IGBzdWJgIGFuZCBgc3VwYCBlbGVtZW50cyBmcm9tIGFmZmVjdGluZyB0aGUgbGluZSBoZWlnaHQgaW5cXG4gKiBhbGwgYnJvd3NlcnMuXFxuICovXFxuXFxuc3ViLFxcbnN1cCB7XFxuICBmb250LXNpemU6IDc1JTtcXG4gIGxpbmUtaGVpZ2h0OiAwO1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgdmVydGljYWwtYWxpZ246IGJhc2VsaW5lO1xcbn1cXG5cXG5zdWIge1xcbiAgYm90dG9tOiAtMC4yNWVtO1xcbn1cXG5cXG5zdXAge1xcbiAgdG9wOiAtMC41ZW07XFxufVxcblxcbi8qIEVtYmVkZGVkIGNvbnRlbnRcXG4gICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xcblxcbi8qKlxcbiAqIFJlbW92ZSB0aGUgYm9yZGVyIG9uIGltYWdlcyBpbnNpZGUgbGlua3MgaW4gSUUgMTAuXFxuICovXFxuXFxuaW1nIHtcXG4gIGJvcmRlci1zdHlsZTogbm9uZTtcXG59XFxuXFxuLyogRm9ybXNcXG4gICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xcblxcbi8qKlxcbiAqIDEuIENoYW5nZSB0aGUgZm9udCBzdHlsZXMgaW4gYWxsIGJyb3dzZXJzLlxcbiAqIDIuIFJlbW92ZSB0aGUgbWFyZ2luIGluIEZpcmVmb3ggYW5kIFNhZmFyaS5cXG4gKi9cXG5cXG5idXR0b24sXFxuaW5wdXQsXFxub3B0Z3JvdXAsXFxuc2VsZWN0LFxcbnRleHRhcmVhIHtcXG4gIGZvbnQtZmFtaWx5OiBpbmhlcml0OyAvKiAxICovXFxuICBmb250LXNpemU6IDEwMCU7IC8qIDEgKi9cXG4gIGxpbmUtaGVpZ2h0OiAxLjE1OyAvKiAxICovXFxuICBtYXJnaW46IDA7IC8qIDIgKi9cXG59XFxuXFxuLyoqXFxuICogU2hvdyB0aGUgb3ZlcmZsb3cgaW4gSUUuXFxuICogMS4gU2hvdyB0aGUgb3ZlcmZsb3cgaW4gRWRnZS5cXG4gKi9cXG5cXG5idXR0b24sXFxuaW5wdXQgeyAvKiAxICovXFxuICBvdmVyZmxvdzogdmlzaWJsZTtcXG59XFxuXFxuLyoqXFxuICogUmVtb3ZlIHRoZSBpbmhlcml0YW5jZSBvZiB0ZXh0IHRyYW5zZm9ybSBpbiBFZGdlLCBGaXJlZm94LCBhbmQgSUUuXFxuICogMS4gUmVtb3ZlIHRoZSBpbmhlcml0YW5jZSBvZiB0ZXh0IHRyYW5zZm9ybSBpbiBGaXJlZm94LlxcbiAqL1xcblxcbmJ1dHRvbixcXG5zZWxlY3QgeyAvKiAxICovXFxuICB0ZXh0LXRyYW5zZm9ybTogbm9uZTtcXG59XFxuXFxuLyoqXFxuICogQ29ycmVjdCB0aGUgaW5hYmlsaXR5IHRvIHN0eWxlIGNsaWNrYWJsZSB0eXBlcyBpbiBpT1MgYW5kIFNhZmFyaS5cXG4gKi9cXG5cXG5idXR0b24sXFxuW3R5cGU9XFxcImJ1dHRvblxcXCJdLFxcblt0eXBlPVxcXCJyZXNldFxcXCJdLFxcblt0eXBlPVxcXCJzdWJtaXRcXFwiXSB7XFxuICAtd2Via2l0LWFwcGVhcmFuY2U6IGJ1dHRvbjtcXG59XFxuXFxuLyoqXFxuICogUmVtb3ZlIHRoZSBpbm5lciBib3JkZXIgYW5kIHBhZGRpbmcgaW4gRmlyZWZveC5cXG4gKi9cXG5cXG5idXR0b246Oi1tb3otZm9jdXMtaW5uZXIsXFxuW3R5cGU9XFxcImJ1dHRvblxcXCJdOjotbW96LWZvY3VzLWlubmVyLFxcblt0eXBlPVxcXCJyZXNldFxcXCJdOjotbW96LWZvY3VzLWlubmVyLFxcblt0eXBlPVxcXCJzdWJtaXRcXFwiXTo6LW1vei1mb2N1cy1pbm5lciB7XFxuICBib3JkZXItc3R5bGU6IG5vbmU7XFxuICBwYWRkaW5nOiAwO1xcbn1cXG5cXG4vKipcXG4gKiBSZXN0b3JlIHRoZSBmb2N1cyBzdHlsZXMgdW5zZXQgYnkgdGhlIHByZXZpb3VzIHJ1bGUuXFxuICovXFxuXFxuYnV0dG9uOi1tb3otZm9jdXNyaW5nLFxcblt0eXBlPVxcXCJidXR0b25cXFwiXTotbW96LWZvY3VzcmluZyxcXG5bdHlwZT1cXFwicmVzZXRcXFwiXTotbW96LWZvY3VzcmluZyxcXG5bdHlwZT1cXFwic3VibWl0XFxcIl06LW1vei1mb2N1c3Jpbmcge1xcbiAgb3V0bGluZTogMXB4IGRvdHRlZCBCdXR0b25UZXh0O1xcbn1cXG5cXG4vKipcXG4gKiBDb3JyZWN0IHRoZSBwYWRkaW5nIGluIEZpcmVmb3guXFxuICovXFxuXFxuZmllbGRzZXQge1xcbiAgcGFkZGluZzogMC4zNWVtIDAuNzVlbSAwLjYyNWVtO1xcbn1cXG5cXG4vKipcXG4gKiAxLiBDb3JyZWN0IHRoZSB0ZXh0IHdyYXBwaW5nIGluIEVkZ2UgYW5kIElFLlxcbiAqIDIuIENvcnJlY3QgdGhlIGNvbG9yIGluaGVyaXRhbmNlIGZyb20gYGZpZWxkc2V0YCBlbGVtZW50cyBpbiBJRS5cXG4gKiAzLiBSZW1vdmUgdGhlIHBhZGRpbmcgc28gZGV2ZWxvcGVycyBhcmUgbm90IGNhdWdodCBvdXQgd2hlbiB0aGV5IHplcm8gb3V0XFxuICogICAgYGZpZWxkc2V0YCBlbGVtZW50cyBpbiBhbGwgYnJvd3NlcnMuXFxuICovXFxuXFxubGVnZW5kIHtcXG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7IC8qIDEgKi9cXG4gIGNvbG9yOiBpbmhlcml0OyAvKiAyICovXFxuICBkaXNwbGF5OiB0YWJsZTsgLyogMSAqL1xcbiAgbWF4LXdpZHRoOiAxMDAlOyAvKiAxICovXFxuICBwYWRkaW5nOiAwOyAvKiAzICovXFxuICB3aGl0ZS1zcGFjZTogbm9ybWFsOyAvKiAxICovXFxufVxcblxcbi8qKlxcbiAqIEFkZCB0aGUgY29ycmVjdCB2ZXJ0aWNhbCBhbGlnbm1lbnQgaW4gQ2hyb21lLCBGaXJlZm94LCBhbmQgT3BlcmEuXFxuICovXFxuXFxucHJvZ3Jlc3Mge1xcbiAgdmVydGljYWwtYWxpZ246IGJhc2VsaW5lO1xcbn1cXG5cXG4vKipcXG4gKiBSZW1vdmUgdGhlIGRlZmF1bHQgdmVydGljYWwgc2Nyb2xsYmFyIGluIElFIDEwKy5cXG4gKi9cXG5cXG50ZXh0YXJlYSB7XFxuICBvdmVyZmxvdzogYXV0bztcXG59XFxuXFxuLyoqXFxuICogMS4gQWRkIHRoZSBjb3JyZWN0IGJveCBzaXppbmcgaW4gSUUgMTAuXFxuICogMi4gUmVtb3ZlIHRoZSBwYWRkaW5nIGluIElFIDEwLlxcbiAqL1xcblxcblt0eXBlPVxcXCJjaGVja2JveFxcXCJdLFxcblt0eXBlPVxcXCJyYWRpb1xcXCJdIHtcXG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7IC8qIDEgKi9cXG4gIHBhZGRpbmc6IDA7IC8qIDIgKi9cXG59XFxuXFxuLyoqXFxuICogQ29ycmVjdCB0aGUgY3Vyc29yIHN0eWxlIG9mIGluY3JlbWVudCBhbmQgZGVjcmVtZW50IGJ1dHRvbnMgaW4gQ2hyb21lLlxcbiAqL1xcblxcblt0eXBlPVxcXCJudW1iZXJcXFwiXTo6LXdlYmtpdC1pbm5lci1zcGluLWJ1dHRvbixcXG5bdHlwZT1cXFwibnVtYmVyXFxcIl06Oi13ZWJraXQtb3V0ZXItc3Bpbi1idXR0b24ge1xcbiAgaGVpZ2h0OiBhdXRvO1xcbn1cXG5cXG4vKipcXG4gKiAxLiBDb3JyZWN0IHRoZSBvZGQgYXBwZWFyYW5jZSBpbiBDaHJvbWUgYW5kIFNhZmFyaS5cXG4gKiAyLiBDb3JyZWN0IHRoZSBvdXRsaW5lIHN0eWxlIGluIFNhZmFyaS5cXG4gKi9cXG5cXG5bdHlwZT1cXFwic2VhcmNoXFxcIl0ge1xcbiAgLXdlYmtpdC1hcHBlYXJhbmNlOiB0ZXh0ZmllbGQ7IC8qIDEgKi9cXG4gIG91dGxpbmUtb2Zmc2V0OiAtMnB4OyAvKiAyICovXFxufVxcblxcbi8qKlxcbiAqIFJlbW92ZSB0aGUgaW5uZXIgcGFkZGluZyBpbiBDaHJvbWUgYW5kIFNhZmFyaSBvbiBtYWNPUy5cXG4gKi9cXG5cXG5bdHlwZT1cXFwic2VhcmNoXFxcIl06Oi13ZWJraXQtc2VhcmNoLWRlY29yYXRpb24ge1xcbiAgLXdlYmtpdC1hcHBlYXJhbmNlOiBub25lO1xcbn1cXG5cXG4vKipcXG4gKiAxLiBDb3JyZWN0IHRoZSBpbmFiaWxpdHkgdG8gc3R5bGUgY2xpY2thYmxlIHR5cGVzIGluIGlPUyBhbmQgU2FmYXJpLlxcbiAqIDIuIENoYW5nZSBmb250IHByb3BlcnRpZXMgdG8gYGluaGVyaXRgIGluIFNhZmFyaS5cXG4gKi9cXG5cXG46Oi13ZWJraXQtZmlsZS11cGxvYWQtYnV0dG9uIHtcXG4gIC13ZWJraXQtYXBwZWFyYW5jZTogYnV0dG9uOyAvKiAxICovXFxuICBmb250OiBpbmhlcml0OyAvKiAyICovXFxufVxcblxcbi8qIEludGVyYWN0aXZlXFxuICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cXG5cXG4vKlxcbiAqIEFkZCB0aGUgY29ycmVjdCBkaXNwbGF5IGluIEVkZ2UsIElFIDEwKywgYW5kIEZpcmVmb3guXFxuICovXFxuXFxuZGV0YWlscyB7XFxuICBkaXNwbGF5OiBibG9jaztcXG59XFxuXFxuLypcXG4gKiBBZGQgdGhlIGNvcnJlY3QgZGlzcGxheSBpbiBhbGwgYnJvd3NlcnMuXFxuICovXFxuXFxuc3VtbWFyeSB7XFxuICBkaXNwbGF5OiBsaXN0LWl0ZW07XFxufVxcblxcbi8qIE1pc2NcXG4gICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xcblxcbi8qKlxcbiAqIEFkZCB0aGUgY29ycmVjdCBkaXNwbGF5IGluIElFIDEwKy5cXG4gKi9cXG5cXG50ZW1wbGF0ZSB7XFxuICBkaXNwbGF5OiBub25lO1xcbn1cXG5cXG4vKipcXG4gKiBBZGQgdGhlIGNvcnJlY3QgZGlzcGxheSBpbiBJRSAxMC5cXG4gKi9cXG5cXG5baGlkZGVuXSB7XFxuICBkaXNwbGF5OiBub25lO1xcbn1cXG5cXG4ucmMtd3JhcHBlcixcXG4ucmMsXFxuLnJjLXNsaWRlciB7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG59XFxuXFxuLnJjIHtcXG4gICAgb3ZlcmZsb3cteDogYXV0bztcXG4gICAgLXdlYmtpdC1vdmVyZmxvdy1zY3JvbGxpbmc6IHRvdWNoO1xcbn1cXG5cXG4ucmMuLW5vLXNjcm9sbCB7XFxuICAgIG92ZXJmbG93LXg6IGhpZGRlbjtcXG59XFxuXFxuLnJjLXNsaWRlciB7XFxuICAgIHdpZHRoOiAtd2Via2l0LWZpdC1jb250ZW50O1xcbiAgICB3aWR0aDogLW1vei1maXQtY29udGVudDtcXG4gICAgd2lkdGg6IGZpdC1jb250ZW50O1xcbiAgICB3aGl0ZS1zcGFjZTogbm93cmFwO1xcbn1cXG5cXG4ucmMtc2xpZGUge1xcbiAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxufVxcblxcbi5yYy1zbGlkZTpob3ZlciB7XFxuICAgIGN1cnNvcjogcG9pbnRlcjtcXG59XFxuXFxuLnJjLXNsaWRlci4tZHJhZ2dhYmxlOmhvdmVyIHtcXG4gICAgY3Vyc29yOiAtd2Via2l0LWdyYWI7XFxuICAgIGN1cnNvcjogZ3JhYjtcXG59XFxuXFxuLnJjLXNsaWRlci4tZHJhZ2dhYmxlLi1kcmFnZ2luZyxcXG4ucmMtc2xpZGVyLi1kcmFnZ2FibGUuLWRyYWdnaW5nIC5yYy1zbGlkZSB7XFxuICAgIGN1cnNvcjogLXdlYmtpdC1ncmFiYmluZztcXG4gICAgY3Vyc29yOiBncmFiYmluZztcXG59XFxuXFxuLnJjLWFycm93IHtcXG4gICAgcG9zaXRpb246ICBhYnNvbHV0ZTtcXG4gICAgdG9wOiA1MCU7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWSgtNTAlKTtcXG59XFxuXFxuLnJjLWFycm93Li1sZWZ0IHsgbGVmdDogMTVweDsgfVxcblxcbi5yYy1hcnJvdy4tcmlnaHQgeyByaWdodDogMTVweDsgfVxcblxcbi5yYy1kb3RzIHtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxufVxcblxcbi5yYy1kb3Qge1xcbiAgICBtYXJnaW46IDAgNXB4O1xcbiAgICBvcGFjaXR5OiAwLjU7XFxufVxcblxcbi5yYy1kb3QuLWN1cnJlbnQge1xcbiAgICBvcGFjaXR5OiAxO1xcbn1cXG5cXG4vKiBJbnRlcm5hbCAqL1xcblxcbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxuICAgQ3VzdG9tIG1lZGlhIHF1ZXJpZXNcXG5cXG4gICBVc2UgaXQgbGlrZSBzbzogQG1lZGlhICgtLWxheW91dC1zbWFsbCkgeyAuLi4gfVxcbiAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXFxuXFxuLyogMzc1cHggKi9cXG5cXG4vKiA0ODBweCAqL1xcblxcbi8qIDc2OHB4ICovXFxuXFxuLyogMTAyNHB4ICovXFxuXFxuLyogMTI4MHB4ICovXFxuXFxuLyogMTQ0MHB4ICovXFxuXFxuLyogMTkyMHB4ICovXFxuXFxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXG4gICBDb2xvcnNcXG4gICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xcblxcbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxuICAgWi1JbmRleGVzXFxuICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cXG5cXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcbiAgIFNpemVzXFxuICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cXG5cXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcbiAgICBMYW5kc2NhcGVcXG4gICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cXG5cXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcbiAgICBQb3J0cmFpdFxcbiAgICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xcblxcbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxuICAgQ3VzdG9tIG1lZGlhc1xcbiAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXFxuXFxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXG4gICBQcm9wZXIgYm94LXNpemluZyBtb2RlbFxcbiAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXFxuXFxuKixcXG4qOjpiZWZvcmUsXFxuKjo6YWZ0ZXIge1xcbiAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbn1cXG5cXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcbiAgIERvY3VtZW50XFxuICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cXG5cXG4vKlxcbiAgIDEuIFN0cmV0Y2ggPGh0bWw+IHN0cmV0Y2ggdG8gZmlsbCBvdXIgc2NyZWVuIGhlaWdodFxcbiAgIDIuIE1ha2UgY2hpbGRyZW4gb2YgaHRtbCAoYm9keSkgb2NjdXB5IGF0IGxlYXN0IDEwMCUgb2YgdGhlIHNjcmVlblxcbiAgIDMuIFZpZXdwb3J0IGlzIHNjYWxhYmxlIGFuZCBvY2N1cGllcyBhdCBsZWFzdCAzMjBweCAoaVBob25lIFNFKVxcbiovXFxuXFxuaHRtbCB7XFxuICAgIG1pbi13aWR0aDogMzJlbTtcXG4gICAgaGVpZ2h0OiAwOyAvKiAzICovXFxuICAgIG1pbi1oZWlnaHQ6IDEwMCU7IC8qIDEgKi9cXG4gICAgZGlzcGxheTogZmxleDsgLyogMiAqL1xcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uOyAvKiAyICovXFxufVxcblxcbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxuICAgQm9keSAmICNyb290XFxuICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cXG5cXG5ib2R5IHtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgZmxleDogMSAwIGF1dG87XFxuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxufVxcblxcbjpnbG9iYWwoI19fbmV4dCkge1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBmbGV4OiAxIDAgYXV0bztcXG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG59XFxuXFxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXG4gIEZvbnRzXFxuICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xcblxcbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxuICBBbGwgdHlwb2dyYXBoeSB2YXJpYW50c1xcblxcbiAgJHVuaXQgLSBFaXRoZXIgZW0gb3IgcmVtXFxuICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xcblxcbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxuICAgU21vb3RoICYgc2hhcnAgbWl4aW5zXFxuICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cXG5cXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcbiAgIEVsbGlwc2lzIG1peGluXFxuXFxuICAgVGhlIGNvbnRhaW5lciBuZWVkcyB0byBoYXZlIGEgd2lkdGggZm9yIGl0IHRvIHdvcmtcXG4gICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xcblxcbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxuICAgVHlwb2dyYXBoeSBEZWZhdWx0c1xcbiAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXFxuXFxuaHRtbCB7XFxuICBmb250LXNpemU6IDYyLjUlOyAvKiA2Mi41JSBzbyB0aGF0IGFsbCB0aGUgUkVNIG1lYXN1cmVtZW50cyByZSBiYXNlZCBvbiAxMHB4IHNpemluZyAqL1xcbn1cXG5cXG5ib2R5IHtcXG4gIGZvbnQtZmFtaWx5OiBcXFwiS2FyYXN1bWFcXFwiLCBzYW5zLXNlcmlmO1xcbiAgZm9udC13ZWlnaHQ6IG5vcm1hbDtcXG4gIGZvbnQtc2l6ZTogMS42cmVtO1xcbiAgLW1vei1vc3gtZm9udC1zbW9vdGhpbmc6IGdyYXlzY2FsZTtcXG4gIC8qIEZvbnQgc21vb3RoaW5nIHR3ZWFrcyBmb3IgTWFjT1N4IGluIEdlY2tvICovXFxuICAtd2Via2l0LWZvbnQtc21vb3RoaW5nOiBhbnRpYWxpYXNlZDtcXG4gIC8qIEZvbnQgc21vb3RoaW5nIHR3ZWFrcyBmb3IgTWFjT1N4IGluIFdlYmtpdCAqL1xcblxcbiAgb3ZlcmZsb3ctd3JhcDogYnJlYWstd29yZDsgIC8qIEJyZWFrIGxvbmcgd29yZHMgYnkgZGVmYXVsdCAqL1xcbiAgLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yOiB0cmFuc3BhcmVudDsgIC8qIERvIG5vdCBzaG93IGEgaGlnaGxpZ2h0IChyZWN0YW5nbGUgYXJvdW5kIHRoZSBsaW5rKSB3aGlsZSB0YXBwaW5nIGl0ICovXFxufVxcblxcbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxuICBIZWFkaW5nc1xcbiAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cXG5cXG5oMSxcXG5oMixcXG5oMyxcXG5oNCB7XFxuICBtYXJnaW46IDAuN2VtIDA7XFxufVxcblxcbmgxIHtcXG4gIGZvbnQtZmFtaWx5OiBcXFwiS2FyYXN1bWFcXFwiLCBzYW5zLXNlcmlmO1xcbiAgZm9udC13ZWlnaHQ6IGJvbGRlcjtcXG4gIGZvbnQtc2l6ZTogOHJlbTtcXG59XFxuXFxuaDIge1xcbiAgZm9udC1mYW1pbHk6IFxcXCJLYXJhc3VtYVxcXCIsIHNhbnMtc2VyaWY7XFxuICBmb250LXdlaWdodDogYm9sZDtcXG4gIGZvbnQtc2l6ZTogNC44cmVtO1xcbn1cXG5cXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcbiAgRm9udHNcXG4gIElmIHlvdSBhcmUgZ29pbmcgdG8gaW5jbHVkZSBjdXN0b20gZm9udHMgcGxlYXNlIHVzZSB0aGUgL3d3dy9zaGFyZWQvbWVkaWEvZm9udHNcXG4gIGRpcmVjdG9yeS5cXG4gID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXFxuXFxuLyogc3R5bGVsaW50LWRpc2FibGUgc2NhbGUtdW5saW1pdGVkL2RlY2xhcmF0aW9uLXN0cmljdC12YWx1ZSAqL1xcblxcbkBmb250LWZhY2Uge1xcbiAgZm9udC1mYW1pbHk6IFxcXCJLYXJhc3VtYVxcXCI7XFxuICBmb250LXdlaWdodDogbm9ybWFsO1xcbiAgZm9udC1zdHlsZTogbm9ybWFsO1xcbiAgZm9udC1kaXNwbGF5OiBzd2FwO1xcbiAgc3JjOiB1cmwoXFxcImRhdGE6Zm9udC93b2ZmMjtiYXNlNjQsZDA5R01nQUJBQUFBQUZ3MEFBNEFBQUFCUDlBQUFGdlZBQUVBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUdvRnVHNEdhU2h5QmszZ0dZQUNEWEJFSUNvSDdRSUhDYnd1R09nQUJOZ0lrQTR4dUJDQUZsbk1Ib2c1YlN4OXhCbXUzblgrZ2l0c0dBMnRYYzM2clVzSThYeCtBZXNKVVovdWxkODlJaExCeEFNa0RTb1RzLy8vL1QwNFdjYXlaUFdaM2orQVVVZlU5WkhrNEVrcUZRMTRIak9PTkp0d3luUUllZ1htdXFNaGxwVXlvWVJxM1VjMWFRL2ZIUU1rVGl4WkQ1aUFTQzdNbHlONXBhbzkyN0N2RzVVbHJlWlc1ZDFmUGVrazB0UmZ0RkFqNHVsTEt1cmxiczdzcGRSRjQ4L0w4VEVudmN0bnF4V3hjWFhrbjE5YzhTMC9Ja3ZyejF5VFI0NWRxNGxmL1h1WVR4ekZRUlMydjNjbVU3ZmJSMHkrdEp6NDQyVzJIZ2pPTWFuM05LSXd5Y2Y0dVpSY0RoRTNXeEsxbzlxNzBjZXVsOGlxT0gyMDRFeVB1UTdDd3lxMHRQRVF0TXl6M0RBNkZESmNMNFFwYWtGRGhhZjVNNmI4bmk4QzRoWSthVXkvRVAzT2ZQM09UQmVDa3dLd0FMU2tTRGpXeWExMVZ6OG95cVNvVXFvcm8vNWNqZnM1K1pwOUUvQkVlSVFRSXlTTUpsZ1N4NExuOGdGZk1LYTFUUjdTTzFZeTZjVmVoZG03MGZzcWxZcHdhRm5oZUtsVFR5c2dtd2s4RXlObi83SkhKdlk3R0Yxd0JZaVhsQU9iV3dkaW9FWUpJMnJRdktpRVN1WTBSbzBlUDZERmFLamRHYkl3YUhZTFFJa29wSVFPeEdHQmhFSXIxWmNieDcxei9NMG1MekNRdFhlNXovekw3VlRtU05ndmVGdWp0aWlhWks2SHMvcFRsdlU4MWpTQlhvTmpYTXc4QUN0bmRid0FZWUdHWDZtcHByNm0yeEROWXd0eW5aSExxMTBablpCdUowVXFFcTc3NjZoZm1kckVTc1pnbzRiMUJwbDRkTGpyRVBBSlFoY3ZFL0FEOFdxbWF3VXZoN25ZQkJnVlFmSWdmRWlXUFMzZXBxVDMrdi9jK3EwOTlTdS84RjA3aEZIeGY1U3VjZ2xONEN1Y1Ztc0t6OEYzd0xyTE9RbGs0QzgrQzJZSThqdzNkWjg5anFxYXlxUVNoMWxKc3haWUdqS09XMURpRUJrMzh1bWZMVFc2MzgyUXNoR1RUYVBBNlpUOGFzRjR0RHVqdHZrZWhiS1V0NjlFQ1djdDBnRmlmdnZQSWtFTWZmcStYQkFwVi9adlRZZ2hZTkpiZTdzemNoVmhIQWd2RnlwRUVBa2Rnd3lvbDlTNHFza2kyTDc4dTdlSXhrQnNzRXV1YngrN1grMVB3OUVGWEYzMEI4bVVPc3pBMWd3U3d5ODRUaTREVytER3czZGc3RWpGYUVOdU5kNmZIbUo3ZlpyT0lxY3NMb3cvdXA3U3l2eTlWdmY0UEVBWm9ZeklFNmNLa2M1SjFxVlRpdVFPa1hHOHA3WnBUVGpsL3ZML2JDUllzUllLN29nMlNMaURVQUZDVWVyUUxyS2hkQ0NxZ0sraEdwY3BLVTBrcmdDcFViSk4wVGF2dDFzck51WlYyT1BxWTY3SGRjcXZIZS81L1hkL2FQUExmeVlwbDF6c0dxZkNpVzhXbDFrNTg5aVl6ai95N2I3TXcrOWNlZy9nL2cwc3kwY25ZeXZ4QnZjTTdNYTN4b3FKV0w2bThvb1RUWjZqK1AwRTd6bGEwbk8yZ29pcm9lc29TaW1yVjdFMlVNS1RESXR5dGNGaTVoN3RvaGVUWHhDazB3cUExQ290MUNPM2g0ZituS3ZWTk5neGcrU3hpTm1leTB2VTBUckV5VU5IdlZ0MXVOQllLNzBSY0o2aGpvNTdDUWhNR3k4UDNSNy94Kys2Y3Y2eGs1WHBibGcwb3M4Q2pMTUYwV3pqQktOS3M4ZHdEalFpZHpLOS9ybzlES0wrVTFiR0VlQVlyUEpEdXFVeHdMb1BIemNkOFNVa1doUXVoU0JHeFlqOE84OTJKLy85MUVsSm9hUGU0NGppcUtpSkdkc1NJMld4RVZKMzMrZTgraGxOUVZvV3hLT3Y3ajh6Wi82ZlMzcDMxbHUwR0p5dUVRQ1lra2dHaS82eXk2OEFZZkpCQk9MWGR4LytBSUtBV0FCQWlvU3FvV2dPaVVTUFVaRE9pUlF2VWFpdGltKzNRRG5zUWUrMkQ5anVNT09JSWROUlp4RG5ub1BPdUlLN3FnbDUxQTNIVFRhaGJOK0tXVzlCdGR4QjMvUlA2dDM4ai9tTUdJeWhBRW1ra0dJc1dTS3hhd2RpTWhpVEdHREN4SmtLUzVMUXcwMFZFTWtka21ITFJrVlJnaGxtck5wTHQ2a01JcURaYkczYm1OOStEWmJ1bnF5RjZKNmNxaU42WmpJYm8zY2dRUk85TzNvQ2RBQmdGNkVYUGVIc1VPejlkSW1IUmFvNWlsNjhXS0JZVUEwQXhJQ2dHZ3RydGR3YTBzOXR3bVFudzc2ekh3d09CWlNRaFJraHhjWE9odTh4MkQxOGVESjcvdHd1RDBLRHRVTVdyWVNxbnRTSUxpQU5FdW81eExCYUtqOVh6U2xXNldmV0puTG13YTRPUG5qZ1o5bmlMb3BmTWxGSXh2S0lrME1DUitoYWxGdVMwVzV2WlNBTktyK1FTZFZORk9Hazl2RHg4eGR3MWlZd3NNUytzQlc5c1BVSEpEa0Z4OXlsOWxlMmxGbVZrQ1k0YTBVVWFRYksyMk1ybnNQdmVPc29PWVBnTHZ4bTlJNWV1cE5PVWhmTWxZQW9DZVJMbXBuOEFobDVnSnl3NFEweG5aSGVCUFFiR1pZUEtZSjdPWUFFRVdIQ1FwR1lrZnh0RklPK1FJZ0J1emdkcUIvRWNaMjIxcGF0bTJtd2Iwa3k5ZWVCRDhtSmxYNENIODVtUHFvNnlWQUlwSzJ0dmtmNk1NYWF3aGIxNTVJRnNFWjBjQ0xjTTExT1NiRjVjUGFKSndkRjNBNjNsaVc5S2llSWtORG9mMTlWU1l5czEzTDNNNWxKYjY4QzEzQmsyVHRRUkxxMC9mYkhTbUFaemZseVVlcWh6VWM3Nm9tWXdOZWJhVXp3UVJWS1UwOEZocXpUSEdNLzAzRFBTeWVXcXBFK09TcmRjZXI5WHJUQmZsdG13WmwwQWFWaGtaSHpYbmZqUU5FbXhidGpCSmJadXpzYThaMlVOa0VsWWxQUjdva283Wm04bjVicGg3OVd6dGcwODJvd0NXdzVlL3N2VWlGS2lMSE00dTV6eWpucXRnTTlvRWZMTDIzMFdWSFdOV2VXcHRMT3A4RGVmU0JmYzJNN2dwdFgxd2Fqem9QUUJ0UVhwQ2xDd3lZUzFuYUJiLzdHU3hKcCt0SXd1bE9TUnY1U0NycW1Ma2FTQjBFRVJXTVhYd1hVYmNqWEFCRWlkeGZHQ0hMUDF0TXU1SlFtSHBDeGZRbGw1anhzWk52Z2VHb0dDZE44dlo0SUJUK1pYWU9lZzdQOTQ4Y08xQW4vOWZkUVBXTjhhQWgrbFdVSDBuc0ZTbVVhblRLVmFmMGNkMkhpZS9NMjIzZDE5WUZRZlYwRmloMUVwUXBrWjFOOGFmM21jL21aNmJ5R2kyMWpRaUxzWEpxR1JEa09zcWpOdWxsOGp4NDJIMWJuTzVOOWprSzEwd0JralBLT01aQ2VPVjl6bEVqRFRiRWVHR0gxd2NKNTl3WVAxZmQ0b3UvQTF5Mk1Xa0tZaVJpVFJYZzRYYTNZbGNpZEhGc0lPdm8yZUduWHUzRWNsMENwcnBiTFhWcFI1VFFxRjEwWDJHZ2pQZmRPQlBiMVZhbmpZb0s2V2ZvMFIxV1hWWW1ZYzFjQS9heGQ3eDR0RjA1aDh1aC9PNEJLR2VhMkROaElMQzJiajBoZ0NDWS9LUTdUMzY0U05KanRuZkJHaXg4cVpHMTA2REJjTkdBcmV3SUNyd2VUeGdjbkd0S01xS3RNNWVvaHRrUUtBcDlISzYzMkp1TkxFcTMza2xvc0NYUGZad0Y1d2FWNWR5bWpQRVJmR2N1dElqcFdETFpFcTQ3bXlJbkQ4L3dEVGlDU0F6c0JZSEZGUkt0cFcweDNyWmd0bi9mQy9YbE51WllGaWtjcU1GV1dTU1Z6bW1DUERYSE5scWxRcHkwb3JaYXV5WG80V0xVcTAyYXJVZG5zTXRNOUp3NTEzeFJSZHVzMXkxejBMZk9VcmkvVG9zWmhQcnlYOEhsbm16LzVxcFgvNnA5VUpvQlRXUkVhdUpncEt0WWpKYURRQmc4R1JrdUxJeUVSUVViRlNVelBSMExBS0ZZWXdNVEVUQ0pKRmlxUmxZY0d6c2twa1krTVVKWXBCdEdncDRzU3hzYk5ERGc0S0NSSWtidVNTSkVxbWt5SlVxaUJwN05LcHVTaGxrTWdVSXdzdFc0UWNESThrLzVQQUsxQUJoMEo2Ull5S3hTa1RvdCs3Um44RGxvOEREWkpnTU9JTm9USlV1R0dDRFJkdmhFZ2pSUmxGWnJSWVkxaU1GV0dTYUhPSXpHVlNpYldTVk5XSTN6MlV2Snc3VzE2ejlaeGFKckhJSzNGbm0yaUgzZXoyaUxGdnd0NURsTFFjeDBjRk91WWt4NGx0bkF1dVNOQzFUZkNxNitMZEVPdW1CTjFpM2VWMGo4TlhUSHFZK0ZBZUNOREx5by95VUlCSHJQNGs4aGVwZjY2RWlLL0JITWxwa0tMMFRsYnBsNmJobVdJZldISmhwRUJUaWFSbXBoR0oreG9nc1NJbVZseGpsMUwyVWNsbjdNSVp1MlNTcGk0NlJaSmtXVVlubGdkZWJveFJ2Y1h4eWlUaGdWTWlvcFNPV0NETHRzTmgwTmgwam15RnBDd21UWWEwV1IvMHhqTkdLRHptd2F3Q1FTb0ZXZ2xWVFpoWWlpMTQ3Q3A1OXV4RmY3Ylk3NGc0UjBWeE9lV3NLR2xreTVHam1MRkMxdHYyekprVFJSV1pLS3JJbUhDWm5pUVFJWWV0S1diTmhHYjZqUUNUOGozUVdmNEFJMVBKRjR3ZC9rQnBQbjVGcFhoYUxncFVzbW85YmNqL3cwajBZeGpzNE8xaUZYYUE1NFBoam0vTzBjdFBGL05hbUtSLzZSYXl2Q3R5OEMxdVlMWDFYdVFaeDJCbnozdDM1LzN3SGdxNysrb00xYjljN0xWSDdNK3AzZm1GdHZlK0RhT3R0ZW54d1FwS1loS3hncVRMWk00WmZvYmt2WUhaUWRkckkxM1drYm9sTG4vakh4S2trbG5YZW5jOElTaDZqRjF2cnhXOWhsTDMwUVgwSDl3T3drQzN4WjNDYjZJL1pWUWFIV2V5MkU2VnpFWnhrdWJhMGg0Y2pDYlRHV214WE1XRy83T0g0K2w4dVNaWGxoeDUzUElWS2xLaVZKbCtoaGhtaEpGR0cyZUNTYWFaWmJhNUtzeTN5QkpMVlZwaHBTclZhdFNxVTY5Qmt3MDJhdEdxVGJzT1cyeTF6WFk3N0xUTGJudnN0YzhwcDUxeDFubVhYWEhWRGQxdXVlME9ud2Y4SG5yaXFUNi9OSTF1bExxVDZYYTN2ejMrODRJb3lZcXE2VUdTdHRzZkFrTWdVV2hNMFBEZ2kzb1E0WTk2R1BITGZ5SUNFNUtHVWxPbFI3a0NtU2xHaEVhR1JvZG1CeW95ckFqc1NYRWoxQjN5SmZNbmV4SjRHaXpXMFVBNzBBbnNjOGd4cDV3ajVwSnJicmtYd2hNV1IwaENRVkZTVkFMZGQ3b0VmYVZDeW1Tb2pha0ZYbm5oMnhjZXY4QlNCVFNCdUtoMExCZFdYNENpS29XbUZIMmxvS25Lb0NsRFJaYStNcUpFbDVuY2NiMGVSZDg4ek1lbWt0anBxdnJNMUdldUt2eXQydkErWGEyQ1pWWXZTa2kxRERrMEZKWS9INTVNeUNZdWlmdlJFK2VOeVM4S0ZCbVlod1ltaytkRVZUK05HbEdyVHIwR2pXbC8zQUdkRGpya3NDUHBhTXd4eDUxd01wL1Y1Wnk0NEdKY3dtVlhkTG1YZXQvMDZPTjk5Zm41VHljZXpyVERBd29RQklaQVlYREVvKzhRb2ErSXIrQStZd3FoV3FrNXBIdTQ5TkdNVkpuSnN2SlNXNkpXblhvTkdtZjNKUE1sOFIrS0NZRW9pcUlvV2xLa2FFTHVaZlpsUnd1UEtJK3BqSThaa2xJRTFERVRBdVZ2bVI5WEdmVnQzT080WC82VG9LUWhDY2N1NEhJSWlnanZ5WjJxTWg4TUhKSlhUN0xtZXR1ZDlOTGVBUUxGSXNOMVhGREpweFhtVUE1MlRpcVBxcnhXbGJBTjdkcmxPRkhFWmxNVlhENWF4YUNXVHMybTU4aUVOamdHOUFObzh1T3BnZlJlY05Wa1JNem80b2J1QjMxNWVwREszejFNZlFiNHBhTXE2a0hPSFpGSVVTTmd5dHBzZUUxQnFYUXBPQzZFSVZzQzBTbEJVdFVRbXJTMFArT1FGMUhDcTlROS9ZMHhRQXd5MkpDdEVSbjk0S3pBL0lpbE5acEd0SWwySGJiWWFyc2RkdHBsZHpyRjY3UXplODRiNDBhNloyL3h1aHZ3VGZ3TEV4MkROSXJUM05WQ2JsNVVqams4dTNMTEVseFIweGp3OU0wSVpxUFM2RndldWxGMUJ4N0hrN0ZTSTlKRG1UMzJDRi80czJFeWZZeFFSYUpGQVozbHRXSkxuVHAxVFIzUE1hdEhVMnJUcnNNV1cyMTN0eGhIbVViZGNHSm9RTjR4WVZZZWMzdFVwcXU3dmhoL1ljcHBPK1o0TXUzTnpKakR3TUt4Z0dmSkt0a2JNNTVBSkpFcFZCcGRtcnEwSmFITGxZK2hST21rN0N0VTlHVVNRbkh4eXU5QnhzaVpNZFc3cUZHMTZ0UnIwQmg3VGtPUjlBUVhaL3JRT3NJRzYvcW9sa24yKzdDRDNBMHA3cFhORHFDbEtEMHl4WjVEZ21PdGdTZjFUa1pDRXEzdGJtS2IrQml6TGU1MHNmcVM1allNb0dvaVRUWkMvK2dBdDJleWlHcFZvMWFkZWcwYXcvY2s5OWJucTN0MDYzY1RFYjZ1T3RjaXpXMkEwalNOMTlrN0tYcGRUc2xuRWFYR3NFUWpuRE1Ob3hvQ3JnelFsNUxwbWJoRElwT3prb3RVOWxkYWVORzVIWEpKOGorcHFvNzVkNm9NVzUrUkNPNU5RVWxDQXVGSnpNd053WVM0SlJsVnJTZjBjaHdTdHBINXYzQ2w5K1gvY3lDaHhFa3AycVFYTFZ4RkJJUENNbStlemlJNDJVV0huSWZDWkJXTnladk1rdGtITGcxY0ZyZzhjTVUweE1CVmdhc0Qxd1N1RGR3eHdERC9qU05oL21NTm1CYUp2dUljVUNXN1NNMUdjQzB6UklGK3FKQXVuOUVnYnhKRzRaRnBYVW51MTZYTXI2YnRSeEd3TVM2SGFSZm5uUjF4b0g3Y3hiRzNQQlhNRGM5SnZnMXJyd2pVVXBZK1VhRkcwL3hvdmsxVlkzRXM2ODBCYWNLaHJ6TVBLczQvZWtsSld6aGJDTmZlakh0TU9vZU9HODhIUmNLVTFnUGZZeVMzaENIWjI5dVlnMmcvMjNkSW16bFJTL2E5SFgrckRFWnIxZ0p6YnZmQmI2eXBtajV1MHNQQUx2QUd2Y2E3aGtobFpRdXI0ektOd0Y4STZtM3RzSklWMmtTK2dyQ1MydVRqdEdEbkl3c1Zia2o1OTB4WTdkTDhsVG5BUWFjZ1d3K2FjN0x3MHJzbFIycHhyVzlxU20xazMzWDFTK21IczRJT283cEE5SlZncnBNR2hrSTF1V3pHOTVLQWZQb0dNaU92V1ZHTkJrL3grTXlEUkF2SnFMWkdneWpIODJRMW9LTWgrVlJKV0o4YkJMcFlpckpicFhVZmYrZXhLaWdvSmJtTkFkZlhUVmNqU2YyU0VFdWFLUWRyZnBJTm9GWVZmSzZ1dnNsa1M2blIwaUo5REd2YUM3MXBUTjI3WkdjQWFYbXVsc2J3M25zT3N4ZzBoS1ljNkh2RnJlOWEvRW9UWWhKb2lPUzNTa2FpRFNMZDJ4ZkRzcWkwMzlDMjMrQ1dOZmlVODFZbG1CaXA0R1ZRLzdUN3VlcysxQ0F0NWFtdExMRWkrOVpjb29idXFhMzVxWjlONkxiaTZWQndLNnZXdGxBMmVvcFlUL09NdmYyQnMwT2RScXU2bXZ4S0dYeHdhQi92ME9CWlcrRlR4NE9SaUIwcTFhRCtuYytCS0UyK2ZMQStHQkEvVGRKMVNiSi9Kdit3ek9LanQxcXpzclZCaGdINW1rVlhvNnRtOUt3RmtjL3FIak5abGFvemp3NTJGRENYb3QyM1pCODdLcWVmRjZUUHl2K3p6RExLRW54cHNWdGZabGRYK3dhZWE4aWhTMXR6cnM2TXd3cFZGYW00Um1GdmJ6c2JRT2tLUjY3UnB3QngyY0RSdTJZM0NUK05xdHZwanRVaHZ6bWEyaFZPbWw1Y1JnVzBaN2lwb3o5R1p4cEZWV1FYTFpGblBLK3BBa0ZFTUhoRm5vV0ZSanZjc3l1L1BvNTN4Witoc3dJbXNTNnhEWGV2MkJNZ05LVmRQVTFKdUFzSWQycTRFcXFVb1hGZjV5NXZKSzRyMXJsM0xhZXF3ZDNyQUsvbWM2dWdhbWUva0JUeVFSV2QvbzBKekl3ZzhTYWxMTzNDdzV5Q1NaNEZDb1J0alRYb3BtNldRU0plYW4zVDV0ZlpOalVQRi80eVVsdlZjZjFrL0FHdGlaV21RWlMwRHlZUXlhMlV0TjVUQmQrNlBjTHVNVVh3L3R6aStKWDNBS1I0NTFFR3VoNGwyNjNpOUNkSUI5dFo5Vmk3VnFQalhmQ1dMZjliRlRWbzZLSm14NVhpWXJFbFVkTDZZMld5aC9TaEpPNXJVL21JZVRwMFp3VGttMHgyVGRROGJNUnFDSzJmT2RubFZUbExhUjhnRW9MVnUvd0R2cCtaWDJpbE5sQXQ0dC83Z3J1VGExRUZiVGZPTUQ5Ulo5cmdkSFBDZ3YvcUE2VUdCK2FVRlVTUTlIOS9SSUFnVW5waFZJeU10QVRaQXVYSzQrUXhRWUxKSnV0dmxqa0dtS3ZDWVBNdE10UVNsVVphWWFVeHFtMDF6blo3TExiUExTdmNjYzl1UHIzMjhYdWsweE5QSGRhbnoxRy85RXZIL05sZkhRK0pESndNalFvNGxiaHF6blRZQ001MlZJRnpIVE9XQzUzUXdhVzBUZVp5WjB6amF2cTY2TXJJTEY3TmxGV3ZaYys5ZTAwVjBnZVZpK3JES3NUMFVmT2Q3ZU1XaXUrVGxranEwMnJrOWxrTkdIM1pXc1YxTHo2R3BKampnQWdBcHN2NXhsN1pLMkJ5Zkl5dkFQQ0tucXpYZ0FjQWdDVHdSWXB0RFFDNnJBRUFVVWNVUno5MG8yRmxLWmZBZkFNQWhIRUJWVDhsQmtNT0VNSXdET2RvQktadWF3cGozYmJUMVUyaXdUbGc3L2E5OFc0SklFRG9DWU9UWGRvWWhhOWc0T0lrRVNBeWdFaC82aFlnSUVibHFtN2pyRDJHTU1abWhENFRjOFhRVDJpRnV2VitkbkRTUUQxd3JwUjNGamlmc29MekFnMGRPbWRyL0g3MGdjMDZidStwWjZGRTd2SkhmcGFUdFlKeEplT0Y0dWZFRGk4c2FCY3I5OGdTVzNmRVJxOHExSktoc3BOdUp4ejBSOXp3SWZhdGVOTksxbWI3R1VJd1UrdVVFaUlpNUhhdmFhOC9IbzN6QTZpS3lCQU9rT0lRQUZDRVEwcURmTkdFa01ra1pPanlhZE9rc2NZZGtENEhBS3dxdm9yekZjZE5nSkVGMkFLcUJRY2M4dVhFSmVLVXJ0ajNMd1RFeTY1bytFdVZUV0d5YldRNnVrQTRWNkZUUXpSRm9OZWE2Y3RPdXpObjVFRThndEtoVXJwcnYxcnF3UW9NV29oUVhhUElTYzBoYzJLVjhoMEhKUlU0anRpZFBha3l3ZVlTbk00SkQvY2UwVHhUdVVGTEpzTGpUNHNIK1Vhc0d4WUJkSDl0MzBWdDlIL3lXbjdMdi9JdnVTY2tBcEZFRmdPY2tJQXhGQU1qalBsMFEzMWZLbjBET2RVZWZ0Mzhjb1hweHhVK1l5K3cvdjhCdVJjNGZsMFErRy96R3Q2bm8vODE0ZUxnMzMrKysxYmhQN2FBcUtvN1JBVjVBU2x2alJOSUZCb2o5NWZTOFlJb3lRRHlCcEFQZ0FBQUtRRHk5RFI3Mklnc3lpVW5RNHF1cEp5TWtoUHB0YmRWQ1pkNGt1TFB3cEZYZnFRVmVScHorNiswdnVaRjV6NzN0SW9tbTFXNEpHOTB0WVFOejl6ck4zOXRYQ1B4V3dNMVlBRkJLZ3dGQ05sc1VCY2d3R09naU5aZGRFc0JvVW8wUUdLTmxRSFU3L21oM1VGOGJvZjc5dThHRnRER2FhQ0YybHp3a2UvVm9rMDNrbmdzYlM2N3FjOGZJeVhhRUtESU9vNHVBN0VQbENZQWtqN3o4NVAxN0ZKcTQ2TjNRbW5IS29nM1ZrRTNSa3ZuSHVRZHBWWFArU2FRZEZSQ0hGdENOMFp1WTJHUzRpZWx1bkFwRVJkZlE1ZERhL0JReVhWMERDcFYvZk5yaVlwbkllNEIwSTBSRW4yeTdkRnREY0ZmeEJhM3dnQThneTRFZC9ubzBMNUtxL0RSMlZ5bU9BbTJTeGZVRlNoMTd0dTZWVGVkMWFRVVlidXdBZG9RbEZ5R0xueUdrMWtHU0h5Rmo5dGxLalExUUJxOEUxK0t5dUREeXllRjY3Z2h0MWRLMk9oWFNWaEdZK0VpeU9RV0FTbVVsTTc2eWZSejJDT05WUXM3T01XWXIveDA1R29nNldRNHQxUTVQQVVxamFFY3NpMVZ6MnVGemt4UWVHMEx0WXUxZjhla0NOUjZiVXYxQzkvQXhnWXFOMjFMalZ0ZFF4UWFWTmhwVzJxKytVSEV2Z0Zsc1cycGRWdGJRZUlTS0dXMnBmWnR6MEJxSFNpQzNWNG5oR0U0bjl5ZVluRXNjSzlqMjg5NUpOQ05JRmVZN1lHakxReGpucXp0dFdhMTdXNlpkYVMxR3psNnAvMjRYOTBzTk9rU0gyMVJ4NjhtYkRRWnpadkgxN2F0ZVgzdDIzTkdoalJrNUpRQ2FBWGl2K0p2SmNTdk55b3hvR09JMzJPQktxWHNXRE5seGh3R0ZvNEZQRXRXQ0d4Q0tyUUxpV2w2TjdaZVJJeTNZWXlEQ012cTFYZThJN3N2ckxTRm5lenRVTWM3MDhXdWRic0h2Mkx6cjkzemhWMm5ubmpuUnpCR3p2REJoeGx4Z05nRWpIOGlrNXpjbEtjeDNkS2tlT0hGbEZpQWJBVEtQNk9aRFpTZG5FUVhxMFJsNnBhMXpFOFpJb0pGbWVFbW1tMnhOWnExMmUySWMxNXp6d2UrNHRmbmQ0Rnk1RFVhYlpMWkZuQkNFaVJDdkhSMExCVWFkRGd2S2xvUExEMmR5V21yUnlGdFJWVlZCUUFJWnkyWWVaZkR4ck9jVXdwcm5jWDhGTitQQW4zUVVPR2p4QUludkFrbG5reUtxYVdkUWFhQjJPTUNsNVFKT3g3Q3hIQ0pJcFZjMUZjb1Y2V3FWYXQ2TlhxQVkzV2NOSHM4dnpqRFpjYmFPVGhYeHorZllYWU81d1ZCbEVRSEVUWlNUTEREblVDaVNTV2ZTcHJwWlp4RnRqakJKQVJZY1NGWWlmbFdxTGZKZHAxT3VlTFcyaEpuSXFiVWlTNHg4bzVQOUd3YS91YUtaU1BpNlF5bnJSNkZzQmF6UCs5eXFEcjQ3VUc4R0pmYzlKWlBmT09KSC90Yk9hclZLMmczVFRjQ1YzNG80bVVxd05hZ3k1QUoxM3pQTCt6MWhiOEdwSTVvSXl3c1lZK1V5QTV2d3l1SnBMcVlHanNQRVNQVkhsNnNScHMrWTJaOHd3LzhRcDlQL041VGRyL3E1eUNnRlN3ZG9YVm9jVU1yRUJiZ3FDbFZCUUFBa0NSRnE3eHM1dDJCN1hOSzBVcnJiLzh6S2c2UkV4NDhUTVFBMkFEaVR5VEo1RkpPSTkyTU1zOEdSK2owS1ZsdzRpT0tVZ3Nwc3JpU3kwd084bFN3WXBXdVFsV3JWZjJhMUxKMmRDWmJzVWJhNkdhRVMydU5OZDFDRzlyS0x2WjF1Qk9kN1ZMWHU5UERudldhRDN4bDM3bG5QdmdWZ2xFeXVoRERqalFtc1l0N0FoT2QxT1NuTXMzcHpYZ1dzNVdUbUFrRFdlV1NYekVzVitpaUZyK1VaVkZPNVYyaEZWK1pWVnkxMVY2RE5WMVE3ZFZGdVpYV3BIYjFhRXdrRi9HTmIyYUxHMmliQnR1L0l6dTVjN3U4Rzd1N1IzdStOL3FvOWU1MzJZcys5ZWRTWXZWRlh2TGxYdmsxdXc3WDh3YmYySnQrQzIvMWJiMzlkL0l1MzUxN2R1MGIzOUhkM05zZytTdlJEbmJvSXh6RDd5ZndFYjRUUG9tVFBhVlRQNTB6UExPek5nZHpOZjdrTTV2RHZKYjQzZ0t2WTY5MFRkWnUzVGR3b3pkMWM3ZDBhN2QxZTNkMFo4dnRkL1prOWZVMzNkR3U5clN2aDhta011NGhmVGJ6Q1oveW1UMjc1L3ErMEJmN1VsL3VLMzIxci9WMXY4RTNmaHI2NGNMekNBZllVV2hWZFM2b2drVXR0QW9XOVZKS1ZRQUFBRWxTcTFncW1OY0ZDMGVoVmZNODFMWUV3bUpLVlFVQUFKQWt0WTRxWlZWVlZWVlZWVlZWRlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBUUpJa1NaSWtTWklrU1pJa1NWSjBkcGh5dGN6dmtZU2p4ZXFDdFd3UUxteFZCUUFBa0NUWjUwNUpBY1FveENqRWlNUWFRMkpWZUY1c2tXK0pHZ3RJS1lWSjAvL0dPekJiWnI4UjdBTXJlQlQxYXhFS1lEZzlwUnNIRU9mOVNHMjhSWGlJVERMSWZTZnVDbzlHOE9ZMHUwbFZCRXVldFFBZkpveXVyT0lkeXlzeFZZVmxHVHBTUkNKcWVxWVkxUlBObVhob1JrWVJjVUE5MVVTYk55Y2lka2ppdEVGaWdmRTdvRFppME1icFExR3FDR29kTnUyMnYzeU9oWk9MNTFZcGZaVjZHM1Q0bW9lY2NzbHJWU2ZsdEQvVlBhazUrbE1UTmdqaE5LL3ZKNGVxU0JVbDZ0aTlQelhVNXk1dU15cGZhZ0JZVGFQVEt5UFpwT0t0YjR3U1FiOHVyVGlSOG5pRmZZVm4rY1p0Y3NTSGNIQzN1OXVIa1ZqNFhaTmdyRlhmOUdlRldJa0F5MjJ5MVY1SG5ISEZUVy80d0JkOG52aSszNEUxcUZhblVadE8wOHhseVlFN1AyUXhrbVVyVUtwR2kyNURMdDhCdlBvZFhPanlFOWZENWZHSjg3cWY5L3NiSEI0ZG54ejZpS0VRQzlMN0hOOVVWclArVzdoRGVhbnlyanVRVjZ6WTM4cUpWVlh4bXRVWFZUT1ZiNnk5eXJyNTFkZHdyQTE3MjdqVnB1VTF6K2FyV283bi8xb1A1Yy9hRHVadjIyK3g0Mmc3RDdSclQ3dW4xbFBnQjN1ZnNPOGkrODl3NEZTejQ4MlBkc2lSRGozUVlYczdmSGRIN0hvajl3TGZOYXIvOXR4dC9Ocm84VHVTcHhyVHNMN2JlVGZ3UTJNSGJ1L2RVZHp3N3pmZ044OFRaeDZtSk5ueUFvWkdPTDBsT1FXMVVLTnNXNnpCblVQWlV1RXlIYWtWMUpub3JMakx3OFpMd0ZEd0VmbFNXdTF6bHlaRHVreFpDcFdvd0ZZbEYwdXBTc1hLVlN0U0ZyTGRza082OXZDS2Y1VE1zdVVhWmF6eEpsaGdtNnUrb3ZINWZPWjVOQ3BRaVlJV2JVWVpiWXl4eG1uWG9kTjR5MFdUWFJlRFdZTXk0MkVOMmd6aGlVMG1PY3c3aFZTbUFqKzhMYmdnUmRJY2NGcENjVG9Jc1hBeUtGc3BORTk0QTN4VWdxVk00bGdCaXZjWXNpMTEzLzIyaXZ2d05Idy9HbFBjbzJQSWFSbVkyREk3U3FGK2hVK2RKVkVpMDh5d2lCR3kvbTZvdEpDV1BCVVRrcWNBYVlXZTNhOE9oenkwZTRQaE1kQ2VHekdTUFBNMGMweGtnRXdna2FsWjA1ZjlDVnArdmg2OWg1QmwyaUFuY0NiS0lsK09jaFFneFNtU3BBZ0FnZUV4Qm5ERkZYcGRia2x3eHgwWjdya25FMEdoRWc4NDBtbE9PRWUxd0JCTFJpNEdRUDJ2VlVhclJJb1VKZk1SeS9IS3BHM2RxOHdldFlKT2Z5N29YdjB0OEUyU2xnZFA4WGlWMENCTmtrdkd3WmswVXl4WFNaQkZaZHh5bzB3eVJiUnBhcHlsZDJlM3lsWU8yKzFWNUhaUkI3ajc4US8wUXo4MnlELzkyNUFFVUFyRE9xS0prVVEzR0krcE14a1VLckI5dWVnZG55TytINlNNY1NJdGxBdEk4dStIRkY1ZTAyMVNTSm1ndHNFWUJaRUVadWJ6MXpDaGxzQmQ3MHZjamJQQzd0Wkk2emNudXZTTlMvNW5XcVhOSmFyTzdkNzNEQmpmTk1sYmZJdGs2RlpCWDYvYnBibDFNN2d1SUNYa3RIRWJzV0ZnVTlXcVNTZk1aejBWaGM4bnpoL1hPOTcxbnZkOTRFTWYrZGduUHZXWnp4TjMrSDZ1MkRpM1lNWVRQY1hoMUNhblE1T2dhYmNGcDNyb2lNMHplRmh3YW9TT1dmM2E5eWRNZ0dwYmpOY2hDQWdTN3E5VkVxSmUvZnhmRVFoSzR3RWtkNTh4Z1A1dTRMZHJvaFVwYnV1NWsyMitqQlo2N2xTN2V6a2VldlowTmxDdzZBWGZMeVE5SUdDNjAySXdHbFdoNmhaVi96OWhJMERBQ0FweEhMQlVyUlE4WWVaTHdNZ0N4SEhRU3ZGNGFlVFVncE9BVWJsekVEVk9OdDFzTkg1TFZpdTdveDZpTlRWSmpNbUw4N0xGNlRaSmpKMEtPalRkaGpOdGtoZzNIYVRIMEFQT3RrbGkvQVIxTjJTcXhoNDNZUlJ1OWNvY01sMXpvcHFZTzZ2ZElUT3RTMUNUckwyNmg4eTJJVmxOdGdjWnNBeWJLTGZKSnFzcEU3UUJaWG9TbXpvcE01UFp0RW1abmRTbVQwcDVzcG94SFJSR0pFeVJDbXpoSURuTm5PQTZSc3JVNFFEaDRuMVFDSWIwZTNWOE8zUEM1SEViNXcxdjhubWdsOTlEajd6VTU2ZCs3cGQrN2JkKzF3bUJxWkFRdkwwS0d6NC9hSGRnK09kYzJUNVBlTGtFTHhkSzQ3bFV2UEhtaklMVXNITkNOK1NDM0hhRm1LM1RPSWhIaEJFeTU0UjRRN01yUVJpTnFYdWVHOEJjSEtTRVlYZ2EwZXY2M0FEbUFVZEtFc1htRldLK1NVQ2lHTlJuUVk0cGdjQWJOcnpPSFdDaDVYb1JLdm96UnFNTXpaYXpKM3dFdzdBdk5GZk9yZlZJQ3d2TjVnWXlmRlNBZjVreitacTY1emtPakVheGlpU3NGM0x0eCtCd3BDTlJiRjcreDVvRWJDTG00MVFnMVZWcVVMVWVqK1QvYytTMHVzUkhHRkEySW4wWDRKSTdSYnpNbm1uKzRzYVdBeERvbzRPUmdOMEFBTmFmeFE1dWd0S0dicFpHcUhqTTd3QXZEYUNjR0VCR0RrZ0JDV0FZSUFWOFJFSEFNQlFwNENQYUZjQVlSalFwb000cS80bDMwUGRJSVBidTZzbllPRExiZ3Z2alRia3BQNVczRHVGS1NVQWRvNzJkY3VDWkRIdktZR3pKSnI3K1N0ZDlibTVsNDVKS3lmK2Z2M3N3UVFVT09wQUkvejhiVHp1eVRua0k1RnJ3ZUg1YXNaRTZpd05uK0FCTzhHVmNvTzEraC9YdzhPZGxMaGZ3Qk1TRG5QMmhnR2NnbnZIeHdoOGYrSGpwajQ5T3dTdVFtYlVlZ05jZ2E1bTFEOEJia0EwNSt4WUFQZ2ZaL2o2NytiT2JmSGIzNUQ1NytQUFRmZmJ5NTJmNjdPTWYwdVp6Z0wrMGQ0TjdCRmo2T3dDOEtJQmtMQkQzQlVQWEFjeDhtQTN1LzU0b0xJckVtZitBSFljSkNIN254cU1jeXNQc0h0Wm54aE5nclNMWDk5SHdnSjBUUUFjc0NHUTNiRk84NE16K2ZPZlVlV0t4dUowVjhJclhRaklqdzFiV3JQU3Q4c3RpTGZxKzZwMEIvMXB4b0hDQ0Qyd0NjalpTYkg1NitBREFuN25rVm5ZRklLRGNSeUZpN0QxWThDam9FM0F1U1huSUs3OGxyaFYxNGlyU216VzhKaThGNVY0aVE1cGtZSitGdHR6WVBhOFBreTVrY3hwZ2pYLzcrT1IrNGZWVFBBdEQzZzJhSXR1eDc5TVBHMjBvRVFiN01iR1ZXWThzTTZmVGR4NFFMUzNqL1JqOWtxYnhvMWE3K2VEcUdjOEwrSmkybGl2d00wdkRlRzZSMGc0RHM0RW1MRmVjTW5zckpTWEN1ak9NVjNUdGJ3Ti9JVWUxa21RQkRyZ0pyMDdYeXdYSnY0N01XWFVLYU9Tb2hnL0RzOW1JR1BaUmlwK0hybHVCUm80cStiS256UXQvbGJUTkNZRGNpRGZ5a284MWVnQnlWQW5oYjhNSGk0cEk5U3BOMkh0NFUyRVhpTkhmU3ZLL0UxaHhsSXNoNGF2NE4xS1YxQThrbndTaGx2V0ZLT1B2S3A2U1FpUkFyb0tZYklibEFhazFzbDNEUEZQdXNzRXdHY1ZwUXJCeWptRGVQTEZjb0FpelpaTGRMUnNSWWtGMWgxZENJQjNTTWFIYytjcnV1Y2tXaGNtYWxKV2hWc3kzSGNtdmJGVytqdEN4ZkNHK3NydlVLZXo1K1c4UHpmQ3R4bEZTWlVCMDhCQmRKbEpnUzUvb1lxZnd6eFVuV2N4SW9rais2NkhVc3FZd1p5aXA2Lzk3bFA5ZVFDRlpEbkRnTjdBaWNlMDBMYytXczIrTGtlRTgxK0VyUmk1S2ExbUo2bFFVSm5qeGdUUDJGWVJsaVNoVGpadGxrT2FUTGxpV3Z6aWtHWG1SVktZcHlCTXBzWEIwR2VMazhiQVNhYjJZbkNXUUx2cjZ3MUV1bVhwdFVjdkRaMHExUzJ3RHBjbGtXZGg1WGhXTkhMT1c1b0E0dE9UUDRkek5MbWYzd09CZVRTZlhieXhUZVQvYWZZYVBlK0c4V1ZxMEN5ME9sdlQ4Z2xwc25uYzk5RjEyZlBDY0paVUZ0R2V0UUEwUGFQT2VpVWo2b3hQM1AvWFhzVE9QUmx0N3J1MlNid2NEaVdtUzVuR0pzWWM5VTlQNkljZEJUVE9Xb1E3OUliMmdTYkRxWWx4anBpeFNoaFdWWlVrK2xZc1FJL2I3M3c5Ui9ERUdjc2kxVlZxQlFoWE5NSHVSbVd1b0JmeWRDaDFyUi8zaWR3YmFxUjhISEpoSHZxMlkxcDA1Uk5vTmppbWxPU3ZXc0NIcUQwZTJLQzBXaFlYNnFUcXJscUMwbjBqdXRPYlh6dks1cjZqa3Z5K0R3WkZIeGhIMlFzb3k4aE96Zm5vd3pBUkhwTzMvbExMOTV3ZFBTOXY5dTVWREZMZ0FGeUhFaG9SWGxnZ3Y0eVdNdTBLT3ZKWit3QmFhVmxiRTJiYnpKdU5iSjYyOXRnSkJhcHI5SGxCWllib2ptV0lYc1dmTC9PbU1YRWxKT21oUmpDaVBuSG5zaDlYWi91d1RtZ1VVdVFQNTczS2Z4WStwVmJQK0xMSFVwYXNiZm9SMkxsMCt2M29FMzl1RXduRm43dkJqdDFablIrUkZzYnV4VjNKamJsMUVNZlJ6dkJtdEpDd05OYWUrRmI2S0tsSjhyeDdXSWQzZXB6eHg4VjNVV2N0eHBWN2xtS29sTVlNaVBFSHQ3Z0xsUUxibmx1ZnIvcFhZVzFQT0tUV3VnL2d4TXloaFdrUUpUZEF2OEJyMkozbnkvN1E0cjBEaVlKN2ZjMU51TzIvc05OQmVmQndPWmtxbDZtK1dHdzE4dWVtMmFwTEpicVZmY3VjQzY5SzFJdElyaVpWdWZkVmIyOFMzWFBNVXBTc0M4VmRsOU5uYUZMQUt3OGx2NStlL0hadjNFak55SVhmekJLZDVUVXNmUzQvZWRJSzdnM1VmYWx4bVJGN2lKL3dCVzJoUlppU3IzUE5YS2t0YjhYcHJ3dWZwY2xTaEtxTk1aVnJVMEJRZnZOaUhIOTRJa3RoRFh6eVVIcTlTaTRLR0taTVdOeGZVQ0RUS3FQSkpQNm5lZ3FybU52QjdFQ3FFaWdRR0tQMmo2b2RaOWwzb2dOMkQ3L2pNSDM0akhPVUd6MGY4L3RNUEpaaXJMMitvRXNVdTJ1a1Z0Q0ZMQlZaVVV2WWVQYm41a1B6Vjd6NzFFT2JyUEtTM2Z2SzNGUWdhS3h4WDNJS0F2eHVteEN4cXFhN1ZTMXBaZ01ab25KQjdnYWJWend1c0FoZUhoYkVmK3haMXVSSlZjbzBnNE5LUUo0U3J6QXFXVnFQMUt0UVcycHYwQ2xXeEovamdpZVFUN1dKYW1rbDI0am5MQTVFM1VYZlB5bVBjOVpkWHZZNXk1REw4UXh5NExDdEpHeE1pNDd2ZXExQUc4N25vZittR1FrOVJibTgrUk5TSVA3T21NRkQ1L0pXa1A2WnFLMDAwbllSOGRwM2g3WXhQZnpaOHVRNnFxQXJtUCthOXVkWmRHK2pHbGpqWG1KRnAwUVZJYXlTZXEzK3FzdkpJV0FuWlpVZXFQRUZJUFRCU3pRcVpZUGdFMmN3dXBiRm15Q3BPcllCVW9qMThoZjFSbW1ydGFqRWRaUm1USnRhdVFKMTNWUG9rYWdEN2lHMllnWk9hNHlnNENnZDlnMTQ0bGZ3NEFwb05GZERnWFZpK1JjK0NhRTMvNmxlbVR1VzhUZEZmLzlwd2oycVQ4TzVtT3k5QjlGRTc5aVBEY0syT2xZbzVwS0ExVHZtVTZTbit5SGRlWW84MHRQcGFCZHNoZEdWS3RpV2c2WU5IS2FyZUh4b0Y4UUpoamF3VmtZQ3N6RFNCaE1uTTVoN0l1N3lzQ05tT3JQWjRoY0dEbjZJT0RiRXJvb2U4Rm5LRmh1Y2VJV0ZwTDEvSWpieDhXMDFwSkxhbllzMUY1cSsvL29MRndwWnRaY1dUaUVxeitQVzBlS1lYUHVUeHl4Q0syUDB2TFI2TzJpbVhSaVp6WjdDOWJ6WVA2eFFaeVppK2M3Q1dpZXVrL0Fxd3l2SU1LTVFHUUpaaVVzWEFTZXZhZDdkcUlWMzFhVUlkN1BKeThKb2hEcmsxZEJmUVpUS0JidUZ3ZG8yMkZEWDFnd05kOWVzRlZrdU13QjJTMzFuL05uRjJnZnpFSUNzMnk4ekxoMWs2WjQyc1NlNEtOc3hoMTdheGtSTzBJdmpRR3hhRzMwYzY3MWF3YVk1L05KVUt5SHFHaEJ3MFJXMHYyaXBSbGNNL2ZrOVVhUnhHRlJxZUlFNjV4NmNVMUN3LzJvWG95b2pFTXFsNXIwb0tMWStKMFpweldtdHRsZlBkRHJkaHVmWjZpNEk5cmpBUUVFYkMwV3p1VWJGTEFVeTNKdnZLbm1ReUx1V2tqYzUzV1ZBVVdueDQ4cXh3Sk1pVjYwT2EvVlVHbUhLVnlwRnRyMGVZTHY5YnRscmNUSUx6YTRKT3duTExKcEQ1VHBVRGpHK1pQenhLcDVrYUZ0LytPVGwvZTlxS2d2SnIxbktDbFJSbFJzT3Z0RTk1bGt6MjZyVDE4RXBQd1F0NmZwWGNqeUwxY0I3MTJwRVRZYkk5dGt4YTNFeUNWVzhDdmxubUExWklCcDAwWkZ2Y2ZLc1BPV2czdVduTVNxNW9YWXhwdnFxTlZPb3dPQ3NGbkdPbVpTc0dtbWI1SERUVk1naE50NTVpakVteXhyd2pkWlpOdDJQYlhiM2NYakMyNEJlclJWVm5vRW9hV1RlUnE2MUdJdXI4dzBxQ0JtYy9BSzNNRGtMVGNoeTFWRHZCdGxLa3RQMDUvdWJCWUovRW9kQVNWbmt5cGREdjVtU1o5a0VmZlcrejJtb1RUTmhiNjhoU0EyTFhSU0dlUmVzZ3J4WHBXQWNsV1JMS21LejcvMCtHNWlSTDh5SS8wYmxrbDJQZEg4bUdPdmtINWNWZitwSG5sakg3SjliaDhqcVdMaDFTWi9LajdiSjdtcWR2aEt6YXd0YnQzTTZ3aFd0MSt2RUtPZURGdUZaWnJMQVlyR0hvWGZBR0hZb0NqdzVpMXJyTkNKWHZ3T0RvY2dxK3FLYTVzSlhBMGRTMGpSNTVXdVMyaXdzSUpjaWFzd3g5eE5vSjZBYldRR2lKeGJOalNZWTFla3lHS1Z0SzJxTXYwSDBnR3U0SnFLYWFKWWQ4d2NxdlRPL1g1VnF4djRFN1ZnNkR1S3lBMEdncjV5dzFJWWNsejJyR3dRcC81anNjaEFGdHU3Y01WVWlDa0J3NUNrMlVqUTNsYld0ZUdBU3hRa0pwVU4zbVd3Unpra2s3UUpEd0s5SmxUOVVvalc0UnhHVG9ycHJnK3Rta0FvRzBzL2NpbVQ5QmU5aVV2aWhBcEdId090UndHeEJJOEJsM0FvUkxQalExVEZuTVlRcUNqcVVxdDhlUWFsVVU1L056eW56MUFzS2VxV2pIWFFwWXo5b1lqVS9zMGErT1NnQWlWL2UvMXIrendvMXlLeDkwcXhmSCtZeWZRUXVPN0pBVjNrWG4zdjlFYlVwMnhOT21YZVFDek1obnFIam1jNDZEQ3NqTUNNY0VhYzFDdmNHeTRBaUhOc2RudDNaK28xOGF6ZkxDdnJvQWlMY0Q2dElsMUhya1huNVFtN1g3TzVZY0cwMTFsaFJvNUtQZmx3Mkw1QU5rVS9yMEhxOS8yZjYzQW45YWFyQngrdEQyeCtYMnU3TWNmT0pCNWZRZ2x5dmNUd1FRYUpzNzhOL2lrYkc1djVaMEppTXY1MDA1NVhTeWxiWnFCVWFrTG02QVVDT0xHR2tFMTBmeDZySFp1UjM4dC9tZWNIUmR1bVNSc3JhNWpSeHZMSTlxRnRvNGJteCs4SCt0WnM0alZIUDBXV0UxRDA3Vy8xOVdyeWhZajBtdVY2a0x3eWpob1kvb0hSWWJKZmN4NDVKangzMlBkYWZwWXBmYVkrckx0bmVOWVowM2syejVjY0wvWGgrVFpySjFvTlhJUzJYS1E4SGt2MWdzZjdJSGsrL0tmK3FVVlZrVTdYWkRrL1JYbWQ5RW9QUzlmM3h6TlJ5WHZiYkdHblJxeDZVUDFJMWd4Q20rc08zb3Aram9mSGpyM2s3QitrenVZbDRwUE5wZjN4cll3MGtDWmJmbUJ2RnhJL0h3RG52MExTZkt3bWN4ZWx2ZWx0RXJQeFM2dEF5aWF1K0U5QkcrOHRpdVdqMDNrRTZXMzQxNGxKWExnVjFSU3BjcExZZXEzSno4ZVNlN1FjMGw5SUdjK05wMXZUenR6RUNqZHRsY3Y2bzZFN0hwbnNuMGp2YXFUSFQxbFd1MlBYbGVrc2Z3RmROTjJqRTAxYm5HSk9BR1pJenVvRTdpNldhUldKTW9BVGE3QW1takNlYk1ob0E3MTZ0MENpaldqWUt1SnZIS214dWl3TjF3Rjg2TjgxZ3kvUDM2SHpoK0IrbHZ4YUZ4QnY2Q0RlZDJvMys4UlgrODFiTy9lZW1NK0ZNYUJmSEl4MFpabU9Dd1dlb2oyeGJrOHJ3dm5QenlubXpDT25pS1ArTXhrQ21DMDEydWQvT2sydElSNkwwOTVuMDVQK2hoSFZhR3R4NkxPUVNzNXZIcVNGZzNzdUh0a00zNUVrdnRPL2l6UWNWazdRUmQyR1BmWC95VklYUmh2UFRZMi9EdUJGUlRtSkQyOHRHbWV2bHNMeCs5NTM0QkNSa1pHQWpPUXcwdDF1RUMxaUcvYVRuYmhuUkgwOUpBVWJtSDJEV2MvNXZHYldNZzdZM1gzRGg2emlzcUZDYWt0M3owNkZ4MzdNbFZXSUFJbFlHeU1mZENsdlhlZ3NSQXdPM2NrbHlFL0prbUFjRFhuOENldmhBU3RFY3ZGOU1rRzR1akRHV0F5YjNEcDUvaWVKRCthc1YrVkhWSVBNa1QveHZPQUtYWFBBeUw5Rk4wOWZ6cjYyNjRxMzJuNmQ2RmQzZnMxWnNEdUw2Q21MMTZXRTEvZnNiVDNFeU1acXRQTDFBTHJzTEJlekJ3YkhLM2V2R3liUlljV3JnMkg1bWJoK2ZuMy9uNWVOUGRFRENFbWlZcUxmdnhlZVdhaGJYclV1dnBXbmY4OEUvZkF3SUp4eStuWEtJN3hDN292bnJsa3Q1K056K2Q0aEE0WlNoM3lxQ2ZMWkhUZGNnMTlBK0xRQ0pVSlJhTzQ3dloxaWpqeWtwODJBcndsVitGdCtWQURzZmwwVmE2RHMyRWRUYVRpVVFqZzRNWUdyZ1NEUXhCTW9Fck1TcWhMaEl3YTFyc3Jhb09taFUva085L2NNYjF2dnpBZmRPaVFZRzh5UXNxY2cxOGJpdjAzek1yN2pmMDBYWDFCdnVyMFBaSURGNElUVzRMQkJVblI2RjUvdHVpa1EvMS8zekJrWVFlQnB5N0x2WmpoNi9yb2FBYk5TcEVCRllKdldGNm8vRHZqbmc3VUJhS2xtVDV1T1g0Wng3Si96eEFGa3VKZHo2dWhMZlF4QjhFdlRKcGU4aHBIV2FWTkEzbDJ0TmJob3VLbTRjMW5qMjBvN2VwRllxYmg0QnVCem1QaEUrSldIdGxpdVFPTkQ4ZmJBKzRIRzhjOWpBVzluZ2prZ1hXMUZ0alRkUU92K2owc1ZpeDhhZXpxUTlndEUrUXJ5K1pLa2M3QnZnNDRFNDYrRHUya2hwdXovZDBMVS9saHdhMStsa0VXNnNIR3NheEYzalRPdForL25xYmdNZmNzcWlUSStTbjIrbmJwS29IVmpBVGk0Zis5ekkxVXpkeE56bmpROElUQXNPdzJvWlJWQ3dQSzJHU2NvV0xFV1Zza1QrU09ISHhzZ1BRSXUrVlplNFRLQStjUWhGTjNpNDdoZ1JMb3RBa2VEdEZUalV0cENYN3dKN0NQYXhidFM0UlRjQ1BaVExtR2N4clRPYTgvQldBdmh0QzlqSXpFY3IxNXNmRkx2RTdncWI1K25URk5KQVUzRXovcTByNkFPckxIUCtYQ2lwbGVPRUFPeElvNFd3ZU9GUk9pVHJBcnAwOTJhTW10ZmU4ZW5WTmp6cEk3b1cvY0Z4QWNyZmZTZ0pmUFRqN0RrcmF2d2ptc3NodHBNaXFuTGlVa2xKSStteFo5UHNhVitqZHhVejJ1eHUzVkxTRm0yZWhVbkpIY1J0MThUbktyek1oamQ2ZEZ4SFhWMWlUZVNrem81NEdGQWhweW56ZW1vUUkyT0JOeUovY0Rpcmd3dC9RQTJuTkF3bjcwZVg3MnFlZ0NDNnJmNEJvMDVncTVxdlUyNFVyQzBmdkgrV1oza1hmZUlDRzFJQmJrcnVvNFEwQjM1clVpT3l1L2p4Rzd6QWRNSTBhbGJjT09QK3JOWk44b2tYd1J1bHB4NXRvT2JnSER3L0pRWldrTTFTcUZZZUdOaGw5YTZZZDYwTmQ0OStSdmZCVTJqYy9sdHcrSmcrLytJelBYRmhpOWxwYTJoWUxIaDQ4c25zbHEyOE1jb0I2YnVUMzBHWElYTk43Q1daVkw2S0UzODQ4V0ZUTkZZSTh5VGRxZjhNb0ZQYXRaZTBUakpUTnV3ekpjQjY5ZmVjbWVodk9RM0w5NVhCWndjeDl2V3RRQ0tPcWY3Kzh4R2pQaDJpSU8xWkJvL2RXUUJ4RWQrWXpSMk9LYVJBRzVIV1paK05abVVDR3NBMDBVUG4wb3FiM0pLVFI1RXNUL2E4QjFBTHFtY3pZRXlsL1JqeTU0K0orQU9xSmc0VW56S1Azd2VxRGc0ZURydnp1SGEyKy9xNlJyTXlSeTVDeEVxVFdEb3E2RkJtWWs4d3FJd1AxVHNrdUlleUNYS1p0Qkp5dkJ3ejkxNS9PbXFGblRUZmh2dERWanF2NlpqTW1EcFlmZnZNKzdPN21yS21JOURSK0w0T3M0NktCOGl3amY1d1JyZGEzeERjN3p0ZUxIb09NZUlLYS9ubnY2dEtucjRlM3VGaytlcllNbmxSUnBYRU1mME1Nd1N5K2N1NzVOa3pDNE91MzU5dWxYSmFxaTIvajN0RXQrSk9sc282RW5DSFptSVFwbVVJUXFYY1dkaEtVeDdWNEpQQ05vZTVKYnQvZTR1MlVqRUQzbS9JS09sNW9NekMyTysxdmN4YytERWwvOTU3bjhXdHdUNi94QzZmbVJsMitZNjNaWkhrWW9UTk9La3pyaEg1b1M4a3ZTR0wyQUZWWDNGZkpyY2xORVE3L2R6aVh5OGYvS1A3UFoxaVlUYzAvU2tOREJ5QzVoM2ZmZnRtZnc2aU5VUkNqaFd1NWU1d3VkQjc5K2ZqYnlCbGNIVHN4S0xLbGdtNDdlRHkrbGtyeHowdWlhb0ZiNjcvUDVGanJUZXpGYjFZQndXL0tuTEs3ZGZLRk82RDQxRjd5UTltbnNPRzV3RU0rUVllRzV6N05LSDNyS0FKNU80RGt2aXVNWTVCOGtsbkUrVTkvV3lUNFhlWURvdUk5ZE00dWNDcG5LNWR1ejhZL2VQV3prNXlVMlJRR1dMM3lRejJQVThXZS8yYmpGL3l1ZkdQMDRScmlRc3k0VmM5NGs3UjArZWlwdUFiZndjRER3N01mWjVhK0pZb3JQU3lZM01wL21iL2RiK2N4WGpKQXBndExXeklHR2dudWpoMkM5VS9mM1puLzlQN2xUZkJhRmhrVWNUWVBzZ29jY1ZFeW1pUHYzcWgwUVV0MHUyYncrcDBqVlFFcDNqNExRaml1K1A3UjNEMzdPemdNaDd4M1dsUStYbnRZbnE0anFuc1hYS2FVbjNIbkJCRXJpcTFFWE5sMmh4UEZnVmRBalUvUW9aSEdpMlZNSERtNDcwZVhsWlpKZmlEeFRabXorTlVpc2FpTG5JcCtqVXQrRnhDNlR6WWR5S0J4TERNMTBjdjdtMnFhMERYMUxmTGd4YjFlcHVvbkJDNGlkN002a2pTUG9JTGx5M3M5K3FSa29xbmlMMEdVM1lRTDBSZk9ELzZmZDJzWkQvSk9XWG1DaHBhb3B2YW4vYnBDRW5yeVlNUm5MUnpjRlVmTmIwL3pWenVDUFc2cmJMcVhXYWJZRzZZM3AvU2U1N3ZLYTZIbGJhU3RkeFJMMDZOc1BEZEM1ZmJQWWhWYk41VE5HblRRcGgrNkh2dnZzNTFETC9rdVFGN2RNa3VkNVFLeWhWWHZGaGJWSCs2cy9ZTlQxMkxWWHE1dHpkWXR6cDdyWHBpdEE0a0JydXp6NlQyeUg2Yy9xRjhWV0pTOXkvMVhRcEdxbEhpTCtqZUxORmVwSisybDdDNTNSN0pqdERDa3dsNXh0OE9oMVpTUmQ3NWRmWVVLbml3UG1zeHVmSGYvSlNDS3IvK2hYNG1MZDlpZncwS0IxWllWWkp5Yy9KZ3ExYTFhNmZ5WXRxOGJYdWtBLzVSUCtrU0IrYWFwSCsrQm5Zeis4Qk53K0ZIUUYvaTRYMlRaeGo1OGJ3NDVublFmdjBobVYyOEtyN3dFUTVtUmNUZzg4WDZMNzBXNzNXNDd1Q2ZUdVRiYVluVXFob0JKT2hFdVpTa3dLTW41M2E0cWd2UUxEeVdIME56bHpHOW9hSlYrTG13NzZZVU9QdUNzajNWVXpyUjdjYmRXOEtobEY5bHVnRlpmUVM1OTh0OStaY0krTTJVTmRmczRaMDc4MC94UVRlUm5idVBkSUFXRE8waWR2UWpkTy9xQjhxYktoZU52SkFaQVk3VG1Ick9vN3ZGQWY4MjlFbGJWQ3BENTVuL0wweERkdlBLbWYxLzVkVnU4ZTMyUFUzWkVJS05qZGVSUyt6Mm1EeTE0cjhmNm5xN1BLNkFsZFFlaHV4ZXBjOGNnU09GdVkrNVBFYlVOUUhMdkRraThHUzgwVlE2VUZ4eG4xdDRiSGFubXNvcHI3dlVQMWo2Q09QN1RBVjBVUXQ3c2xSMUxPY3VGbEhYNlNxS3RIS0twZDZqSUo5ZEJ3ZmFXb2lMamMvdi9YVGlnMW5abVVEdDZRVDNJZStEZDRNWmczMEFmcmZKS1d4R1pzRjl6RUU3YTRnaUVJQWk1T3ZVZjYwVDBCR0YvaExsV3NMd3ByUzQ5ODdIb3c0ZEpwb3FCc2daQjNmak1YQXN1RFlYVXZHTVFyTEJiVlBWRC9PSzl4REJDS3lOZ1ZETXFrMVU5UjZxK3pTcXVXZS91cVZtRThJN3F1dC9qKytxaXhHdWZ6dDY2ZjJ2eFlWOWFabjVzVW5rRnNMMDN2RkVMZ25yMkJBbytUTytNQTRFU0EwRkZUN211N292RC9mdTNKbyt5VzJLcWc5NHZIbWJNQmlSM3cxWnk2Z0hmL05PZERPRzByK0VSTE5pM3dIMEs4enNkMk43Y01kR2pwTWJReDlVaFN0NW9WYy9Cc01UR3lXc1QvMjQ4aklpbmtNaEoyYUZMRDE5NnhrUjUrZWFXUkEvWER0Si9rcWlRdWtKVEIyODl2TEc0MFplU3dZaU9MNmtBSFFmcEJ3cUdDS1NDMFFONUl5U0NQNWRkOTdRM3ltU1FHUmxnRTIrTWoxUmtPZlhWUG9HeU5rREIzWXNTUDNPTEZDRVV0WDBSUjNEK2FMUTJXcjJhQzdnSDdSdU9Jc0tVOWJsZGcwSkZTWW1MZDllUGl4YVhEQXpVUFM1cS9wWUQyM3QxR0gzQXZaWWNxSXRkbWNMRlZ4VkhuZ2VqT01LMUkxS200VVJ2bjFRbk1YNG5ERWxxV0xYMlNGVkZZczN2MmVXcHYxdmx5cmtIbFR1dmgxSGR6TU1iajB5cG5zSytyM2czZG1Wd3JRYlVybmtQN0lhNldSZ1pIMXBTSHZsTUFEY3NNL1ppQmxSMERIU2dOOUNnNDMrbmVNUDczcXl3cW5kdmJFclgwcU5semtaZmJIcEJ5QW12SXdRempTakErcjFsaWQ2dlpZTzgzK3k1UUJMZTAwNEMrbDY2OTViSUJXMWhrWG50YlpIMlU4SWk1YWUybjhOUFJiVlU5bkFuU09aWCtUVHlkZVEvcitNK0d2LzkyUHU5Wlh0OU5OeU9nM3lidjY3MjhGVXZYa3VzSEY3T1NyWWk0dldlQzRIQytMNTh3NlB3L0cxOGJuOCtwTFVycmZFSVdVMjdOK0crQ0hsTkEwZm55Y0x3QmpjeElEQjFOVFVnTUpHN3NURDBwQytORkpFaDZPK1RuQ2tqcHhJK0tmNENHYmZsMDBDQmZ4Z0V5K1l4RG9qUGdsL3FoelpXUGR6NjRTZjlTS0FtcFNIWlgzQm03WDJJa2U1eE9qN053TUVpdWxYUkVPc0J4Q3U3OVRtV3FYZzQwd1hjb1QzNS84Qmpmc3Q0c291TGhTSVRuWkIvalJ3WlA3Y2kvVTczbi84K3B0MlNQcGZlZFU3MDhYV3grblV4aThBUWdvaVFGVHJZWDl4bWZVL3R2UnU5b2wxcEFRaUtYTnBpWFdQcUxhRC9tTVVQRlVsZytTMTRrZWM2NTVvRXhIamQvNm9paHNmWjVDbGFzZTZsQkZ5WGpPVWVRbUVNQW9PT0d3Y1hNWE9FeEZ6bjdKR3RTTGFwd3hqOEw3bmFScWZTMHJKejh5ak55MnR4N2NXbGFka2xKWTFKMTI4MHBaYXlNN1BMeTgrMnJpNkdOVE1abWRtMDNMYjg5WjdoNytqcHE5K0VSaElYVXM2dVpzRFVUelNJZitLcXRhcTN2Zy9aL3RScVdHUllibWk0WllncHh4Umh5ditFVkFPbmNxbC9DWjMzNnZ6U2VUQllqN2p1UWdyMWRDUTU2dWw2K2w2VnFkbEtRUzN6MmljeXJLVjVJLzJxS1JFMS9SYmg0N3QzQm05NHh3Zjc4dGlGNDdGSGErM3d2TEtWMnluOHQzZ2N6ekx0cGZraUl2SkxWaTkzRG5CWFVSZ3gzZ0E2VHJUOGRiZ0hXSkhBUEV0azRTUDhYZ05ia01haHRRZzJXam8yVnRxNmxwYW50YTJzRTdWc3IxN0NsRUMvVkhyRi85WXQvNVdHRklWYk4rVlRHcmgrUmR5djdhYmZ5MVJYWmhvRmFxdjVHeHByQmZockd1TFhQV3RydmRZVDZvRzBVME1hRDM3OTJxbDlQaU5SUEkwMlQzYXpDeTRxV2w0cUJoTWlYVVF3MHhLbEQ2L1VCTjkzVWJyQWIrT1VuVVJQSmNmMEovV0ZhbVluWUt3MFQvU2pRL3B5aXZNYmkvUDB5WEtFQzYxbzVWQW5vc2tKdDBRVjR0RnhNSFcyekgwUnBYRFJuT1IwenBYUHB3ZWpaOHFETnhEWmZSNU9tVjZQeEh0ZTlmVmU5LzlCWW9tTUpUWUpRNk93WWIzdys4NnBoUEtuaTBueFM5Y1RFaS8rQWNwakIxbTBHWVhrR09LbUUzNmI2VEVhZmxFaStNQnY0a3NGTW1ndmNHdEdhbUMvMXNtaXBhVmlMcjlZVkx6SVVWaGN1dGZKRGcxVmRTSHNrSldCdzU2aXlsMlRvNzU4Z1djN1h1VmNCYjhuVkE4VkI1d1pVY3ZRRzQrMzhTQ1k5V1ZQMVZWWFhLNk5kNmVVWjRkMEY2TjYyVER4dU9GR09XLzhKY2xnRTRKRE1DNG0wb0xrUkhleURjU2MxaWFhNHl3RHpQZjI4NXhkS0Nzdkd5dUtJSkFESGRDb01IUmNqUFBaMitVZ3UvZDlqOTN1bGgyVU5RSHk1MFp4Wm1NdFgxTjl1bkZKN1JCVWRheHl2NHpFdnFHQ0dBZ0NwUFRvZjhTL2tiemNPeWkrTjJ1QTVBTHB6MlNpczVFQnNWOGhsL2NGL0k4c21jUUt1YnZZUXRESnhHWkVzcDNuY1I1dm5Lb3pQNXgrdGNLL3hlNTZVOXVkQWZ3ZGUrMGFyM0NhVzZZWG12bzNlWEt1dWZYcTNPQWJPMi9QR0ZkbjF4aHZPNUw3V2FLelp4eElOMHRla1p3V2lvMjB1Uk5ndG9tUmw4eS9ob290aUdXME1teXlHVjc0NzVDQjhTaittY3lPR3prZDBtWm1QUTZvYjlaSTZFblY1OEhwNjFtcWF6dVpaRHVhbjJtTjYyVVZGcHdycE5qNzBoSThTbU5SR1F5L3Q1RDcwd3FzYnpMeVV2alhVREVGTVl4V0J1R3NjdW5sZkNBZlIzdm9ZYkNlUmhvbmZmVWRiRkp0c081Nm5nUjlZeU5YZlhRSGI4Z3dQWS9laytsbjd1MUJFRUw1Q3BFRHJFTW1jMmdEaUpPbTNEME8vT1JrWHVnV0NaUm5HWG8ycmRROTRPTlh3OXVZb0lzb1R3UlhBblZ6K1JXN2F0ZStaYmZiWTNkWWRXN25hMDc0NXBhVVh4UCtyWDN4anpZWEt1Wk9UbVc5clF5UmxGVVdvT2wxMHZta3FwcWRXTEhBK1p0YzVBOGFoQVBYL2p1aVd1SzA3a3hyRWF5MWRHeXN0WFV0clU1clcxa2xhdG0yWGtLV0hNdklCSFZ3V0hSdkgxNkJVMGozOGQ3UEYxRkNCZVNUTFhNVGpSUG1wbHNna3RSUFB0QTZGc3l0bkYzZ1ZNeFdMTjJlSFdUK0hHYndXM1JkRHZlT2R2M0lIVldSUjN0WVV2aHk1S2o4OHJncWk4R1FLVnRnTkhSMFgraW1YWnJ0VUYxSTZQa1d0NWRRMmVlMklQeUhoZGxPVEhSc0g3WHQrUkpZWXd5YlZQbEtIaHIzMUgyVmdqUEMxNjZZdXlEOFczdnNqelk1RlhQSHhnMGF4SkdWNWJ1YXR6T3hXYjJaSFJnK0sxTlBxcDk0VitNUzg4V1BCSU5ZWStoOTZYc3VEalJ2REF2b0VzZ0JHb3dobEVndE5LbjIyQlc3V0U2cXY4bkl5YWt1OStqM1JqUUNKdkt5QzB1Q2NOY2pqbTFhRVVRaWVaTUtDb3hFNnMzd1Zoa00wdTJCYVc2U1UyVEwzR3JnWU9tM2Y2TXhKS0FrMllsU1A4OE5Ic1QvZEc0M2htck9WZjRkVktyNElTRFVpc1g1WmprMUU2djR6SjlzeWFDR0JGOEZpa0pCMFMwQWMzY3VSM2RUZDFkd3VrUGFlTWwzaytIc0tHckg5b0RpWHViZVBQRUhlaXI5bnpMQmk5eHRWWUYzNHAvVHhUKy9HemJaM3ZvdVp0ZlE0dUpyODhzRW9NTmg4dnZHYlRyWE0rMUNja3BxTC9td1dBbDZpRk1QWTU5M3JnOWNiWTdPelF3QlNtdHVlc2EwbTE4eUMzd241VkFqSXhnWndXWUI1KzhSdVU0S1pRV1NUcUpEekpEZUFzODEyMnZDdjdVdS90RVNYTXhRbjRTM3dxNk1MeW1ydEF2MVV2T1ZCQlZXZHpPdUxoSnJjeFpOQm9qdnZlSG5lNzlSeGJwZFhmNmduRTBPbFZKY3FUNGxySGdweG5xR3RWM004c3pxYUZrVHdLbS9kTm5EZUoxZ0FVV2ZOeGtsUFhkSFczUmszUWJNTmJHSHZHUWNSS1RNQXkzNWw4ejMyc245V0RnNHgwUE83TUhsckx5alU4MExEOW9ENlhER3VWMjdvcEdEc2NxZmllRktQd0ZURGI5Tkpsejk3TTQrYUpmMEh3U3ZlZG5rRzNLdmRWNlBlVnpDNGpWck4wWXdjcHpkd2RQblhMblpYVDN2TXh3Lzc5NkM4Ryt0c1Q5YUYwV2Y4ODdONG8rTVJDVWt0ZEdRcVdpK0VTczlsaU8rNzVNYW5FNWM4VmszZ3QyenRWY0pMWWZmR3h0VUpsL3lMSzN0eWQ1RUN4M2YyUkpSLzJmM2d6QW9FTUxiNUhZTUkrWTBXMVh5SjJOdTJsS0FsUTdsakM4N3h6d2o3RVdzUkNXUldUWFZFS2pmbWhmbVcxREJhV2tvdVRaS01sM2hldjhqenBIMmc3Y2ZveWdDOGR5Sm43NmszWUpVT1BYWXZkZytIV2hqYU9kRGpyUEJSOGZxRmw5UWRFazdna3ZIdDl4Ly91ck0xYzB5SXpzY1FwMlRPenNiR0RrVEVSZjQ5a2JwRTRuNlR3bmtUVk9jN002V05xS1FDb2IvbE1hWldJWWxPOW1lTFdsR0llUUxxV3dYdmdUOHgyYWNDbWJiZld0cktOT1QzWWlvampXbUkvYm1oTnBPSGxQbDFrSzdrRGM0blV5NU84czlwVDA3Q3VWVUpua2VLOXFWTDYvU292aEdMYWpFM1pBU09lU0RONG80akx1TjBoRVNScHh1Q2g0V01kazRkV0Yxc0hhZFhWeStPanhTOGFDb3RINmoxRE5HbkI3c3dZUXdGcHM5b0JPUW1PZW44dzJMWEo3cE9kaU1YbDVtQS90MnB5a25VRURJVEd1U2ZvM29DbWVYcUhJMVhTK2tqUDdiV2Z1eXBmY1dIdUQ1U3hERy82Tm0rL29uZHowTTY0LzFXNkhRREUrUURzNXozK3k4S1AxdEdoamZkVEp0akYzN3REZktlSUFaRlJCWTZCYVA2cTE3MnZnL1ZpL2RTOXQ3UVFDeE5SVWNzdUZva1VFZ3NhSDlLdXo5eEMzMERiN3RaQlpPQ0t2UExZSjlmSnJuMmdwQkQ0ZW44ZjdjZ2VoNlNCQ2ZHd09oeTBSMzFpWTgySmRVNHNUMWFhSWYxRDVURWk1d2RsRTJRSS9zNHVoZDVPUGJtd25ubTdxYTlQMzVHcm9hQUJVUExKL1FPNDVtRkFLbE1hY1k5dDRsdTRheW1mWFZlSGw2TVFoSWNTZUthR0ZONFlSczhwYlhOMi9CNDJqRXZ3cGJFRVVpTnFXNnc5dVB4MWJWdE5iTnR5MEdRUmNjbUpJUmNzY25qam01cmdudmhPUHkzUlpmY3FXaytYRnorcFgwZUZCUEdFNmlUbExucVZQVWxqY3Q2VlBwOCttVDZVblFMaTQwTWZIM2xRSTk0VUpaSExoY0N5LzJWY3hLbGhTNUdNYXZtb3ZMeWJ5N3FlOVpSVGpLMHNMRUNHOFJaWUV6TnJIRWdWNnN0RDFrSHUxbFZUaEV6NmtWclBPOVdmWlpzb0ZaNVVpMjY2OHh2MzdqUW5VOFQ0ZzltSlY2NFREV1h1YjJHQnZQWmhtQzE3S1p2Ym1ORjhTc1BERkFmSjBZM0dsaWpUaUpteG15WWw2cTBaWHNRQzdCL3pKWTVraDJKOWNRZ2RmWTNTNHdpK0JpMHQ4SWVtL05TVnNETmQrbnBiaVpvdmcrN252dE9Dd2J0UlMzVWhQU0gvcHFVNGgvaTE5VnJFdnBzeVRveXc5aUU1NEtqY3JPNjgyMW5KbWJtNUI5RHBROUk0ZjJqUEdxNVlIMW9MVFVER3VHd1lDNXFYa2R4Z3hMdGhTdHF0T1cyUFRsWVVpRUpTWjltVE9IdEpFV1dHTVRPdGxwSFF0ekUrUFk3Q0xsMUdsa0hPM1UwY2FiR3h2eHhTMG5qZmZUU0ZhNEU4czhpa3B5Q2ZmVkZDTmNsT3FPUUV2dllkbzBQOUt4a25qYU9wc1VUSThualRmOXlQSmxwbzV6dk5JWFAvOS9PQ050bm13V2lkTUxqa0k3alV1ZFp2eDViYzd1WTgxaTNxNTJiSGw2YnF6cmwrYm1SdEZtWDlmQWRQQnRhOWE5SEo4bVB4WkxUTTd1ckhuejgzQk5hRGJvbk9YRmlVQk5zUjNYNXFaTkNWSGw2R2N3UzF4dmlJaXdzNlZRS3FNcUtSU0M3ZW5rOVZIVjVEQ0MzY2xybytvbzRYWjJLVFhtRHhvakl4TlFXRjkwQmNYUGdvdmNWQlZkRlVhWmhWeVRHOWtRRVduUElqRURqbkxacnc1YUJxZ1l1cVkwRFNiS3RTck9kTGRvYzFQL0o5Y3M5OUxNdUxwYjBkelk5L0cxeW8zV2ZNZkJ4Z25LVklxN2ZFSU1wVVp2WGZrMFpoajFNMmRGY3B0dzZiRlBtd2p6YjJ1V2lZMzJUMnh3VG11ZjFKNWNtZnNHcmVKckx2SDNGUWpNT0dyeUNTQS8rQkdRWFJ5dSsyOFVrSjFlQU9UcmI3NUI4cjMvT2gvdmN5NTNhKzgrTFgzdlcxMTFYQjUvTXZvRW11NGNLOUtLcFo3cWE2anh1NTljQkxhNjRZTFc1T20wWjBnVXppdllNM202MEpxTjZKdVJSR2JCd204MldoTk9oa2NveTh3STJYUDVIY1dtekZXRlJ3c05YVnlGREluT3lVUm5ZUU5YVjlEZUp5RlgzQkNZN3VjcTJ0elkvS1U1eGpVOU43YjhLUDZMZEdLL0pHZ2tpR2plMmtUTGxwbWdOb25nYXRoVHVJZGN0aFI4em91K0h5cUdQdFc0Y0RVVVdRYmc5UU5kbDJGRmpzYWs0cGdHSDk5OUNnNXJaSUxIVXZBWUV5TmxoUC9aMkRtck9DellUeXJ0WnJaWTl4aG5XTmYxbjd3Mlp6VnVFYXRkbkUvbEhqTzM2akJPczY0eE5qb0xtbkhhUlkyQjZiNHVZaTBOSGUrYlk0a1p1WURKMDRmeis0N1JsSlQrd1ErbjRQM0FZSExLeU9pZjN2OG5oNUtUQjRiaGU5L1hrd01weVFORDN5SCtRVlBQM3ViYUxIS01POXA0Rmtvdm9ZN3dwa0MzMFVtSmtPMzZiY3lkOHRPbUZCcmJYYUE4ODBpY080bmloY0pzcGZEZktRS2NMVXZVWm5LZ2lqdVlhMmZMaVMxQjVLdlZPVXNSOUpPVE53Q1VqazRXVnpvOE9QTnFWUW4ydloxYzVhNXcxeWJYakxaRkF1Y29NY1h3bUpobHNyYk9HRFpCbkM5SHNSTkxSbmhCbDRTdkxVSDBvMVB0U3hGME92cHhjZWF0Y1RqdFFGYnpZaHpkN0hnbzlYTVQrT0tZckhiN0hkdTBrclRXdnRhU0FwUThGUVdZbWtWc3BmSitlYm45cnkycUNsWGFPYjNNOXFKRXQ3RjYxcis3NWdjMGY5M1FxYUx0bDVNOWVGbW5zbExydDluQjNaY2Q1Y1JMWlJtZHpJVSsxWGJRK1RCUjRlRVpMazJyUzYxTnBVcUhlN0RkTzZmYXZZYTkycWRBVjF5K2E1cEtwNTA1TFp2RFNaeE81Q3hBM1BTRjBSeGFaUVh0bVVvYkhVMENURzBJcllxemNJS3NKR3NJTU9LZVBxNnFvcUpQSnlkNHhDcG9WSXFGQUdpeWNuRjhnU0NiUDAxU1luNGkzVzJLcFkvUEh4VEpDdkY3OHRRcUNZbnZjYWdCcEJDL1h5V3FQeU85MUQxa0JkTFMxeDJCNVVYZi9NdzhvUVBKS3pETjNaeUZNdVlzTE96RUZ6alU3S2lKbkF2VytVRmNlWVdFcTI1RVpBdU16NTZzS0d5bGlUTjVjbVRCOFdNblprMERwakRPa3FaRGQ2NDlGOU1CQ0JmaTRmN2hRMitIMXgraXJ4L0Q0UFc3WnU2dHJVRmlseVNkSjZFRmNERjRaYVdIZ3BCeEI2b2RLK3RXVTYyeHF0V0ErTlY3dThQU1BWWDh6UWRZT2NTeEtyS0ZoMzYyZG5ERzRGemN3YnlzWUdKamJtYmludVhrdlptNUVZY3VIMVllelljaHRtTFE4a0Q0K3RYV0huTjZhREh2MWNyK2wzSW9MU3k5cjJCT2F6SWRqSGRtNFA2NjgrWXZSWDJmajRTbXdvSmI4bm5Ecmo3a1lwUnA0V1ZubkVPeXQxUXRPbFJjdDErOWpTdW9rNzNEbDcyTldscFNTMGxNeWxnRDFCUmFISHhzZ3NlWjdkUG1wMTUwcHZma28wT3VxN2M2bWVycHgweEZkUjV1VXBoWVZ4cVpORnBmUnNPUkhBMWNKSHNNMXNkQkpzYk5BYUtuOC9rdm5oekNUR0pCZVNIN0Nhb2ZQaXJTR1kwcWJIRGJ6dFJyTUpsTzYwLzJNaGtXWklWR0RXbU0yTVBDN3lxMU5OWEN3K3hVQWdtTHdmbGd0T0s5elBCK0J2Mk5SOW9iWlJveHFlK1lNY2owS1h1VGowMzBPTE45NnR6VXE4NnNjL25DaEpUejhtR2tvY1lPTVM1T3FCZW5UQm10TGFGaHZKcDcyV010UFYyUDZqMkx6Zk9GZ2V5OWhYMGc5Q2U5Sm81b3YwSHZrQUgzcCtqb0dINEVkejRlRzJ6NFNQYmpCTDBWTHZxeVZuSlF6Z09IY3BNRjZwaXRUTHdFOFNHNDhvNGxHbVlkWlZmWHpqSFE3V08zcXFhamVoZTg3aUY1alpXSEd4ZUZsSGpzQnUwaDZpbXFQeVdrOEVsUS9uZzIzcjRwaVo3VGx4UVUvUGhrbDZiMDVEYUJaM1oyZzkzcGJwZlh4M2x4K1huaDgrWGk1ZDNDM1dYZzNHZTVzU0R6ZGVHWndsUmUvYzZEeENYTm8rKzNZWnc4MEl6alhFVXRWcmRCM0xsY3ozdXRHR2NQMGJ3VDNFUndxMXA3VnNIOE0xZmprL2ZiTzlpd1Jrd1hzK083amtZQVpURzBZdlVBUDNxOE96cTV3SjlyNFFjc2NSWnk3K0FISGZITHZoSFgwd0NrZVRBN1B6c1V3QVMybjdBeFhrS2JJNkFzUnRIMU9mOEpnTTB4QnB2WG1lUDl2VWFpRWZnSHhUcDJySzJEQUNzNWdsUlAwUFhuckNpVHRYc2QvcG9ZajFiZy8vVm0xaGxXS2s5MENmLytlOGxFSG1GeW1RelN2ZEcvR29SeHF3dSs2N2IyKzM5c2NFYVhvdnR6UFIrV2FDWnA4MVgyVzg4OUJXemZtcDBBbm5zVEJLeFBwUVNuQmVyS3FEWkRRQTcyekZxNUI4dXc5bkNUeUF4c1JmY1k4VmEvTWxuc0xTT0x3NG1lU3JIbjNQSUZWazRodnRIZCtRTmRuUDVZTzhWN3hXTUdwVGVaRDBjZlVyZXAzUnhuQStMTmxlU1RZTk01emtDTXpmSGJEVW82ejhSUmRaM3RxQ1VUUjJ2OURBY3JVK01CVmdhdTQva0I5Qy9Ic0pjL1U2dDhsdDBHWk44Qjk2VmxkaFM2dnk5TUNtTVZFRlRWSTRlcTgwd0hvZmgvdXBPMWZvYVRsZTIzTW5EaEhETWtndzRoc3QvV0JiM2MwZXFCN2x6OGpwVDFNeXlCQjdpallUTXNRUWhaSTJHZjlIVzA3TTRyV25uMVAwTmErZFB6YXV5RzN2UnZtL29jZml3NEJ6N3VFMEdOUlp5eDIvUHFneEpYVUo4bkVnZDdVcTRuNHZlVDd3RVVVZ0tneUplZzZjUFZ1ZWM3Tit6WDFCM1Q2aGxjUUVJUGJEY3dzblc5djVCZVFIc1E3UnFEKzNDQjV6eHUxRFI3OEpPZG5hYXdDSHpFdmlqUkQvekFiOTUrTjlXbkpWYmlSeFUwdll0MVkzNlJqc0JXOEhaUkJ4ZitzbEFxOWFIOUhxbFNaT0NVNUpMQXlXazM5TC83VHhFeHkvZjBMckcrT1dzaVVrdFBmY3ZEL2U2WmpobDlzeG1URHZoL1RNWTF4Z0wvbHJNbnNMeTB1VFp6RFV4SHZ0dzgwQ0lqSE95MG1wblV6ZEpaQ3RoMk94UG5MV3JLSmFlSDRnd1RvL2ViY2VmWjFkRGVjNHZsZUJ6Y1B4TWh6WlkwUzNYTHpIMExZY2ZzdkFzSHpBb05HK3Z1K1FTWVdyZGZFb3MvTGpFazJ4UUkwSDdSbWhzS1dnbElDamQzK3E5VEowY01kT3Bwb3lPT2wrY3VXT2NIOFJHNmw2aWZQK0Q1WU4wNXQ0Y3hGUGlsYldjRlhMbjZ2Q3kxQnJCNS9RQnpOaHdnT21pMVJYbVkvZzRCYVB2Z0NpY1BhNnRhd3EvWEhudkdpUm4rSmlBc0JnRGVYN1ExQjRBUE5wY0R2eEsrL09ZRFJMaUFTZ1FBZ2gvUzBVUDczOE5rODNYZ29ZdGVXQ1BuYXFoRDYveW42OVJEVTQ1a0hKU1NzTmlpVHpyOGJWb09rUEJoNlFmeHI5TzRzNnR1aTRwUnBZN2hYNzVsbGJwNExFbmtLOFZTVVNBRE1meWtWVktTMllva0VWZ2dLU21oUXh0VU9WdkVnL0ZGUG0wT2FWcTRhbW5kakhWb1I3d1dkSENWR0pyOW1yemRkdFZwQ2tzNTZHRE9WdElZNkp2T3FIVHE5cnRjalZTQjlnclM0YWtYT3ZCbWxGYXBpMGhQcVU1SlFSS1E4SlJ1V0tlZmcxdHMwVi82amU4NVhWSEVSenpRU1NhL1VqZUJJMm4rZ1lOdlIrb0t0djJ5SkFkTEp1T0E0RXQ3YXJuWXgrVjNsbHRDdWlEUmtWV2FmNVBPMmZINkZOQ1B0UXhKWmtNR2ZZWkpBeEx5ZmRvdkZ1YklXUXZ2Tk9VN1NnVmR1eko0MW41M3NjaVhLNWpsUHZJNzZzR3djckxrTUZJNTdGYnVRdkZDSGJwa2NIaTdFTDdja2NJQjMxTldLWVBOVmVGY1R5L0NMRzhlZXd4SlpiSE1KQXF2SlAvc2E0TlhKWWp6WE1xWHh3OWxvQ1VRRkVCbnFSTHFFQzVSaXRGQ2FVRmxWVU55TnErZ0RDWUYwS2lpWG5JbjV6bVZML21BR29jak1HQy9TdW5nRnNtTlJaNXM1RitDYkRBa1o4c3ZLSU5KQWJUdE9NRDVoR1doVGw5VWtXNktUenY4L2JSc3UwMGRielQ0RUJjQ25HRVVxSHdIcElCS1FOd0lBdUJLVURZTHhBemdOb0RCQUFCSkwvWWF6dmx3VUFkTnBubUlHTVNYaTBLdGhscGZYc1h1b1VKRktGaXR1Z3JLVmZLZE9vWXhvNkhOY2krS2Zwa09CZ093SXczYmRWU1lQNmc4VkYrQm5UNTdJd0tKSXNRTHMxL0xZVXVvZjFURGlxdFVpc29SOWJXMkFqVVp4VHBZT0NSNkViV3JuSVpCRStmL3M3VVI1clE1ZVdRT3NhaHlQWjZoYzFrSEY1V1ZtVGRUWDc3YnlJcjE5QmpwRFdLSHIzWlFzWmJqdWhaOFVuRXo4d2pKWTVBdHhHb1FXU2FXYmFSdG10dCtTbTROa3RQZzVVZVhIdzFJYlphMU5nWVlkTU82Q1pEQlFRa0Jka0pvSXFEMGVoK2dYeUpWdkFTU0JYT0VPUThZTTNVc0RNVFo0aWc4dEpsQURQcmpJQk8vU3hPS2hOazRaaUg5T21JZVRWbjJ0NlMvZUxXNE5QM0ZpTDlBYjJxVEg0cHZGZ0RhSm1DNWh3ZmFNVjhxYUNuZ0J0TzBvTllBY3ZPWHplTGtJNk1seEpjUDJnTGJnb1UyTEYxTnZCeVpkM2hSYm1uM1VCYmdHOUlhU2hJTlVPQmZjQWFsNEYxWk1Sc2xOZTlnWStvczc0NTk0d0ZlRkdOcUFmaEhFNFlCRmdYUVI5anR3MmpBZWVERlNKVkNKb2d5bkVra21DK1Q0cTJNS1NQUFlhWmNvRjFnS2tUYkVsT0p5WTlNRlpOOVlXb0V1aXhUWjVOck1QWDBmc1hlU09VUlRRRlY5c1VvUVUzWk44QUVsR1ZQbVRJSTlTKzNYQTVtN0lXQUZSS0FPS05jZDJKUW1LNHpoTEx5TVVPWnJFOE1MVFo2TUF4ZHpHVlkwYkdSRVJrY0Z4a3hhWFVJSStGSlNveE1kQXBqRkRGV2x6TktTWGtYYkdwZ1FCUFFOYU1Rb0QzdkF6QUlobnhCaG9Bclgya3JDcno1dm5zbEV4M2RFdmNpaEI4N08xSW1DK0psYkdueUZhdDBRWjVCb2VEWU5IQVErcjk1NU5IYWlpNGFKeVpmcnZkRHZQQVZMYTBWYXhaNjdRNVpkelpLMDhrWEkwMmVIQ05sbU11UldFalVvQkNmSFdDdnBJeDg2OXVrUkJBNXhoQW1YSU9SSmlBTDRPRWcweXgwKzVHSVNEYVBiMUFhRXBEeWlKTTV5Vy9aNkdkV21KRWpEaGZDa1hlT3pxRjB3aUtOUSt1S25lcUlObjdET1NEUUFmR25YMmQxMnZGK3Brc1hVek1jTzBZa29xMWJiYkdkdVA0c1BFeDJEYkhINlRRVkhGOVlYTm9wVzlwM0NyRXBxYW5TTDU4TVc0TVN0MDliV1Z4cVB1djNVRkZwZ1dGeEoraDhJVkJDZ2RCT1E3YTBEYk5ZSXl5OGYyYnRKblAwaGRxTUdlejFsa05JbHdiK2lTMVhnaFdCSXRHVWRHUHkvaHRlblV5cFRnbldOWXlJczdnYXpzZnFaMFRiZktiS2Z5T1l2OHpoSGViQjNSVGdKSTFoaHBXZ2NySFpza0NDRHM4MThWbWRnQWpsb0tlcUFIaytPcTF3NXFHbW5nanFhQWNmTkRTaUdKbEFlSmxmVFh3MTlsNmlEanVqR2Q0UEtsclB0TXFLdVQxdUt2RE9MQVlyMG1MWStMQ29rQXNOVFJoNXlqUDdJRTUrVGl4WlUyZ3E2RU5ua0JGNlJPdENLdWlrQ2pXbEpyN2tKWU5aaUwyeCtWMmVSVVF5cm5NeTBBM1hVeWZLUlRoVmx2akdMRU1PTGxjakphMGtPeUhhZVdJK2tjbUlrQ05lUDVETzhZUUdxSWYxcnI2UklkOTNGd2pKd3NGUkl5M296cy90b3kyRktjNU44U0VMa0Q4VWp5aEM0a1NtaEh3aER0VUxNREdFUW42QUk0UVpNd1lOTmJpQTFjT0ZsaWN6Q3JBT3lDYkNJUzRXSURxRVhNL09ONGdqMElJd2FnOEU2NXdxTVR4OGk4ZGpUaXJUQlFNbE5CeVV6WXdaUTRtNFoyYjNnd2x6SVR6MVExQkFBY29lRnBVcnR1Z0VReXltcURwWnlpZ0xpcy9xQStuaWNnYVNzOTZGaW1SQzRUeUhpN1lBWXNPUVI4R1M5akdsTEFqY0VSUGVuYWlwOHNDYUIwQkJ0aEl5WWh6RkFwSEhuNWhESzljd08ycnBQSnEwSEFzQkQ2MHBPS2Ewc21yY0ZMWEFNS3RKbStDUlV1WlRtMllGa2lsU1A0TGxZaFpYZmtiRzRVS2cxM1ZwWldnZWJwY0pZd0FPbWFZbFdKOCsxQjFtSnhqbzZmbnI5Y1pEclJKbWJSbE1obThEbGF0MmcxbHE5NGhXWGlBYXlvRE1Ha2hHTDZONHA3QnpJUkhyeHBYdWJ0KzV2U2l3RENta2tVRVdSU2hHQ1VwUmhuSlVvQkpWcUZZalo0QmFBK1ZuZ1ZHY3BGbGVsRlhkdEoxdXJ6LzRtZVQ1OVFhcy92QjdmemllenBmcjdmNlFkUzZST1ZyMnVhT1U5SUpoV2xMVG53blg4NE13aXBNMHk0dXlxcHUyRTJtWWRYQ1YrNGVIZ01RaDkyTzVid0FRQkFhQmlTRmM5ZUxqWUhGNFF2ZHZ0a1NtVUdsMEJwUEY1bkI1ZklGUUpKWklaWEtGVXFYV2FIVjZnOUZrdGxodGRvZlQ1Zlo0Zlg2T0YwUkpWbFJOTjB6TGRselBEL3FETUlxVE5NdUxzb0xoYUR5Wnp1YUw1V3E5MmU3MmgxeHE2Mk91ZmU3emZ2OHQ1UURDaEtLNURNdmpGNy81dzE5K0hOZnpnekNLa3pUTGk3S3FtN2JUN2ZVSHc5RjRNcDNORjh2VmVyUGQ3US9IMC9seXZkMGZUd0NFWUFURmNJS2thSWJsZUVHVVpFWFZkTU8wYk1mMS9DQ000aVROOHFLczZxYnQrbUdjNW1YZDl1Tzg3c2Z6OVFZQUJBSUdBUVVEaDRDRWdvYUJoWU5IUUVSQ1JrRkZROGZBeE1MdXIyOHcvd1dBNU5KblN3QVJKcFJ4SVpVMjFzK1ZBU0pNS09OQ0ttMnNuNnNBUkpoUXhvVlUybGcvVndXSU1LR01DNm0wc1g2dUJoQmhRaGtYVW1sai9Wd2RJTUtFTWk2azBzYm10d0FpVENqalFpcHRySjlyQTBTWVVNYUZWTnBZUDljQmlEQ2hqQXVwdExGK3Jnc1FZVUlaRjFKcFkvMWNQMENFQ1dWY1NLV045WE05Z0FnVHlyaVFTaHZyajNzalkyNEs3SGNQZktoYno4eXhibjNHTFY0Mlc0Y0lFOHE0a0NwZEJJZ3dvWXdMcWJTeGZxNEVFR0ZDR1IrM3YzV1NKRW1TSkVtU0pFbVNKRW1TSkVtU0pPbUU2Zkt0ZWY1SXBEY0JJaHpwMHBDVEx1UHhVNE54SVVlOVBoOTkrOFp3ZS9jREFBQUFBQUFBQUFBQUFBRHdtN2ZjSmtSWXMxdjJZbWFGNUVMQjZxTG5nVDlrcUVZZHJpYzRMNkFkdkJmdzlpNzhyNXJXNUYxNEU1ck1FQW9XQjQyOWdIQUlPMGIzTHZ4aG0vU1FDZm1PM1Vsdnd5TWo2UEE5Ti9hRTNQa2JpL3l2eVZ2dzRBbzZQSVZVVi9hNU40OTB4T3doRkd4Mm1pTjBIYmxzaURoOGZ2TllkMldjWEg4UDN3S1hJUm4wdWRLTmpZcEt4M09LaTJVRkFBQUFcXFwiKSBmb3JtYXQoXFxcIndvZmYyXFxcIik7XFxufVxcblxcbkBmb250LWZhY2Uge1xcbiAgZm9udC1mYW1pbHk6IFxcXCJLYXJhc3VtYVxcXCI7XFxuICBmb250LXdlaWdodDogYm9sZDtcXG4gIGZvbnQtc3R5bGU6IG5vcm1hbDtcXG4gIGZvbnQtZGlzcGxheTogc3dhcDtcXG4gIHNyYzogdXJsKFxcXCJkYXRhOmZvbnQvd29mZjI7YmFzZTY0LGQwOUdNZ0FCQUFBQUFGUnNBQTRBQUFBQklIZ0FBRlFRQUFFQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFHb0ZjRytWU0hJR1FJQVpnQUlOd0VRZ0tnZmRNZ2I0aEM0WW1BQUUyQWlRRGpFZ0VJQVdXRmdlaEVodXcvMWVvZWZkZkpXem9QTFAwbFV3ZWszVUo4NndQRG5Xeml1ZTJKYXlqRVVsSmE2dXkvLy8vVDAwcVkremZkUmN1aGtoWVppVkU3dUpnY2NXVUtSRjVWVkZ5M29DTEI2RDRvd2pWVXNzdXFXUnAwTWw2OVB5VXNBeHcrdlJVMUN5bkhHQ1pYVTBKbE5kN2Iva29FdFF1THBmK2lDTjJsM1ovUmxsak8rV2xGaUZlYitsZytEbFMzU1JXMkRuRExDTkMwckJ6d25xZzcwVlMxZC9KbmJyWjA0UVpOWE1uZk5NOENFbkRzOTNoaW1wM2RkY0dhVWhPNE5NTnlDL20vRzhWaUxQYmRhR3BNOUZZZFNOd0VsVHpaOTNsb2J2Nks5Y0xvaERTZkUzcThHZElNMWtFeGkxMjFKbDVlUjdxei81LzdhcFQ2YVIxbGZTRDBua0doekkvUnBCbjMwTUkvUU0vdDk3L0M4YklGTW1CQVl5cU1jWVlNSEpqaEVxTUdxTkhDUzNSSWdMU0JsaUVJbTJBalloUkROSHpGTzg0UVE4NVFmUUVvK2dwRDk1OWw4dE13YW8xcW5qaGkyaHpaYXRkNVdoa05oRnFrMkg3OWFGRmFEd1JOaUhTaUMraVhVZEdOYlpZSTlxNG51cXJMYUlUOS9NWGpRUGFQY0lCVGpFcThsZjg5RzUrZjA0RU9UTkRTdG5kSitaL2FyK1ptVUR1bGhyUWxtdENjbFlTK2pTMDczMnFhVWhXL1ZjVWNXU3dsTUtmdXErT3pPMGpVd3QrVTBVdEF2em4xL3FkTytKdjFGZGNJaG82aVp4b2laQi9hc3Z6K0h2ZGxaM01vUkNLNE5qcSthOVFGWm9aajNFWXVSUnBQTDd4ZFl3ZHY5NzVhKzEzUnhTYnpwQ2hTNGlFc3JlNFo5dVF5WVJHSkJRUmZmSy9yNXdnbnNRRzU5VjZoOWhlQW9UTmw0aW5kait6Nzc0T0kwcEp5a0lTald4ejBCS2xFRG9wd1RWam9oZVJoNGVRUmdidmJrUW51L28xUzVGSjV0S2xNU2xUcGt1M3Bja1lDYmo3Ty85dnY0Q014U2RHcS9WWFhsV2QzZ0RMMklNV1hvNlFCclR2NGpHUUd5d1M2NHYvdEFVQVY3T2tIYUJOTEZ2SmxwN3I1Y253QlZVNDBJSk83RUtlWXlrSHlOYzg4R0JVNmRsTFRab0ZuN3N5dFV5bnVlUnpXY1FaeW5tV2ZxdEFHVjg1Q2ZMa1RheElvZnhzN3hLTDJka2xGOWd6QUpaVUxYQnZhTTdBUEw5QTgzb3NRTjZENURuY3lid3hobkllNE4wNzd6SlpIeG9mR3BkRVNtUGpRNFVLMGtqL3QxWnBwM2EyWHdlb2oyV0FIRDgvUzdQdlZBZ3NzRDM2M2RPVm10cWF2bXp2d1V3ZDhSeHZDS2FodW50NFlZNVJoUjBBeUFnWkZYVTJxSUIwb2hMaGt1ZDMzUUhLZlJFcTcxUmliS3lKbE9IaG4zdVYvM2puWm5wRTQvcXlSeGRRellwWTBER1BoNjFXZ2JwWHkvUDhuOHkzZCsyL0xDRGYyZjZzU1dtQldlSllNSVVEYWFjUzlVTm9KeitWbDRKWjVhSDVMUDVaRmw5S0E1cE1sUDl0elFFT2JHRHorOVpXejMrRjJIYkJZMlRPSEVpQlRMbzUwWVM4VGtrUmMvdEh2WVRtZnZRamhKSjJEM0hCaWJ1TlJUbksyVDBOMU40VHNVU0VpSGd5aU1nd2lFaDB6M3VzRGFHMWdTT25HUGxiOVREbTZxanMxcTYrclpzVnlFaFJGTEc2MzFZMnc1VlNyT2doeG9oTVpKREI4dmdvMnkzL2xnc3dDMENoRFZFRVVhd0NxbElsUkpWNnFBWU5FQWUwUXJWcGh6aW9BNnJUVVloanVxRjY5RUQwR29JYU5nd3g0Z0xVbUhHSWk2NUNYWE1ONHJyclVCTW1JRzZZaExycEo4UXZ2NkIrcHlEWklMclFiQmc5U0RZS0NacU5vdy9KSnRrS3plYlpEc21XTVlWbSs4UkFja214MEZ4V0tTUjNWUStGQU5OMG1VSVArRVZaUVBLS3Z6WUhKR0VCUzA5QUx2L1VPVUFBQWdRV2lnQkZuRGtQa3AxZ2dhYzFBdERubUZsN0Y1MjVPbDk1eXI4ZzBWUG1qMng3ZG5oLy9CSUdhdzdzbThaQTB3WVpkM3ZMS1pROVp0OFRCZU12cDdYLzFvU292eWhOVlFhUkYwMlppMUpKRGN2dko1V3RySHlTZFZDUWp4V285WW9OOTByOWNqK2dqZURjTjg5WW9ZOUJyVVlhSDFIVGJDdE1CZ3o0Wm5jbTQyZW8velBQRmNKUEFIdGRzK05xbDl5RWoyeFlHVDdqN1ZVblJLMmNvOFA2UjlrRDJ1NzgxaVQ3eXFWc01BaTZIZjdzUWpURElSQkZKRUdTRkdreVpNbFJva3lGS25WYXRPa2kwYmZGTnRzWk1tS016SVFwTSthc1dMTmh5NDQ5QjQ2YzBMaHl4K1RKaXpjZi9nTHRzRk93TU9FaXhZaVhJSmxBcW94eWxDbEx0ano1aWhRclVhcE11UXBWYXUzWDRJQkdUWnExYUdXeWJObUhISFpFQjU2NWZnTUdEUmx4M2dWanJycHVncVAvV3pYdkg0dGVXL0xXcXZWOGx3WGlNOXFqeVdxOU9WOS9FQ1JGTXl6SEM2YnJoZFg1Y3FNWmx1T3BFRGhmZ1greUZnT3ZzOVpaV25BSllzSXFsMDNBTm1hZnNTT3hNeEdjU0lnSkNzbUxkV1JjVFZ4UHpPZFl6TEVVZXh0UEI4OE16eHpQbStaRDg2V3hhR3lhSDQxRDg2Y0YwQUpwMFFTbEpwUUNSSHdDV3ozbGZLcTlvOVpMNnRYVGJnTG5hMm5oV3ZyM1dzS3pZakl4dzRBTkdiWmtyTVl3ck9ySlZHKzFlbGhXSVRLRkNQS3RGb0puOVlKTUw5QWlyeUp2SXF1OTRBcWZTelFpVmNCMEFiTVZLWmFqMUY3S3RWT3BTTlVXYXRWUnI5Mm1oRVppY3c3ZEZNTTAyZ2w2aEJGeURibUZtQ0YyS0NBV0ZVb01GS2VVcEpTbWxLV1VwMVNrVktZY2l4eVBuSWljakhSRnVpTTlrZDdRcWREcFVGL29UR2pJdU9IUWFPaHM2RnpvZk9oQ2FEdzBGWHAxdWQ1Y3J0VUNmc0NDcGNYeERwVVRHbWQwTGhoY3VjbUJXb0ZLUzZCRlpLbG02T2F4YWlXYkROc011MXoyT1J3Q3hYbEs4cFRtS2N0VG5xY2lUMldlamh6emFZdHBCRzFQQUFBQUFBQ0E0UUREU2RENmpibGFGYXdxS3ltVUhhMDBRY1JpMHFId1dOTDVVaVBaZ1lYSXY1RjExb3ZMTUl5aVdwQnNLeWxsYmM1bVdxNXNkdktTZFVYcG1hTEJGZU42MHFYYmN3U1F5RWF5YmFSVTg2YzFkQktPWkdRMEp3V3lXZEZxdGtWYmZqNGlFbEIvSDczcGtTQU1zNWh1TmpHQ1RoeXVtWlRIZnBQaDhWdkZiRHJFdHZ0MmhJSWJYSVhydytmei9KTnJNZUYxOHlxV2RSTWpxT0dFbG1WR29qTzVxVjgrUlZHYmxYSXBNNVhPMUFEcS9hVFkxZ0JUTU1lR3dLM1RucDZWbkxJOE1YaVo0aXNFUzhBUE9PQXY3Z2lDaDhmSFVyT3llbjlWckJIUUJNM1FBcTNRRGdmaEVCeUdJODM5R0FaZzBHOUVpS3ZCOWFlZndIQXpOazhXdzVOVWpqYUtUZEdxZzNoaXdPVFl2N2txU2RZdnl1M1o5SWVRMFN2WlFjY3VPb0xwU0VwY3BlTTZIWWlxMS9CMldUWUorNnlPclBuRVlnTG5Hd1loSkdFZ0RGTExxaFFMcGcwQXJzeE1sdkhKcWdJYW9RbWFvUVZhb1IxdXRqUUV5ZDhZcExrc0d6anptNFhQa01TU2syVUhqRDF1L2pmQ1lnc2svUzdnTmpCcWR2ejlDYW5nQkRSd0JqcTRBQU5jd2EzWkcwSVFIL0FGRnJEQkR6amdEd0VRQ05ITnNiK0xtQUlGc0FlS29BU3FvSnJzUFpuYWpwUzBsM1FUaHBId1k4enU2YmNQRlZlc1JLRVV5cUFjS3FDU2RleTRTSW1acmFoOXFFNUF1TWk2eDZQTmV3V2FFRStPVm5ldzNuRllMb0lOc3hmb2NGQnUwVGp2NEE1Rm90UkEydWEwTm5GOHFDMHkwQzJyNlRHV0xrZXFhV1NDNi9ZUGsrUEdrQU5Zc1VJSmxFSVpsRU1GVkxMNWsvNVhCVHdtdk1uK2JoclVWMWVsMmhMcmljV3JPUWJEMEZDTTFMaCsvbVFqZGlFOFViWVphc1BBSVdDUVpUV1RxUnJtb000bG8rakdaRC9ZZ0FHYm15T2I1di9hS3VxWUorQVNJeFhRenBLOWpzYjBVWXh0VHE1VHVIUVdIc2tNVmpTdzJUUGNtdEpHNGpLSlNVQ29QRDJFcVk0SjJpYTZQMXYrZHVhblZhSXlXTmMwQzJKSlRYWWszbVJ1NUhpREhBMXlETWl4SU1lOU5EK1FFMEJPQkRrSjVHU1FDNEdrTFRsbzJwSUlmeWswZUpBTkRIakhyTUpGdXVZWlJSajZuWUt1OThkZ3dlSndnd2s2ZTh0QTV6cTQ0UGVLR2pRU3dPeElDelRPMXpPN0lxRENxWmhzb1V3RkJ2dWJYaE9LMTN1cUtXdHNQVjdENm04SjhsMnNia1dzc1M2Y0ovYUt1THhoWjN2c2pueG92UFczekZXMGlmd2s2U2dmQ3d3RzJaYzNWUUtOSVd5NU9lQTRqeEF5akdQYnFqRGpWemJOdE5iQW12UHJRTnFqRktKdnZUaEFCZG1XdnJaM2dPdmc5SHZwMmhKQ3BjSkdpWU4wYUhFL2RMRzVyekoyTVY5TGErZVB2cVJDUGZEQktTNzkrVkdIQWplNURMRzc4R0xsNXM2MlVzOXBRTXBIS2FSWXRBQUUwTnJ0Y1pVRmhjSEFMdjB5STBmY3JPWUJRRzhNSjhtMXFSOERRRXd1cFF2VmVKSGlsVUNtV1RjcnFTQ0Zic2RqMHg5UlZKK1lydDVvQjBvc3dEUlR4akNia2ljUnV1dEdKelVaS2ZJZTF0WjkrS3ZIMExpem1hZ0pIay9Yb0NmWmRGMGN3a2sxVzJVaG9JV2lWS29xdm1GUGVubTE3SWxDTFMxLzNDUDlBL2hralY0LzhRVzRKU3lXeWxEdkxTMTJNNjB3OVRESCtldFVETytiUkJ2SWdZcG9keVpuS0ZUU1hmZjJKaVdyQjJuQ0NiQ3NEc0ZpOFY5M3JzaVk3cUF2SnprWDlFREhPazRsZUc2V3RIaGkyZkdzdWVRYWNwVFVhazhkVjh1dDRLVjUveFlzMXVyTGVQVGtjWjdtOGhuNXNFcGdZRXdTSmord0VKc2UydXVkOGI5b2paOHlIWTlFem0xSmpweXlYVWUxamkyNUgxNlU2WEI1T3RFelZJcFdHTWFxNnFjZHArVFB5a2ZzN3hkQXZvYmUzV2k3b1JaV1VacjI5Y0gzN3JyTHdPckJUbUthVzlINFpWWGR6d3FFV3phZWczOXV1UVdINnVKL2JXbkg1NjFyZTFJWmlzOUVyRVZuNWx5Q2NkZGRKRlp3bFpMZVhuM1VNVE5LMWtkeU53Qmh1bWZrMEJnbVlVMVEyUVk2MWxGUzZpMU1TcEFXK3lYS3FudHcxdVFlamM1U1pMZFdwMU10cFJzSzd4a2pHYy9EUHUzdXBNdVo3clQ3QXNVcGpMOENRNmVNVm80dEVqWGNmV1piZ2N2cHJyY2pKU0tSRmpuc29oRFE4cEF1dlFESU1RbWpKQmNNcVg1eERCSUFuKzdtRmRYclFVbjhScEtPZ3ZyVzZiK2F6QmdKSkQ1bDZ4TG5IeVFLeHNYZWRDbWFucUhLNG5kVEwwTVpKTVJSL2lGc0RzNUZDcDRuUGVQdk9zMW85dkNBTy9KT2hyVVI2ZWNTZWRwRnZROEFRWGpFbU1tNGpvTHdVTDJQT0Y3bGZSeHIzM25rZnE1SHlURithNlNtUDhYZ2cvT0lpRStpSEQvSW5DcnhNWFVrNVRqalN1MU9zVWxVbXBMYUh3dHpIQ2h3YUZoTE85Zlo3TjMzY0pEa2RSNHk0WjZvT3ZDSVZSR1FUM3RWL0NvT1UrSUJZcy9DY2xCYW83VjcrckhhdTcvdWlkcW9RMENIN3FtSzRLRDJBM3E4WHREOXlSekxuM2xNT1hPaUs0RDg3NXRvSEJ4UFJKTXFXV28xWDl0VjRLNG45SVppZjJTMlNyVWRvM1Zrc1ROMk1tWGJLVSsrRU1WYWhXblhZYmVqSnVTWk5PV0llYThjdGVpTkU1YTgxVzNWcWw3cldjOHAzL0k5cHgwL3VEUm5JcDQ1L1pHT3RNRm9SY3RRZEtKck9OdXl6V2dNWStoc3lDRTdGN09ZT3grcldCbUxUV3lNeHo3MkxzWXhiaTdGdTBCVGlTN2FkUGp4Q1JOWG5Ka2tsT0J4a2tveW01UlNQRWwrZXp4TlVTWCtURm1WNWlCd3VmT1VtTW1BQ0FDTXpVMnQyQmJURHcrTTdOME1uUUhBdzVlUnBlVU4rdU1TQlh3QzJWb05BRFNaQmdBUXRBaGlFWU5tb0s5aUtjMGh4VWNIQU1KeEFZcXVGTkhwY2dBaG5IbDd4cUhpbWRxYVRHRm8yRzduV2o2OG9PY0lzRzBBSzU2TEJNQ2ZFZWIwSEFDQzRwdlRaRDRaQVJWbkNBRGhORUNnM2JnRkNOQnBDcGNTMXMvYXdTSGNhVFlPZjA0VHg2VEQ5U3RUWU91dGlkMUdlbkR4ZldWallpL3A2RkR6MUx1RkdyWkV6NHYyMkUzMlI1MGJtQkM2aGwvaGV6NXBsVkZYVWo4WVNkTEVEUEhKMFl6MTJCUmhwemlBQlNFb0loVjJYcXlscDJ1QTZYL2tXMDNHRGhXMFpNMUl0TUZ6dzlLRWJEeWhiZWthSGVIakIzRVlnRW9ob2d2MUlJWEdBOHdXVkJMaUtRbENCc2Nib3NsUFRaV0txVnc5cElzQkFFNEl2OGE1QllZWkFRWXN3QnFnbUdHQW5keGNNWkc0Uk1UM3BVOUlJNDhCRkIzVmxHVXViSk1Na1R4aVRJR2tpbWpZdndmaHNkbDZyRzJ5a2R5Umg1RGQxM0w3NGhmbW1yY01RZ3ZpaTJ0b2RLQTVoSmxoN1hoV0NTbkF2di9HVVVnSStZSzFYc0RYaUFVN21KdGxGMjd3TUxlNDRYalludWZnYkFYcll4TkE4L2IvdDFtY0QrYlZ4YUhxSFVFTUh3c2dIQUUrN25ELzR3bkV4c3A1TUtpcHZlNU9NUFhpdzlMSzJ6N1gxanZ6SUtqVVd0b0FVZ0lZbmtpbTBqRVdoeWNRU1dRQUFnQ2tjUGVQU0tPOHZ4M1R5dGhUaHh1UUIrMHdUdVlhRm9BRTNwRDFnM1JoWCszYXFUZHlLNyt6MzVlc2Rtc2tqL0pyYks0OWZPMGpiRHYvWDJmZFhFd3ZKanhRRUduQUFBV0ZBUVFGQXVUY3hDUXZNSWNXQ0VSMnFVeUNBY2ttaE0vaHdacUV1Z1JqNFFiZ2YvbU1rTEdsYXpScXhscmkyU1MwZ2t1dnBtTmQ2SDd6ZlJ4c0dSWmRHR0lMYTg2Sm9naVJid1NnQXNsZmlZMytDWEwxL29LS09Qb2V1Sm1CYUg0dys4REJsQjh4Y3ZIK2dFcDA5RFM0MUFCaGZpQzdjai9GdGNaT3VtTVhoTkZwNENZQXd2d2d0dHQyMGw1R1h2QjZaeUtqaVhhakFXRitBT3QySlgxakk5M2xPL0REMzBQQ01vU2FkOWpNcHV0N3hqWnoxWU1iZmdabXhEakV1Q2M3VVJ2dmFoc25MdUxZNGVQZ29oYkNmQytXVStvM0d6ODVRQldIbDgySUI4SHpZSndxZElyWU9LZVBqZzRQUW9PZ09abHA0ZXpFZEI2S0REZUMwTjVXZ2c3Q0tRZnZmOXNyQzM5V1F1MVZmeThwSUZQMUxyTi9BczJiMlUrQit2MmZnOG05empVeDBQVGc2OERtTXVBb0JwcGRkanR3T1F4c3J6RFEvSXB6NExNSjJLNWhvT1VIMjROSU9yQWR3a0FyRDdtQTRDL2d1ekhBOFAxYStYdWl6Z0gzeGtBTGgvNGxSRFhBZFhHbTFTR1F0Skx2ZmVYanhBeU5JV1RKN3p4bWd6V2gwQnZDekpBZDR3WUplWm5Ub20ydlBLTE9Ea0llaGJXYmppcndrR2ZHUTV5Rm1XN00rUXVOTWlDVFhRVVg5SnRqZk9kdmxwMmJIUkF5eElpVEpFZWVBc1hmcDJOcW5GbVRKMWEyUlp3eHY4ZTZwSEpFWHJubkdHcE8wWEtPbmt1TVhIUExJeWFFVkxRSDJkYjBIbG14RVFKRnRVUHhYaldvNVgrTW04ZTYzajR6Wis2OE9Xdjl0dGh1dmx1OTArNjJkNVlkZFpuTDJkRGxiK3JtYmZuV2JmdWUyUDY5c0JON2Y1L3UvQzd2cC8xMWhMYXlxVGRTYVo4VDB6OFhabUx1ejlPWm4rVkxidGFOZXQydTd3MmFUL09qMkhxWjFKQ2d0SkI0Q3hJaHdXNkZxalU2b3Nld1M2Wk1lMjdScWkraG1jMUNOTE0xNXFIRUxYYkJSWlZRZW5tVlZsTmpoenJScWZpd0JuczEyWWsySENCRkcxRUJBQ1JKa3FydUFySERMVlN0WElVUVJWVUw5cWVBVzdMaTFPaVYyeVZZL3dtRmRibzFqVzNkd1ZpNlVPM296V0REaFJsRHY2VEtVNjVPdXhQNlhUQlJRbDFlbGF0bU5haGs5ODJhcTdYRnhOWnVOZjN0UkJzT2tLb1dvaFRETFZUOWhpQW1Tc3MyNTF4ejE2eS9MUG5vUi9nc2oycDBZeFRyMFBJc0lHNXhwVmRRWlEwZHFxdkJ4cHZzWWM5NjFiczJCdERwTWl3YWhWU01pbVdoRklhZ1ZFRnpvMjJNditjbEtNZGVYMXRyeCtyclhOZTYzWFRQbW0rcHRlekZZL0wyVG9DV01EbWp1bk1MNjdZRTBBaXVTQWtBQUVpU0pFbXFtajl2aHR1cEhVT0lxbVpKUFB1UGdSbk80TUxSbksxalBwUnhHL1lFRDI4RWt6T2xReDMrS01jODNvbFBjZG96bmYwODV4Y0kzb1lxZEdFRWE5RGdpUUJ3RVlkMEZLQVNUSWloaFIxQnBGRkZIMHVjOGI2Z3JlQ3Z4aHFzNmRvdlkzMTM1MFp0MG1adDhaS1h1L0kxcm51am05L21qbmU3OS8wK21HaUs4V25mOXJNODZqR1BjNkhIdjlUTHUvS2puL0RVWnozL0phOTgzWnZmOFY3dm55akpwVHBKSk5PV2RIb3ppQkZNNEc0V2trZzJwZFRUeVRDenJIUElOYS84RkVRMjVGQ2EyaXB6VWVRbXRvTEZrMEE1S2hWVmZDbGxsbGR4RmRYV1ZIczk5V3VFWWx2VnVqYXl0V24yZElDNWpuTzZDMXhwcHNYVzJ1NmcwNjY2NzZYUGZnOG9WZjFveENDbXYwRi9HZC9zVEZTU2twWGlrTU9OUE1hNEUwMCt6WXl6elQzZmhmMGUvZGUyMTdMVU1zdHBhUGxOYlU2TFN5eXp3aXByYkU4TE50bGlteDEyMldPZi9YNklybzFDdFgvcm03N3QwNTc1MFowZjhYR2YramxmL01SblB2K2xUeDVOZkhjYTdWZnRES29iaUhPb0U4WUdWSmN3TnBPVUFBQWdTWklrcVM2TGxEQTBBeGllUVhVNURTSFhDWURHS1FFQUFDUkpraVRWWGNGbEFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCQWtpUkpraVJKa2lSSmtpUkpraVJKa2lSRkNRQUFBSklrU1pJUzdrNXNiamtQajBxZ3BiMm9PeHp6Qk5DTURRQUFJRW1TSkNtWUVHY1p3MWZCYUQ0RUJJRzB6WG1wVlQ2NVhIaWdJMG1ETmQvbjU2WUU5cjJhNE5pVWg4NmxYMWNpNUtoZnRxU1JCUUtMdlFocFc4K0VpWTVtVVB5QnVtWnpKQnM0aTlwWmNnTVVubmp1QXZ6c2lYRUQ1R1lFaWp6eENPVEVQanRMSUVLYUt1MW9SdFZXNUpqQzBxUkpLMlNZM2M1V2UzRzBZZ3pOVmpHQVppTTRYd0tZVFo5OFRGeGtpMDJMV3ZjbVJ0ajZvOHNpSWJORmYrSkpMMUN1VmpOMzNLWGZPWmRTbjdUVCtKTDNtT1RUVXMvVTBDZG9nbVp1K1lvMjZ5Z3BtM3IwNVNiRkpWUWFtbHBNUG9KcWxPQk43NGZtL21xaHVRK0dCYjNLMlJmSDNCZk9hKzd3YXJuaFlWM3JzM1lTSGhIMjl5TUlOdDgxNjhZd3VYK2NsVlZPQkRoUW5WYWRlZ3k2NEpyYnBqMHpiOG1hTHdIU3ovSW9Sek1HSWNjNjFOenlMU2h1L0FSbFZWaGxkYlhXV1UrRFhYZ0N1TG0rREFpaXVNUnFmWE43ZHlDU3lCUXFqYTRFaGtCaHNHTU1BZ0o0QUN4K08yYm1DMWpXMnJrZFRuNFJESWZIY2txUlZBbjJpZUtaa2JnN01YVm1GYzlKd3BRK0pkdVZxbFk2VHhsQnNwTDBKMmZBaWVTMU9aYUNMczlVUEtWU3A4cXRxc1NwU2tsTm5uZXFUN25wa2hxamJ1NVg4NVJhUFdwM3F0T3Vick42alVmaVUvcXk0NnlWNXhsb0xHbzlyTGJGY3V3MU1OdFcrUVdzbmJtL1RmTTVHcjI2WXJ0cE5YMk85MWZIb2ZHRUFDMlNzdUpKWXFITjkrNDNvUDVTT1BPRGdQckxOTHRNUjRzSDlZMlQwemhYWXpmMDQvUVNOY1hBMzVJdXFDWXZ1NFFnREo2OE1aMitXZkJua2c0S3FsMUNjWVZMMDJiTWN4by9tOHYrQ3paem1jOEdJY1VnVzdJMTIySVlveGlISEpPWWhsOHMyVmVDUTMrbnNoM1EzNm50QXhVUnVrdko4Y0pMVE5VdEViKzB6WHVRQ00yZEhqR1VSQ2xnUU41UlpZUkRONFJBYk9xRmFNMXR3UGNFTklubmNyUVJoSEM3dFRWQjlhQkhWdzlDMmlzNkx5TG5FSHBXQXdneWNDYUtBM2NzY1JpZ0k0dk9IQjJnd0tFTEFWNXpnYXB4RTB4Tm1tUm55aFI3S0JRbW00TnNtZnEyUU9DSkVTOHF4UHV2MHNoanNHU0pNYlh1VWVUR2V0MVozUERPVTVReDJjTE93a1FvYTVUTTdjTVZsQXpGMG1PaVExUVNTOXZQS1VtWEF5bGg1OXdpVXJTdFloUkRXYTlucEVBclkrMDZNZDFvQ3N2Tkg1N3RnNC84L1BTTGZ3aVpGaGp0YU50SjlJcWg0eVZ4TUZEQWVlZEUzUGNIMU5vSmtoa2ZTcVJ5NFkwOCsvNDhNUEJ4VDhGU2daekJJcmM5Z2JoOC9obFcwa3pSNUU2T2tPUzlld2lRMXV1U2FOd25nL3hyRmFnMVNOWGE2RDJuamdzdG1ZdUZkNVBjM0dyRkVzUDdmdGg5cVd1UEFTVWdrKzVxd3lnTVk0cTBZblFDcHBXM2dvblBJcVlmNnI0SEhucGttdENNeDJZOThkUWZpVWRZbXdvZVQ5MHc0MkU4U1phczBqMm5Mc1d4NU5mRHAzS0lIaHlMb3dpSFQ1VVFwMUM3MC8zZG1VS1VndlNpZ3c4UVJMTC9yTXloeXBWUEZINXpKY3p0V3NrRk13YlFIdEVQWFJINFJPL0lybm1qY0d2a0lTOFA5eDVGeU0wdmh1dWlNK0QyVzBnQ09YVktYQ1YyL2QrUU5VUDhmMWdKQk5pSXdvZ0QxaUxQc3ZSOVVvQ05LekRpb0dXQ0NHdUkvdHc1YmFJYXNOcWo3TU0yalQrbFdPdnpzOHJqa2Rnc3I2YkkyOEovRTJCelBKUmhLYThlaHlTMlVLRUtSeFU4QVVsc3FVeDJ5bE9aYnF0UmVIWmhLbDgxcXExenI5TFZPRFdndHNHcnVEVkJMYXR0TWRUaHFhODlTUjJ5Mms1Wkd4QStzZTJWeERIYlFVa0N0UjJWSkxIYVNZVUdFUnE2Q0x5aEJKeDJWbllmZzBMZVNoRDR2UXgyZ1ZDRFF5UkJpZ3haR3FYbGhDYk1iWGZNKzhjcmkxNTdZOFdxLy9NcDY5bkk1M3doN1pTaGtGeFdNdmp1VlZEOVozL0dnUTEvT3NuNkU3V3RVWXFvRUFLTVNrV3NiTTVSS0diWXVUOE53aGFDaG8yeHEwWmpqaUtVQmlGak54K3hhRmJOVVpyV1VON1hCTmc5RHNVd2c5QUhVZ1VEMEJoN01JUlNDSU9ueHRqVFFDR0V3ZEFZZTNFTTNlZkpwUkhxcjJzRzdKMGxVMldockxwOHhDNHJVY0tVaG0rRVkxaG5pUnFtbG5wamhGbWlNSFV5YkJNUDd6TEgvRFdVOTlVT05vMlN5WktnS3BOTHYxa2NodEFKWWZBVS9jME5GQ3dzWmx0b1g4U1ZyYTVMdldXa2hFKzZtenB1THNHQnRuMzNBSGh1YTFHK2JYSTYvcllpVktEQTNnbzJCaTRId0hIL0dBTjBndjgvK2VuL05BaW1QdGQ3a0ZjQVBRVEFtRGpRQVJYWUFPaUFuOEpBZ0ExZ0VJR2Z3cm9HYkVFVGxqZ3dwOER2WnNSdkxzM1VQSis1SDZHNThmanNzUjFmYmdDTGp6VllUZXhrOUgrZkIrWm82b3hKMkhQUjgvV0I1dkx4MXVjZlhYMnJydWNkYWNQMXEvQlAveDBUbnhoRS96Wm0rOXZXSjk1WnkrRkRnRDRMY3pMYmVnUXg1eEFLak9GbXFQQXFMSkh6Zk5tMmhTK0FIUGYweHdOZkJ1V1R6L29wNEt1Z2ZFWDBkVi81a2VnYnZ2S1RGcjRKeHA1K0JzQzN3SGo1MDI4TS9BQ010eVpuaS83b0cxOHBadEUzZnIrWVNkMmltUFY5aTQrSjJkQzMrSVNZalgyVGxXSTI5MDFHWXJidy9mOWQ3YmtZeU5LL0FlUnhRTjBBbEhmQlpCZXcwNWNCMkFIZ0FuZW9HSStKeTlqNXdIZzJkVlkxL2tFZnN3M2FuRjNqdUhnOEh6b0ZMcUZoanJxTlFHYTlTcDdPcWk0TDl6ZnVuc3ZsT0pPNmVRNHRRbEhQK1BPQXJWckNMSFU4SHdYcEgyLzVxckJXOEhrNytmQjNkamFsRmdMQlR3MXlJYXBVOXB3enZ3aEFRWm5YallldTR2cFQvRkRMdmFwandKcUZEbTllekRNQm5lUTZNajVPcjRBclBPUlVLbXE5b2hBeHFTRGNudDNhWjNSMzEyRkh4QTJsSWdQc1Z2K3JNWkMzcFB4ZW1Fb2FOSHR3NzJ0K3NkR0c2bTR3QTE3ajlIYjZucmJuV01IQ2d1YzEvTlQrNCt1MjJxQWI5QWRmbDFETDkxZmFnYjhpaC9HNDhwd1QraWdHaG5EMWdiMm90MXB6RGxqWFlQR0c3cFlZL0NLa1UwUW5welFmOENYb0NJVmV4b3lMMmFXb3pZNHZRdEpjTXgwOFBJSmFIQ1B6dzhuMzE4RFh3eGl2N1FTQ2ZGWG9YK1MzUGVIT1lpSjU4UHg0RzJzTFpVSklXZ29KYVduREt6UmhHZ2ZzWlZnSkpTcVByVnNQdE5sV3VzSkhhOHEzRnY0UjBEZEpoTXUxazNrcHBuM01XYzRyT2lEZENLcDJZTndLMzk1Q0xkeFVESFQycVlZMFRRaXQ1U0JMVmc5MHVycHdLQldrN0F4RTkxYU1oRkJWOFFRc01ham1hOGphVzNTMzEzaGZGVmZhMWFWQjAwZElRT1dRNFdZZlB4MVNFamY4SVpKTFNJcTg1Q3VSeXdrL2ZpdHZWQjZhM3JSOWw1MTBjc1o0SnRPa0lGdXhXS0F1Z1QzeWc3dG5pbVZFTVZuUkpDTDFRQkZTMzU2SzViSFRyalZxeWF2RTVwYk95bGtyd2xHL3JHVDBxcEJiNmpDTWE3YWZ5MGNPNGhLZ1ZGZ1hQbE1JU3ppZ2RGcUpDa3BZek03QVozSDJPSDQ2ZnA3S0lYM09PVlpZek5sV0ZqUGtRaWJDZnUycnVSc3VUZGt4dnFpRTdPQ0lIbHY3T2IzNUR6dEkvbmtadm1kVWxibDM1N1c4WStiZFE3SXV2cWRnMU8yVGNXaXM5dGNERVZrZCtwditDVmU2aWpqZkUrbHNoV1ViZlpnL3pYWDlGTXZRd1kweXVhSm1rby9kRXNmWEpoK0tvcXZDT3c2ekpzOGNwTUpTSmJKTjYrNld3RE0xWTA3dENXdFpKV0poSUlNd2hNQTVWcFFTTW1PWm10bUVLMHdURFdXdDVGb01sMUZZb2o5dUhTT3JoZ0J5cEd0OTJvRnJpNmdLUW5tc1ZzQ3JON25yZENMeCt5c2swc000S2tmanRZbGFHQzJyQW9sUUk3akJJYlBUbEtGZzdMZzlaL2F3WW0zRkZpdnlsanM4emt1a2xDeDZYSkR0UU5hNzVnVVh3d3RVMjhMVm9hUytvcVVTcUloTnpyVm1kRXJaenF0cXlxUFMyY1pibHFYRG85VmpsNTJUY01xeGJ0ZEo0ZVI0NXA3QjAyNHl3WnpyLzcrTGh4cHY4Qm1KTEkyeTV5UUg4ZURhN0sxcUo3eThXckpTV3BMS3VLa3laQjFmYld0OG1VRGhmWFpMTERyeWx3ZGh5YW9TWEIycEJWdGQ2ald2bXhBc0dVcFBTRWxXaVJ4MHJGb2p3WUdLS2FXeUhjZzBqZFZqajBTeFdraGN5alprcFVFMjhKNU9vOWZzWjl0VWNSZ0ZIUTdjTnM0OFBKMVlGeEt6bmVCYjJ5enlHRUpOZWtCaUFObmo0RUhzNWxueFZkT0NsUmY0S3BIK1Flb3ltVldyMUNSdUV5V0JzYTY0b003eTJGN29qS0t0d0dramlUaVJZVTJhVVVvTmVRa1hlR3pyNXFOVWlrd0Q0U2R4ZWQwK0FkWWNDYkpNb3BVaFNjZG4wczVTVmF4QStzVFZNNlgzZ3BuTTV1QUVJZHlWZStRMXhhR2ZseE5YQ3JTMFJLMU53Uko1OEVJWHVURVhsSjR1bzludE9iSWwyNndhV1NnUFltekdBVHhrWkFZR1p6SlZLU3VkTzFjb3pYZ2tKbXBuVjQ1cFcwNzNXTzJLcVpwNTBoZklIYmNIczhEcGN3QXlVY0NCMDg1SkJ4Vkw1S25ZcFFGRlhWaUpCNnEvUVhUVWtiRzEvZk5CL2VPVmc4akx3cWR1bnR6QUVqeUpxcFMxWU1TZkNDbGpLUy8rTnNjWm1id1RodUNHeDYrZUx4blRSZXp1Snd4NWRjTlJwVDVIRjJPZU0vd2k4WW9HQ3pmMnE1bDk3Q0FqUmprQW5UZnhGUnVSUGNYRDBRelVrRTFDWWY1T0pBai9WRnBjQXB3cXJObjZMbWFFTXlVaFNLQnFaUjl4N1Z5T1R6MTVBcXJaZFR6cG01OCswVmF0UjI3UkF2VTlwSVpqbXBjWFRmakZzc1VOUGhxaWw1bWpFUk8xdlN2SG9hT0Q4bmtEaXVCNmdiemlQdmZ5VjZHcDFKSjBBU2J6WVFZVGtUT2ZldHlxOXV4bm54WHdkWjczeU82WWt6NXo1bDI4b3hPTklLZlIrUnZ5T0s5LzdtWHgwejZoZmlJVndoWjdCcE8vLzNCeVlaQ0J2T3hNTEZwMEtVcXlQcUZ3bGNPK2Fra0hxWEI4NVdYUldSZHhUcDF6cVJqTzZTeGpqWTV3UDFiSDhDQmlvMGFGdEV1MkwwbDBKalptVjVYaEJleGdGODVDQUVsQkg0cW02YTdJa0ExOEhJUUNBT293RHZVdE1xTlVkbVF4dU5mbEpFRHVHSmgxaWNYQ2pOZ3NobjZxc0hHeHhaSnMvVi9sa0tWSGt0WEFaSEl5bjVGaldKRWZsMWdVZ0pvYWZxZjNFVVhNOFlGZjhuS3p2VldJV2hwQ1lTcGQ0WnZ6RkswVlNKMWxCRWtoUTlNZVkxT0sraWpYOGFXWHRhZW8wSFJWU1htMWxNaVhEdFdPQUFrS3BDTmRpUW9saXIxWWVaSTk2YlA4WENXcDhvNk5wZmdFL09Ndno3em96Y2Q1R3FvTTdaL0ZpT1VyNDZUTnFyVm1Velg5eHpxcnBma1pQTEhVK29lc29WMW01Y3dWdHA1QzA1SjU5VHgxazFud0t3WUtXODd5am4wdWNVTExNMTNRUmFrd0JVb0hJeTR3SjhndzFvYmxaTWNhUHRYUkFObllGN0FjNDBSdFI0c3p3dzY1SFdUbzRKbkNYck9mdmZYUXRFWElnYUJ4WEdwOHRTaVhXY2tRdUdLeFVYU0ZTTW5USGxWb253K1g5YjZtWFMyRDZCQ1ZKa0RrWm5FSGV6REV5YzlYcm5iQXNZSElVYTJLWjFBd0xjaUlUODdCWEUzemtDZFN6YUV5WlhDc29qNnJzTng0MVBwcklxL2JKbytLR1BORUJNbWs2WTZLcHk3RDJWZ0NtVVhycDhsTWZRclJpZ1ozd1ZRSmlSWVFwUnFNT1RFWnF4RnNkeFlueXpoUmpnQUN3aG1MMlZybWFvbExFZlRhK3ZYR2pSdUZUNmcwVFphZnV6dGxNemdieDR3ZHVhb3pkUDJDQ0hiMm43ZVhkVEF5aTNha29rYWhHQnZoK1VFelQ4dS96OEZBOVY4ZkVxdW9Da3VjaUJGSU0xdlVqc3h1Y3JZTC9HcjlQOFdQZDU3Um1ScGIwTThhL2tYRlpwSkNLOGE0Ump1RFd0cVZoU3ZxeTBTSFJSNzc4TWMzK2ZVcmk4dnNTakJiREIvb2lpdWpvZkk3SFdYaEV5VmsyMXRzQjdSQlBCYkhQdE9CNnUrK2JLeWlJRk9lSXhiTzlRaXRVQnROdGdQVlgvYU9WYVJuZ3ExY2VlTG1xbzRoemVWYlFpQk1pMFZTMkhIdXViZFY0SFRjUndKN0FrQ25XeUNGRDZUWmMrNnR4dHRtTXJhamlkNGViUmhiU1Vnem1XWkpWc2dzZVNHWE8wSnRPVG9Wc0wxRkJPemFId0VXN1FGbXl6N1VuaWhzUDFFdTVOVWNjV2ptV3BJanA3WnJjenR2SmZVS05yUmoyb0VKVmVyS3REV3hKVzdaVkQ1WVlrQ2xGemt3RndLenJKNWtjMW1wTFhBOEpUejNJNjJWRi9rcEo5RU1YU1lqSnY5WVF2RWZiT0pKZlE1NmxGbFlyVi91V05jMlppQjk0V2RVNVhEYjFDa3JyakpvMXhZT1hkWk5pQWVxSDNscFloVmhvZEVqcWR3WGtldGFmUWFMRnFvSkxPSGNBSUJoWlhaMk0vamZXb1hMTk16RFJsQnpIZS94QmxISmRXUC9aZFphQnZZaDE5aTVTMXZZUUUyY083dWc4YzVIUWFtZEFhYmNSWXgzcUoyMGIyc0ZLKzJxVmpEZGdLR0MvTEVYNEJDWDhhUjczWndGWmJKaXVmMVRXeGxLMy9rb2lNTVpZQWFkWXh4SXRyVzAyYnp4eXZIOWZrVG81U01raTA2RllwdkhBU29vaU9aS0orNTVnZFl0OGZCV29LYk9EL1JhMEthbXhac1FUcUJUSmJ1ZER2NGRZeWswbmVuYk5XUHRqMGdKWU9NNjNkUStkaklzMVQxb3puSVhIWTdrbDViT1NiQXJ0VytVb3RWd0NzU1RBSi9VaFpXU0ZHT09Nc0l6dG5DZldjQXlDQ3ZTNDNPTGhMbURITG1Eck1ZV2pCZHpGTWlHYkVwVTdzYndlZ054LzdEcFhqdDRuWG1uZjhyalp0a1VxY0tzZ0ExWElIMXQ2REVRZUJ5SkJDY2ZaTTIwWmtMV016elRDNE52WStIZEI1aHVNYVNHNnNnMElKYmFKa1ZyYWhMY25RQjRpVk1SVGNTSUJvOC80WmcwV1N2Y09OSHBlSXR3dlBWNVh1QlRQd3NGcFovWEthQnY1Q2dQTWRyL3dORWxYYkFNNXdXRERmckhQY0UxRVg1NFVjbFRKN08yb0xPeXVSOGNzVGUzek9GMHpaV2xRdlBqY3VMUWFON3VoNFBJTUJOeURSQmFZb2tnbXNEdUNjWFJzSTVNQmk1QUI2VURvQ2hZck1OQjRQRnJMRWc2ZUNJZXhqWG9SbmxLb25WdkloQ25ZaTYyN3E0Qlo0TzBZOGs3ZHhQWnZ1QlRpengzMy84bkN0cG5vUnJHSmNjMjFRTG5RSnZDcFpIZmU5am9HbW1VL2lRcWF1TVhwNFY3clM4YS9NK0pENDBPSzBzSGZlWk9tVTE5S3Z2VTZVR1VaMlEweEl3VktGaEUzc3o2Vi9YRERqMEV4OEFNc3prOG9Bc0YzU2wrK3FnQmhGbmlvL1pOdks4c1ZRSys2MXA0TUYwZTcrZFAvL0NBSjN6Z1NZa2R3UEhQNGpOdXBTZG5jdXZFOFFXN3RzdWkydnozYVorQllLTS9RclB4ZEVpbGNPUVdjdFFnaFE5azRseW1jS284QjFxM1RuRU9oL0lUSHRRcUwxZDJxL2JsdTJURnAxcFdSL1c2emRKRCtkeDRQSERJRi8xWWVPUkdIWmRRQVRuSitRdDZ1d2VybjI1NzIxdzRGNDViaVptc1ltOXN6M0Zyb3MrZXQ2TjJQT05aMzFrelNVZDdvbDJ4ckRrZ2RvMmN4VloxdUJrT2UvZ2tabXhOR3JLejRtcldzendNanN0WXg4eUZvR0FXZVM4Y2FzczBEYWQ0VnlaU0dzenFWT2E1dzZab3BDVTFBZGloSEZ0dHZjak5OYnNiL0MvWVd3T3ZUQTArRkNhR0tFcXg0WXVnZHZnQ2M5NlNCOUkrK0xrbURrQ0c0dXN2dzdaVS82Ym1uYXI2R0lVTFBWYnFYdXFKbjBBeFJZa0I3QkEvMG1JR2pOWEtDb3MzaWRNUkhhaU1RQVg1TGh1TDlCdG5JYUU3OVJ2eGxFL1RxRlNramZycGFJd2tMVUVEUmxFWlNUcXFvMmhNZjNOc0lLRkFBUUlJVGtBSExRWndFZ093KzYyaVRFR1cxbFFsN3haVVp6SFBHREhsb2pTdDN6QWFVNGtsYU1BMEtsTnBHTDFwQ0tMQmtZeFk0a2crWHMzM3BKWkJsRTVWRTNuaWxYREY2UEpIdkFLdkhOdHpvOS9IZlF1TnBIcGN6QnNUNnpRYVFYTm4zdGNvUlBBNytVOFhaa2t2V0MvRzZ5bFEyRy9zbnpyVDJSSGpNVnRKNHlPYlpEajI3STg1cC9FWU5Mc05nSm9qTmx6WHVuYzh5OFAxTFVkaEZpWmRKYTh0emJqaHkxaU9VMjdxY201aTcrZk9ObzNabFhLZWN1czY1VFp4eXExbjNVNWpPOXpVaGo3czM1T1BwOVBqNXdHK2Z3WExKOUI0TFVSbVpZa2daWEwxRnQxNDBlQUdESGs2M0JneDBjQUExeGdleUZzSUxWNWErT00rR0xRVDZMQ1JiKzBGOTBsTDk0elVKM1F3bG83VTJQWGROMVMvcDBjb2lmYnMwR0gzTlczd0dFTjYvcE1YMjhBK004RUZKU1R1a2tFTDZkTE5YRENIODJJZi9wQkhlay9ES2FIaTEvZm9xSkhFM2lZZE5MNzNrZUhLVXhpRXkvamxaUm5veG95eXBVTjJnWk9ZdjJlZ1dqY0RvWHBJK2ZyWlFRTFlGaW41UUUzLzVkYURaeTVEalEvc0hiaGl5cExHajE5NWg2UzFIT3kvQlB0STlZRkw3VzE5bDdDUmYxTnh3aXZ3TkhlamZjUXRXQTZVeXVJK0V1WnNSM3RMUCtNYlN0N3pwMmZiVVN6WjR0NFNGbmN2Y3o5d1ZsaVFmSGMycTN5Z0lyaG0rUGlKZi80YzdaKzkyM2puWm0wQVpWMkZrbEdENkpRUC93M09PeU1QWmhQTlZXektNZ05EV1JuOHNPajhTMTZtOGZSZ010TnRlczNieDNhYjBVN2VWWVNySEJXOUFvUFV1bFk4bUdocXZjRm9JMUMyWDNGK3I0enlmNGU1cDMvbS9zeHhOTkVzZkVPMkpPR2hITW5DTWFWVndNSzNzQWhYVklRdGNsZHlJZHk3SitJamR6MWQ3dzZxRk5xdkdDL3VMUjZuZ2JMQWpQYjNSczhHa0dYZFluamdDb3lZYURjR1Q1cUVsMDVtS0duZ1A0czEvNldFYTVvcVFHMkRCSWluTkpnN0hvQTRTSEpvUFlURk4rSGgrNWNtTExZSkM1L2hPNUFWaElBVDJuV0xjcDRvQ1pZZ2UwRm1PU1V4cE5JdmZFOXFWRXh1RHNSdWd6OTFzTzlXZGRadkZCLy84ZmY5UDJmRlVoRTRJcmR1dDQ2WmNNRDQ3bzJLVGFoS2dpRFkyWmlTdi9mZnZRbmxDUkFBZmhuOHNJanlHSlJ0aE9UdnUvMHBzV1Z4MHhvTVEwNTdUNEdpMkZINS92TlFBMWRvR3hDTyswSmFlRno5YU96SEdONFFqL3VlSlY0Ukx3NnRjcTMvQy9iZVJndE1zUDVsOFdISisrcVg2ZzRJd0RuTFlwT1NDVFpTWmoreWw1UXVtdG5oeXIwcktnK3o4TXBjQzBia3ducU0yaE9TamxPL2QwQTZvMWZ4dWRabnhVdVdNbDRaUWY3N1c3L0NITkVrL0xZZ2J3b3JCZE93WUtIejVYTmlYVE1rUTlMKzVtZjFyWkNZVk5jQ282VEdLZUlqUkFGSE9uRWZiTmJrTnhqdllSU3F4aDVXS1JKM0t6V2RoMnpvTTFpWTFGK0FQc2hwUEpldVJLeFFISHNJVlRBNlJKaXYzaDNHcmMxUFNLekpDdy83cWhXYW5Sd1VtSlY0SlRNeE1DZ3pHYmE0dkFuck1XcExTRHJtOU8wd1pMcWVVbnFoOVZuaHFxV01iL3FPZ0xxV2IvQTNrUngrSnpsdkNwV0VSMDFWeTc5S1QyNGsxalVqTDJvYW56VzJJSC9VdFFENW0xdE10TENCSi9EMkt4b2JLYWtDNDFHYmpSVVk1YTRFNXg4REZibWhQNklnWWFxUTRObzhaZ1ZERVM2VUNmQW9tbDBWU0V3Ly9TcUVzaXZLb1VvbEZzSFBqVDNJN0VnYWt4ZnM0Um5QUlRsYjBKcnl5Y2M3SzE5S1BiMlVrM282Z2JyRHdqTVRlTW9sUW9Qem55cDk2TXowenhXNERMcUxvNWMvbUQvWnRXZnBUVDd0ZXBYeDg2aWVYbTRxN2k4cHRUNVJGZHF0d0d6OE9kRVBNckNlemJpeE83ZmF6WU9ZTHZQQXlaVElXcGhDVDVMYTRIQ1oyNU84bXY3UWF3WUp0ZTljZTRyU3oxcS9LSUNnck1USXRBVkR1cHJyakt1Qmt1MjV1dUtrUnFRVnF1TEtTak5MRDBDK2d5clBPaUNLRE1Vc1RUMWhzNmFDa0pYa3ArTHpLZWVjbVRnVUFVN292L2J6MFprOUIwNW1xVXFWNGE1UEhya2d2dkRKQ1pEQzNJakFrTkowQWVISmNtUitkQ0E3TFR4bURYWTYzM2FVeWU2cktSNTQ4THZ4bnZzLyt2ZWNLVlhJb0lCNFRNVEZqc2IvQXZZMi80eTVjSld2eFl2VkhyLzZnOWNvRXI0WjZxVUJKMVJnRmUvZEZWSlNzMFhpOXRNbmI5WS9QWG45NUE3bVRiekRERVhtWS9NalI3SGJOK1lMVEdka0tEWTBCbHdlcjIyS1BacWUxZi9vZDhPZEQyRGswT2hSZEM5MUpmbFNmZGk3M282VmdCcEswYUhRb1RpZGk5ZCs4US84Q0ZmU2VKbTMzNDVYeUxNTjJiWXhoVEdnZHJPU3kvUWlnbUcwMEVvU25pcitycC8wV1piRXV2VWsya0JnWklSZllIQXl4T1U2eVRwNXBmM1orbTNhLzF0bHQwUzJYK29PT2Q0SGU3QkFVQkNXcVJ4ZmtsRVpXU29WSjJoeVIwSlpibUphV1dkSy9JRXArSzhqeUpBMktPa1Y2MFZ6WGhRTXpIb2tlaURrK0NGZW5QYjQxVis4eHFaZk1SZXZ4bW9QandDN21GdE5qWml1bmNqakt6UDNmdlFQM1AweGMvZm5RRCtlWDlhZVg5VVZYaTFveXY0VVhmajdhVWxWZVZwcVpXblpFd2c1OW5ZaXh5UTVjcFpJeW14STIxNWZGSzArQzlQd1pyR2tmUWxGNzkvQ1hMZ2xNN2c2djZ2aTVsc3JuaFZZMnRHQ1ZhVGVTRXM4bGZqcnRlUVRzRzNVSXdTV2hML0tEMmFDZXg0blNhVnNjM3Qxb1I2WXZwZVNkL2lHV3pIQkp4eE8yNU81UHdwWXdNajJLOUk0YXREZTNUNXYyMy85OHRuNEMzb0xzSTBQTWJjd3R4OWFQUVNuSnFIZHJVL3NyWXBLN0MzcnQrejZpcnFPUzU4OFhnVEs2MExGMG5nSnhjYjRFRTBGWWJPbW5oQ0VxaWVGUVZKUlJIRVpMRkZmK3BPRWhGUzZSTkQ4UEpqSjNIZ29KalB5RUZTYmhOdStpUnQraTd6NTc2T2xPUEozY1pNYUsxeTYvUytnQjl4d3YwSkpmUHhjcmY4bnBHeWtJT1dpVWFuY1cwejZ1RDlEeTFoNDVnd2lKcFIvNVFBWEliY0VTSmRTd3pBb0JxUW5xMkVnUzJULy93anJiR3hTOU0yMGFQbnFrUGpsSVJEK04vTWZiUDYwOHBLcDBjYUVNZm11KzZlUHVobW1NTjJUemRKVUdMaVRKOTNGeE9SNlpYRXUva3dmWDU3TDEwMkttdTAvQjI5eHU3YVhCWGsyY2orUURoSzJzazZFYkhvU1haSVJsQmszcURpcW5FM1pRWU1pd0FrdHlVUWNtY3FrSk9vNmh4eDF5OXZyK3JLbXl1VkY5cjRUSHR6Y2d5bDZiTWtSNUtaUjNraVNJR2UwdVRGbmFCN1NGSDZSN0RGWWZZY2Z6NlhlaWw3WEZlZkVSZmtsRmZZZjZpZ2NUR0lsaElzSDZoSW54UDREUlJudUNZL3NmUzR2cW1wY1grYnZQZW9XNHB5bzQrNUlwdUtJWkF2QUNVMUhKUFRZQjFPVTE1UHlSb3h5K3Vlemh4cWJjMFloU3dFeE1DZGlTWlFOd1NYWDJpcmY1M3Y5ditSWDFHVjRDMmhKR3JLYWg4UXVUSTQrZ2NpQ3dydGxKV0JJRDNuN010MHkvY2piSTZ6Qk94ZE9aSWR2c2xqYWJFcUx0L2VBMUxFL0NYM3FWUm9rMXhSWGJrSWVMK21CaExaWFIwd2U5eGd0dDlobHByTGFkUzZ2K3BoYmlIT1NMcE5DcHVMRUxwbnpwN2YrdFRZc3lEblIySlJ6Wmo1N3NPRkExa2tZTEN1M0FKelEwRWFDRk5XYmxEODQ4dzlNM0xLc0F4NC9OU3c4SXh2eVFpeENjSnlWNnZCZHhlRzdxaU9DcVU0Z01obGkwWmpRTFMzOCtJSGd2dUlrc2I0NTVrem1BVTVvb1M0VDNSMTFaR0VrSzU1ODNTODBFdFRhZkVSeTVVTmVpUDVOQ1ozSVk4bUMxR09wcWx3eGJlNUlhazdIdFRzajd5MkdkNGFGZVhGQ1k0Tk9HWTZ4ZzdsZVBqeEJjQWQxbUQ1SEw2SmZrRHM0L2FvakZuN1JjV2toWVdrVnJVRHhpNEVkRm1kZy8rTW4vQWpIWVhVOGtyUEhqYkl2SnFmbVhEVEtHWWZjWTRBSGswdVNDbkJJWWdCRXhRWVo3azdITFFPSXdsdXRYQkVmVFBLU3FmR2tWUC9NSkNkQlhzajJHK0tib21zVHdpekc1YmdlTWVWRnZDeHdlcnhaVGVZQzE5M0xQY0lCQ0U0V0h0SjM5WTlwSG1tRUxEaXVlTy81SE9HOHdsR3lsSVF6bjhIeGpYSkVnRldyZm8xMFRMT3pBL0toQTduNFRMZytBTnNYUTk3T2JITHdNVk5USWIvMlVRbEUrL0MzamtPblM5dmJObkZMY1RBdm1pdXlETmw2VDB3dmFpZzk5OVREVjNDZFAzNFIvTlNnSFhucGJyTWh5bEVob1hEZVhTVkxOb3RMcG0yR0lEbHNpTTJaRmVMSWl2bTV0NktuM2xyTGZncHh1M3BGa2xtZ2xJN3JmcG13ak9KczZHRmsvNkxvV1JGVi9GbHhOQVRiWTludW0xM2UrS2huYkZaM04xS1J6MmRJcHBtTFN4NHdkd1UxM1NjeFcyRDNtUFlKZ3ZUbnNqdElJMEhoTTVpazBPbDhmS0tDdDY2cnd6YU95bTdQbzZsUjRibkt1VkhocVVjOVZYWnY0N2c2ZU9za0tzVGdYZjdONVlRS25oZ3F1RnJTWTgwOHBEWjVTTVdhV2Jnb3Vobk9DamlodWFDbE5BU2k5WG9nV2cvbytxcExETHc2blk0ZXl3MFR6SVlsRjlWdjJzUlc4TTBzNlFvUHQ4VEJldnpkVTMrM01IS3R2RncyaVM0b1cxSTVpTjhLL203ZmZLTnJucTJYODNZamJTdEhOdUlQSzFsMFpGYU9XQ3BrMkR1TkREZjh2VzhiamZYOHJmQjd6djBEWXZsU29idWk2NHJNMGdKaFdGZVU1aFpTVjUyaHBWaXJLenI4K3MwMW1lN3lFNlZlcW9Fbjl4UUZkc05kVzJ5WXR3eW1EZGZaODZWVDVCVzJLdnZ1YkZUVi9NOVZrU3Q2SW1oQUdNdmJmUWNYZGhGZXVYNmhZUGRqTXV3WkRVQmVrMzk4YkU5cGFYVnRaVVhNNGNrSGdxUDE5Y05wUE5EUWtYYnJUa2RHWStPKzJwYW01Q1AzSjNpSGFxdlJjWmRYSEN0K2ZHbnd5eTg0RDJPZmZ3eU5OZ2tZZy9ONW55Sk8rTmFteVhIMm1KNGJKU1dRaVA5MnErME9vdzRKOS9Gdjd0UHc5SWpDT1FXWmdLVVJoUkZ3bk9WS2kzcTd1Vk5ZNXFiR0hFK09RdUhYRkxtWHRpUzMvZm5kMnJtSm5UMGZibHk2Ky8zNVdWbVhjSGNPWmpySXpGUXQvNVBjWmNYOHIwbXlDM2gyUXJTekxKcVREUWZnMFBMOTg1ZVhueFAvUjRpZWhaWWZFOE1aeGw2aW5vVldIK09OM0xhRE1tZWpZRWRBRHB1NUlOQ2Y0aEFWc0hXYXdMWk9hVHI4d1lQdzZVUFo2Zy91cTJVZkVuSzV5ejEybjd0UWFmcEQzWWVhdld2NzYybytoRm4yeDAzNDFkVDRUY1RYVGs0VExwS3o5djVVMDl4bDZacG5YVnk2SXlkemQ0KzV6WEFjZHpwM1BaUGU5OGZGeGxPZ1h5TGl5UzdOTHN2aEN3WXpCL2ltaFZuT1RCUHlrRGh2c0dSLzlkSGFjdHRrVmNhNVRnbDlQaWVBWWh5VVpSQ2dPd2J1MUU1bHZSRUZsS1VzZC9uT0ZaVzNZMVNSdnd4VU9kTEFBOHkrdnY1UlR0ZU9JMklIRDRyWkUrcDErMGYzeU81ZGYrQktUM2Z0Ymh2KzluVjQ2TnMzaUg3OUZzR3VJODJUS2lJK2NXRnN2cjl4OU1NMjl1aU9zNnFCV2kzTUpzMGdzSFVSOWt6MkFHbEV4a0E0YlNBVUdreFBOelZHb1k0QmdRVW83a2dKQXBzSWd2T043d3QrWUg4VTNQKzl6QS8rREo4aGFLa3pRalhVc2YrcnNobmJ4dEhaeTlIMmorcmJIVWM3Snp1elE5TmJTNE1Ld3dobDUrRGEzTWtuelpqTTEvcitoazcwSFdaR2hpRld2akVuWTV6Wmx0dTJ1cHJhT2ZxYktEMUYwb1dOaDlxdU5TUjY4TGsrUkpGWTBmUTQvNHk1WmxDbXI3UXpOVjR5SWJjUmNCOHRpaUM2c3VDdjZnSmVrVVhJbGc1UlRkZHlIMzlPdVkrbXE2ZzU4QmRHeHdQV1JGSGhOQkh6SGdHY0VNZ3YzUUNJcm91K1Mxcmo5bC94RXR1MUU5d2g4VzdCT2JUcUJycFRqRzdrU1FDOXBXSGMwL0tyL3piY3pnZkNwTHpYa1ltcG84ZXZUeDN4T256bHh2RVRFemVHMzNvRkI2Y0UrZ2NKUXJ5Q2Q2WUZjSUxUd2JORDdvcmNaZGxzL2R1UHlxOVBKemhTOXh4TjNvQlA2U2ZTOTF6Ync1emVROFVKTDhPdmp1R3hRTnlWM1djZkZsMVdjdmluUlozd1VnRVBiZlZPWDRjajlOUU0zVTEyTXl6TnJ1ZWVxNnZmUDFDWHlJbXQzTzJSNmkwUzNCVWhEWG5MZ1FuL1p2V1lJYmRkcVVENUQ3VTh0dGc0c293OTJXUzNzSll3TzZZUmsycG9aZUc1VFdzU3c3dGNXbE45cGpqY2FVZUF1NmhJS0NFbXpJTS9WVnJaNzF0d0hFMTBxTm5EOExXMkJ5U2M2bEJXMGI3SEJ4cTk4SktwMGM0OFBwKy8wQmJvNVFtTG5FVUpSRDNIZjBtT1JFTDlvTmpzbFZRRm9xODJ6QlBwUHJTOHJKVUhPblRGaitzcmVvWDMwUjRzbEpXMDhJQkVWOEJPWGpJZzNVUE12WE1WeHZsVnRMNHIyQkdZczhPL0lOQS9KeXB3VXlCZEpjVlBEeWFyUzhhclN5UENJVG11MmhpYzdjemh0RG92c01jN3Q5MWgzd0VUL2RkQ2xpOWdCdDJhTDdvUjdDcG5ZcS9mbWx1SUg3Ly85SVVRaTlnNVVyZC9OaVNmd0ZkR1l2eFIxQXBrMUZqMUhpTk9WU0hYeVNFcGhuZGNDeDZ6ZU9IekRXNStDYjVPQnMwQkJDTEo4WTIrSTVIUU1CaXhPN1lFeFBFZ3Z6ODFzK24rT2VhbWR1YkJHekRlMzhiVW1GdGZ2RlJXK1dHVDJ5Q1RJQklFUVc2OTlMbEhldHJvbnVMK0NicC83cjZidFQxczFXbWt2RlRjTGViMEN5OWllaHRLVzJ1ZHZWN0s1NjRZbHprWnBwYWVaakZmaDlWT1hvS2w1WEdjTXZJeTR5b3F2WTdRZGsrSnFlUUpYL2JQUXgxMFlyUDkySmV2c3RTQXk5ZjgyQk91WEdPeitDdUFMMk5mV0h6N3JVZlJNR2ZjUHh3U3NXOStwN2lXMjlOUkkzaC9saDRkREY3c0dIWE0vdlVYeXlLdC85N1BFZWVmYzJ5TGxJRzdQOTZlZFJ5NVNxTzlITnpGbWJQMk91Y0tMSzJPTlNsWmR5a3FtSFU1WFh0WGN3eTZ5RFpMLzE4aXNpNjBsWG1CMS92UnFQdGQ1SVdaclkzT2l6MTdNb0pEOTJUdWVRRkZidGNVWHk0M3ZndHFHQ3RNU3owZXFTNjlYN1R2UGh5R2E3aG56eVovTkVTbTg0QURnWVg4cExRUFhsNWhDZUFGN0tUWU1HNTZ3azQxMTVPams5dkxyYXRBTTB1M3E3ZFBJSTNYM1NDSXlTSWt0cDRoN09KTTRUNFZ1aFVSKzZNUHFRUlhQMGNxdkxlaHV3VGRIYmo4NTh0S1FicUZMZWtUZ3A4R0Jydk1yNitPaW15b2plSFYxMFpHMVZXTGNlUnhQcWRvYWZPOEUzV2JvWk9UOFZvWWJyZ2QzaHhZWk1YcXAzRVc0WVJ0d2Y4bDFRM1BvTzNqNFo1MEUxMU1zZTl5UFcrbmRmRG53TDNvVXk1R0hudnFud3N1ZXdTZTQxdGVaWDI2ZHdxdFFCMDlob01pWTNiVGY3eWtIRjQrSFNKNHBTaGVlUW1jbFkzMkV0dlpaUFZDcWlhUTBST2VONmY4elh4bElBTmNGTzg4RW1iYU80MzJMcjJaL0s0SkZBVkxLNWwvVnM2UkMvL245ZzdWZkk3ckJVRUJPUVllUTVGNG93NWtoS1JWNHJXdGxzWVZxZ0E4UUhieUg0SVl5ZkVOWG5WL0tibkdqYXgyUFpRL3hoVUM2dDMzTlIzUGVpNG1ZL1JtVVhicnV5U0hTL3pDWXBhck9JdFliekFzNVZFYUZRekZuSVBqb2FYQlpoWFhDeHh6STI3ekZQVlVadE9hNityVEd1UDRhUWNhNmp3Ymk0alpxRTVpM2crVEkzZXFZbWxNZWJsU0VBSWMxUlhoRU5JUE5ZaWtYQzRlSzlFMUNLT1JMV0xvS2x0VXI5YWZPQS8ybzQxdkd6K3VNSGt4N3E0eDBlNnUwZEd1N3RFeDJMUXQ3akV4N200eFVlNXVVVkZ1N2xFeFlNQ29DWE9QYXo1RXdPbmIvYXhMc1hDTnFRMWp4cmQwaUdDMzJQMW9FRmdhSnRCbUpPeXFiMGtMNTkzUDVPenhsa0I1RjlyMGltZUZ5MFhtOFZZb2lYazhyODBTQWVNVkhnczRHNm9YU0xoU2lnZktlQ0kyVkRPV01GWFhodDczcHRCaVhmSjlsUS9mSzZaVXUvMzF5emVYdSs4NE00eFg3Zm03c3JRd05wdHB6enVkblpVNDJNVGRVaHU3aTUyZE4xRDB5b21kYXlNTHppbSthd1FxeGdnTzhXQVBWdlR0c0dGTXJVa29tU1hzUXYreC9kSGpFRy9ZQ0Q5N1BscHRhRGhhL2V5RllVbERwNjE4cGlnZnNIZEh1Mjc4RHgvaDQ4VDdic2hVK0xGRmpkeWYzNXNPNis2UGhrTDRTbEtFVGFNZm9BY09OaDM4L0Y2Z1pUZU1JQ1Zubkp3OWRuanlDVVRtRjk0dEx3RkM1THVid0V0NDRlWFM3TTJ1Zys0cFVMWVFIZzZQZitoRHEvVFpWVmQvQkZTZnRYcnFXRUM1OFFtL3Jqb3FzcjZoT0M1ZTBUeU51czJRNW1TOFJxVWFib2R0UVE3Nzc3bFF2REluZkpLOFpOdnRtY3YrdmRHOXNSQURhZEZBS2tpUmlzb1lDc3NLQVVTMFlnYklnR1NHTHk4bFhHMDczV1k3Ukd3KzNRd2k4bkE0UFBHeEY2WFNON2l1cmdPVTFrOWlmbkI5blpVL05oWVRIdGtWdml6bDRsMkViNC9BL2wzMVcrK25sMk9pRUxpWnV5cTJkbjNYL25wSWsvMkxiWnM3UlFDT1FFOFdwaDNhaFFwSXNzQ0lYRzNwaVQ4U3c3ZUZSLzZJVEFjamw2Rk0zdjg4Rm0rRDEybldHYkVSd1lyNFB5SVR3cVNKNCtOZm56Q3NpZTFWY1FIVHNlcFNxeEROTFY1M0YxTk5lOUhSUG82U1ZIQU9DZlQyREE0RVozQjJscWQzVmhsc1U1UjhvUEJzYjBPVFg2ek9hanh3cmhjSzk5ejZacjg0YkRVM3BEMWdmT1BwRFFlN2pzR09YMTh3cTZkWnZRK083bXBqUzNQRnJUTHNySnpkWnMybmtWVHFnZXZrYW0zVEZrUzkzYTdnV0U0czZTeCtNaHB0NHNUU2RYaUNpc2E0eDQyMk5zU1pXTVB5QkFuYmtVaGFuVGxWT1p1NjJ2YzVNNnJLdHZFaTNsVjNybnNzdWxTV0czbEYzVW44UTUzSklWL2ROcWxKbGRXZ2lRYzdKNVpuVk5MaGJNZkEzZnE4RHU5UWp1THQwUUZyQzJ0ekoxcWErdzBOV0psYldkQ1VRaDJVQ0dXMUdrTmlrZU53alNJUnd2TDBJRlVwanNHK1hwNGh2cXM5MU9EVlhMYWtlS2h2YTdBUE1TTyt3Q0tzVXQrclljeVh5NDF1enJncVpqcS93KzgyOUZ5UmNIRDhDeG1YenBBKzROL2tIUmZNOUlqbllvWjh2ckIvWGxwNlc4dTFjK0p4bFRLRStodW5UTDI0cEhZYnRpeGFOaUJLWk1VUUd3WVdrempaRHJFeFVSbjlMUkRKT2RqaWxjRytlak9CVmVHUnhjdkx1WFRncStUVkEvd2NzSTRRc2ZpNVVmVW8rb3hzbCt5TWdJUjVEMEZhZ1Jrc0gzNkV0MmZTZ1dSZkx4N1AyeU8xTGpXemVOR016a0lKeE9KSGsxMU5iZGlmNENFcGRTa1BUUFQyVEhWN2tlN3JFeE1KVVVHOTRHUmZWSXluaDRDNFhwNVJ2RkY2YW4yS3IzY01EKzhBdnQ5YnA2MkRtNkp0Qmt4U0ovK1djNUpib293czdvQUdScS8vbG5XUzNTV3lxL1E2Z2JXWW1IUzNmSjFtNURPZDdlR3FwYUxYZ1NPckdDL1F4TC9kbEowNWZiaUtBVmdRRFFuRVFDZ0RhU0d0eG1PdU9mMEZFdldtVlZlZTY0TG83UHEvQmVDZW0vNEwydzNHUnhlK0FFNkl2aGZGUGhLS291L0JxV2RxZWFGeWVYSHFPMnQ5SmVOc0JoenZZWDJma3NWalhwakNySXhtak1JN3Nveks4dlZHS2FlV0Q4a29UNWJVMHdmM1IrNlBuQ1c2ZkZGbFZjQW9QazFUZmtyRUIxQ1dNb0VqRVNEbUxPZlhKc3ZFU0RUeVhiM0ZUblIwN1F5M3o2TWxTVUdudnlVcUl6WW0yeUdKc3poQWJNaUtJVXBvZC8vdVl5UXlZeGdmMUc3Z2t6TzJheUxxMENsUkJNZ1RCTDNpSmQ5dWlBcmxTZ1ZnUE40eVpmM0l3Wnk3ZHg4R3U1dEQycFpHODlwNEl3ejJvT011WDAvdkVGOUhTcGh2Nnk2VzlnaUhFc0x5OEF4alVSekNmRDJab2I3QVh0aVVkYm0zYllSZVk1QmhKN0ROTWJBc3lnbU92OVc3L3lhemw3S0gyVWF4VHdQTHduVHR3WmJJM2JHOExQdGt6dUsvWE44VWFoWlBWQko4cngvK01URFExM082YiszL3RUNlYxak13OFAzajl6cWwrL1RwRDU4K1dCb3BtZVVIMktYMlY0ZnZjcUoyak1pdW5lUE5RcnBKNjBmb2JSVXhudHJUcnNDM2N3VzA1cFhkMHc4dkUremFpVUhoY0tCMWJVUlo4cTVKajFsa0JDREJabkNFTnBsOG42eGRLQ3pxNUhvWnZQbk1Qc0FvWFFkajJZMkc2ZVN3cDdMSmRwaWpYTTY5SHp0dmNuN3N0OUt2Q2pyYmgwcGhlOUtkaFNVaE5jVGUwZjN5ZXIrellQcHhzZHpQbStybzUxWE85cEtVYXZXbXorVTkwVXZ5RU42Z29xdUN0YXkyWnJJQnkyWm0ycWlVUlV6UGRvRTM4OXN1aTFDYjNnOEJzNUE3Mkc2cllsMHdVdER3dEFFZGRoZmRvQkxBQlNOMDdYaThTVjFsVTUzM01YM0dsK1c5RlpFWlh3NFgvN2ZxcVdEeDdiSHRzZUpOS3FxYkw5dDJ0RnA4OTFKZWVkMWRudmFsbmxleHpQZ09WaVBqV1ViRzVVcWRwZHdTN2xHbENzUE03WTk3amljL1REN2VBN1lDMXB4Szdla2VINVBja0xRcEVDaFZVdHBMV1pmZVpFOXBxUlE0WG1QMWRJMlBSOUFsZWlvSjlKdkNhS003WUdVNFppV3QvaERxT2tMUFBtNEhRR21wck9nZXZhcVhiQnNsMmRPK2YvTlp0ZmRVZy9ZcjN0KytRYkZUeUdFaFdVTzlTZ0JkTktRZk03THF2RUt2UVZKbGNWemd3WDZLKzRZRFMwRXliOFBKV1V4YUp6cVI2Z3NiUUNOQzgrNWhNUjdTbm5jZkY3ZExTcURNLy9hTjU2eGtrSEdtWnBCaGxjY0ZHaVJSSHBXc2hyT1ZZNTJuMEhpeWJoY1poWERmazhHRis4ZjNyWGtkMEZRV3Y2L0FhMGxwVGdtL0VFZDJwWWN5WENJWWRMS0pDdzFrR3k4OW5sT2FLU1VvTzZVejJlbDdtOHV3YzMvUnFLNjJEdTVlMEN0OVp1TFo1TVNOMmFDSjJZbWJFMytjN3ZMZzVPVHU1bVI3ZVBwbjc4N2w1QUJ5NmFuTDU1SVZZYlp4Z2JpYWxQY2Jtc1hhcmxSZWpucVF2YnRoUjdZZS9GWVpXQlpjMXZvUENUbXVUcGhUd01NQnNkcXhLa3pNVFdjZlExTUhIMGNleTVsS1lxb3BER3R1N1RYdUtwZnJ4T2FINmxubUhHdE95YjEwQ0k2TDJVUXFjcTNwZ1Z1cWdvVDNucDRxR2EyUTV0MjlRdGMwOGd0T0NCRkJkbHN5c2pzUHBCUmNPZExXUWZHbm01bXduUjNzT05Sazd3QlBpRXVNRlRuZGxkK2JrQWl0WWdjbkN5T1o4ZkcrUkR5RHlBbWpobzdrN0swYXlnbDE5T2ZTaVhoZllueUNlK1JrWVV1TGt4dDU2M1l2SzNzSFg2dnRXNWxrR3R2Y3lZaWtUeld5c1BybFRUVUVGVG1TVFpRaTE0WWVzS1VxYVByK0g2ZktSaW9sbys5MlJIR0NFNE1KTW1tV2JwVEE1UVlIemxmbDQweHhaRHNIZXdWNlFTLyt6TVNmRW5tNXowNTNyd2VmZ25mWCsxTVFDSWh4dTYwdnJ5U2Mycmo3Mk5PY1RDKzRWb0NjVUFQNU5rQW9IYVkvaDJEOTJFOUJQUUN1TlplRVAzdHc3NVU2TWhqT0tKMmE3NTIvMVhmTEhkOFV6Q3ozSnZSQzB1M3UwTzRRY1hiVmdhQk45L3prWldjS1YzM2YzakIxT3ZYeStldFFkNFY1L3NZbG1nTlh2WFpmcUJyZDhSTDBQajNmeUJQaENlbXV6OVp6Qk50NnFXTkxVQ1Y0UFVmbWRoT1RGaE1zMkJ6bzFqWXQ2QncwdG5lNDlWTHRISWxyQnc5NElaNDB0emFaYjBMekE4T29zWVVsMFBwSTNBNHFpbElCMEFYNkx1VFRkZ1J4US9OYlFSei82V1F3VnF3cnRBdEU1Sk4xZ25vMUMxUVdTdlNlUXlvNGRDbmJROURiWTFUWGh6RVJQMnFzd2VrTE1hMjM4cjZ1aS81TC9US1owcVptRmVWRlNMOVFDZHRyS1VRVk5wT1RkVWM3UVczL0dnVUFMd0FuNGtIR0hrUTRmWkwwcjltZVo3WUhUd1NJQ3ZPcXp2Rks4Rkxsd3hVUFJ0SXRBaC8ydE8zOU1uOERiRmg4M1lmTUEyQWRCdDgzZkhYcGZ4NjJOWWhHVFNlQWk4T3pnUjdpaVN6SkFTNWNiZ2xJVDR0QWhId1ZLb1R2bG9sZzhHWXlvdlNRaU5ST292c3dQcDYrQktFMWdtVU5tNUtMd200azJ4VjBveWd6T1FvUnhhOUhteDhxZUxKRllZM0xWMEpyYWRlYkxDVXFPQmUrdkVHZExENWJtc2paQUltMWFuRXo1NmlibUN3cXhoTmdnVmtra0RyRTZNTkVyUi9XNDJXempHK3NiSTYyQVd2SGFsUmN3TW14MzRlTzRNTlcwOCttMXppU0JiSTRmM1UwZmJmazVDcW1HM1A1ODhqZTRId28vQTFnYitCUkhQWjNBVG5SL21HNzBSVzA1dFVLaTFkRlJkaXZyeTk0K01WanYyR0JPdmlJemZKalhiNHlTaTV2bWxGakJjL0xZNUt0clhtSDVJRllDZmtHS3l5TmhRZDFiaHQ4QlRuVzNzU3VRWTBDckEzTnUvejFocWdFVW9uYkNzUVZYYk95UFh1YUplczVvcW0rOWxxczYxcXpjaWpmd2ZHYWVPZDkxMU1zcGdyR3N5cUF1RDV1eWFvNTkvMzdkNThWeTEwSjIyOGVGMVk2eEx2YlN0cXBSNEJ4NCs2UUIyR0haTTNFZWdiMnlicGthSDB2NlBkVi8yRWdacXViNE1admlzS2s3TmNKWWdRQUFIaCsxaXNTQU9DRng0WEVMMDVmUUpFcklmU0ZDRUdBQWdSODFZSzE4S2VOK01PNkljaEQvbmw0L0N2YUxLQUErUkVvenpwY0hid3pwZEFjc0w1NWZSZUZuZE40ZFhHdExxeTdVbDBuY0hZU3BQYWFtZ2xYVkEwcXJRaXZ5L2hIRkhzTWNaY2c0Z3dVbkp2d25lQjk3aUxPVGN5RUt4cSsxQk80Y0FMWGQxVzNrUGNQUmQ1OVozSXl2K2pEaWljTTc1dGdaMlpRSUY4YWh2SzArNUZicWFLdEZoOHJmUC9zd0lrWktkQUlGYzFPdVNEdTl3U0lSL3FuVDcrZFo5ZnUyZHI4Q2VyaXoycFF6ZE5pWE4rZ2QvbzV2NlBWbmVCNkNranNNQi9NWis5dDBwaE9rMzVTZjhrYlE0SklMbjNjYnFBUW4wZkRmbTI1eE9lazVNWFlkWm16Q3pDcnhsQSsyeUNkM2dNR1hRdXpWcUpyc0hzLzRGaCtla2U5VFJObzRsMmh2S0xDMUh3YXF2YUFUV1hDSDN0RnhMbzY4MWg2KzFyUElUTDN1RzZZOVh5RWI2bjVucEhDNFpscUZOZFdvL1ZiU3ErL3ZKMFh4Zlh3WHhhbkhyUHo1OE1KWWg2Qnc1UmZaRjlnM3hVSzQ3d1lpSDBIZElQaUFrMGdXRXNKS0R1MkN5dThFNzY3VmtGSW5rQlhDOTNnRlFpWklmYWNyeUxPaXdyeCthQkFGM2dFUlhqcHMwSWUyeVFyVG04RHRpZ0l5Uk80dU1PN3ZBTGRZUHpiUXB3NzdCNVRVYWFTSDEweGJ4cDdRcFZuSHFYTGRhS3k2aGJnenEwSGcrV2dBL3BBZVI4b1FFNEE3VXBRemdYWkEzZ1pRUDJvOWhiS2crb29LbmNEYTJlR2ZOYWtKTUcydWsyK2lHcVlsSWF3eGZGYjFYMFM5N0x3YmVYVHN3NjIyVDlNc0pLTlVQbEZxVHhIbXBUK2gvWDlkWXJmMk1uc3NuaXRIdUczcWJLckxXTmt6TmRxOU1nT2g5cUlmcVRhbTJZQkoxcG4rWHk2dW52VytKRC9meDhhRkU5c1BBQTQ2aW5yaHpuSTJkdUs5aC8xa0o4ejJtSjQrQVRmRE9QdWVLTGR0UW8rTmRsWVYwaDc3dEdXdVBkY1paNjRybDNTbUVkUzlwWDJNOElZYXptWFQ5T0VnZm91U3N0bjM3U3gzakYzdGFFdEFNN1c2WEhRWVljdVRMNlRyTTdmeU45NElBbStjYmttRTcwY1h2VmpXM3c1VkNMSFNtWmZQVmhWTFc2MVlGWCtZVmdOMmJTMVk2UGkySWhadGJTVFBLaVVQL2xOZWptQTBaWHVZbkVnN2daZGdyRURkOGsrUld3TVFML3l0U3M3L1VRZjk1V2dtekQ4MVZpcnhWdDJOdUNpMmJWRG1kNFUxNUYvNUJScDg3aVBCQ1lFejFHR3JlQXVBbmtuV1JuRkZoM1pKYkFQY0NZNWNtMG9jaWc0bDBJcWgwb0ZOcWRJRlRuQlVrYytOVklqbmxlbEhybjBTVk8yNXFyVWg4dXZwQUh0ckVvekZJcTBOS2R1OUxhY3Axck9QbG5BVFBtdUZKTGxSMUt4cVN5ZGZLVlRjVENRYmdESzQ4ZmdURUpvdEhFSlJXZy9rREM0Tnk5aEdmU29FbzV5ankvaGtYcUZrZ2pPMXlVUkVIdi9sa1RSSDFZU3MzWEtUWkxJZUNwMVMwbm0vWVluQzFqb1QwbWgzcCtUQ3R2K2w0TlZqM01uMWROa1pPRG5hTmoySHV0RU5RbUxkK215MFIrbzRPYjRJbytjZWdGQlkyWHkrOFdoQTJOS3JEWE1tbFJ2MVBmZzNwMnRUWHQwSjllZkZrNyszU2NMNk9oM0k1dXplSkREempIa2kzdmRwa0d4c1BwUUVRMTBNaENnVkhOSUhpdHdzYVh3MnF5VFgxZ29IR2djVDFIcG1WODhXNzB3MjJUOGdtSURUOEFtazNkMlZjSDFQQXUwU0Z3alRNcG1uWlluQnFnUEdCdWJQNlpZaFBBWGJvOURaOWh2cVRnTW51SlFPdDRWeTg5di8waUVXcnNxc0pZN2J3cE9NNE1vWEhCaUoyMnBKdUhRNFh2OG1jQUV2VC8rYU1vU21RWWs3SittTkxEV2ROVXZMckhCUk9KNVQydGlhU29MUnFwYXJ6YzRrbDYwMjR4Q2o2WU9zMlgxSDRHSTFmMTV4ak1ZU2dML2hQV3lvRHpVUXppOHQzdVBkWC9oUllrMWJBVW5YUlhJZENVMzQ2VlVmZVJZblFmbW9QeW5MMndoWlh0VDFidWc1dUUyc3dRWjdVN1RxMk5nWWFxUXJpcXJEZ0xURzZRSWo1NGZUc3RkT2FCandBZGk0ZXJiQmlhVVJvSUo3K3BLNUE4NWxrZ3R1S0ExSEJTd1RScEZwK2trMmNPYXZES1NKZ0M3eFBoM1JRblZORERUU0NsWDlGMUF2anJXVERmZGtkUFhacktFME5aR1Rjck5PU2xYVVVyazkxaXB3VXdITG94OTJ4S2ZJR1BhSmdJa05rL0tLRFczU2l2cGhWbU03Sit0cEFkdUpBaXRENTZJSXpJSUVXeWs3WWFpbkdab2dMcWcwL3BMZXZnK1RrQ2tUQTd1N09zQ2QzNFdCSHNLeFZqcjFtSmpGc0IrY0I1U0NIbEdVb0s5b0VmVk9XQlNWZ1g3QUljTEMyWUlQbk5ZRFNlZ1BsTkw5V1Y4SmFPQUhiZHk0REhocWF2eUZ5QVkwQU5GalVrNWdKVW51dlJzQlNmYUZBNGllb2VXcFNzSDRCRG1lQmgvTXVNcEM2VGkvZ1AwNE9TZ0NGTytoeExLdXJTSHFoa3FFWlh1bzg5UUEwK2w2eDRZbUhyaDhNTit3YWdYektNQStCWm5tZDFjT3Vwa2svdko0WXN1OUc2b29leWdGUWVBd3NobkREYU1nVytBWm5KbW1YeWpWYk9nWmkrMVVkZkpDYkRTWW9BalpTYXI1S1pKclNKS3NwVi9VNlRrUGJ0ejZuekZKbGc0U1gyWHQxeVBFZzRUWHZuVWx6YkdsdXJZYW1BNEZwYzRHVTRnc0dnaW9XeVNack1XVUl5REVSR092TkNOY1V4QW1Zb29OS0VUUU1SY2dMYktQU1dtd0U4MDEvRVhoVzIrZ2ViWGRGN1k0Y2FrbVJoMDBVTWZHOWpFRnJhUlVLQkVoUjBNY01WeFBUOElvemhKczd3b3E3clJiTFU3M2Q3WE9tZVBlMXErWXIvKzdXNS9PSjdPbDJ0QzF5SElSQksrZGt3aU95MUtjcExaSDE3VERkT3lIZGZ6Z3pCS0EwL3YwaklGT3Rxa3FOZTdIeUNaUFhJa09jdFdWNUxLeWV3Ty8xTUtvaVFycXFZYnBtVTdydWNIWVJRbmFaWVhaVlUzYmRjUGkrVnF2ZG51OW9majZYeTUzdTZQNSt2OStmNytobW5aanV2NVFSakZTWnJsUlZuVlRkdjF3emdCaURDaGpNL0x1dTNIZWQzUCsvMHNhaDVaUFh2dlI5SVBoQ2lxcGh1bXpiSTd2b3ZocitSd2VYeUJVQ1NXU0dWeWhWS2wxdERVMHRiUjFkTTNNRFF5TmpFMU03ZXd0TEsyc2JXemQzQjBjblp4ZFhPM3NMU3l0ckcxQTRMQUVDZ01qa0NpMEJnc0RrOGdrc2dVS28zT1lMTFlIQzZQTHhDS3hCS3BUSzVRcXRRYXJVNXZNSnJzSFJ5ZG5GMWNrU2cwQm92REU0Z2tNb1ZLb3pPWXJENy85ZWZ2QThBdVd3S0lNS0dNQzZtMHNYNnVEQkJoUWhrWFVtbGovVndGSU1LRU1pNmswc2I2dVNwQWhBbGxYRWlsamZWek5ZQUlFOHE0a0VvYjYrZnFBQkVtbEhFaGxUWTJ2d1VRWVVJWkYxSnBZLzFjR3lEQ2hESXVwTkxHK3JrT1FJUUpaVnhJcFkzMWMxMkFDQlBLdUpCS0crdm4rZ0VpVENqalFpcHRySi9yQVVTWVVNYUZWTnBZZjcwN011YUd3Qmw3NEllNklUUEd1blhJOXR5L253QVJKcFJ4SVZXNkNCQmhRaGtYVW1sai9Wd0pJTUtFTXA2YjczV1NKRW1TSkVtU0pFbVNKRW1TSkVtU0pHbkRjSG1VeWh1Sm9Ba1E0VWlYNXVYdGRaRlk5ZWJIdUpCTFhkNWJ1TVI4QUFBQUFBQUFBQUFBQUFBQXZzMTJqQmNLMnhlOThaT2lsUGViNFY0UTgweGIzRE52TEgzK1pFaFlpbXlzSlpFb0U1S2VDVE00azhIU0oyWUcwa2gvc2s4U1RhOEJIK2o5dVhwQnV0UEdGLzlJS0hvbCtrREJaRVA4dU9jM1R1SjBpVVFEVWVBeVhTbEZxWnA3T2VkU3ZRQUFcXFwiKSBmb3JtYXQoXFxcIndvZmYyXFxcIik7XFxufVxcblxcbkBmb250LWZhY2Uge1xcbiAgZm9udC1mYW1pbHk6IFxcXCJLYXJhc3VtYVxcXCI7XFxuICBmb250LXdlaWdodDogOTAwO1xcbiAgZm9udC1zdHlsZTogbm9ybWFsO1xcbiAgZm9udC1kaXNwbGF5OiBzd2FwO1xcbiAgc3JjOiB1cmwoXFxcImRhdGE6Zm9udC93b2ZmMjtiYXNlNjQsZDA5R01nQUJBQUFBQUZRRUFBNEFBQUFCSEdRQUFGT3BBQUVBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUdvRmNHOTBDSElHUUlBWmdBSU53RVFnS2dmZE1nYng2QzRZbUFBRTJBaVFEakVnRUlBV1dVZ2VoRWh2MSttY0dOMHNsRkxjREhML1Q1MTJyR0xzZTlHYUhOYlc2QVVZaTdBWnBGYmJzLy8vL1QwNDJSamhBUFJCVjFmMS9XL3RXY1hBb2xBT3FUTGxsODB5bGxsSmFvWjQ3bkRLMWtWdWUxSWN2cFYzWW82dWtwSHFnblprYVc2eWFTVXJZWE1rSVV1Y0RaaHB3aWV0cjdyMTRDWGNaOFNlNSsyUlhlay94b0Zwck5lYnBlWUM2KzJhZTNCbVdVZWlsR1VHVnZubUJhS0lDWVcvMkFPczMvY1JTY2NUZmt6cE5ybVNTWFpCV0dLSThkK2dOVVNFMnhEeFBHb3Rlbnc5WllVTldNa2tKb2daYitDRy9mODh0NWFUdmdockQ0dFVZVGZ3VGdabitmeUtMQUhkNlNCbnVoT2YvUDdmNmZjNjlWUlJsQVFVaUlpSVdpSWdaUTZmc2hKenNucUFUUW9oZjgxNnVYdlAxUW9qMkQ1QzNmeHNieTNMY2ljZ2s1MXpMc1kvWWJNem1tR01ZWTY3bHlybHhSNDQ1SSs0Y2tTdGRqdWpTNWU2U3JIVHArS0pmMVArK3Jwdm5nZjNGZCs3VHpJZmZmRkNKYW16d0FzemJZQ2JRYVRPWXpQUCtIK3krYmZ1L2sxSGtpY2VZV2VMeFQvNmlYK2RXMTJONnZqQW9Fb1JEYUJMQUlqUUM2UkRPN3ZhcHFoRVpzMHczU2tCRVdrN3liWE92KzBsaVpLcVFCby9uTnN6ckQ5dm1XSjc1eGFhc3lJSGJMQUc1ZTdUZFlkdkdwbEtNakdrTThBLzlmZG5Oc21GMmFtcU43dVhmbTBJcGo0Y2tlM25LMTZFV0cvRGhLZC9lT1h5bmZZSkFPek9LbS9ZZEVzdFNZQXVVZEpzRmZyYm53RWtPbmVTUTBiQnd4Si9BSGZBUENkQ3laYm5tS1lrdk1sbyt5SEdvUDZFa1BtZ2NSako2cWVsTERTMjFJMnAwcU9ITDVZaFNHS2VQY1Q1RXA0QXFYQ1orSW40SDlIYmY1VWtNZ3BwbTZRQ3RBSkxTYmo1OVNLRnlLTXFmM3VNUVFKZ1Rrd0xpT3J5RWpZUHFJK0RldGMvZE81ZW9nd0lwWU4xYUZxWXZ5UkhKa3U1YlhUU0dVQUhEekNUL2MxZ1ZGUlhFZHNYSnRWd2NuV0dVd1ZtU1NTSTdlUWliTUlhK1l2RVl5QTBXaWZXRnpKV3BaVHJESldqZUFtOTVNbjdmbVNBU2lMdVhONmw4RU03MkxCYzd1OFJoZ1NWNUlKWTg0Y2d6d09FTUFKNEJ5VGN3SkE4RWp5ZnlMZTFieStmTC9Yc0FiNHgxa1p5TFZMbkNVS0hpVjZRZ0RRWFAyN0xaZmRRaEdhNUk1RGpXM1IzRW96ekNYNWxieXVkVFpWV29vWlRpNkVwZzNBYlZpaUllb3hSQjhYL1RVbnA2ZC9Qa3BPc2RJS2s0N3dEYnZldHBsWmZLM2Y3TTZkL2U5MWd1ZlZKNjBlaExXbTExTzljR2FDcHNCY0ZnRTVEU0NBd2h1OHdYcFRJWEZPaVltUVVIaGhMejhQMTlHNy92eldrRjh6KzNaZG1BQXZOQUV3Nmg4WUFnNHZFM1ZoMy9YZU5abkNuWW13Tm9FcHJHWnJCRVU2cHVOZ1VNT0ZCQjgwU29sL01KZEh6RXhFeFZSTzEvTjZ6L0d2Ty8zYU5DK3k0cFF5bmlpb2dFQ1pJVmtWSzZ4N21zYVUwQUVlMkNGRnhNNTYzeHV6dkdVbmRwNkcrZmJVbjZKS24rb0tpZzRBdUNtbXpydnIzaEpxYW5wR05OMDVFK252N1BLSENUOStRSUNBQ0FxaEVYUXJoSU1hUXJsRUM0VWpXa205UkF1RmtUcERzMVE3aGJPNlFISElId2tLT1FudEFINFVsRGtGNXlHc0xMemtONjB5aUV0MTJGOUlFeENCOGFoL1NSQ1FnZm00TDBxVjhRRnZ5R3RBVU9TVjEwMFBUTERpUU4wVVV6SUR1Uk5NVUF6YkFZSVJrVmN6UlRzZ2NpeHhZTm1ka0tJWEpwMVpBRStPb202WVpmeTZPUVB2bFBzRUthQld5SkFEbnByN2RDRWdnUWx2SW92Kzg4UktheDROYjZYWWRQK3Z3K0pUL3NrcHhPZ2htek1aZkx4Yjc0RzdQOHZYSXo3dUE3ZTVmdUNBMEtkLzNBN3NsK1B4WHRHR3hINmlTZTNqTjFIengzejlOUGFxNmVGL0hwTTdTM3U3TFhVZFJMT3RGS0VoSThJVy9ZUjlqTE11SDVpYjJaNGJ4WDNJZDVvcitWUDY1RHZ1L2VlSSt4bFFlbkIyTlhMQVlPSVN6NzRIMzJMWjdjK1dQU3lTaUpML0hEM2dSaDAvemZqeEgzN2tiMmhteGZldSsrbjJZRUJXZmZoM3h5NCtydW02c3NwcW9tciszcm5RK0RZVnZ6eTBLNEZZb255WmVTbGhIS3ltbFgxS1drcktxbXJtSEFvR0VqUm8wWjF6SmgwcFJwU3l5MXpISXJyTFRLR3V1UU9LTnh4ZURHblFkZmZnS3dCUWtSS3R3ZXNlSWtTSlJNSUUyNkRObHk3SmV2UUtFaVFzVktWYXBTbzFZZGRxaGVnMFpOSWo3WW9sV2J3OXJuci9VYk1HaklzSFBPdStDcThTYmsrYkdsWHZTeWYxcHRyZlUrVlQvMnhNcmMvdU9HakZrZzJNV1dQWGNZSElGRW9URllISjNONFN1c2Jld1VLRlJFcUhnb1M4Z0x5VXZrSDhtbi84bjJVTUdtd0FxelFZaU1yU0FBc0VFUWlHTVNaZGxNZThIVllCd3M4Vjd5VnBrMU5sdzJpMnlFYk83cFBOSjVwbU9tODBybm5jNG5uVzg2VmpxL2RKRXBKRXlnZ21DSXhjVEwxQXphQ3RTTjAzWVVlUlFybzNnOUNqU1pqQnhqak5pa0VUR04xaGx4TWcyUk15VFJGK3VHd25oZURVZWlsbmtsNit0YXU5QXhqRlpicW85VTlrMVROa0hGQUZWcnRraXhXdnB0TlVjOWFJQnQ4WEZObm82YU1ZYzB3SW1pRXM0REYxenhDaXdtQW1FdmtuOHFCVUloUlFncHBzUjFwcnJvcG9kZWp0TG5qaVdPYzRLVG5BcERScDBXUmpnalo4RTV6alBLakZzZUUxNTliVjNsejMrYWJGaG1nS1JtaUFlUmY5SUNIWkdWUGpZbVJCNzhDN1BsMmRFbEVvbEVJckdLNHZhOEpjN0xhVWs2Z1JBRVFSQlVSVnlNSENCOWYxMDdjWnFTZUNLRHJqRFlaSE5HbGdqTjlQanhwV1FxQTFrWmc2L2hoVm9QVWptWmlDejN5dXVqSXRGTVI4SXlRayttRitkUHNjR1Y0ZkdzYzV0bkNkaThVY2dib0ZMTHdnQUhkcWRSZzR0SE1wYjJ4dzRsdS90Y1NpTENCMWVQR2lGaTJ3Z1g0K1dzbWduU1FZWU1abkl4c3pLeCtTakVjQUZFRUZjWkQwdGFYbEJlSnYrNDlaaDlHaEZyaTcyS0pMRm84eFNGSlNpcUtkT3BZS3F5WmNwV29CNTBHWVBBSElKdmE3WE8rNUUramhKRzFOeWF5VE5PVE1FYkgzeE5BSUwyeGpMSmt2UVpTak4xb0o0R0dtbWltUlphYWVPdzYwZHRnTUZPd3poZGpmSGlpYWhOTTB2Unk0bEpVNUh0dmtBeVI2eTRvS2xkdklya2syYWN2QklRcnNBZ3FEZ2VYSVZyWEJCdCtoTm9WaEliWUp2U0xtNEp2RlJVZVdkbytOekRDTmtrYk5ZNUlwUEptdG1WMkpUU29JNTZHbWlraVdhbXArV1NyNzJhbURXK0MwWlNaV3p1NDZ4ZzRCQ1FVTkF3c0hDUlU1UTBOYUF6YTB6YnovZmR2TWluZ0VJcEVvUVVVeUx0blVnY1RUS2lKUDI4R1VEUldET1J0dkRxa0VNZytjKzVxSWtMSWNreXJkcEZxdkpGcU8zd1ZvR0JpUnBycEduU2g4U2gxRUF0Njl3SzlUNkZaR3JJYWVqMDRSRkxPeW5zSVBsQkFZVVVJYVNZa3NrbGpNbktyK1RWK3Q4YVNFdURxY2E0T0ZMTTNOeWVxQTF0RmFQV3FQNDZia1N3SXRCRVJSTkp1L3BCZXBUWnVnQ0pGRGVOWk11WDRweW5WcVBpWlZXcFRuaTNzWC9nckdWUzBGVVNwYll4VVoyeVZVVXpGY2ZZV2hOS3BZWHN2M3lQVlVtVE5LL0VLd2RJNVhmVWpPUk9XOS9XNnZidWp0aVgvVjVYZVczTGlsMmJlelFJMVZ0cWpnRFBxd2t4YjVnVGJzL1pHWkNjOVlOMjVNT3NZZzNFbGd3aGhQYk5SOTRSQjdNZkVlQ1FUYkNPZUhOUnZ4Sk5IVVBBb2RRQ2dyejd3YzBVTUZFODRiTmpZZ0pqTWZBbG5qUUtyR21acmVqU0tlYTJab2xLWEtzY1owV3p4S1VCSUl2WEhBbVZkd0xoblkvZkExOUN2dnUwUVBxNTB1SFRRMmVCajZ4MVBabkMrOTdqY0I1dGI2S1RweGthTko1U0RSUC9DK3VsdFZnWHNMYXFURHZtSmpaK0NSQm9ON2F0R3BtQTB2Ri9SRXQyZm5PT1ZMRFdpV2hhZncxVmJML1JCeDVkQkUwL2lyYjRMcXBDbVQyWlEyY0xIcEFqRThSdTEzQUZVc1RtK0ZDZXMvY2FJNzhzOEpqMzQzcDE4M2N6Q1RETkUrbmRkeWNycEdzZXBscWxyMU94c2xvazlTaG9vUGkxRjR0UThwcFhOWXdaRHozMGVVbmhmL25vSmp1NU9iNUkvSHhXanpqTzVxeWFESnpLdEY3ZnRPeUtLRUE4aVZ0Z1luUlFOVkhHd0pxaWJQWGVjWXN2eWNhclgrVVRPUkU3VHVZaGlEbnFFdXZSK2pSMjdQM2IxTlJhL215ck15MkpWbGRYaWljdXlwdldubEljNHJxVWpmQ3A5ZjlxSjQ2aTNvcU5pZHJFYlYweEwyTmhnVjNBVUt2RExsQ3Q5WVlMWUdDQ1ptaHp0V2pLckhuTHk5UlExdHg3R29PRjVmcWVjaldlZE9WMVJObVlvTzBMSFY5SmtJNTRWSDN5MHZTT3gvSjJHeGo2VjV0LzI0V1Z4NVA1dWE0RXRFT29DSG4xTDNXWHZ2QnJVeVl4bXZrKzNDWmNybXQ1YTZnTHllYStUZFdMQzVjWi94YWdHbnk0MUtBUXRWdTI2L3BrWWFMNnlxdTJnTE52ZzVhRnkyQ1pYaTlpbHNQQWNNR3I2Z1lvMzY5ZzlsOVJVUDNuVlZYa3N1dmpWWFlHMHBhRUNLbkd2SnYra05aZS84VjNUWlFMWDIwUjBXYW52bDdOZHdrdnNkZlZtVnREMU9IbWMzNDJtM3VpUlZjQWQwaklnSEhSUU5lRGt5Z1BaYnZSVG5oWU40aGYrdy8vQ0VhSk04U01IQW41bjZzNnoycjJJTzJqZ3R2ZnRWdkwxNDNGM1ovM0hzRE5QaldoN0tJVC8wdXFKenZWSXBwdFZYKzVvRURVNVJsVUlMeGtxbk1pRTVUeGxlZUd0RXFka0RRYXo3Kzk5R1RnM3hZck4ycis1cjd4YktPSXNVMmROOWxKdS9sRkZuRjc4cWZ2TGFwelZPUklxYzk3bk9yUG5xeHJ6YUJRRjhIbmF2bUhOTGdCU1E5ZVBMQXhtR3QxWmJ1QTZwVnNPR0x6Z1BWUEtLcEZ2bHhIMjFvZFdGWk5mM3JyNnNBekRmNXFkb3o0OG1DNFNOWGl1QWNKVC9qL3AxVWd5MmpYS2FsYlJWb2trbE8zU3J1MUhCbWJ3V0hpRUtGb0lrUmdpTFdYbXdTSlBDVVQ4SkltQTB1MkhBSHlOUW5VckYyeUl5YWttektqMlpKbGJWNTZwY09xTlYzV3Jldnh5U2U5dnZ2aGFGRGk4R1N3a3VLcHlJb3N6MlM3Yk9mWjRFU0g1MklvaHJ3UVl6SG14WmlLS1MvRlFnaThIQ3V4NHRYWWlBMnZ4VDAvNXhKWnBQRkVGV1VpTWNXWVRGeHhwaEpmdk9ra2xXUW1PZVc2bHYwVnVKbWlTdHlHNE9RU2hxQUFZQmlNbXBBeFBuOElERmxzbFVHZC9zRkJRMXB5SytTV0w4ZVIxODV5VGVvRmtGUVNBYkJxckU0RmJaS2FCbFNrOVNBSHdNTkNaU3QwYTcrdW1icGRNTVAyeFlHUXgwanBVNVhTRVdzdEx0TXpDd2kzR3BhaXhsUExucEN6UWhFYk1YVEpoaVdwanVKZDdWd01MaTl0Z2VYQlN2N2tOTWdUUGlFcndma3JyMU5DK1F4bFZwMmlVbno4YUYwSmJIM2FpRVdXTldCaWJzWi92ODY1dE93NEtMMXMwUnBaYlMyOCtxc2JNbzdNdXlRTmlSQmVPVy9XWUFmRnJjV0I5cXpPc1hmcGxIU3R6Y2xRaEYzbEFCb2F3WElsYlM3TVZkUFFyeWt3OEI0K3BXclVKUEFFcmk0YklCSVZwbWNYbGhEYnM1Y2NBVm5JUTRLS3NnSmZod1p5QURoZHNlQWVKdmJ4SWlGT2xjM0xLU25CMDZXVEo2dEI5QXNBS0I1d3Q1WkFZQWcwQ1FZVHhnU3EvMjdqeXVFUU53bHI5NTVMaWNJNWFWVjlmM3NYQzVYTHNCS3REUTRjQ2FqMmlEa3pmMjY1alhIcncvcU1XTmJ0T0lkcFA2QUsrNzUyeTdnWVhBaVREWnZPUlFvdlZydUJDNXpwM2I1UVFvdkNJdE9TVnE0ZDVMKzNQTkJKeHRUNmUvcWdPQzVTMDlJd2NvSTl4cU1HRzA3dnVnRGZqSTQvZlc3SVM3dHl5L3J2UjZDSUxiRmdLSHN3T1RjOXczSU8vMm1DMERweWdtdUYwYkY1eklYNXlTZm1qZkQ4Y09zRkMyRDFpdlNwQTFFQktZWWpJYWxOU2taV3V3NmR1blFEQVNCNnJKVnYxS0x2MTZTaDd2R0xHemdiTitOUjlMUjRBZXRpZDV6K2NqcS95N3V4WmNmVUVaNkZ6OHFkRjNSMmRGN3ZDaXVYeWp2cWtTeDhsOGJKbnVlbkVUUlF2Z29EMUdwTllqVUJjclpzVDVIYmZtWWx4SmxjT1R6RWFZdlloV0FnbjBENnVISHVZNHgrNStuUXNqdStPaVB1MmlpUXBwQUtpbDlGbloxdnRxWGVsOVc4Nm1DMERTOXQ0MVFaNFNNQllJRGtiNlI2L3dLaEdpNWcrTDBmZ2svdVFqQTJtcjEwa1BZMUZJcmhBRWF5ZHh2NHBBYkNZaVBaS1gyYU0xQVh2cWVYMTlzZmZNS0NzTmdvdHJ4dHR4cDFJYnA3SkhvMThNazJ4R0lqbU8xU1BOUVIxam5XYmY4QTQzZ0RZZlpnbDIrYjBUOUVuYnV1R3FkOUQ0WmtGTUpiZ2V5UnV2d0pwZFB0OE5yMkp2QlJDV0d4UWV5c1Vqa1BsMEVtd0JTMXN5NTRTRDA2Z08wNTVYMnA0M1A2OWRwdURRbkNlaStiTEl6RlRDNHpTOXRBMU94MHNFUlNodXV2dWpiSFBkTllmZGcvT01XSWRLNno0V2FRZVNUYjJaWVgrQUN4WE9HcWxySGxCeDlDUExPZ0lvMnRZTXBGb0xJOTZKYU5yZlMwUTBHbkNUb2ZHRnZoMWxhU2lBV2RlNHl0M0RZTGVMNEROZFhZeUE5cjZCL0FlQTFVZDJPcnNPMmZzTWsxb09vWU9yNjd4T0Y4NDBOdkV0ZFk0TjZRb1pmTUtrTlMxVnZCME1neWNZR0krYXI5UlZzZnVtT2REWkUzWE5teWMzN2IzQnZQcG9YNzFtbk85N1JxeWlhd29Qei90b2ZLL3RzZ3h5MEFRbGFiUUZxN3ZBNEZuWDhIaG5YYjBKRWRNV09ZOE4xeFhTWTc1aGF0M2VLUVk2VElPVVdKbW5NdTBYT0ZrRW5XSllaZHp6V2tZZjZDNjhyZVM0eWVFYjdIT05tc3krdlgzZXZwOWVyYTZQK010V2xidE5yV3lGcGFoM1ZkbnczZXFFM2U3Qlh1d1czZTd1M2Y4enV4cy90Z2wvYk5mcHlGOVp5Y28rN29hdk4wVC8rY240bVpuUWV6TkcrT3FXUHRPQnlYNDNuODUyUDlyNjJabFJ4ZFZGWER6dnlGaVpNcVQ1azZoL1U1N1pJWjh4YTl0TzVyS29FVVJFc01oQ0QyNHBKWFFVVVVGNy9zQ3F1b3J0YTZPMTRVY1p1bmEwNTJUNnJzNW9uSEUwL0lrcTJ5bXppcFdDd1dpOFZpc1ZBb0ZBcUZRbUdFRDJPTUh0bzhQVmxkRll2RlFxSEZJMXlvL2hZcVpwMk9qamZTbGE1M3Q2ZTlhaVAvS2F0cExhcTJHcW1sT296citFendSRTN5Wkk5d0Rvcmh6Zk94RmlUTEpuUlFzMjc5enBzb0pVMW9WSTJXMFRPbWZHUEIwOUthbnlXNmRxdnR1eWRWZGhON3hHS2hNTUlGbm91aHJYR0VLY3BmajJHdkdYUFRndWRXdmZjelYwSlJFeDNCaTdXUVlzU0tXMHo4OWxWU1RhMzFOdGhvVTgzMXFPWCs3WE9oZlRXdjIxUlg4V3FwOWtybG4xTEluTU5ROEU5ZWlXWHE2NVUxMWRuSnpqYlc5ZVo3MUZLcmJlUnFjMHoyM2dzL1lYS1dUTFlrblhOS1hEK25KSGdpbWV3SUx1S2NZckZZTERadjNyeDU4K2FGUXFGUUtEUm56cHc1Y3pFM0w1UE4wSjV5eXJIR2RiNkdNVGRENnY4SkNqS3U3NHJwK1VuWnplZEhsWnAwT3Vtc01XaW4vUW55QUNZczFjZVdyb2RaUGF6WDE1clczc0hSS2VxWDg0c0NZRmlvMEdTU2xXd05qb2hOeXBROUZUVFF3WEZHdU1KMVRHSmFkdjZqVFRVMWE0NjQyTFdDMHFyNmxpNDllOUJtdSszM3ZCTmlYWE5IYnhmeXVxbHlqVm90YnlZMFByTzR0bTFsMVhXNHZrNTNxWm4wd3VyVy9tbU92QzNhMEthM2V0dU9uRHgzK2VZN3JuSk42OXpKbmQzWTRPeWw2M2Z1ZjNjNXZQVDZ4NzcwNncrZnZmN3c5ZGUvdnVhdDcvM2dRVWM1UlVxZkpXZStJdE9paXBxYTFFcHRMVnlpYktXYWFxOEtOYWhEeHpXaUs3cis5MW8vcTlVdWlmOEJDeTI0TnR3VWJnLzNoQWZEWThIQ0JoekFHVWhnd3NwWURXdG1uZXc0TzgxRzJRVDdMdnNwdTh4K3kvN0svZ2IvUVVYQVZid3UzaFJ2aTNmRisrSkQ4Ykg0Vk96aERoN2lHVXh3d3N0NERXL2loM2wzV1R5Y1J2c0ZpNTJGVWpibldEV1lvRkJLR09Na3B5b0FBSUFrcVpRc0pReXh3ZVFzbEhJZVFtNFRFTVk1VlJVQUFFQ1NWTG9vWlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWRlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQ0k4TG5UYVg0VEdZTUxXd3VzQzZiQ0JzcVZWVlZRRUFnR0ZLU2l1dDlDRHRTSE1Hd2RQZXNwSXF2NVFGRGF5MGlxVjJmWDdPYjJJN0crR1lQNGVUaHE4VjBhN3NqSzhuRDRTcTl5ZEw2L2JVU2xLMGdPUVAxSG05N3RTOVNYV1duQTNKRmVSU2dNKzRGQmREemlPcFlFYzhpVEpqSyt6aVNBaVYxS0lsYWd4cHhSd3JFcW5HRkxQck1kQ25wUm9UTkdPaWg2YUI0MTlCRUk5OHpIeElYMWVsNW13aU4vN3JjeHBhbHB0NTRnbmZSNmhTZzYyMVY3K3pMcVU2YXhrdWtPeXE1SndYU0E1UkNKRlF3b1hLb2NweGtCSzE0bkdCbkV0OVhFbDVwSXFTQXlBaWpjNWRCWm1ycW9UTWxjUkVVRnZNZ1RTT0EvRnF4UjFlNUJ0ZnAxUS83U2Z1ZXE0cWdPRHAvZlpSSFRHV3JML01paEtTQUZzNXFFbUhQb1BPRzNQZHZFZVdyTnJ3TmFRcm9haUtsdWlKcVZpTFF5NTU1aCszcUJKTEw2K1NEdFpVUjMwTmR2NEo0TEw2VjZGZERWVlZ0VlJQVGRWYUhjWmxQTWQvdUJNMWlaTStlVk15QjZkcE9xWnZCaUc0c0kzOXlGSjduTyttdkYybmRTaFAxYTN5VUhDSk0za3JubXo2bEgvdTI4YjJ1ZURDcHhiM2lQUk5NbGNJTDVZOS9ibUJQZmIybWQzei9PVHVlc2ZVdmxaNFNPY2RpamZvT2xGcDFidmJmbFIrVTgvektzL29mVXowa09vRGFuZm91MG45T3YzWHJLR1NQenN3MUM0MzVOczJ4enZpZ2Z6Y3dlVjJ1Q3FmZDZpMXgwMzUvbk40NG5OMG01a0x2R3lzc0tReXkzTzROQjRjZ2llUUV1cHhnRU02Tmppd043M0VHTGRQeldxZ1FHSng3ZjJZUGI2RUNzb3ZyLzJscERrUEU1UldhdWxsVkZScGxWVjBzTnlFbFZWVlNRZXFycmh5Q00wbmI4aW45RGI4TWRSbnRiVUNCZU1LbGVLUUN4WnB2RG5mZUJ0eFNVbGE2cUlyZXFJdkJtSW94b0lYRXpFVk16R1hxS0xKZmdONzJqbW45Q2dNekdtOWFJSG5MQ1NuNWpraGx6T1ZQdlZRY05DbnVTU2dXcVZLVGd6bmpaSXhzNzgvdTU4UVBhTVF0RFlFeW8zd2dtd0VQVTgwYmxCVEhUb2VzM1ZFR0RRNGNlRm1SOC9aSkZyZ2lXTGszaFV3d01xWlFUQURBT1dZd1FFODZEdzFiNWxnN2hOVC92S1pHYmFVTWhrR21TZlY2U05jYlFKV0lkMnhpaU52YTVZVzIzcCt1cXRnVzliYnZyS3RlWFpDMGZhSXNLOXNiNERYUVpxT2p2ZVFzbVRwNmVRbGFxbFY4NTVwZGF0a0hOSlQzeEVpR1RqR00zYkdKK0dkcDRtSnUzUndOVGs4cHVudjM4czc3M243NVRmZlNJclBQdEVXYmZZbmV0WE00QzExR0hod2VFK0VienlFOUtkVHBSUE5RRHVWWWh4NThSMDZVRVdadkxCNGduWUc3V3liQjJMS09UbzBRcFBXdDN2cFBpdWRjeDhnQUhuVDVrUkp2L1NDSFY3bnFUUkkxZTcwcVZOSHBzVjBzdmcyS1MydThoYmJPdjF4Mkw3VTFXTkFFMXFrVysweUNwY3hMM1NSOHdqTW03K0VTYS9ENXU5cjFtMXo3cGduY3RjOUMrNTc0R0htaFRibXVxTzVIUXVlWWFmbjVGeVNueDZiakpYZmpwd3VnL0NFdWRWUmdDT25LeUE4WmRTZDdqQ2NKQzdwTVVrdlBrRFF5UjFkVFZPWEVjN0hZcURTRGdXUVBXbkJBUElSL2EvcmNHT3MzRFo1anpTM092SXdlWTgydDdzS01MbVBaWVBxaHJhRzFHOGhrNkI5ZWxwaUtoRDQ3L3dIZ3ViL043d0NJS0JCb1JVdldGN2VZdWVaZnlRQkF4Vm94WXNXTk1TalM0bm5TczlQelVramFqcFM3Mk9ENmR1eVdmSDV1VHZ2NkR3eFZKWXV5Tlk1OWxBQ2hzM0RSVlp4bzFtVEowYW1SMHNjSmFCTkprK01UdEIyM1Vjcm1YUmpWK0YyYjh6dVk1WGxxdkhTc1hXN1oxWGtxSmF4bTd0N2s4cDhOV0VlTFhPVk4zT0NneVpmVFU3UUI5eGo4OWpVNU03bXMrbkozWlRYRmszdUNmbHE4ZlJvUlVKRk9TZFJEUWY1YWNrRTl6Rm5aMjlmUU55OEgrM204UDhsaVovbm5JcDFTRUpjZDhPU0Y1YTk5STlYL3JQdWc0OCsrZXlMcnhWUmt0a1N3TzllT1dXZHQ3ZEIvNTlPc3Y5RTdWTlZ3Vm9JQWhLM0VKYnl4aWNoYzlsNStYb0l5NG4xWmlpV0tScVBGcWdLb1dCNVNMSmt0aklxMGtGeDN4YXdJZzBaWVpSbUxxZWtjRnZBU3RCQ3lUSCtQQlNyQWdYSCtEQVVxNDFSZjU1Y0g2SDgyamF3cGtoZEVxRmIycmc0UUl2Vm5hc0gzSUFVM0NMV2RxNXQ5b0NCUmF6V1pUSzZHWkJlNFNqZm9MaHZkUmhNRWhaSnRpVGs1ZytsMFVMSE1mNDgrTU9CZ2lWaVBhTEswbHlWWmRYczBVUkRldDUyOXJrS29lQXNzYmNCZDlxWWZtQ3RhUDliKy9ucUFOakx3UURZQ0FCZzkvZnFJTWJBd2lNeDlqOEFFaS8zUDVEYkFiZzhRQ1FBRmhoUUJ4YjhqQmdCZFlZUGZrYmNCNEFSRVNzQUtlZjV3MHk4NTlMTXpPSTgvU3FsTlJBZEVwMFNQVlBWcnQ1WXJhM0oxem9XL3Z3SlFFcmtnWmlKMTF3TTdBMml3ZEg0OStYLzlWa3hvZnBKK1dpaC8vOS8rM3gyNmZyUytOS3BwZFFsK2Z1Zmw5ZVd2enVSVVJBWUNxQmQrdmZzUUVaU0JpWGlQQXdQc0NVNjNNcWlHQjhCMlZHOEUvQXAwT2U2UHcvNEhPaWJoaSt0Zm12NHl1cjNNYjRHa2VKK0FOK0FhSER4RE9ESElGb1E3VGY4eVVabkc1bGtvMGVNVEc2dUdwbGlxMWNhbVdhclZ4dVpZV3REamN5eHRaNlJ1WGJoK1hFNURpRC8veFFnVndFd1UwSHZCYlVHV0x3ZUFHQUdBTTVCRmRVSTluS0I4MnJSbktIaDRxRlRoV0dVMFA2Szh0bnBFQkpGMW9LR1VNZXlBT2haQmdMVjVsZ3JIcTN0cnliT1NvbDFqSCtJQWE3eEViT0ZHWTYxOGpYaCtWV3BIZ2RYNGhCS3Y1N0RCcUxERWRqOFpKR2tWSG5Hb1o5QVhSUEFFYkpwOGZMaHp4aWR0c2VoTWFGaHgwSk1Ba25TS0VhRDhmYmZIc0FoemxPcUZhVWMweEV4eFlDQUdROGVQWjBkQnZkTkp4NHhCQUdleE5mS01WQ25qTEN6d0ZDNklTWTZ0MUx6RFVjTzFZd2dnV052YWp0dGVUMjNGUnhZY0xuU21uWWFiOWFGUS9UeGlWKzNpSlpPRDJNSC9BMnpvVzlIbm5PSDNrcUdNYkIvaDEySnlscHpkakNkZ242RGRFSk5qeVlvV1dweUE4MVM5Tm1BNTdPZ1hZb0kzcUlGc3hqaVlHTFVRVUpOU0FPTkhLRURHczFzZGQzRE1md0dDUjBRUmlnTDNkNjl1OTZRTjBnazQ4emtJbytHOVlDR1RZbU1lMEFnM0dJaEYrakdXc3g2YkxVdkhHNUhjQzFIbGsyaTdlSE5Xc0t1aXA4Qnlsb1I3bnE4SXlJVk44dFF6bUZPaHVpSTQwQ3RiQUJIcnBNVHlzZVI2Z3BCVEdQVU9rMlF0OXFJR0RaWUhDNWc1TFI1ZWlta1FLN283WUFEb0d5K3VQSHN4dFBKa1FUSW5VMTQra3NRQUVyeHlDRkZrTy92WHlBZmJ2eWtFYzVCQW9sa3RzZDlObVVQZitnTGtkdjJUN05LTmtlUEkwcmlqSVpLalErVU9YQ05VdityNUQ5MHlOSkh2MmpmZEN3ZHNLN09ZVVp1QjMxOHN6azVVOTEzNWM0UTd6M2FRZ1dvVlBZZTNjSG5YV3MzcTZGUzlYd3U4a3BXaEhmVmlnSWdvK1RrS1lnWm83UGlMWWd6ZlZOWnNReVNiZlR4ek1teDl0Y3FMVVEvU2lJVk5xeEtNeEZkY2xmbG95NHYwcFhaSnA5VWxlTXZELy82SjVIU2Z1S3VIR2g0a3pjbnJaREsvNFhHVXRXWnRwMHBkbm5ydkY1bTZORDYwQzdUaFNjMWFZTlVabEs3Tmg5KytTQzhTcjlKODUyVGtsVkxielBsYUVYRXgzK2JmdlduRjhYT3hmREhtWFlsWlFYTEVOTXliT2xkMUdmM0hOMHhRUVlobGRrc3JFZ2h0MVlFNnZpY1RWQ2ltVnhGQVBwRE9IZ2VVWlZ4Wmd0UmdCVUYyaFIrN1RVSERWUWdTUGJyc0NlT1o2N2NpdEdiM0htSDI2clZRUWI2b3kzQ2NSNVNYcFpYc2dtTWtONUtrSHJqbW5PUVNzNENrV1ZMcjZub3Y1WHNkTXNTVmY5dVlRVk51VTZrZTJkNUozeHNpci82cks1bWVKOUZYQXFVRVEwK0R6a0lWOTBkbEx2emNBNXNpR05UNnNaM1FwYW1ibnBuN210V3g4Ung1ZldhU3Vod09OSW41UWtkRCtWWVYwL2lwRnRRSWpmT0hObktua0owNHAveWVQNjd0MnY4NlhlNHNKZlVMNmJmL3V5VE4zcDdteHVhbTVXdmFUbTRrb29vbkpzOXFzSzdvRFExV3QxamVnUE1BdmpFcFdqU3FiNmJkemZjZ1ZsYWl1elFESEVRVTQvNnBnZklRZWFVVFo0dURNNUFtd2F5VXpYU21XSWhBZnhCMjByKzRIZmw1V2xEaHVJaUJpME9iUFd6dzJDTzNHa2F6UUI1VGJWVThNZiszYTNHV0hLUkRrUnFmZzN6cE1zZ3RKNFFHY0tDdW9tcHZwTFlKc3lta1FmSXlzbk1EbVVveUljamN5Q3FENjN5UEV1QnVyaGlwTWJVaEFnU2FOQWUySU5ieHViL0p5Yi85ZHlWbCtYNGJZSXNOdm56bE9Zd3dVV0JVZlFIQWxVdnFicUl0TjJKcGJKSHJic1VtWkFERUVOSFJNQ21pS00wQU5XOEZZNUFlWUkzZmpPR1lkY3dudWFwSjBwMU4zc3J1ZjREbXN0QnhaQTFLMXFpWlRhTk5LeHd5V1l2WSt1V25QZGcxRXBNVWdwNkloT2NuUkYzc1c4T2psSVBPalE2WkhNVVJ5WlNwRkZ5UzYrSktGQmREaFF0R1ZYMFhCeTN0RmttelNNVC9tRGFha1Z6ejNTM001TFRPZG1rNGxaNDQvQWFTY2pWTE52ZzJ5SXYwczlzQlllMkNUV3RYOUo2UVd4UUNNMWwvUEY1ZWs0N3pDdlZ5ZU5VazRmdFRBeXAwREw4NVlCb0ZWeHVaY0lSdDU2aUdpVmExUzdmNldwMER3MkI1cXlnUVUzUTJBVm1rNTFQSHIwRTRuVG1YRlViSlFKeUVFOTZKbW1XMHU1Zjc2ZUxkRmVOcUs2M05hcDNDSDVjTmt2L08wSzJrOXFWVnB3V3hMTlJ2Mk81OXFQOHZ4Y3RhNU9oMlR0S1BhdmtUTmhSSVRBRmNWOHZhbFFIZWxBQXlTTnBqMkRQYUYvL1c1bWVrMThVbjcxN3BxZGMyYXd1RzhISGhXcUpFVk85V0ltMnlvRTNCTnZ6WWV4UTMwMjFuRHUveWh1OFdjSVVZQThkU21wdTlOb1BHNUJWUHl0UUtmbzNkWE9SeDdrMGFOUkdjZDBzVlFkUU1LSnVhZ1VNakVHempwdG1SMjlKTW1VRGpuQlgzbUM3dXYxTTlZdWg2eVhpZUhBWHVSeEowbTF4SUl5S3Mzejd2bG4rOEtlV1NwV2loU2puZEtnYStoUkhadkRsTnhjbDFxMG9mQU9SbmhndnNDMHJNMzdVZjZQNHdVL2NGQXhKYit0Ky9QMzg2OVFCRnVOcmJ5c1pBcjA0eGEyZG5KRGVmdGxnVVBBVkYrcDc2dCtncC9PYXdwVEg5Y3FMR3ZYQzRCUThUV3g2bmFjS0hlbStISmRsbW1ZdlVRemdTazFlRDl4WTBkTjVrVmFyR2o5M1ZkdUI4N3JTa3o1cVcrVVh5R1JvRklYRjVpRE9sSFcrMU1RcW9Xd1NxTE9GekVkWGFEYXFGMThTcXNneDhiOU9ENVlVYVpKR2tzVER2cW5Sa0gzY21GNzdBYkxUSTMzd2Vyekg5bTlFTGw3T0ZHdFE4eWJONEt2bGI2VDc3cnp6VFhsWjQrdU9uVGh4OUZ6anpsdFZaL1lqci92aTNIYzN2UHJ6WThKUFZITExVSXdCOC9uVE9ITmRWZmlsaWZsMWI2WWw1RW9KM2J6K3g2bGd1ZUdOZEtxcHNDaklGMVlSMVRzY09BNnBqbFJEb1ZJSnJ4M3RvZkg3MWQrT2FTQ0habTl2SDJRRnVxVTg1RGlidWN2VHh1OFc5bEl0VjdsWkQybTR1bEZsWmdyQmdkQXZVMFZML251dTVsUk1uUHdmMDNSS0cybUVVU1JJSHVnMXRTbUhYN283U1V0RlFWc2xWVEUrWXNRb0kvWVdqQjJVNUE4YkpzSzFxVUtxYUdTcjQ3N3BkTm5VeG0xUjVyVVBBMzlvZDRWYWV4bHFrQ1U1emhqRXd6R2M2bmFIWGdESTJWQ2xSbld3MG1PREtUV0VTSVdJZGxwU0I3cTZrOE9CMlJkN0svdkRaRGswQ2dVSWtCRmp0QkU3Unl6QmlyWGRWMTE2cjJocEtWUnBTRTFDeDVLSVNESnkrSVl4U1N4cStjZXRMV0JIRGhheGRBdm12L3g0V1paRGh4bWRRUk9DWGovWW42RXRXajVwcFZFZnhvV0prZW5CS1hBdEhuYVY1TkRzQzNJdVR4bU10Wi9oWjliK2dGZERtSVBONkxQcmZzaXkvY0hKNURNdXVkVDN3czhtbTUvNk92NXk5NDkvR25tY3JDdnM4bFZOblUyamRZNnU5dnIxWlBpU2htbXFnY1JwRzV0TWVxWjdDdXA5SEVnRmkzZEpSalgwVi9XK1o3cUhSZnVtSThXRW80NWNqT0VIclRwSXJPdERteEFvUURQcGNJZVRuaSt1ZXFVa1h1Y2pwUVdLRlRNQUNoa1gvRnpIOVk5VHV6RWo4eXo3M01HZUd3NzgvakRjMjk5MnZ1eDlsVjNuc3A3VWRIcDNxLzdvaHhWNzE3NnhPdWhsb25VaUtHVzBDeFNPQWI5TWpDZExHV3BSeEpnZUVyaUlFeVZ3RVkxNmx3ZHhlZXpOSDdmZnpzWnRXMUtHVFVjcFAraG13LzRhaUladUJmblBSUHBWZ3BCUXJuUUF5NXRPWkw1YXg5NTVuM0ZaSzQvaTVDd3YwMGtkVzMwb2RNQ05menhXanVTQXJjWjlINE1XV3hoNkk3VEhUSUpqMlZsVEtxY1IvY0tta3B5cXFuVVlWUlFxYWRhQk9ockRGeW9tUG1CbDFIMGtBc3M4aVZNcHJFQURIQ0FqQU1RSVI3d2dQMmovMERNSi8ybVNZNS82dUVwaXVYUEwrZThxWDBnZlRlS2Urc0U3WnplVnZmcDhGOHBycnJNM1JHTDdWOHo3d2NyMlBoTVlwUmJ5eG5oQVRuM0EzQWF4SDdySDZWY3lqOEl4WlBrQzM2MVc5VWtoa2JJblA5V2dDQjJONUxoNlhqb0pWSjNRZisrNGJOaWJYTng1anlvTVpXSzl3R0VCUzhqNnNQUkc2ZEdxQzV1dmNIcUEyNmZjRlJUeEZiTWRhZ3IwbDZnNExGR1FDbVVFNjErMkxSaVQ5SCsvRi9abHcrTllWWWUyMlNaNU5hVmoyaGIwejR2ejBUcWdzd0pLZ1ZxN3h2c3dCMzFqdW5WVktiVUVxVzA3VllPZUs2NXQwQjdGUHpqQnEvbkpxdUlXdDhWSzdHVlpwcE1pdDg3ZDlOWmlSQ0Z0U1M0NFBZWk1IeVJJSDhSMTdwSUFLNW0zUVUyTEdjZndod1J3QjV1Nzh2YzVUZlVDSjJQMTA3YWd1TzlPR3E5NGNHeCtRS1dMTnNUUjBuSzRMdVpxSnJGVWNoQ3hlTVBuMmRjYnlqZDlnZXpUbHVkRUZJTXJSU1lHY20xTHN0MzJVWm9vQmUrbU9mSW5GUS8wMjBzYlp1TTh2eEZoWDA1M2FJajcxTHZteVdsRXVkZWNuU2VWaEtBZDdGWmFTeVVjSlE3OHNycmFLZ0xUbGExUmFzVE4xT0I3aHcvbGhoRnpiTC83c0ZyUjhkdzVYMWljZVIvbVhTNGRaRjNyS204V051Uzk3cGF6Tzh6d0ZQdFVBZkxKN2tFZzhhbitLUkxGMDhJbjR6R3ZVUmxPdmxxMU5DbnRWTUNVbHYxR1YzMUhDYUF6Mmo3WWliWmZIQzlLcjdVOFRqcG1vM1c3RXh3UEo2TVU3NGR1eDdSOGRSMldhSzd0WlF3bk01cHFEQm9ERGNvM2d4bE9BQWFvNGJUOTJyTmZLcTA3MDBPRnZBWGZjRmtwMmFmN2lpZ3F0SVZkdHRkUmdycExnaWQ5OGdQbXU4dWpzWU53TGxIVFZ1Z0liVEtnZHFqT29XWmsremdyRDBQb1BJSmtWZWRCSTlaaUkwWmpqeXYxd282Zmg3aTJBWkF3eW9mQzhRMVkzL3p6VGZEL25UK25rbThHbldQckFRYnB5ME1tcmFPVWIxOGQvL0ZJU05KVUw1L2puY0RMem5TWXhuRDdjaWRPVTJHYnZaSWpVME1CZ3FUWHBtcHpTNjh2MG1YR0FtTUQzL3ZjWFpWdTJ6ZzU4UGpHY3Y5eUIwc0hodXk4c2c2dW11d0UxTEhieHhwSXU2SkJHZ0VxVGpqY2E2dVYvWFp6ejExOTNnNGFzUnV1NlBiQXg5d1lodWN1K1AxbWZPSHFjRzl0NE0rZmM4UFYvZGo1bG01N3Q2SUQ1K05nVlN1aFRUaTBiUzNpa2p1eHc1QWNKbXBFdHBwVnNqNHdURFFQTmdLUmZFYUpzSVN0eTRZUEZpSlpBVWtKRTBubUo0VWMyR3lhUnZLdDJIV1hXbXFpRGhZUWl2U1lxOXQrNWdXS1NqZHJacFVwdHd1b2FFTmdSN1hBazg0aHpJTnRhMEdLdHkrTTl4SnNuSXJYSU5xdkRHN3Qrb0VnaSsrN3BiTzZ1QlNSR3o1SUVlZ3JZZzdMTmNwMC9kY2pqaVRKUUJ5c3RxKyt4R2RLeThOOVlJMmhqNlBBZGxFM2ZtRGF0Zk1hVlAvWjRZUi9semQ2RSszelJNaWhDMTB4Nk9FRmsrT0JoNFUwS0tNSHRpVkkxQjNpVTBHY0ZDMFp5a0Nja1lId1l5M3JwMmttdFJCSzJwMElxQnB5WEhkWTRJaUxZbXBBbTRNd0VpeEVMNlBlcm1yS1NMckVadjlIZzA1WkJvY0ZGL0V2Q3Y4YTJsdTNXRHVWWGVacHoxTFAzSCtHOTB6OXJGaUwxVnF1V3ZrclZoVG4zRnBIa0tXWVlGVTVrcUtvRlFSNGk3ZDYwSEtMcWNFWGtUSmswSWhCWXdHOHR1L1hUNTlWZVFyNzlld3VMT3ZOeFdOLzBWajNGNUd0TlgxSXk1cGxpemtscnNxejdHb2haWFBlYytIQ0NrcjFvYktFUXkyT2kxalRVU01oanNBTDRtamtSRW1JR256dEliT1NoK2xLSG1wWllJZFlwd3ZaZDhYVmVYNDhBSzE3SkJ3YUFVNGdRa1lBSFU0aWRuclZOeTBWdk1FclRlRExUQmVBRjNpbnA0TGlKeEViemM0NythSER5bnVOSTF6b21LbjJWWjNsY2FXT0hhdXJJSUQvNm83bENUTWc0T2xLWFIxdnBXdmdjZ0Y1NnJ1SzBpYjRtQ2ZSWEtrdkprdVh2VzM0NURiMHdaamE3MVVsNUxFNTVNbkg2dC8rR0MrUUNISFhFZnVGL3QvaTczK2dINjVKcmIyWFI1NlFRQVpxSUR3UUpEL2RheTFJa2U4V0JCMUpnYitTVkR5Zzd0TE56cU9YcmtPREI5UmV1ZFhUUFhyVGRQS05POVJmdXVFbWdPZnlUQzgwdW9ZU2UraUFFdDJoay9BNjBnTmg3RXl3TXFJaVBSRFprYnVNWEV4cnRkekZES2tXY2JHWSszV0lZRUFEaXZJYjFmK0hCZnQ2OC93Z3JiZTcvLzM2K0xtbmp6c1dwc3FkemErSVNLa2xkdVRxOGJkaTFXNU02TnhEOUY1Y0pWdFNkL3RTWFhlN0ZrLzc3WExWRlpocW5UR3g1OWlCUXIrSlZ1MVk2OVhTOUlPSDRmZGhjSEtwTnhHTVV6dzlVSnVwYlIrL2xTdi9zZXBTYnIyT2ZSMWp5VUFDeC9BZ3gwZ1JabUcwU1dscDFOOXZTbmg3QzhYY1BKVXE2NnI0UlV5SjFxZmtnM1hhN0l2MjFmY0Nndm1heWFnSjdGYXV6SktNVkdDaWpIQUNXbVViK29zUHZlZUd0M3Btd0cxSFBPRlU4NEpySVJZU2d0c1AwNTdtcmNBTGVMYnZ5ZFBjcC9BVVhvREZmUkdnUkhVY0RHWENMLzV2Q01jWjNncGllQ2ZSZktMRGZWbVJQQWpNZzdWZE1tZ3B1KzhpTnVYSVJkSFI4dklVREpVTWZRb1lMd3pjYVFTSFJHOC9uMmgvY0FKeWxtOVlrMHBUWUtJdmtNRWh4SnZoSGNzQ2NnSE1Pb24vNm9LRWl1bHN5RHpXVVN5TkhaUS9Od1RsK1MyMzFKTEFlNVc0bzZBZitrOFFUNndWckVuWVlLVklmd0puRlk1THBUVThncElTQkQwcHlDdVlMd0F1Y1BtcHdZNng5a1doRkxFdXdpcXBUZDBGZzNNNjZaZHdYVUlHN3NKYjE1MHdyMUM4N0RWeU1sSjNDcUpDZW5adTJHTGxweXB2aGRxVHN6THZ3MFdNZnNROFAvL0dkMG00RGV0MEhTblR3SlEwQ0lUQWxQVEFBSDc2NTYyWW53YTlPblZDekFDSlNkSVpxUUk3V1VYMThQZG5TbVp1MWlwaGM1VTZ6MlNuMUp3WGozSVNqNm81bjVMZGRXYWZFclphNmRyTmtqT0pPRlpDcEx0YlFzVEpoSWptUko1a2RsTm9vRE1sbE4wVUZsQUJCdld2WWkrYWR5Y0tqcEYvdEVKczZGRzlJMy9PKzkzREZsUnVkZ2l4ZDhyT2VBQlg4L1hxY1AwYkdtWmI2OS9KRkF5WnNRV3BpT0dVTkxaL2FqcjRRd0EvdGJiZG52KzVsUFpwcWVUVXQyN3lUUTFiS3ZVbzl2Vnp5RWVHNG52ZVNQZXNKY0NKczFRQ2xVeENXeCs0bXcwVXRkTUpOUUhYbS9qbDM0SlFQby9qNzZ4ejlPajF0blJuV2xtNk9sbmIrbmphOHlHRk9YUXc1aXhoNzN1RGV6TTVHY2RUeU41bWRKNDNydWUxaFA0MzcySTI4MHoxSzR3dGxmTlIyUEw2ejhibkgyejA2SUxITzZPN1dnSjBwZnFEcWxoVEV6V01pdU5icnh4Skg5UWhVbEdPNTRQeWhGM252VE9TQXVLTUQyVXJ2eVdGUzNrcHJZR0xzUlhqQ3B4T01qN3JtcFVRbUdoUm9aa3NTYTc5MzdVbkwzR0ljRE1KS1BHc2dIMXJPMm1hUWVJdUpvYU9nOVBwb1FYSVFrdFpOME1hZXdjbFBTY2JNbmFwQlZqUkl3eGdaV1RiR1pIK3RtblJHVi8xdDJ6OHJybzNVc0FGbEVqNFkvUE1xY3kyb2YxYnBHdkVaeWFiTDI1OXM2Rkh1anpiNkI3bHc1bjgzc3NNZDNVaWg3cTZuWVNnRDEwdGtuc0tNNU9iamp5YXVuVkVWTDlYR0NmTmJVYWkzSWlIa2c0ZWlsOGs3V3RHUll4ZmpzUEZKZWhNWEJLUGFOeVdZQVp0ZG9BU1diR3JLODVXSGZqTmFtRmw2UVlGR0xlOU1tNE5adWZ0Q0t3Q0xxQkVacFEyNEZGNTBFSTl2aVJWS0FWQXBwS3BRRXA1SmMvSTlBbzUxUHR3NHRxUlJ5MUZGWW5JTUJtdHVqdlhUdWdhTlV6UkRyWUVINlI5S1R4elp2K2ozUm1TQ1pyS2Z5ZWRYRWRScGRRZElxaXFWTkNrdEg2NE9SVmdGQ21xL0FXUGlOSmZFODViVlNWNVhzNnBSeDB2S1VPY1NuQ29iS1dyQVE4L04yaFpFRmZjOFVYOWVSNys4a0Fxb0x2QUY2VXV1anl4TDJsb09RZXJPTWxjaDBnL3FmQUtZTlZqai9EYTNpV0RrVW5qU1BwdHgwbEpTUUhYb2owdVFXZnFFaXJDWENKaTh2S29uVG5Mb2lZdm9TT2FENkVpY3RFbVhUV3Q5L0J0OTJxTWlrL2xuYkhnbTRuV2YvOWJia0Vzalg2c2lrbVBIMHVMamEwQ3J2bGE2dk03TCtSNENmbVpPNFdIaUpCcGZ5ek5Vb20wSVB2bzRSdjRLaHBWMFhuM3cxajY3YUg4aHhrMnhvYm5VRzhyL3RXdFdoazZ2MUlGMWdUQUhyckU5cmRENm5CSk1jb1pXOGF0MDdCby82OEczaHNMTW5uaWtmbXhnbUNlazRSWUJDbERyVlp6M0x1STdubWdwRGJiWWVBSmlQRXJLSjRiUUJtcnFLb0FPeVZSL2VndnJvRTJMc1RnMTJoZFk1U3dhTDZvS0FvMEJTSUZIVFVwMnFjYjI2WkYrdHZPaUdCeGF4bzlpUjJ1dzhyZzZzSkFhOFJPcnNaSkRCVEkzSFBBNG9tSDdVcWlqNE5TWHdZbkw3Mit2VHIzNjRMVXp3dXoxMWN2dkFia0x0R2tkcEFVSitvZ0xINHRWQzhBYjhsSTdPUmx5cGc0V2ljdVUrRzZKMGhvdDJtclBGZlJCbmlpNGpOS2JBd003NHM4UXNTNlRDekx0cGtTcFdNTjBoNTRwOEd2RWJBdFl1MHh4YStjQXEyeVI2YzZPeW5OR3RXYkV2Vk14QXdkOFpaRXFubFlzcmlia3pBemF0dzI0NDNxbmZaZmFXMlk0RlBjbnk1UkxCcm5XNGgwb1dJSS9nV2YvNTlhYllYR0JYWUlCRTdaZW9rQnpIelRzZFFEVHM4elNsdWRBNU9PeE9uNFM1NUQ0Yk00QjNvRHk3OEhsdlZ5eWlGWFFacEEzRVFnU24vZUxvNVk1RXV3ZklMSVRFNFpsbFBPSlB0eTBMNTg1SE5ORkh5VERteDF6aWgxZW42Z3h1VkZkbEVqaVNYb0VPQUMwVlkxZ0JKVm5jUG8rSGZFNFFtOW5BTloyWnp5M3NDeTc1Q3RzTm5jVEZyYzRpK3gzOFlXbU9DSGN0NFJQSC83UUF2cEJQVkJ6VnVISm5oQWpXQXo2SHNDd0pUQXdjMFNxNGxWdUNxdG13dDNMaFZrYTlwby9vNXJOVENIM0F1ZnRXNUpkUmZJaHJXTURGekdhbm4zQmlYVDhuWWsrTGhuR1o5TG9tUGZNWk0xN0x2MmJ6ei82ZVdVWkZJUW1aTU5uMVA0MWNMM0o5QkZha2ZzWUdyVzRJTTFPSCtqaGcvZTNodzNWNzlnNEhHcU9SSVJvdTZVMkthVW1PN2ttQ1pBUjNDcUMrS2NHb3A4VHVqd2Qwem9UOGhUWTh6bFJ0YjlGUjZMRCs2dHpPYlV5Y3hWWWNyc2Nva3QzVTY4d0UyZ3N4VjRuSndGTEM2Nkx6MGw5VmkyYkNSV25YY3VLL3ZJdFRzbjN0VlUwR2plMmM3ZXRJcThDaGVhejI3N0wwb2hoQituRTMwMi9ieklHemkzREMrZllBYWRWVys5cEtoZU83QjcydTZXZC9OdlJQczN1REhaOVpMc0JvanNCRFJVVG1LcSs2T1U1K21sYmJoam0yZzJGTnhGRVl6cXJobzJ1cjQ2VHFyU3FaakpxaExqU25RRmxqZTNXT0J4aEF0U0dzbjVDVUhHVmF5Q1FEYWZIMElGcXZtN1pETmZXenRMWjEyRTJsNzVaYjBUMjNycklCTUdqZSs5L2Fselc3YS9pdTl2UTdHbTZpS2tweDJscHJXUGFSenZnVUk0S1hmbDNYdVZHMkFxenNHTjNhTXl0dCt5MmNMVkNCV2YyN1J3QWpId3JRcFhoYTNHZ3NXUk5YNE5SeUppUnRKeUJ1NVhHbGQ5SkJyOGc0RXh4VkVwNUloVStKeWVrV1VwNHdFak9UOXpUVzRmNWtDZnNMWVRrOUZaSTN4RHJTd3MvaWNBZFhGT1o4Q0pnRXBEWXlLKzRsTFkyYkFhVy94T1l3am9yQXJWWmFuM0VuVzgrYXFGbFYxU1pEUldLZ1hkdTZWd05JNENTYzlXWGRBUHpZWStYakpEM3pFRHkxQW1Ba0VpUXhyNk4zZXJ5NTlLdTNLQ1UzSjhaRWhPY0U1a1NId3l0aWNnM0hKZXpOUk4yOUZETWVtV2VZZlJGcHE5UzdvMVMxYWJKWnR1UFJKMmtFWWQ1cmVTUEJRZFFkZHFDRERWcGJTNUFZa1NFWlNka01UYW4yM3plK3J2TkRRWlNBZ0U0VXUrTmxWeTViajRjVXIyTGdaWjI5UnBtL2YzZ2dkRElrbFRvZ2ZTQzRkWkdwRG9jY20xcGptUUd5TWRVakJEU0l5WmpRZkNDeXhURzVFUlFPOSt6VXhYSVlMcEFxWnZtdUdDMHFKc0xoeGJWOXhNZUdXSSs1OUJiODNSQllVdnYrRTZYeXJiVFZmTVl5Y21pNCtjL1FqM0ZZNVZyLzBLczU2ZUFhWXNaRkxUdFJ6UnFFTW5UWTZnenFJblVNc3I2NzhmYnI2ZEtTdnVzbUxqalloRm43VXh3WXRuSXptcjRXQytvU2pxeVNncGFtNnRLSTFvaHNzd3M3ZTl2cWE1dGJHMmZlLzFtZmJFUXcydHJTME5zVzB3QlpmRG1tcktXMXZMU3Jxejc4d1BmTnlBSVRqOThmK0JNKy9XWVJoT3YvOGZ0aXFKamwwN2VxM08vT3IxQlhtRy9JSzhScVdHOVlJMXczcmh1K2xWK0tjdmZDeGMyWEwxY3ZobElDLzQrTWw4dFZIcFBNNVFSYnRidjFHTWtvdlUraUNiVmIzREZFa3F6WUFUY0ZyczBkM24waTloMUIvcllleUtUa1pMSWx5c3hoVWp2cGQ1RUFuTzI1SWtTVHUvU1QwMmNwOVUxQ2t0aEM0NGpseTZlUnU1OG1PakNPR2c5TUE1VExhR2N1OXYrdjhneDE5eTVZVlY4RUpkWFhpaEZieXdZdGM5WVJWN0FoUjVKQ1BEZ0hoUVpUNzA5dTNRK2RZTTlkdXpXek5hUmR5VGo5czV5ODNjZU9lMTg1L3MyL2RrZjM3dWs4WGMvQ2tWVlpqYXYyL3hhUzdhaHZyNmRYZjF3d3VieXo2VTBDek15Q0hCd2hBdTJZeG1VZkpoYzluRDBlb3UwQ2VqM0QyTHNvb3pveEpQQzRhakNYYTJKSHNubXBucDJVMVJ3d1hWQjdvcmhjUTRkZGZSRmhtamFOK0EzU1o2eiszMFdMakg0TVh0U05neHJNUldtYUI0V2ZaS2dzNncwdjRtS0Z3R1VyanV3RjJ4NXBNVG9xak9nTU5TTFMxU3RrQ2NZdnZnTzV3YStCQnlQZ2hNN2V6LytMSC8xS2RQN0pzelRiOTFDd1JIaC9wRWV4bUZ6UGJSVHpzUGE5T2NIWjJjYWJEN3Z1amN3M09Rc2tGNC9MaWxXUlExdDh4RTZGT1BjbkdCNXREWGdNdDhSbjJXK1hDenp0aURKK0xCYzNVc2R2T1lHMFhEd01YSUtpY2E2dTcxbkR3eGR6UW5JcnU5MkpWdGl1RXV3dlduZzB1Tllsbnl3a3dibWpaTzIwM2ZLWE02azBqUzA5cGVaMlpGMDk0Q2lOVG5EVDJkMXh2aTZYdUMzREdZYUxRZ2dwWHh1Z2xVK0d2bEZML0hGSWdzQjlSYU5SL2NCT0dCSEg0NHVQVkFJYzJZTm9Gek16NWoyekM2RURkd1J1ajNhVE5TTkM4dDl0RUVVQ0xZUFRZeHVFYm1veW8za1h5eEljSGdESUxWNHRtV1JWUUFpbG1wREVxcmRhaWJHUTlYeXRkeUFMT2d5RGg4N1ZwMzc5Uk1PK1B3K0ZSdjM4elUyVFVHSnpneGdNVk81RENDQXZuK3JHQUI1TGNyWEZHNEhGOHhuZzdGSzFLc28rTUF0aHY4eTN2K01WcEpHMHZqTC9GZFRmbVQ5Tjh5NXk2UXhDOG1YYnViKzBDRkdDcGN3MXo5R3dPbHg1dzN6R3VFM0ZLSVBhaUYyZUdvdXl1WnZaUi90YTZwNFZ4REFqdmxRS3FkandHR09CbnVBQmhtQTFvSC8zSlVLaGNwWGZ1dnpxbGk4YWozVlZFMk5DMWJKNXdqL3d6ZmZJTG9hV3BNMm1xNUlyYm5Sa0ZOMVhCeHFEM0xseUlwR1l3T0QyVEVpSVFIK2gxUW9qbWFiSmRFV0pPa1p6OElTRDZPcjFmdjRIN1d4RUZrenBmM0dxcUtPWWN6Ui9pWXVVYU9YaldwTU44a2lKOU9aSlBZNWJCSThTK2p5SXZMbVJXSmZNd29oektpMWtsdUFhTFFBaHNHeHQxVnhld1NET05BTzJia3VQODdoQmlLT3ROUTFoNEwrbTVxL3E4enQ5SUJrVENKcUN2cmlnWjkraGIvaDdHYWRPUklVUklEZ2JKcThqZ01oNm5DN2dDSHdiNGY5UkhKOEtGSy9DOFR4Zm1qUnBzUUtxOHFnUjc0TGhFVjZSbnE0c1AxVEhZSkJ4TWRYMUZBSGxEYUlKSWFDYzFVRXczaEh2VUYrcGEzdk1uUklkSXNhL1pVbE8rZG9TV2pJM3l4SVNGU2FSYk9OcHZaS004N3BaNVp0dmxWWXQrbFlNVmpaNDJtUkVhUm9jL2k2S2dKM1hRaHArMGtnaWdETkl1QmNYTlZOWnVHb1ZlMisvUTJFZnJ3b0gweGYyS05wYUZkeWg5VC9Nb29QelJLZWQzTi96RjB0UzJzdUZpdmRic2xuK3Q3SUxUWkRZMDlHbk14Q1RmUHU0dVBMazZydWcrWHl3RmlGQ2RPbUxwL3lSWW8rekU2NmFhWElkY2pKN1p0RjEyL0x5Zk5iUWE5NUNNMzhhbXRFZzFLNmI2SzdMY1pyZ0dyM0plc0dML0RocGFMcy9aOCtPRE1SMUEvZkhZaGxneEU3UStFdUhmR1I5Zk56a1hpM2ZjYkhUN2g1WjE3bzJwdnpZV2Z6ZmpJSDdyZDZ1MDdlOVQzTHF1eDdkNk4vS2o5K3pUWnZkN2pyRWJSSWhQUlVGSEV5WFhMZ25Rbm5JQzNESXdGZGJxa1U2YTJLTUpBTlp6VVJEN3gxTEpHbkZCYXV6STYrNDlyZGQ5UHFoUEZUdHFBeGtuZHVscjNrL0dSa1JUbnlKajRrOEIxbURaZFFtZmVNKzhORHpteVoyOTBTN0N5ZkJYNnFBZzZRRmh3Y1luVnVFZ1Ura2E2QXdtY0V1aWhVYnBrb2pORENzZ0JIcDQrM0VEUGp3YW5nUm41enFIZTJBKy9wcDV0bDF4LytaMkxHeEIyRXJKczRyK25ZOXpvS3U1MFRtODA0blgxUkFhKytlVjNrZDc3N0RiK1QwWW5UV0xCZ25odm1aZnZkTDcyUW4xd28xR3AvVWcwVkx4N2VhcWlaTXhvVStXcXR3SS9Ia3NUaVpmOHhCVFhJdTdmMzV6Z0NZcEZkNE10T1NqemdMY2h0UmR2ZDNZRzJCVW1NNnNNQTlEVlVvazdUY1FNSGZCV1dkaklaSlE3dVNncmV1cXZmVGRZV2JsWkl0Tjk1N2VlVXBzamprTXFqNUREUkNUQ09UeWdnY2VHR2RsWWpXY1Axc2o5VHdsTGVJK3lNZ3ptOWhld0dSZ3EvRis5NHhnREc5dEJxeUxyM2I5YXpyelpDYk9vRWo0eE1PNGl0YjcwaUpJTVZLUDdZL1dPdVc5S2dsb2NETVdSdFZLSVIvckxOUW9wOUZUaXY4aWFuZzlVN2VVUzNyOFhnSFU5SWM1S24xd3ZwWXAvODFyVjROOW82NUdRckZpdm5nNGJCa25HZ3NLVlBoQjc2YmovSmllOXdYZlpkdnlBNHdIWWlHZk5uNGh5M20wWGVGdHhjcytVT1pRaXIyZ2JSQS9kN2RPdFk5dmx6QWhKakc2ZlFNdm5LUXd4Ny90ZFJpdENtQXZ1bDl0NjdEWEdqYlp5V1ZWUkRhSTdZVy8wQk5HOHByVVQ3VGd2RHJ2WTg1Z1h3N24wajYyVFNweWNuZ0ZqQ21ZbmJ5ZlBIZmtSVDhCdklmbG1aUGo2WktRZUZ3aU9wMmFneU82czlEU1d6NStTMURRZlZoYXdkTytNcDRhM05XOFMvMXpsaVVZMFhrKzhjOFRobHRQbmpwcTl4Z0VMcXk1ak9DYTd2bEQ3eEZjMy84WUNUZVBYRkpFTnhKQW5lN096TlJIMEZPK24xb0QrZ1M1eUluOWJFVzNBcWltdTdHajVyRXFOTkxVaUo3OHZvQ05GMVF0WWsvaHhuMGJTdmlMYWk1cEs2dlBNMGxacUFDdEwvd3IyVjdYUjhGMlFHTGVnNkdtN1NiT0lObGp2N1o1VWcxM2poQWVzU0Mxb0pkQ1FkSWkycFI4OG0vcGhvenM1dGlrNXBqc2xwZ20wZHFsM3JJWnFUY25jZVQ2Y2NweXd0Vi9ZbDA1SGI3c3dHcTExYWZoTFlLMW5IaWl2eDcrWlNucEJwVDUwNE9xNWNmU09wcVhyOWJvRmNIVWRvR2cydGNHYnhxeUdyQmY5UlA0alU5Q3V2bnBYazFhZjlzOU9JVHZ6VzVwNTRCd2V3S0JIc1VGeThzc2RpRXBaZEtXZTh0eE8zVkVKNFhkZ3EwRFVINUY4aDBIcThYWVh0dmFENWpWMjdLdUQ3Vk9pN3A4b0dBcTZyS1A2L01FcGRLKzFCaThRa1VhOXRDOWltM3ZZcGlDTEhKQUM0THh1ZVFCdU8rY1pMRHgzbW1HaGJxanVMem01cXFFcWtPaUdBUWpuMzZQYjkvaDRDS0Y1QUxZcVVmeVJibSszd3NPdXdRcytudWQ4UXNYclJTcjkwRGI1ZXJ4cDlrZldBY0xqZDhLWFdQczhmamhPNE9aNjB1UmxZeXR5N1ZKT1pYdGVtcUpFZkFhUmdjdkUwWWcwUHBpamh0SVlob3dsaGdtakk3T0Raa0pib2huUzBtQ3I3S2JSMGQrN0YzcWx5cmRRZ0s2ODVKL2M0MmRYRTJuVHFuMVRCV3VLeHpJVlVqS0FtYlFubUowY0JaN2dsY1FMNUNUemx2ZEQ4OGVQTmpiNVJXaXQ5dERnZ3Z6SVAzWVV6NHBBN1ZCak9BalR5VWNyL1gwaXhVZlg5YVBkd29zOUpJZURheVZ0V0plWmNkY3pQVmx0Z2kvd043VUFiOUtWNGhDbndxTlowVTNwL2x0cGJQYUxEb251Yjh3Yy80NDU2Y051U1orYXRVaGE4QzJDdkRLQ1BqWjltaERFUEdZelUxUm1FR2pWOHJFWnJYVHdvWUtrTWtzSlRvaWxnUTh1UStHQm1rcnF4UGZzQ2JtM2FrajQwejVQMXRXejNUWVQxWDdod1J4K0IxNkhGUm5yNEh0RnhqdkljR0xwczBCSkRScmhCd0VGblBuY2tWUXUyZE1GS0lJZ3RuOGFCNXhTSkNBbTYxWVBvQ1VGQjdJRndVRHpHZlpJY2hBbzNOckVYbnZDRWdnejFsSHJ6RFVvSFFvWGlCOExnL055QVdnUU9HZzZSaEozZVZMV21FME44VGovNlFyMkRTc2E3elhBMnV4L2c1SFNuUFRjdEF5clRMZlYxMEtQM0YxSmFXR0pkNnBoajJKam5WMmo2L2lOU3BkQzI5eU1YTUc5Q3N6Mit4VlJBdmlMaE5YNTk3OHMyZXl5UjNtUGxBL29yTHdDOWpzcWZYdCtoaG50SElPZm0vdVdPa1EzeTgzbTA4NVJ6Zkt6elJqdGd6NEg2bmFCYnBxYkVVNC80OTZRbmJ0SU9SMFE1MjkwTzBNTFg3Y2ZEZ3lZWGpYaG1BRFRBclV2WUJrMnE2cXlvcUxkdGlpM3lSWFFIRDZWcDdvQWozWXNLNklXUURSc3ltLzdhbFhVeXVKdHFua3dKSEVRZ1YzNmdQa244aldQOVI4Ym81cUphT2RuNFJBMjM1b0ExenZWOUV1QnQ2c2oxa0xHc0JKUWk1a0RZS2tuSEJuQUFVcGs4bkd6MlB4ZExPSVQ0UHRHVjFiM3JheU42akMxdGFWR3BLQ3ZqNmt6dXJ5MmIzbDFGTFJIcEVaQVdrcjVqMTJiY21zMVpqVTI1ZFpDbmZLZi90cWVaZkp2cmNhdXh2Qng3YWszaXZXOHNDMUhLUkRGRkdmaXZYUlFicElrYWZjUmVkcEJEVEVaUHRrck0yMXRZMUV2bjlSWHJmUTBzTFpVTWI1VEhaYVlsSnE3UytqeGVqWFRMY01xTnpVbmZhUlUvaEZhbXZjaEpGTDVqMVdiY3ZOMXJDWVdNaDAzcVB5eEk4dHE3Q29aeUhXUTdCL3ZMMFc2R2p2c0d0THN4YU0xVS9GSThUcGFZdEJaQWVkZ0ttY2tLUmgzTDRBcUNBNElGQVJYcEFVRitLVnh3SmVzVWZlVzRYbzVLSUplcjVkQlRDSHUwL3NyTHpzby93dmRaZDQ3Z2Q1dlgrRGFZazhrcGVQQjJwUnZLQ3JOU1U3THNTaDFmL1Z2RGozWk9qY2pTekJVQWNGbS9LOG5qdi85OFBqeC82ei9POTRUTC9OWDY1OERwLzUrM0hjVVh2LzFOcFlmdDVOL2d1TmdrdTVERk4xeHVTaDJRbXlUNTNNdmxKeThDMVZudmpjRzVySkpvYm9rVjhJQzU5L0FEbStSb0Fjc0pxTFVBTmR2Z0tCZDJ2WEphenA2cUlXL1UrVThFazV6ekJUakE0dVZkMmlLN1NGQm1FTmQ3bDh0bE1vRVlVTEp6U0dsRmRmUlZ0UFdzWHM2MVljZERtSFRhY0VzVHc4T0MxekE5VGY3YkZCL0RUdjVid3cwVjVhdzk1QWdYTXJCWjF5YzNoaDQvL1JpbVRmR3kydGZIa3M3eXhFaERFZFdPR216SmxaM1pIaVJpUFBEZmpjcUVDUEhMVlR2WU9MeUh1WVZRQUhxQVFZNy8wZW90WXYwdnYyYVc5VzJXclA2cDlSOVUrZ0JPazVZb1dQVDlqcWJ6b3hYbjFsWTRwY251L3Z6TlZTM3lFM3M3bXNtZnZPWCs3UnlQS09XeVBRMGp0cE9QRzNWQnpZcG8wRS9mbmFwak1WVDkxTEhWTHArMWdjRjlWMzVhL2xkOVdBM1gyeG1vV0JDNTI3M24rbzE2WlhSUUR6cTdYdG5idlNDM3EvWk9WL2ZvMkRMTFo2YjlTRWJoSFgxUUswWFBTOSs4Y0lGajdXRHlWYmlGYzNOeW1PS09DR3JqYzRKelh2TWlFbkRscGNYdGI2VHpsTytheTB1djhBUnRYZSsrUGJzaTJXOU1sbVNLQ0JZcC9maXhlMkhDSDRpbVpVSDRlbit3TUJkREtnRUtwZ21KN3o2U1hHcTB2ek85N2pZZVRBaDBvczRSNTg2STBnSnhlV3VWeDRYN3VCWTljWmt6NzVCaUN4b0pjbW1MRGltNVZjdEw5T2F4THZNTWFEVHRKQjk4SmFnTkhBbUZqZllOMDh1VzRwSDk5ZFMyTDJxZ2xHUkRPZFllM3RhVzNsNTJ2emw1WjdzNVFHS2RjZkdNQ3JmaFZoVlVoTGRWMURXVlBZTE01Y2VUckFsdzdEczJSc1BaaVp2M291NWVXL3kyczM3SStOVlQyTG8wV1FuUmxUc0UvamlLSDR4Y2NIbjBVWTk1ckt4UFVuZ2tTWWRQV0M3VzNLNWFDWm9sZXFjS2xrS1FwcWpySk9IUWZTTkZ3TStaZDJxQW5sMWhlcm0yU3BWTjFrdUh2bUtSZFBZdWN2SjFKMXFiWU56VVlTYjJnYURqTW5TelNrb2R1QjJRbTVYYzByT1ZCdjBTeEVqRlBic292bmlLMGYxYTV3NWtYYUpXMGlsVjRzVmVHODcvVndEM1hkakdBRUhjbm9hQklYWGpuUmVzbVpZR2VvNVcxbWIwL0N2eDMxcHdBdWpTM1pNMWwwUGM2ZitXbjFqM3g2M3FHaDNTVFJKa2hua0VIb3VxN3JxYkRaM3R4ZkhRUkxOa0l5T1lmQ3U1N2FQOE1tNjN3bVdEZ2E2WkdYS21CMTVqQXhiN3VrU2VRbzhTNXF2Y1dVUTM3NHZrVk5zNEZOeHBVUXU4dDlPRnAzdGFTL3B4czdlUEhPa0c3c2hwN3ZKaW1hMk1PL3JDc1BJZWpCUFZDM2ltQ0dpWXhmaDh3YmFKbVdqeitVZHN0cGhxa2VHYUFMOU5CVnpXbmtqaGN5OGZDc3VZaURoU0xQZi83TitvZ3lyVzV1VUdscWtKU1c3OEdjOWgyOTNsQWtFVFVLVHh5alVCeUkzd2x3eGFMNFI1bGI2cDNWZ2Z0QjgwVzU0ZUFnSFE0dGRqb2JJM1dvQnRuZVZSUHhiN1ljOEZtTUVWSmJxd09ZNWFHQlRQdmxzNXRua2pkMUJ3TjgvWndwbUlNUjdzbUF5WDVrZkNNUWVPc0o5RXg3MGlHUVFaYUJia2N1cGZNVGpjTmFoLzlDdTZlRkhqdnJSK3ZWMWUvVEloby9DMmFIL3d2Q0RXa1VMSTF1d1hyVzVpblJ4SUs0dmFGQWsyNWoxMDZTUUhQcEZmdUNnd3FmMmFqVm9pbjhnQ2N6MVU0QW53NDFkQWNuQmVuWHVuejRsQi92VEYveEF4djVFQVYwdXRBU1lwTkRsTVlFT2NBTHc0Z3ZUQmRPQUZoUGVlZEJUQ1NKL3pWcS9wOXJIQkpTL0U3M3RzSy9kNHVpOEtHbmxIR0RlWE9oRjUzWC9vcm9Qa0I5TVdzdExvMld6WUVtQVY1Rmt4LzBObHdLYUtPUlRRUDJkbG9kU0JSWXpWeE9mQzBSZUVJdGhPaVp3LzJyaXNYMi9iaEw0clB0TGhVZE5FZUpqeC9XUVlCd1B5S1VCTkE5d0RMbEdRTkpQdTlPdC85SC9GUlFnMExmODhVTEVnN25lQnhLNE5wektNeFVjR0Q3SVBEcGtTKzR4WHhhaVZzWk5JOUxXM0UrbnlQL3FMY1R4Y2VPVC9DOGtKam1TSjNPN3drTDQ0aHc5RkJNdjNlSncxczU5SU5HWm1GQVM1c0tsWUVuQWxGVG9MTDNrSmRaU1RYOWQrLzI5VWxDYnkrdjRxcTBQSytNK3VlWUVQMytzOXhHVXM0bVJnem1EbTcvcmhwSU9XMGx2bUdwV3lFdXd5TE12YWc1aURnRmpCMjYyNldZQnNieXVXL3RzYTE2ajhEeHovUkI2T3l1MlVBQy9lM1JsYmQvSzZ1VFFqQjNCNXUxR3EzbHJDTHRPdXp1dXdxbnl2T1VTZDhGSVRaOE41M0o3V1VZRjQ4SGRuSGhaZnZHYWpJZDg1TFFxSlBVQzdWdi9MdUoxRjZ0d0dZakRSdS9DZElSN0h0VE8rMFlZWHczQUQzUkhxU2dkL2JaK2JPTWhObDM5NWZLbWhsRnErVGczMTZWN1JUOXlkc2pNLzZjMnhXdjJ1bi83YVZ6bTE1WityRjMxOFZDTGdKdHYrdnVWNzRoelZIZ2ozTENkV0E2b3BieE9lNXZ0Z1NIZG52cFYxbnM0L3ZlLzZKWU9QZjV0aHIwWWpIMTlBRWhzYS9lZyt5cW9aMGhkcGg4U1NZMDgrNmJKSUkvb05xQTNhdXZvS0FETU9IWEE0cEVlWG1hejhjNlhnV0p1blRFUWZyc3k5SEs4Tmw3eVh6L3ZpR2doNUtYcmNlNUNBTUV2N3MrOWVZaU03ZDhsMnp3QWZ2cXNtNk1BaUxlZnY3L3Urb29zSEpLNkEvQW9BTUgvWWFBVmZtdUt2dVQwQmdHYnkxWDNrRFhBTDc1NDVYcWdYMmx2UmJaYk9teTlKMkpIaTJlMkRqbk5hRjFrb0l0b1ZNL2NxTXVkckhMaGZVdHA1VW5wYjJmWGp3U01GUHV2SVZ0dEpNYTI4Vm0yNk0zRW1HVU9XNFM1bVh5bUpsVWtmTXNkU3dIMktNd3RqTWVZaXNOaFV2dmhuaDBJUE1PZDc4Rk9yQWhmZEtDNGZBSWpWT3B6bEt0UmRQbXV2ZDRoam1zZEJIT1JIOUJ1VU9ld3FxZmRSOCtrT3diWHFMR3EwYUN2cnNUcklqZm9DanpxV2hXd3ZId0h6RjhKN0Z2TWFqME9uVVYydzd4aG5oMU1hVVZuYmNhR05lVG80cnk3SG5UMHBkMGlBWmRyNFpUaGVWQjROblFhM293Z2xIWkVYd2l5UFlUdFFMNmFwamI1cTNjbE5aaFZwL3cwOThTNlhEbnZOQ2Q1VDNyZDhWTTNJelJLUEwrb3Z1RDNkN3pMZEd6VWVIZlR4RkVaeGF4THdWbHQwVFVqZUJ3ZW80NWlWVFlqbE45eitxbkdtM1djMmh5MTZqQjZOK3JJY2UvbVkxNGtTenFVcUo1alJvWE5UMUpWMU9WREhXZ043QXBBZTk2Q1d0YU9hZGZPczZjREUwTGRsaXRGcUVPY29oQlpKM3liY1RsUHFvbzZEcUNnQm5HS29QTEp5THBrdW13SnNrb0VJQyt3VUljNHBGRCtXeXd1RHJya1IwWDNuS1JIRHZhOWpGeEZLdklPYzZWNHB2bG1LK0NVR1FISkxjQUNEK2pEUUlIc0FzNWR2NzR0SUNQeXI2NnpXN3hDY0V2aG9BN1NmaExhL0JPdU1PVE1rbWJISk1pa3huYmRLS1ByTUlhWjJrVVpwNFJkZFIybjhld3psdmw0NWN1ZHNLSkRFVjRsSlUvQSs4M0pweXlqeWhVTXAramc0MVNqUlhGTk04V2hLZk4yZUZYM2EyKzFKajN5ZkhrNU5PQVF5MTlvSjh4bzR6bXU4QXNEclVHd2ZLMCtqUmkzTTNQN0t2SnhOWTA3UDFTUG8zOXNQbnBXRk9GZVNSclZZdnFPTlBjZUgwbXBUa0t6NU5mSmlxNEhYRHkvVE5aMmZGeWd1SDRKYitRb2ZvMW9PMll2UGpCdklOVE5ISmFhcDlQTktFNFpnNkhpanlvRkxOU3c3dll3ZXhINmdqVEdxWU5JQ2FzeWtrTkhJUlNjRVVBeVVkcEZJSXhKU2FoV1RXZFNyTk12clRDOVRVSU1PdzVTeXliaGxocWIvdVd6Y1ZHQWpyTzVpU3FCdml2VlJCQnNOVm1yT3lhdUI0Q3NGbkR1S3BPSmNweFVwRHBCKzlOZUs3NWJuM1NVV25BcDVYMGQrQWRPSVc4TTkrNkFndlFDRjZCazNSQ0RaSHIyRFBvdU9BOXJnZEhJM0dsbVFMYUNGeTh5Mlk1WFR2YmxqWWx3ZUtzamxid2p5TU84SzU4QlBtRW9rN3pIeWUvNXBGcmU4MjA2Q2tVKzVZYlM1OU5LeFlYVWtFcGhkbVlFYmNYM2dBL3A0anUrb0tmNE42U2tyOFJ3RjBrMUZiM3FNZ0plVk9vcnZQTHJ6Ynh4K0w3aXJhSEdoWGNVbTJUZTFXeksrSVE5ejJuZTQzZGNQbW5teXZKdGhqbytmQ3BSWWgrZk50MDluQnFpVlhZbWdVTDNMdkJDdWJ2S0s4djdpRy9NY0lMWFoydDltTjVvRUNjQ085eUp0aG5MOTlyZTZWL0lEYkd5U0MxUjB0WllWc3JhZXc0RE9GZGphMkJtYzdzeFg4bmdkVnE3ZFU5VW1yNkNzLy9GU0poSi8xaGx6NVFrTWNVYWl1VWcyWUNLT3M4aGh3UHFaS2NWTG1saTBXVmFaZU4wSHp1aU5EdEJWNk9DWGFoN1I2eHNWTktCek1ZL29MalZoN1pReHhKbFVTckRBajBTdHdpVFVqZDU2UmhnUU1uWStYSllYZG1CZjlDdXdvWlFlYnVkNUZVU21ieXhUQXZya3Fuc2lPdGNFbCt5V1MrY1pxaFV1SmVNb2FDbmxxUlh0VDJPUGlib3JYekt0Q2R5RmhUc242NTJzRFowTVMrdWNid3hsSEpMSEtGa1ZlbUtwQXhJNC9VakthT01TUmplZTVndHMrZERxN0xNdWNZUUlKTEJIOW50MmtFcHdSRnF2WjJ0RGYvZ2pTa2JGd2FaTmxBOWt3UGNqSmUxOUlYTGZpNjhOSlM2ZGFTSG5QMU5aMGVBcGo4YVczekJSTjBrTmZPUjFDQmRkS0dtWGhlREdOM3g4NWdacFlzQVJBWmlvS3R6OWxnREU1cVZZZEo3ZjB2cUx6dVdXSWN2R0ZhQUJXeXJuV3FxK1VIakhoWmNPRENpaXZ2TStlTkZEYlVNTUdQbEx2djdrampmTU5iY1pqQlNNazhDTENQWjBHa3BKWjZQbGhyYWt2cFRxMWpJWU9LSG83ZE5FcFBPSElZU0EyTStQMXJRV3NPclNhby96TnFCNXh4VjFnTmhPR3NPRHA1SWNPUWtRS0NvWGk5VXJGY0xNQUJsb2FyK1J6bDNIeXNoVUN3SE04YytnRHMvK3czMk5LSjV0OG94WmdIb2cvZXd4a2pQRkpSTG9BdDJwTzhBa3JndjBBT1loNlVGeEdZSXN3VGNxUDR2Tm5KOURVUlFPNEVyNDVYR2RFbXBic2svQUpHRkxlaXIySFFUT0V2Sm1zNVVEREY0REVneE1HdldabUVDbnRHQmo5dFBabnhsb1RhNWpBQ0I5SFpXaHF2Wnd4cGlXK3FCS3F5Q1NQbVJuaUVIZ3FYMUZtQTBMeHlHdmp3MGJXWExtUUZJekxDQ09LbUFBMHRMQm5SQVpvSTcwa0RUb0lZRkFORWtuWUNSYVpBSVdMNThaZ2xzWFB0Wm9KVkxhK2VEOVFPY3lWa0I2ekxNYXVsR01oNmhMQkF0bVJPNk5EMjdPd3B5aVFnYVEzSUptNnV3UlFTanBUVGYrTXJHMkxJL2twWU1xOW1USWNNRENEREthb2d4S2NvcXNEUUhwVU00QTVhYml1TVNVT3NaQzJYdUVnQWlGMkF0dVNkaUNtU2lmR2RlTlBUOE44Zlg5TitndDlkMUZYb0txYWlhYnBpVzdiaWVEeURDaERJdXBOTEdlczRQd2loTzBxOWFycXkyVkhxZVgvMnlidnR4WHZjVFpYVUhNQitLd3BxTjdQcGhYaEFqdjM1dlJkVjB3N1FTL0h5cTYvbEJiSGE0U1hsY2NsVEZqZmYyTCsza2RyNVlydFpmMjkwK0lkQy84WHE3UDU2djkrZjcreHNGUWpDQ1lqaEJValREY3J3Z1NyS2lhcnBoV3JiamVuNFFSbkdTWm5sUlZuWFRkaHpnQlZHU0ZSVWlUS2ltRzZabE82N25CMkVVSjJtV0YyVlZOMjNYRCtNMEwrdTJqOU84ck50K25OZjl2Tit2eUlhUXl0Q21aVHZ2RUh2eVF6NEFFU2FVY1NHVk50WnpmaEJHY1pKbWVWRldkZE4yL1RCTzg3SnUrM0ZlOS9OK25XNnZQeGlPeGdBSXdRaUs0UVJKMFF6TDhZSW95WXFxNllacDJZN3IrVUVZeFVtYTVVVloxVTA3bWM3bWkrVnF2ZG5hTDErQlFrV0VpcFVvVmFaY2hRTXFWVG1vV2swL0tiWi92L3RWdGdRUVlVSVpGMUpwWS8xY0dTRENoREl1cE5MRytya0tRSVFKWlZ4SXBZMzFjMVdBQ0JQS3VKQktHK3ZuYWdBUkpwUnhJWlUyMXMvVkFTSk1LT05DS20xc2Znc2d3b1F5THFUU3h2cTVOa0NFQ1dWY1NLV045WE1kZ0FnVHlyaVFTaHZyNTdvQUVTYVVjU0dWTnRiUDlRTkVtRkRHaFZUYVdEL1hBNGd3b1l3THFiU3gvcmdyTXVabWdYM1dBMS9VYlRMeldMZld1aVdCN3QxQWhBbGxYRWlWTGdKRW1GREdoVlRhV0Q5WEFvZ3dvWXpudGtVZFlRQUFBQUFBNEE1elZITjVWSjhuRXBrbVFJUWpYUnB5RndlWm9XYy94b1djNnJCbzRURExCd0FBQUFBQUFBQUFBQUFBQU9mOVVzUHBoY0xsZkhyNzh5Z0tKVDk2cnpCSGFCZnVDRytyZHJpQVMzTEdabFZGVkNnVlZJMFF0c3dJR1hkaGhka3lSVlAwQy9ja2FqVUpvSUhGYzlnVTNmREdsZndEdVFVVElob0lKbWxvdWJlZnJZanVSVlJvYUdUZ1dyWkZXU2hodkRQUDdkck9BZz09XFxcIikgZm9ybWF0KFxcXCJ3b2ZmMlxcXCIpO1xcbn1cXG5cXG5AZm9udC1mYWNlIHtcXG4gIGZvbnQtZmFtaWx5OiBcXFwiS2FyYXN1bWFcXFwiO1xcbiAgZm9udC13ZWlnaHQ6IDkwMDtcXG4gIGZvbnQtc3R5bGU6IGl0YWxpYztcXG4gIGZvbnQtZGlzcGxheTogc3dhcDtcXG4gIHNyYzogdXJsKFxcXCJkYXRhOmZvbnQvd29mZjI7YmFzZTY0LGQwOUdNZ0FCQUFBQUFHSGNBQTRBQUFBQlJpd0FBR0Y5QUFFQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFHb0Z1RzRHUmZoeUJrM2dHWUFDRFhCRUlDb0tRSklIU0F3dUdPZ0FCTmdJa0E0eHVCQ0FGbHpVSG9nNWIxU0tSQk9YdUw5OXNLQ1J1Rzh5TVpVSDFjcFlheGphVmFuYTN1a0ZKVThSVlRMZjVnRUIzZ004OXF1bzMrLy8vLy85L1FUSVpzVzBEYnR2Z0ZaVUhmVE9yaXFBRVUvS0NFUklxdFVyYmlhSzRqYXFnSnpNT3FESTlhL1Z1QWJxWXc1aEREVXAyYlI2SXVHazRqUkQyNmVDVHRuU1hURTFFUXJCRlVJSjBvVHNiZzdkWnAyQXVRK3pJM2tPNG1YdGJsYllMQmJ1eVppSkFPeitaa1hLbFhUTFZsSWM0Y1JZcXFRUVU4emdHRGJDR050elliR0tIQ0lnUGlJcjBsZkNrZGt6bUJmY2VuWCtVR3hFUjNNdDcwZWhnODVQZWIrVFp4Wld4eWwvMExQVmd6ay9mWDNPU00wOTVTY2crNzdrT1pLc1F0eCtsdzFiTDlKUXdDL3BOZElnQVI4S0xRU0V2NmtscnA0SEd4cnF1N1p0N2xrbEdtd21RTm1ZejRTd0d1TGVhMDlNOXgxMjhpOEJmK2YrRnJBTnMxd0ZZU05NVHN1RWhUNkt2L2ZpM1ozZlB2WS80eXdDZ1I5WUFvS0src0VHMGlXVzJ3T1ZqbytMeUp1ZXl5Y2hvVkJQK2paeVJjenRmb0pTVEZPZ0oyS29OQlp4cXBlOE5RVFI0SXR6czM4eG1Zd1E5bXZJNXlnV3FaK2JmeEQySWcxdldRYmp3VEFlVFBXZUhoN3o5MjBHN3pHWmphSzRaNXBwaGppc3pObU91TWZmbVBPYWE0NHBjT2NvNVJMcEUrUjFLZEpBK0lSM25VcW0rUHQzVS83cFV2K3Mzc0M1em5rL0dHNlZQUTlYOEpLQjFPQndwZGNyMmwxYldERk9tRE00TGVjUkIzTGRmVzd0RGJNQWpOSHVkbnlLbGllMGdTU3VlS2lHZit2NFRWZWoxOS9TYnVlM3AzcmYrQjB1Q1VoaVVRenFFRW9TZ3Q0UHpTbytyRUkvRG5GbjNLOFVsOUtLUDRBVUlJMDJ5VG9FZzhSMy9BaVdHUlpRbDJ5azQvRHBpVk9GNlFUa0FMcFl0eXhWL2h5eSs0c2NIT1E2MWxscGE4VUhqMEpKcDA1T2F0eU5xOUtqaHkrV0lVaGlIL0Nuc2g3Z09HVlc0VFB4RS9QSTh0ZC9yRFczQU1WZ0VoMC9ucXdBNmFtV01iNk02dnVQak16V213bGQzUE8xWlBDYk0yNnVJTXlBZWRiOTdxVmphZkZQRlp2WUZMcDBXOVRYVmxtYm1rSXp2VTNLTy9TSmtJWUxFc0t4VDlSUzFxNmR3d1pwRStYS0RJNHZqT0k3bmVaN242d0FodGdNdjhlNzA0ZzRCTjhhT2FVaUpoM09oL0trakdtMzhuNm9xclhmL0FEYVhMWDFNaHQwZWxyU1Ard2Q4bWxBQkJjbFVzZnNCMzNVRnBOV1ZhWDF1YmFyemtVanBlK2E4RUcydVdjVFU1Y0xvZzMxS2k2Sy9OOU15L1IrTlpnOTVJRFZEYkluWTh6aUxsWWZxS2dldzNtY3l4blMvMzlOL3VqK2FEY3lBNUF3YUE3dGNEWWpGSGduUVlNRTEwOVBkbU1aZ1FHT3hRK05reUpYRE9UOEExeG1jTnphU3k1eEpWVUJHRm1TejJ3c3kxV1duU0xGOEpKL2xteXBUR0NwVkprSFU3NmYyWnpheG1heUx4ZkZQdUZnTGZBRnUyUVBxS21JbHFwd3R4TlB5cDkyaDdqbEtkU3gweDNyM2I2bVBCMTBkUjJ0TFB6NDE2UTZWWW14VWhLUW9YTTdZMkJpbHdrTjF6OGJ2ZGw0UUlPM2UvemNWbkRRZGNHQWVlWTZCUUR4VTA1L1A3YU12RHVjVDl5UGRuMHRDSzdxMThUZ2NjVVFpUFVwWXNnRUdLbWdLR0hDZ2dnUzFDNlVGZ2FER2t5RGhrNER5Uk9MRTQwZDRrMm5LQVVLMmc4RC9HM2ZzTUxicWxtUVNydjNNUitsRGhraFBST1k3MFY3c1FOSnVkMXozY1lSZ2pEQkNDUEZRaFRINWYvdHQyS2R2YkxWSEJuNzJrdkNSSUNKV3JJZ0U2MTdaOUx5dTRmUllTNmJXZXN5d3dHTjV0bU5zMVdPYzEvV2lEY1lHb3VKYURPQXRZZHM0WVduWTh2dDB6U2J6UW4xV1Q2bnJNSEw1aDhxL2d3akdDZ1kwbjJBQkhCbWtVQUFxQjRSaEFCR0FRaEVnbGdQbEZRQkZOVkJkSGRBd0FBME5BU056ME1JU3NMSUQ3VDFJSER4RUhUMU1uRHhLWGZ5SFAzL0RQNTZpb0tJV0F3Wmh5TEFZTVFvYWsyTEtOTXhZRjZia1NKR1VUR2xJNUNYYkxacUVwVmVja0JHRXRpV2plUDR2SHlFd3ZIV3YzQXhnY3VmT2llbkE1SzZOSktuQTVONk5KTEhBNUw2TnBCSkFSd1hvQWFpQm4vZFRxSXZacFZQOWRLRmVzZGhIRjdOckYvdnFZZ2FrQ3lCZENOS0ZNdmYrenBVQTRzYVJ6NllBL0ovbDVSRUg1VW9nK1ZTb0JFSlJiVnRkeHgzVmNQQmZqWjBiZ2FQbDhkYlhzY05RWmpKTmN4MC9mWjFxUTkzOXBhSG5laU5hdkFzTFVvdlh0NjVQN1IzV3d1VGVWZTZXYjZ3UXdPOTBzVGF2azNkR0wyRnI5clJNUDFseUwrcFg3SEtIZUZhbGFmeVZXWXc2a2NuU1R6dTkzdFRLcis4aEZjd2RxV3FjTW1YWE1nNVlLMWVEa2RNYjVaV3BvSkNzWUdHaldJUlM1aE84cUs5RFhjZUFVMVMxNUZ2OUhCQjY4U0dBWUM2WTNIUFlRUStvdEtOTG14VkI0WGRjZE1nalJZQ3NjcWgwMjhyckNqUWVoVU16dkF6WC8zU1FwQTU1bjVLeWlndnJZOTlncmR3STBCNStPbkxCdXRRUC9LcGZLMmxmWDJuMlpnS01aVzBPUHptV014KzltZnhTOXB3RlI3eE9uZmpKOFpMYTFGb1R2bldQcUcxamkxbmY1a3I5eU1wZVVua21VVTJuTmdCR3Z6bjhJcHFpV2IrdDI3WTdvRGlWWm5tNWRmTzYvVnRzdndNMTF5U3ZUR0ZkRjBDRm55M1ZiU2ZKUmNlNmZoWi96OTNqckx1NHFBdFluVVlQTzl4UDhSc1dBTTJ5SkkrK1REMk5BeHlKZTluY1pVcjZQRjBQajIwME9RemprajZHUlNaVGMxZlhRdmFJZjhoTDJZZFN3V3V6SjBWSW4vck5Sck1TOFNTaEJiclRrQlJZMHphUHdHWG5ubGp6czl4cm8xNnNaTDhNQnI5OTBYdmJYdmZGUTdCZTE0UGlPOVNoWk51YThLK3kxbWRKeDNwbmlvSzVFM3Jramw5SGl5SGVHSWEwNFlhWk9ZWDN2cEV5T2l0eFlxRnQramhiaDY3WVdPY3FjbU9SUndxQVZqUjVlWnJvVFQxL2pSQ1phM3pBb2VpUGgvRnltbm9KbkdzcTA2dnhVMzVDVytXRHNFQ3lQYXlELzZGVStzWW9qVFRqOW13Rk8rcFFkeTdkVWRCL29YS2tRczgxL2RLVURnR1RHNTd1UW1kYWZabEs5cTN4ZEZiNjgxdFJpZFFEbHd0blZMUGJYZVF6UmQ1TEpTTkpzNHRPZkVFa3ZKTWYwcjlRd3ZHNnJNYUNQRGl0N1R0cktSdmh1V2JQZDhvRjNIWWx5U3UyVFJ2emRTdWV3a0tIRnI1eVg1VzJiYktIaWVnY3IxSTNUbXVnT0ZTVjhMSmdDZEo1eVFqbkR3Qyt4dmRqWTBGanZGKzVBUHJDNHF3a2VndzNycTl1N2FJTmhZdDlGSnlFdTdkNEtCakxvcW9YZDV5Y1FOR1VaVmFVSzZqVGpFZmN0YWxvQzg1dTVxUjFWYmdqYkZFdSs2ZHk2TG9wN29GeEc2RWhXTWhkdzJ4VjZoREpISG5KMnVqUS9OT0hBbjlSUG9DZlAzOWRmUkY4cCt1cmRKcHY3WERQV29DTk52aGhiVFpaSnZWa0tONmUxT1loT2tYbC9abzF1WFh0VkZqOGNnaW10dytkbHdQNGVIRFAreFI1dHpaZnYzQjJlNkZUMXZMekg2NEMySjB5V2lXM0dKT09uNi96dVpxbFkrMzBQQi9Tb2wzN2ZsSDE4ZXp0UDRGZUUxUURuQVdoREpWWEJOZEcyeVpORkVnZFRLQU1aQUhQaWlzaUQxd1VQSHdHL0VReEZpK2VvMHlabkdUSjRxeFlNUmZseW0yeHpVNnUyclh6SWJPTHIxNzdCRHJndURDanprazA0YUowbDh6TDg5aGorWllzS2JEaW1VSXZ2RkxpdXgvSy9mSkxSUkFTY21CU1RLRTZhYVpSQTJwVGNJNHVDcXlzVUNnckk2TkJXVjQzSEJ3S1BEd2pXclJCTkZIb282S3laY0FBa1NGREpFYU1XS09oWVRCbVRKc0pFMHptek5IUTBlRllzSUF4akJYckwrSXh0V2FqRmxzMTJLbkNYam9Ic2NhSk5sNkVDWnB5RVdhU2VseUZtNkVOamxhNHF1SnB3VXROM3VyaWE4N1B6ZnpQbEMwaGVPNEdDbUpGQ0MwRnF5WkVzbERWaFdrcFhLb0lqVVdLc3E1bXhCcUlVays4SmpMZFpBY3BpbFd3bjBnSGhlSmpEOWhtakJaU2trWTdNYlNIdGNtWmRRdXB0ZDMyb3R1bnFRT2g4emdFTnBsRkM2bXFJNDZ6TUpxYUczT09sWW5VeW5sL3NqU2xtV210WE5UTUpSbm10ZkJZaWlVcFZvVDZTSUpuR25raDFHY1N2TkxJZHpmNVI2VC9Tb1pCbEdrUHNqVkZTZGpHQ3MyY01tdlN4SzI0SXRGSWlWcDVPK0hVaDllQXluczhZdWlHR1Z4QlJ3bDZvUEVKT2poQlJ3WVN5cGlBQklVcWhrR0U1WUNBRmFHWFIrYnNZd0wxQUdPQk5PWWJDRUF5V2d0YUNBcmFnZ1UwTk1GaUNnNHlhaGcxTk1TSVFRZjRnYjVzdUZteEtzcUZPU2kwWWNFTTlhQm5sS0JEeCtTK29YNUR6UDBCeGNXd0VjWm9RTU1DQzB6REtHSFVURWNmZlRZQnhZQk5RREVBRHN3Rm9PUUJDUTUrTS9xaWoxWlNIQlVrSSs3RGFlMy9zL0VwYXE1TU5Vd3FCRmc5WVFZNWFjV3JpSkwyNmNaemY5NkFHM2NyZStXbTJIRmpyd2NzbFdLZXBzcVkvRkd5Y3loelY1YTdXUnBObCthbnpCY3RQb0dTMTlXOUY5WWJFdGg3U2F6TXdqdnBaZXNGZkpMMXA4TEZqTGZMOEhGNm8vLzJlWEN0L0lCNU5pNTk0Q2tTQ2VZYU1WSjJKeDVFc0t4WEphQUdWbDFoMG1PZmxrWFI4K2JaejVDVWRVblZXSDN3ckdRTUZOWmJiN1Znby84Y2hya3RLWm1iRGQzc2NSSm1mLzR2aXorSkx4Q0tKWXlVdEl5c2tyS0ttcmFPbm9HaHNhbVp1WVdsbGJXTnJaMmprN055Y3VURW1RdFhidGc4ZWZIbXc1Y2ZmOEZDaFlzZ0VpMVd2R1RwTW1USmxpdGZvU0xGeXBUYnBrcTFHclhxYk5lZ1dZdDJIV1E2ZGVtMlM0OWV1L1haWTY5OTlqdGcyQWtualJoMTFqbmpwbHcwWTlhY0ZVKzk4TktxTmVzKys5RXNCRVFmbFNrelREWnN1WERsajBDaTBCZ3NEazlnY25reXZRT1JUSVZvZEVZWExDbFl3WjRpTDdDWHlPZi9SQytGQUJYWUVRNllJK2NzQ1FjUlFBUXl1R3hGR2JkUE1nVXVnaFhSQzlFcXQ4YW56OGZrcytIelp3dGdFN0FGc2dXeENkbUMyVUxZUXRuQzJKSVlLR1JBd3BCZ0NYaUZwakdiQWRrWEZBZTVyL084ODNxa0l1VWMzamZISE5MS1VkWlhnVzk1SDkvTDFuZDlIMlllcGVuWXpETmV5ZnBhZEVreGdWUjU1U3I5S29PbXFCbEhNcVJ1bFFaOHpZemJiQlk1YWdGdGxkY1JVZFhNQmV5QkI4T2xQQnM4dkFtTUlWd0NZaVpXZFN2VnBJWmE2dGhPdmV0bkRqTEFJSWM0ekpEN2d6ckNVWTV4UEk0MDBTa3l4bWs1QTg1eWpnbm0zYk9OZS9YMHVzcWYvendjckxKVmdkTDB2ZzJpOGo2WFVHVjJXZzR1am5yZmlYQVd1WlJMSnBQSlpKTlQrUHRFSzRJWE9RSTFFSVpoR0RhY1lpUU1IckQvMXJvR25BNGlvWXJaR2dHS1VnNUh4WEtTOVYweHhkaHo1alZyR0ZESHFoU1BpZUQwVUVXTGhPZ014eWFLNHlCM0NJK1BxOEdmc3hlNzdtN0RDVkNxVmlxR1NGYU9UdlNCYTFvcG5BUXJQdHRHOUpEOThpeXpxU0ZVcDFlMUVGaVpFekVCWjlVaFVBenlUQkErZlR2T3daQ2pDNmRFVEhFeHJoajFsUEppOE5LdEoranpITXdYRHcwYnNVN3BFY0lTaVdwcWNpUkMzV2t3bXlGSFE4NGtzWUlaZkszMmZjdTAzQkNmdVBrMlgwRGlCQ1FJSWNFMkhLTG4wN2xjcElocG1DSURuWFRSelM1NjJVMGZlOWpyaHVOMmdwUERSaE0zaFl2K1ROd3VjU3ZteGRLd1VxamZUOWhtd2NSRkhRMkovUXNJT3B5SHA4TFRMekw5Uk9rbkFWUHBkekg5SUhUY3A4Z09jUURPeUQ1a0Jid0FDaCsvNGhGNnowS3dHVmR6VENNS2hhSkZYVWtmMHBESTZLU0xibmJSeTZVY240cjE2akNySkFUUm9zNC84UkdDaElLR2dZV0RSekNlbHpKTlFGMDNaLzdMbk5NTWp6WEZLbEF0YXFpbGp1M1V5NzZUYkxyTWhDUEhJNzBlUU9HdXRZd0MzMWhxZ21DSHkzN2M0RUVmUWo0MyswQlZGU0hxdjVHYkNna1p1MnR1NE5TM1ZBOXp3cWgxWWNoZUk2VGNBTjRBTllybm5EWlRMcENxcEpvYWFxbGpPL1haQ2tGVytUVjRkZlczQWFpVjRaUnFKQnc3UWI0dU9XNGpOMkUwbTJqWXltb0lPMHFScWVoZzNMTmhtSDRzYUYwQ3hXN0xvWnoxVXR3MmMydWZnY3RLcFFHK2I3RnQ2QlFGbW1JVkRTVWJsM0NWT1oyaCtvb1ZYU3hUbUxLdGg1aFZwUmwzOENvZWxqRUV5em5FZHF6Tndjb2MzWmlUZnZjNjJpVWFsN0V4MTBYVXJWaDBTSlFGR1dkVGw5bU9XV1pkbWxuS2Jsc2d2UWlwZHVrWUdRYUI3VU1DOUw0Q0I2WS9rVmc1Vkk3MHZlUDdXOVo3dzdkc1gxYUQxVW5YSHdVYkdjRHBJMWhvZkIzcVF1Vjg5L3Qwcnh4RHQwcm52c3pzMXV4aWlSdFUwcXlLNmZYbW1hcjR6WWVHL3RjcjRadDkrMDlCSC9yNWpDcjB0ZWl5ZStvRTRJMXFoZmQ5b25JNGxiaXBhZnd4c2k5dkczUlRBL0w5empHMG1oc0R5bmpGRk0ydVcvMEZJUEFlM0ZZZXpIamF4S2dlMlhuTjdyak9tWmVnbVFnbHliRFBHNjNVMlFxa2VjdkhlTDF5bTBiUUpxRVRKVE40eDVOZ3QxcTRDaE94T1RISXd5UGZiT2ozZGU3cFByV24zL1grTEFLRUxSTHAvZDl3TERXRmk4bGNNN1JCWll2VlhCUlI0Q0RuMXZPdEpQS3NEaXkwYnljUnVreGErbDlIN0xZN0M1dHpTSlIrbG9pWWFxTzZaZ00zYVNyZnRxekM5YU4wQUk5ckQ2d2JHMVFyVU1mQSt1SnUyVjdmNTN1MzQxVTIrU2dFMjNFU3hzbmhxSE85QnUwWjNPaGhJR2ttU0VsL3Q3V1pRbUs4NTlQRWZjZm5iUnRTSjI0ZnVIME96Z1lXbHpVNWNzM1hXekYxM0JxbjN1VVgweWpNOEFtTXJ2TFZMbkN0UnNQNk9MRm1PYzNiem9vVk11M2U5Q3AxZUdhbHZFMG43dk5LZmFkY2kvdWh2SkdZR3V0dmE2S2pSaEowK0x1Wm0wUGNHTTExdXNQbWg0Z3F2K1gwNnZWKzViSWhBalN6RmU4c3M3OTZacXVBUHpCMzRqOTV2ZyszZGE3WW1sNEw5WTdsaW4xQlZVVklscG4xZUpZZGZrUTBTR1ZxOVd6aCtacWxPVTZBa0V5dGRNZm5RRDc0RC9wM0hxbmVCcTFPREJjNnExNE1sZk9WNVBSdnFwVDU1NnpLUnhBaE9qejliN2lrcEtHZXZvNGxnYXltczVsODEwYzM4V1doRUsyemVyNktPTGVjYU1SRnFXVER5ZnZ1eVd5NG0zQmtuQlpJd250ZUR6V09IeWk4UFozWnA3U2RhTmU1ZWhnNHQvN3kzd0MxUzNLT21lMjQxTDlXZGUrMTdnYjlEZ0wzK2E1UjBoZkcvT3VmMTdlUzlXVHZIcFJkZE9SL29UckQwWEd5Mm5wVitYQnNBYjVPejZBQzhOeGxyakc5VGtkdmQ2K2RlNm5yaEViak1UZkM3Zzk4SXo4L0xvdU5rL3VhYlMxOGR2d3h5eXZxOUxYNytjTEg3cmY3Kzc2M3FDNXdJU01sdTNpQXF6L3ZwR3d3WTZET2hjc3V4ZStQSXZsS0p3OG5VMkdwQVJyQnM5VnVkTVJPQnBRL2gzS2VwNTlISjdLYm94dVhGZUxQdlRXNjhabUN2MmhjNXovbS83ZXJ3UlFpQUY1QWhQOFpwQ0pGTUwyUUlQV21EU3VoU3dXVkN3SVdOK1k4aUZtSUZzdExnZ1ErMG1YeWxTVmJnRno1QWhVcUZxSk11WEJWZG9uVWE1OWNCOHdvTW1kZXJ4WFA3UEhDSy91dFduUFF1bldEUHZ2c2tPOStPQndGc1Z3VmpHUzVPampCY1N4Nm9zZng2QXVWNFppS0dTZGpJUmFjQ2xOc0dJMjkySE02anVMSW1mZ2J4dGtrbWNURlNKUXdrMnl6bVUydXVjeEZxcFJMS2JTUStWUmJ5K1ZzdDRGcmFiS1pteUF4YmM0Z0Q2QUFZQXJtMW93bFl3a21EdTdHTGdCZ2JHSmxCVElBd0pHVFpYTnROQUVFS2xvQWJCMjJvb0pJWUdTb0lWRkhqdXNHRUVvYWVQckttOE9xTHRBd1g3ZVc0clBFdXRwaStWak9ERTBEVDR4dDRBU01MVmpMdUNvQkM2R3pCbzVlQjNkMFpia1lYTHV6RGV3N2dpMzRqaE9RSTNmMHBIbGMrTFY3RktIdWFDaFcrWmdTQy9GdDYvS3crODdNM3FnRDhHU3ovRVNkY2FyYmdzcm40ZzQ1ZEN2OE9QR0EwWTNOWjVKS3dqZis2WklHS3MySGlOUnViSXdGS3l0YnFXZUt4WVlZUWl3ekZBSExPWmZhVzhkQTM0ZzI1RVczMnVZMndHdmNCb2xhRW9SRUZXc1NZb1kyaVEyWEQwdEtCQnBxQ2tKNUErUUk5b1RTT2JpdWl0KytSSWloZWtnTitMSG1LeXZ5cFEySVBnMUFEVVg1cWhWTm04UkhFcnE5WjBGdnVtb0ozU21jbCtHenNrNEVPS09jV09qdjc4NkM0b3hhVVVVTGE5MUR1MC80S2dWaDl6SHRQdFUxTTJwVk9JUHBQeVNoZTlJclN6bFlRSldDcmNHMUNCOVlGWnhteVdLeGRFb3FoajEvZEhrYUtQZmNHZXpjV0h0N2w1bDFwVnlMSlgxaVp1Z2x5Y1AwakpNSEx3R2gvK1UvK0tqaUQ3ZmhQcmhmN2hkYmg3RFlkOGltTDNEZ0JNcjArTFlKeWljckh0Zm1DL05RWWRrR2YwNVZkYkM0SHZhZHI0TGQvL1RpR29KTHJjR2dyVmRsOEJKTC8zZGNOYjd5b080Zlp0NHIyQUhnNkVPWGZxR21tQXBjZitTekRNc1R5TWpLS3lKUVJhTHhRTVdtZ1p2T3diVUJ5a3pob2RHTVo0R2FjY2F2VDFXS1VVTS9NK1pGMGdqb2hGQkp2OCtGNlg3VC82WEQydHZtTEgzN2JQMWVxVmFtcmZGdTdiYzJyNDZtRGM5Yzc2cXYrZGp0WEQreWZxM1BLbkNCQ3RYQmdKcUVCc0pPQ0pCMVlCNGlOKys2bEJCN2dRUGhTNXdMaU1VL0Y4ZWpvRDV1TVBjSVZ2elZwd1ZESUNtWk1YZTlUeVE5d2xhazFCMzJlODRicnZqeE9GcFdLakNadldQbkZsVURRaDA4bE1ja3Y5NE1zTFdVZHVETkdlN05vV2E1QzhTVG85V2JMekwyU0drRHZoekJuay9Oa0pPQmVITGtKZXdLY3ZkcmlvaDB1cGkvK3l4cUplU3B1RW9kZCt4M0kwa0YzRU84M1ZPcFdiU0JlSEtFNnB3OGU4dHE2ZmhHZDNkRHRQQUd4R2x3clpjUHMrZklDSGRkRFhaM0NJWmxBc1RkZ2VxbCsrb3FTWk1NRTl1bFljSHhJSTRQV3JBMytNNlBLRU1KZ1BIdHZEc3NTU0EyRDFCWDdFSlBNNEp3MWFrN2Q4SWVFc1dyRHR1WVYySTFMU2s3WndMUk5IY0ZoL1NVNmZwRnhVc1UxeVEyc3JObFN6RWtrK3Zzdmdob0x0VlpWK1czRHdPV0k0UHBjbFZoUnhsNHRnYURjaFhSWXR1L29wQjVpUENNcThxZCt6S0s2VUdFYWE2cXNOdjFiSXFEQ09keVZhVTlqd1RoZmJBQ3JxcDhTUnVDZER1WUgxY1ZYL0lvVUk0Rm96TFpXNndTMi9MdHR4M0kvRmhvdlFuWitsMHpIc0NaSGx1R1E4NFdMeUF4WjlwNlZ2UWpXL2R2c3dsUlpxNFdXR3pZbmplWURHcmlYamJNK3UydGV1QWpVbXo0dDZTd3lHOVplZVFpZ0NoQ2krVDBRcVJLRGVrYmRkVE5Qcnd1SDRLWUp2eTFjUWZsTE5SUGIxbTZ5ZFpkRHpseTlaU25sejd5Z2Nnbld5V21kM3IvTE5vOEU0UlljOXVpSjZ1My9xcy84ejMydzlIeGFMOE82N2pPNklLdTdNYVc5ZDRlNmxNOTJmTjlweC8zaTE3di82STJzckhWdFNhV2FiZFlYZ0lqU2xLeVU1S2FOR2RYWVV4c2RJMkpZWm90aGxlQkpVcC9qdVJVSmpLVGE1VlVraXFvSlhKakNGU0RJVDloNG1Rb1VLbVJ6RjVEVHBrMDc0N0hYbGozWDFRaWlVVlhUSVFwVzRSbm9LSzZOQnlKeHNLQmprcVVOZjJjNE5QcHl4cW9nS1U4RkFWQXdDcXBKRWtTQUFBTXh6UTdybVRES3c3MFhIeDhQQjZITWZYckJTUGFVSW1jWVl3Yzh3aEx5Q3FwYXhPS2xxM2VzSFhYWEVYS1ZHc3cxZzI3bUxkaVV4K0xsV3czTkx4b1JSbGMyUDU5bjJaLyt6cGpXM2NlYnd3NURhTUVXMlY3VVRMTE5sWlFURnBCVll0TzJVV1Y2emJ2bUsxQWlVcDFtdDJWSis5c2tiS3V1V00vSEdNSURsT2Y3dG40NkYyN1RNNjdSVDlZMEVzRnJEd1NOQS96NWc4VE5iOFFqTmRKLy9Zc2ZHSUtXaVl6VXFDSmlzNGVHNEpqaURSV0xyQkVWZC9TbVVOSVNrVXZNbSsybFhhRzBiTnRTOXc3Mi91Z3ovYzFZbTlQWWJMUFRZR2l0cWs5RTVlUWhJS0dMMzdtZWJubUlUSFhFSFQ1OGlIdTRzTUVaUUFITnVXVUpFRUlJWVFBUUpJa1NUWjV0L3RtbUl3cE93b01UZDZnL2NPWU9XeVo3YVNiU2N5MnhJdEt5YXRvNnBCWlVMRjIwL1paOGhXclVLdkpqQnltT2Vyb3N4OTd5TGdaaTlac3RjdndrbFhYMzNMbk9SWmFhcFgxd0FFNEpnQ0VZQVNGeG1CeGVPandrRWNUWTJ4eEI0WkZ4NCsvazVPS0NiWmlLZGJNMmxwV3ZDTk1WRktTbTdMVXBUVzlHY2h3em1VbU4vSWdLM21UamZ3L3ZsdHl5YTZoeTNBZFhZL3htN0NKbTR3cG1NcHBITm5zbmFFNU5aTXpQM2ZtOGJ5WTlabTBBZFpFczlCbGdta0xIb3JDVTVnY21BSkZiVk43Rmo0eEJTMlRSdXRxcHFhM3o0N2tHcVBOMVVzOFdkMi9mTzRZbWxyWkd4QkM1MFNRRk0ydzJCd3VqMCtkSHZOc2Nzd3Q3OFMwN1B5NUdDTVhYbngxeWpmMWZqUExJV2RjODhBcm4zem55TEZIWHZTbUQzM3BSN2U0eHlPZThwSzNmQ1FtMXlCTlVXUWlLem1LTFVpVUpGbUtWR25TVGtoWWdiSXFFM2pKaDhOajJWNExlaldjaGNTRW9GY29KQ1lFWjA0QUFBQkpVaStiVktpbE1OYUNYdXFCbkNjRVowNUprZ0FBQUNSSnZhMlhBUUFBQUFBQUFBQUFNQVFBQUFBQUFBQUFBQUFBQUFCQWY3a1ZiWnFxcGs2akxXaXFUYTJvMHdUQm1Cb0FzQVlBcUpCalRncFZES29ZVklXZ2RpQVFQdE9wUzk3azY5cUdJbkRrMU5rTCtJQjNZRnZPOFFTd0Evdnl3SVZsbGVpRjdEem9OQ29BZ2h0eFVWRENQTnpVdEFMN0Q0a1g5QW1udzJ1clJzbEJRTG1pSEFPNHRxUjRIbVIvRUdJK2ttUXJpYk5FbU1FbUJab28wUlZOVERCaUNWeENsMTRzZ0MzaG1DaHBmZVRwUUROUWFFRFRoWUkvQTFGOHltSDRrSEZFb3pTalorRUczWGNWaGhnY2VYeFFhZEd0NmpTcjhKNWZ1S3ByYWowL3F5S0xWTjFhOWIzS2E4bElpQ3dWT1FOUFNQZEtJa2EyaTN3aFBzNnMzaWVmYWdJaVNmVGUzWU4rb2dmOXVJY3VpTy9wU0tPVGVJYVA4SEs3OGEvMnJ1bUsrK002MndHSCs2MlV5c3kyMzV0cDlIdGgzZnNVeUt2cm05c3pjUWxKS0dnWWpPeExnVHBkTkF6MldBQUVnU0ZRR0d3b2JJRzh1cjc1aHdCZVdJT040YXlIODNLOTNROUFFQmdDaGNHR3doYklxK3NIQnRCeHpqelFxeE9DQ1I4bDNYaWpxNkJiQmpSUzVud3Fkb2YzWGF4ZWlRSFord1ZSbFRaYkY2TVAvTUR0eGNlYS92OVUwbitmaS9wdUdWWXJyUVcyRWp2Vzk4VGVPSnh4MU9lNDNVbWoweHBubGM2M3VpaHdtZTBxdzNYYWJpQmNhL1ZiRXhJbjIvak8wZGJtdnNlZ1NYR2tOeitZeVhhcXY5Lzc1UVBnSTZzQmhOVkFkckxSUWl1dEM5ZzFnbk8wU0ZhQmxrZzlVM0p3K3lxMFpEdFh3N1lOVUh1QnVlWjlYRlJxdmczV3YrWjJpKzlxbjNtbGxsdm1WaXRzc2tXWjdYWlo2dzViN2JUWkRydmRhUnNRUFI5a2gzeWF6c0EvblBSdHdSSXBTb3hZZVhxTWUxekdMODAzM2dZdVdjbEpoeGdLVFl6RlJFekZUTXlGTGhiQ0VFdVJtRlhzS1ZqQktGM3FFSFNuV3hYSEVFWmpjYXpPQ2JtTWJIcHZUM0JIU0hOMHdGQ1ZkZnFGQ3c1L3psU0E2OE0rQWJ3a2xDdVg0ZnNLSVAxZGhjOHFmYytUN0RMZkEzRjZuMFN6VWViaHN5SmxaQlMwWkFBemwzL1NSYnRQMG9BdXNWU2dobFBrVHczMW4xc1d0emtibHIwVVJObXNvdnNEblNCNjI0TTNLTjBVV20xRWlTZzdFYlVzUkExRUUwanJVdm13M0RkQmg4MDdGZC9GK3JWcElJWUE5b1hTeUZmSGlBR09FbTlNM2dDZ3JCbkVBQmM1UjlPRUdWYm16SEV5YjU0ektNTmtLRURPbEdRdEpOTnU0NEZ3WlVUZEFFbHZhbGxsUG16Wjh0SGRYVEUvOXZPKzVjZExlaW9DT0dMZkNtQm9OMlllQmg2cDR3TlFSZVlVcVFmN3dSaGNNOHBqZFhDaGJJUHl4dUlsTXBFY01GZDBWWFJiN1dLaDEzN2VabHRBNE5KSFB0QUhId1g1NVgvQlFVakk2bENFUWtTaHA0K0hwSmhsRUlDTnkwTThheEhVajM1c0Vna1RxQmJveWI5NnNNWEZsY0tUQlZzQm93MUs1Y1ZrSUsyZUx3Mk5BaXZzY1ZmUGQ3UE1Ya3lNdkgzZEVybjMxZHY5TDlOV01tZEt0Yis3VDBjRmNydDVwcnY0Q1ZLaFU0S0g5WlYyUmsvY0N1NGRSSTRZd3VOdGp3MDd0a0JCRmI0VTlPYVBCa3V2eCttUDFBMDMzWExiSFhKM0xiam52Z2NXTTgveFhtZWQ2QWxZc2VTbEpTcHFKaytYQzlOUm5yOTRxZ054SmNldEdGODgxWU80bXVPaThNV0crK0doZHpGdWQwRlFJQzU5YVRVQzFPSHE5RTFGVURrYkFwRGRlY1YwRjNmanhZbkxienBLOC82YndIR3JqUDAzaVp0Y01mYnZsR1l3S2pNdSt2eEFzaC8wRXBlZmJCdUlUSlBkNUJ2K3Z3NlBCQkRRVmNKNDNHRUZ5bXpadGVvTEVuUnZ3SGpjYVpYRzFOanIxOWMrZWVvUk9sM05ObFg3V04vMEUzSlk2WWVvaTh1U0poUDk2dExqdm1VcFBKbm9Mem9xNENvelMrUEp4QURSV2FXZ0NwYkJrNG1CQXNhdWVIUDErOTJndmZCRUg4emlGSTJUcXNHMTA5RXRUck5qRWpXRXJjTmRuS0Y1Y2pXVU8yc1UxV1pUb3BVblY4TUUzQTBJVzA3R2hnc2hiWEkyUWdnWms3V1JRcEJNcmthSnpycE42b1N6V1hzTEprK2pCUnpIc0Y5Z1RZQng4TzdzVFVING96cCtmVmFoelExYnRDdXVXdkhVTXkrODlNcS8xbjJ5NGJNdnZ2b3ZGYUFrTzVvUCtPU1Z0L2JsUVkzUStTVlgxaThUN3E1aUxKQUM5Q21sdUd1YmZSSm1kanZMczBHTUF6R05ENCt4Y2htZE1haDZRY2E0RUhmSnJHU3FSQm1WWlZ2QStEVE1kSWJxMFhGVmx0c0NKa0NYa2hDTTZzTmpvcUZBTUlyRFk1SnBkSHg0Y2loRTdieHRZSEtWZXJVTGhXcHVzWTdpdDNDVERuMFhUV0dkZUJZM1JlaDJ6M1RpSittMVlveWVnTDZxblBhdlVWbTJPdlJOa3R3bDNtb25yL2grYVhRcEI4R29QdXo3R3dwTEZ4c0RLQTNEMWI5R0szcGdvcXQzNXRWVmd3THNHYzdOZlUyUCtUdWF3bmFUdGJZUG9NdWhXZ0RuSUtBYllCc0FBSlpkNXhzRXRnSC83MithL2hRQjN1ZStBOGhyQUhENWdBUUdPTUNBRGdBSHZBdEdRQWVZRUx3TDdrNkFmblRCaFNCcmY3KzFsS0F6ZWViUDQ3UDBmVW0zTzlrZzJUVzV0a0Zwbk5Ub2FLcjhuLzVPUUZaaWZ5d2w4SndQKzZhSjdrWXkrTEczLzNXZjc4eTJiZDRIODMvOTkzZGFUN1Q1VGY0dC85aEt3WWV5L0NlKzcyZ3dDUkJvRVhnNUltVXNlcGF4NGdUdmp3MitFS2RvNHlJNTdTQThETWkxNWE4RDhCaWdIOTNseHdDZUFQUmJIMDhWNlo4K25pN1N2dy9DTTBDaS9ES0FaNEZrby93eEFONEVrbFBRalQ1K0xFb2U4OGxoUmNuYlBqbWNiL2praUtMR0V6NDVxcWp4bEUrT0tXcHUrZVNFb3YvM24rbHlQd0RaLzI4QTVHVUFtSE1CK2k2Zy9TZkFwRDhCQU13QUFHc3hsY3gwWjJhQlZ3MVd2NkhVNHBRM05zVHJJUlhaWjAxSDRTcHlJTXJnRlR1MkFCbHdHQWlVWit4WTRxbXgrak9KczcvRVloTzBuSUEzVkZxYVJ4dnM2R1MvSmZidGxWT2RDeTdQU2s0L3hISUNxUU9MRkRSWnlxTGsra3hMcjRFeDFpMTNZbVdoSFdTL3BoRjk3OEVHTHJPaWcrMTZpbGVJY2RXZlJMSTdGcHhDOHIvQkQzR1dVaW1JT0RNaDV5RW1DSkx0bjVST2o4TDI1RW1FcGpEQXp2V3ZqODU0eGh4K0hoanlwb3NwWkV0WDdOcDY2NHE3d1F3NDB1eTdxcVZaempSRG5US3VabXBXVlg4elQ5WkZHMi80dVlLMjZYU2ZLL0EzSW9heU94UnB5SjRidUFXT2I3SG1hSzBVVXJCMENOTTkwdmxiSXdFUjFkcUlYd0xSNGNVbDl6TUNUbnNqSW5JZmRRcG9SRlFsdEs5bVBYNmpzbzl3aE82UElFSkV0U2JpTjRySm43VzVYZEFBc1NtaVNkZjFaSndyQlpSUXJDRkIraGVhZXUyRXFPR0U5aFpyMjI3eWJBVE41VWdON1Q2L3RhbWlJbThmRS84b0ZQY1dJSEk1L0JiSml3M1VVVDNMQjBqSFFpbTI2aEQwNG5GK0xwM2pzM21UQ1hlMVEwUXB3d0NQYlZuZHZlMXNmMlBhNkhHR2xnVktyOWtZQ0JVVDN1QUhxS2dmaHBoRk83eFRPdDZIN2FTak9LOTREK3JkQURrWDFEeFU2VnJMQStLaDlMK1kyZnZuZjdMVS9yQWJWZ0FHTkFkWitIcGdCVDdKRTdtNXU0Q1NUVmxjZlJNVkQvYnFHb2xLMGRZV3dncERIcE1TVmc0Q3JLbVlqUXM0aGJYdWJNNHpkSjJXSG1yQlpxYjl4MVJaUkkwTEd3SWRoNmYrZHNJSHlEdFV2Sm9DQ0d0WTBZdXlJMmxrOUN5NnpOS2xPT2FuclRLb0k0Mkl3cXMyTTl5R3hwOXBrcVZhSFBhdFpwc2oreG9Ca2c2MW55QUVWb1ZxSHVxaXNUSGNVWE1mMWwrZCsyT2EvemxWQ3c0NExnc3N2YVczSndXNkZLWThyaTNjcFlpV2lySUphYVFFeTFyY1pHQ0QzR2NDM0NiT2hSQW54VVl4V04xVlo1UlM1U1F1NGtReElLa3IyVHNzbUtuaWluelF5VlhIMWVGWGtERUJ3bTVXYTd5WmhTOTJPU3FoUFFKZFVUdEtnOGpiQVVheGF4VkdqVlZTRlZhOG03Mm5sc1FiVUpGWW41OHVQcG9TZTJtSFlHakxWVEZxeVFlcGVhOVhKMGpmUlU3UEt1R0N5TTMrcFlDS3Vwdlc1aUZ3dTA5OVZFbVFSVVpvRHlvbkloNDZmNXRsSkZ0WHNxUkdldVFhdjNCWEZtajJ2WjFxTVNiUmVpY1hHRU9aaFRaOCtkbzlWTVZRdGNLV1BsTlJJSUFuckRSYnlYcnplaU9icHJqZDBaNGpIcnI2Y3dUeGZIQmluNnZ5RWRJTnIzVDJuaG1sSmxUQlZIT2c4TEdLN2tib0dra1VUSlVxQ3BLd1hYQnliaFJaczcxa1ZRWEI1ZHMwVkRYdktIUXIxV1RHZ1ZtUjVBME1MSkVXY1BKYVhrc28rR04rV25ic2tkZWZBV0ppbmw4RGlTdklnRTJtOUVoWWpzQmdlYldSVExjYXhVUjJ0UUxmVkNXcTFpOG9xbGJLMjlGU0trdVA4djBpaVk4QXBFK1pBNnBabmlndFF4ZGgvRW1QcTQ2bG55VURIR053ZkFwdjBtTUludlV3NHpnM0huSUdHSVprRElkY05Wa3EyRUxsQ1BxcXVWVEJCSjNPMm1NbnB0b0JhRnU5cXBVWFlQQURlYnRKY0lRL1cxRDJxdTQ0Zm9CN2dGVkxRTG44bFBCTFhESlRhTEhiTWkzcHNCWC9ZRUxBYU1oU0pCeVN5Z1VWcjlxTWhZNnpBb2NGRTJBdHhodVMreGV3bzZYellMRTRFS3grZVFGL2lVU1l4VVZyVkp1YWJmSkp4SGlLU0twTGMya0hNbFhBMWJOaXp1aVo4UTVZazBROFJCKzdWRkFQM3FoaHJ5QStZaVBBTWpNemUxVDdyc2VTbVhTOWtaaWFxRlQ1NmlzZHBBSHpXeGpDUUNwd0hVWDgzcG13dFZ1K0pKOVlDaUlsbkdBdVdpSVlCQTJ3VHVSYVlTRkM4WE9rV3kyak9vUkJWeEZtYUtHYnRpQkVKN3VnSjAxL2h0WkwyQXBxekZTc25UM0szRWZTcTAxL2ROcEkxQUlwOUpPQkRJNElqSnUreEplR2dXM0NFOHY3QkFreWNTeGk1dEtaYk1ERFA4MXYwYmJUeUNkY2R5OU5zUU1acmliU1JSM3FhVkwxbUx3akkxYUZyZithK3A2ZVY3azlpekU5V01laTBtbGpZVWhEa1hlMi9GVnZUd0ZOS0N2bVcrN0hhU01DdnFSTnYzZnBMV1BMVHc0enFMMW12MVd2eWg5ZVZvcEhGSDFVdVdCaW1JYTdPalRYUVNhNmtTY0w0YVNOZXdlN0FXQnArcHZsMlNQc1lhTEdrckxaUGdPWmc5a2tiVGd2Y0pSNWZvVDhUNVN1bmdEdTQ2V1JjZWRWdzVkYzRxb0FYSkRiVWFsMmpiaDVzZ0xET0QwQWEzb1lZdFM5RitpV0xWZ2NWZTBhd0pNR2kxUGRwcUZSaU9KVzFaNHg2SlhncVpVSGdacHlFcEhxdVV0Sko3SHUwTHA5Ni9McWZlYW5PUkp0WG45NC9mNUMyeitJRnRJNzBhdVVHMUVxMXEraWlqR2VoU0VyWXRTTUE0aEJBOWFmbnpGd2dyeEtQOHd3cnVzaERhQnhnT0hUZm5zTlIwdExWSkUzMENXWnRJNUQ5QVhIa1JkUTh5TW9TQ3FoRWRCVVpSMHdrS0V1ZXNKbURGSDlhZ1FlZHBCbTc5bUR3K2YyVSt1ZHpiV0RSNEVYUUM1dTg2TXlYdWw1ZnVQdHl5M1hhMDVQMFljbmp1U2RCeTVzT0VCVGgxR25iYWw1bi8vNDJMMWI3N0VQRFpmdE1icWhPNFYydkVBa2xwRmVLcVhXanlWRXpxK09aNWtETTZxdUZzMUhYbGFzTjFLdUphUlpYN0FLMWVzbk9sQlZXMGlMRW1JM3NSblE1KzJYOTRKQWRrS2RLRTFSN0RSQlZCR08wb3pINTJLVDhYNUlaWk5wOTN2SDUzRlZjbHNteFBjMkgydGFaUzFRVmlIN1MybDdKUmpSMVVhVzNGWkorM3NobjRsMnVaajRkaXdiTWlxL0VxQnRIcnFjeXJ0WERoelpVdWpEd2hiSkNCNjVyY0gvaEUrOTErd3ZmNlVGRVppK1JQVGhUWUl2WFN6VEZFNUFEa0NSVGIvZ20wU1ZHdmVsa2pIQTlqVDJaVHpYSnNJRWpHY0VhdkdWSGo0elY3ak40TEdnamg1UXR1TEx3YW1aU1VkNlZPaGRTTmE5ak5Pb1VGR2FxRTk2dU15S0ZLNE1jZk51NTRFclFsVlczcnBtY3ZkbzNjZ1Z1OFdqSW1yOTNhRVBLSytDTkN5bUphVXdRVmowaEtEallsdlh5ZUhJcmM0d3JpV25wV0JYT3JzSVhDanBBY1NNczczSjFEa296MHJ1SjV3b3pYUUVOa2Vld1h0MXJaMjJxSU9BbUx4Ky9USnB5aDFCTnVXaklnZ1VxZm5TUW1xOGJKYyt2MFZFVW90N2ZNRGdab1p4eW1xZzYyMVZYS0lXQ3o3WnNjNU1lbjVpTm9YQ296WEhDZnNRenRvb00rbHZNWnRDYVUxT25MUmF2RitVSzlJNWx0b2pTbEU1UEdWSmFBYllVRzZvd3c3cUp0SUJIdDFWQTdPdUNCWEVWUzBISUhEVnhwbFNyM1ZLWWN1dHpXbVpGTlBFMHRMc1NMeHdkWEM0TnM1WGZ4eWlkYTdpaTRKQjZ2UUtKR0NUQXdLbkpKUkhtMEpIczZOSkdaUGVGcUEreWp0cFpSaG14Tnl4dXlZdGJ1eXkybitrZ3VHNkh5bVZGYlBhVUVQMnk5QWFzY3NreE9hOEdURFNOMFFSdUU5cU8xbmdQbW5yU0kxOThvaitCK3htYVZwdnhYdWpkbXVYNkk2a1Y4U2pXVnVUcmNvK1U2U2dubWo3OEVJTnNXV1k3VHVrekFIcWRZQnBBV1RWMjdqV1FTa0F6am1oNEhQZXdKSHk1aTNTVWwrWUIvekNaRUJvcjNEaURNZ00vbnJLNjRQMGR0VWZLRWFYcjQrenRIeUVGZ3g5MjZqWDZjUG56NU9tcVUwU2E3OTFDUWRuTVJZYXRza3h3Tm0yQ0tCTENXWGI0MHVUU2h5TTVJblVzeC9ha2ZEYkJ3ZGN4U0JMUEFLUFFQZ1FSc2kzMGg4S2twOVd2bCs3bGNrdXQ0d3EzcHBlQXh0c3c0QXR0b2p1cW4yRWswcW5tcC9MQTlFY3A5Y2Q4cWkvZklPOFhxWWN5Szlnd1VJVmMyRWZhNzVLbGNzUmNZaVFWOTdleWJKSzhwN3F0NmZmNE82UkVWTVZvd2xQeXV2cDNpRWpiTG9oRE9MZUFFbXhoWHhNNERjL3NxQUsxd0NmREJ5b0ZCRndEby8zbHIvUzhaM01RV0J5S3IvZ0dnOEs2M0kra2o3MnFMSXB4TmdzYlRpRGdjRlN4bWZXQ1RQSE9UTEhXWTJKTkNMT0FBRWd2K01FWHNRRmVHQzl4V1VqVXlwcE84SWNPNVhnSlg5bm9ZWFlJemIyUTU3a1FlMVhTYklwYkRZYzFFd0dNbnRGWU40ZFYrVjBlR3ZGdUpsQlhVb3B4RnI2ME1jRXM1MUZ2WDZzR2I4WStpUDRVdzhUWXhrN2xvd3VaMXBBcWFlUXJSNHNVT2lzdk9iQTBnVXBMWk1peFd5enJZcVdSV3RJdml0TXJtQkI2ODR3bERONytsbUpxYU1tQnFtL0lkOGJLTzA4YkZhd3grY1BNeHdYYWRwbWtRWGZrcG1GNDJQQXU2eDJsR1pXa2E1WnRISlJuY0xUcU9nNSsyeGRvay9UcVhzS3ZwZzhwL2ZDK0MwZStlY1hYSFVSd3dFbm5CV0xKTzRZMzhWaUg4R2xiSEp3L2Rqa3cxRnhrTHM4cVVCNzc0QWo1QzdmSWF4cnpmNXg1OVZjZVFEM3dtVHo3cnhaR3Z1TWxhT0RJTmlabTlWNWFYb2l2VFAwRndyRFlnaXRHMUlML0JRTWkwYVQ2WnVVYVRZVU10Y1kyVkVycjlGK3lOZzdrZDdPQVFzUXdVRFlQMUpBVjRza2F4YUJhRUt4dHB0cGdabW4veGU1eG05ZlFwRjJsT0N0OFcrb1ViQnQ4YXpUTWZiNUJNc2pxaU1VaFI4SFhKRElNRFVZbXdMK0tjTkEvK0ZDU3ZDRWYvQzkrWHZVQi9MLzFwM2lYVHZPTG4xWEMyZG1yRkZOSVZJUHRiWWlBUFBoaFdsUXNXQ2gxaXRYaHFYQmpsRGdoUFR0UGNOZUtlOUEyV0V5ZDZlNXJsb3NxbHluck1lS3NNZUtYajIxWEZWTFV2UmRieHBMWWVVeWJ2bktsajN1YjFFbHZrejhGWnBLZGVYNm9SMXUwV1Z2eThHMHNoUnhuNTRaY0d5cFdwVHJKVmhMZ3YwYUwwZVJHaWNrUUZQczFmcHVvcXhadG80SmhVSkJ0WFNGc1JhZnJ0VkVpemVrZDVLUjZSWFdncHlmU2ZBbTNxQWNKbVhHS1I1Vm5Hc0ZRZlJrcmpRSS9FYk52QjhUblNFeUxpNjg0OEttRW9wc2xTVERXQWNzQnZHRzQrRWdoNWliQ2xjeWFmY2JnSnpXbDMvUmNveUErb051VHBScldvL0NTTFN0TmlNdk85WERhSUZNVGpNcTBWTThkcyttc3hOQWI3VHRlMUFXNFc5VEZSbUpZOEp1K3Z5UzJYYUNSL1Z3NzVMQ0tOemU3VW0ybGRQNzV5NzB3UkNKeGxKcTErWXJtM29vODRlRVo0Y0szVXR5OWptNE9UemcwTTBzdkpWZ3FFZ1hHbGI2dkFjWUVWS01Gd1JLeWtlREE4TDlpQ3lMam5vN2tTNkZ5dnVZTHY0K2l2ek1RNW9mTnJPcXJFTStPd3htOG1QM3lWbnI4bG9JQ3krVlpCTDgvNy9xUitZUjFVeUpNbGMzLzJ0SUpmS29Wa09wVU8xU0NWUDRIaFdJc2N2Q0xFaWFadU5mUGJhT1BJZ1Y2S3NpbmRCMm45RmFIamxOM1BhbXV6Rzk3ci9CTjNlL25QK2FRck9Da0RPSUgvNmV6blNJaXY0d3F6MXREbE5PUklBeTNBdDNUbFE1Y0pIeW9xR25acmViV3R1OTZONjY4L3Yzcjk5Y3BGSG5UY0xrYTFqdVdaWjZkRWtGZ1R0d1ByMDROYXpFSHBsU2VzT05vWS9WOHl2NmZaMzEvUlpERENqTUFsZzZsaVprdFBRZEZ1V1d4QTZjekZQbmwzUytRU2NJbFAycHBnUjBHbEpYK1NuRTdKdjhrV29HWXAwNzlKZTVTbitaYzlnaTI3bEdyY2hLK2x4WkpkcFhOL1g1eGxqbWVzYzVUd0pBM1pneUE3NkVVeFZuc0l1RXNRT3p6M0xNQnZCQ01BRlVZVFU0TFI4aFJBVFc1QWNISWg5K3NLNFFhSGZLNDhJVlBhdThTb0FSbDZCVklQM1JMdHBTcG95ZVRkdFFwcDEvVjY4RlNDaERlelpqUjVtS2RoZXNqcThWYStEV3VQYnhMNlEzYUtOUGxVaitsZ1EyZ1lIajQ3cEVUSTdPak1ldmY0amFmOXpXT1g2UGZQT1g3a3dWSW9wTHBmOThjREhPS1ZIdnN1WGFaeFh0b3lKb3JBN0dGOFVPTkt6cU5iZ3JVc2Y0NER5QWZSdEp5WS9VOGZmMWc0ZDNYOUhvb211V0xWOGJIT2k1WmhqMEJ1V3IwZm5rYW4rZ2lLc2lkUzdQSHhyWWRWbkJmZEUvWC82NGlsb2VTSHI2MkNrWFI5azVlZ3FVL0ZUTEVtd2NlTFI0WFpSdmxhNm5kVHl4Qk9XN2ZiVm0ybm1CbDJyNVo5MGtPZlJkU3NFcStic0dXc053VVVQa0ExckgxZGVuUzQ0a3VSL0JKMVB1TFRVR1dPMitHMXBFckhOaHNFN1BUc1BhdHdSQVJwSmhRV05yZkJzbHo2MDhycmVyYmoyYkttSml2UlB2MlZwemJhSjNITXpIQjV4MERkSE15VzlvYmYzNCt6NDFWdDZQbUxiNnNpbnZlZkFvRU5VTEgxQUQ4bnBrRUUzczN6VWFjUDFiK29PMHJ1dmpNc0x2TmQvTXRBZnArWWkvd1IyMlMwR1JIYWVnVWJtcDM1WlQrQlFESjY4VEJMVWFBZXB1MUlCc1kvNGJRemI0YXFnZlVHK1VTQlp1VHBOZ0JjQldaWTFCbnlqdkN0NnFCYWMzZm1INi95WGJra1JpSkgwVk1rSytnbnFhdGRiK0xaa3VtUWZhRWpUYm5ES2RKQWYzZmVObDlqODFmRzZ3RkxHMGRPZ0o5UytEWitKbndDVmZycHd2bDZFSHhNakVHYnVRam1XZ2FFRXB1cDdxazVTRDVpa0p3K0tDUXdxVHNKR1ZobXZ4eWdvWXduZktIV3g0N0lFbmQ2WjI3TWxUNTlxd2dZaUF0MERxMzI2N0hTME1pS2hOUTNOUmJxbnVzZnZwYXMzaTdmRVk3MTUzRDUrUXBqQ2tXNlhlOVJTRnoyVTNlQldsRG9QWUNPTFd5Y1pPREdhdnl0RTV0WjJFb25NekJoSkFYclYyc0FnYUJzaUY0YVBXRGtjTlZxc05WNTBkUXRCS1hiOHJRZ2dRYlpUT3JRYWtkNHc0TUxwT2lvdFZqb2t0RUxPbFd3eENPQmhyNWhyVGJVOFFEMm5oTVJHYWRXVlJtWEtYK3FhRUJxb0ltV2R0dXZQQ1JyVitrZ2VjWW51NjlUNnBJOUZ6RFZzQ0hGZ1Z4MVlvazJNTzhZOHpLbTdmVTlXL1ovQmFRdnJFaU91cXdjUmpoS0Zwd1RHZDFjb0o2TkRRWk9ERnFLbWpEVnU3QlRMZEdDOWFRRFJoUkNtemNvWlFvRmIzNW5xbktxWll0ZWFNU2dsNU9PWGwxeS9rVjV1UEU4cW14MnBVTVMycUE5ZEkyN1hIR2o5YXFSMnBTTlRZSFJWL3JDSUI0NFB4bGF2dHloYVJtZ1RoWGRJSXRBZWFBNnp6WDBuTzJuVGxocC9TK2s3dWQwcnM3ZEVydWN6YlZ1NTJSQ0cyQWJBQ25OeTJIWDJtTnpYbUVQOG9vL0xXZlZYOXU0WXZKV29mTFdPN3F6Q3hxS0RnMU9DWXJtcHNMRVlZbWd4U0hnU25GN1FLc2F0QkJNbWFiL3pMSys0NGJXMnJLQ0p2WEtCajJGSEVnNHk0WkY1N1kxNng1aXdCa2pQV0hLWTFad3RVMFpaalk4Y0JQaDlPOEN4UE9VdXV2VEdyZU9PYzZTb1lBV1YzQWxYeTJKMitmbTZHYjYybTcvclV1bnJZdThRRjdKUVM4aVFqQjlLbW1aSTlLMkZaNTFWcmlPV2R4OHBaSW9ZNFdTa3c4Ti9YQXM1VFhkOS9kM0E1TVA5azVpdnZvc0h5RlNrRGM3RHp5OVBRMG9kdi9LT29TeGFtbG81ZlZiMFV3NVVzdDlQUVNJcmJqOEFTaEJzODN5UXR5RzNyNWhGaW5vb2s2Rnh5Y1VXNDFIeGNoTjJqbG03YmlrRUxpTVdyQ0o2WmZmcWZtMDloL0NFTjZ1bTBNQmMzZDZ0Z1BZRmFGQ29BYnQ3eHczdThjdWRJOERXVmJDYkhOaVJzNjdxUnZ3NERIbUJoNStad3FhaWdtbEFUb1lOanAvbG8yaFcxbHhHTEQyQ2phTHdvVTFCM21tNGpOMWJteU1jTXlHOTMwRzNjM21BQVREbGZYdmZqMzNueU1kWGl5WkVhRGZOMitLRlpqUjd0Y2ZiYmQrL1pGMjZvZFdGOEk0UlJzNmJmQmdPeWZWQnVLSGVobCs4eEVIUHdvR3hUYWtKUnhyNTdyeWszdEdaeUx6WVZEVXEwbzdwVmZBVTlOZTJEa21YMzByM2ZVd2JudHBocWpXdWQ2aUUvUG8ySzdxQnhMWUVYVnpsZmJoRWg3SFdNdFJmT2JiMFYwbkh5d1RUMUJaSVB6ZFVTWHZhbFJDZzVkOVVvajVXZHh4NmozNG0ybktURzdMWGo0Q1VrVzQ5cXhINSt1MGR6Z0Nmc0ZXcmZ1ZDVIajdTbjlDNFhMdmJXSGNyQnh5cVo2M1RxM2RLOS9NU0EwelhYL3lOMTc0eWpOdms0cVNYM2EvL3BhOXRldUJadmN0VlJXaWJVM0JudFFTbzFtWkNKUm5QVTBSWFFQc3VWYStXK0p4ellLc2hiVUIyL3FJK1NsTDZIdGxPS3ZMeHlOdS9GSjhuVWpqUzRCNGRoaFprZmdiaHdJaVY4TWE2TFZPMzRmSjArT09KYUZ2WTB4TUNiSXV3NFFIbFEvaFh6aVkvWGp1Zi9wMXdyYjBJOEY2TzFxZ1hyNklWUURKSVF2d1BFMklpNFhvRWFlY3BJaExWeW9ZOXBxSVkrR29PQW9VSHMzZHRhSTcyYi94ckRSSGZ1L1pYOHg2eWJxZlk1OGlhUDF0SVpiR3pYbnArcFErcmhvNTl1MHA2V1hONjVmK0dWN20zS2xIU21lZStkbGRJZmgrcHZ2MCs2L2pWOGw2QU9XL1lhMy9wcFowYWpSR3NxUGoyOWhlZzduTFBrKy96d3BzVGdzbHk5eXF1M2tjT0hHRWZia0ZDSnpubjZkZGcyNTNueTQzYzJmRXZxUHZ5d3lrRnVlbmIwN1E3QlcwU2VZZk9MelNleDRzVHdqQmJndkFFVXZZTDlZeUxpbkdwbVF6eVNWZk0weHVYSFJmOXgwai9hNWtaS3B0aEtUR0p1ZW41MGpudDlWYVJIdmthenpwZytGc3E5WWpnYWkwTlFsd0J5WUlldFI4QjdVTGRQWStBN1d1d3pHWEF2eVdYSVR4TzBuKzBtSHViR3RGL0k1eE9keUk1dVhISjJiWExxN2xwY01qQldsU09ZbWhodHVPYlZsdjR5QzhveEN2SlptTHNNbzk0aGkxYzQySTFXcys2ZU5Ya3ByOTZrejBLcmQ3Q0E4YUQ4NkVtMDY4bjd0cThEVm1kSHh6R2M4VVhPcXV0cmdMNHZuNTBVS2RlSVpzMUdmL2t0dFBrdUFLVEJzczNDc1dsYmorbFBkUFRLT0lBUm9QS1Zzb2VocDQ0Wis1dmtyZzZnMVVqQjZJS3ZRbUF6S0ZkNUhWcE13c3k5dkN2R1cvUTNhbDFyUktSMktiM3RBakp6OGtjNkdSZ01yQTF5d2tJNHdCbDM2SStCemZ0c1BmcTAydEdGUnMyd3RHYmJjbkppTHQ0M29tNUh5blhua3JXdnR6WDNWdndzMU9oREZoMjMrOGtyQ0VIenNDS1ZQTlZHVmF3NEk1Y3BQZHBGdGdxTWlOTUY4aytISmxaS2s4NUQxUzV6b2dudHo1eVdERUlZV3V0TUtKMVF3dDE1S0xmSjZKdDdZNUF3dndub0VMREEwUlJ1REV0enduNzVES2M4emxjTTloQ3pnNlNOeEZwaW5YdWp3Q05KVEF6T3B5MTd3OEZ1YkdRck4zNm56cUphSzZsTjhyUzl0cDhkVXJBam54Q3BLTFp0Vjg2WHQyaWZRVnFGbmNvSVpnWVc3Q1NVRUVxNVRZZHlHd2xseERLUEprQW1LQUZMY3lWVGVJb2o5UC8vckUwUVdQRURCaVl3TUNsMFM0TDEzaXluazZ6cjJqUFJLRTlCT044ck53ellFc1VNeWczRVFjZTI2dm5TWWtscDl0ZTUrdlgyNVBaY25XU2RkYWFOV1dvT1dCci8rdjgxekdBMUxLN25uTnF3emlUR0xPaU1LRS9VNHB4Y3JYV1RXTDJDanNjNGYyYytNUktoTTlPT0hvalFrU2U4cVhzcHpLOVhLU2FVY1JzUDVUV3BsTHBlN3JWQUlTOGxyNjFWUDliUm5tamI5TG1Dc2hNbjFyVFBGVjVwUzhuREJMbUxmZmpKVVFDSkhoQzNtVitIQUZNZUdKK0I4Y2J3YTlNR1l0TFFmTFIzYlFiQU1NVnRHR0kxUGkycVN5WThaU0NsOURObzdhcmNpVzBhc3ZXa0R5TlNPVi9lVnZvRzYxc3dlMzFOSy9kR2Y3Mm5EOU9wOVVLZ1pKN2lBSU1lRUpkVEZqRFdxWk5GMGdKWkdVakVtQ1hkS0MzZlAzaWJmS1RzZmJ1a0NjbHpEbkxkSWd4QzhqS2JLcTJCK2kzdXl6c1R6TDA5TSsxNkljSktmbC92bEpHdFZvamszNDRya2FtT1dBeWt1MUt1aWw5ZXQyb1ZzZHExYzI5ZUY3RXFmWnV5dW9GelAwNFJOT3ZNSU5zVU5zWE5DeUhqd3BHamR3bHhsc2hwVWkwamxIa2ZVWGJid2JiNGNBUWpiRFFqSjdLTkc3OVRlMUdWYThiUW5LOFNpZENkYVhscHJscktiUklHNVRTKzY2NVN6bTQ4Sk4xNWxQLy9SUjFsQWMzSTdjd1MwZjBjUXZTand1cWx1S2hvRHVCQlA2UmFzWjFzdGtUWmhGdHJOaTdSQXJjWXc4aERyTG1YTVBRdDlQRTZCWTdkeVEvUnRoRnFWMWlZS2NvZ3VXdFVyVWx6UU8vRTJnL0lWV0J6VDh5Z1RQdmNSWE44bE56UmFJMFU3V2pZWGVUNFVkM2hvUDlhR0pSbVUzUzdHUnBZZlZoTHptdEhENGkzVWhiUVZtblhDN2VlR0Y3VE9sZHdwUzA1RHhQa0llNUtqZ0tCTXJFK1ZTeEgzeE4zT3p6RG1EOER0eFZlaU51VmhwQy9oK29vL2NnMy9lMWFWUEdJUXdqbWR3alF1eWRPQ1g4WjNseHYvb1Mrb3lydWZWeDdELzJhT1RqWDN5dzJyQ1AzT0RBRDV6RFNaaG5NV2hGRHFGWThiUWlmT01nQkpNb1NqMmV3YU0wWW9YN1N0RFM0eldDQVd3SFFXMExjWVQzenJYb1JhakpjRGk0ek1Ib3J6RUVNS3krTXdXWGdjNVFUWEdVWllWSE1JZFZFV0R3RUFtSG91UVVTMzZmbmF1elR1Mm5qS0JEaWNod3QzRlVDdWpYMjlhSDlCVWJCZ0xrNG9wSGFWcThSM2diUTkrV0VxOEovVkhFNUtIZWpMRE9CbCt1NXhNMXNiSkdpTzJCVHYvL1NEYjI4ZVZYMkViZ2ljTUJ2RkFzS05KL2ZneC94eUxWeGQ3ZjJTTktSZnB1RklpMTUvdWhBZmZMS1g1c0dQS1gyTEZadzBYWWQyU1lJeXBMcmp3b0VpQUxNaXpYbHYzNU1qVzhlZWt0Y1locC9OUHpveHZ4STFCeHMzM3pvTHVINi96cFg4aEdsSENNaEpNUlFxelRmNElZT2VFallQT1M2R3ZSTFlxZDlTZWN5R0N1eDVSU3g3dVlUZW9hWjlQMXFaOVJueko0OVgzLzhrSGlqREtmSUMzSVVZdFBWempoYTA4MlZ5ekRpb2tSd2kzQzN0V1JmWFVYZlFJTjNuODU1M2F0MWZXWHRZMzFiMjA5a3RPN0lHZTJ1Nmp2ZExkaWpQYXQ3b1hSWGNkT1p2dHp0NTBxSDcrVGV6V2liSmtySnAyNitPM0ZhWTUwOHFuM3EyanRBdlNRWFhmbDBSWFo0Nm9yZUFnSE5KeGdzNE9ua1pqclozbURCQnNPM295eDhPejhGYmczRjVVM0YwN3BXOHliajh5YUJsMVFZR24zT2dkUS9zY09vd01OK1FpSGwveVRQajRhbE1pb0xWMVZjdXZrUDdSSGpSM2VmdkhxdWZUNDBnMnZ1clNoVkhITDcyZ1pOOEdSWlNEMHRJQ0YzZ29tbDNLZU9xSVhYME55S3pVT2JqeGlzWEx1NTlMem8vZjJjUzljOXJXSm14dzdlNGQ4R212Q1ZvTGhzak4reGxDQTNRVlIvVmxPU3NCWGprLzloM3BFWUJKaXRwRDVFOGRHYjNwdXQ3ZjRndjd0cFVkUzNSN0hveUUydnplcDl1cmMzeFZiZnZFTnAzTFR6OUFlMVJxMkp5NS9PTmlLYVQzOGtOV3FmdmJZaFdOTHNWM285MERZK2dXajRwQ20zOFV3TncvRFFYTGJJMHpiRTZ0c25hdU9YaWJhREYxOEQwMnE0eUwrbU5LOEVuNHpMdXB3L21wcW5VbEhzRVdqWk1vckNKVit0YnR1NXM1bFl5M1JRa1NoN1RyRDBqRktENDEwbHlWRXVOSkUrRXZneDltY3RqYXBDNlpKUmlYZ3lja3J5NU5kN0FqdytHU3I1UVIyaTc1cEErOGhIbDZ3OWxzUDNvbmZ2Ump1WFlzdWNyM0R2WHZiMkQyOXNEQi8vL0RuQ2Vrb0Y5b1dwZytqd1dLVWdmRnFFeVpZYmY1aWY4dFE2WmFIbnhVT3hVTzQ4TCtDVkx5ZWZlYXp5QWR2M3ZZOGU3ZTU5K01oV1g0RDU2UEd0cnlrOEhzb0x4cnNzS1VYVUphN0JVcm1nMGhBSHI5UEx5WmJtamd4eklGa2xUL1VwMWZhU3Y2d1lkcHVsL3VOUVRrd0J4TFovRC85eC9QZ1JmSVZTVkZQZkhwOUVobnFjM2lNd3RKUjJveHRYaXRFOGF1TWFZcFlRKzRSYlNaN0xkL0szMnU2WmJtVWJwU01DcWdYL2R1MDdmR1lRbjAxc3VraEF4aXFtNVdKQ2NEbEFlMkJ0aGhPSzR3RGJKdVhCTlZGMlFkL0UrRWhSYlJ6R2I3RDdWVk96QitsYjZlbkhUK1A5UklZYkFHV005TVNabE5yUXo4K2hlbmVvdCsxZ0d4Ykt0WExnTkwwR2U5N1JGSnJWMklHWWdCZ01CNWYvLy9hYkdyMFAxY0xyeDl4UndIbzFvd08rWEt6LzRFZlRHaktvSEdBM2lDaSs1cDVYbHdjT0RjNXI3djM1T2kvbURnMGRuRnRhNjZFczhzNE9ENUZrZHhLdU9KSW5EUXZKeVFmWWZlTEpxMDM1VEptTm1ydzJsYlUwcWdDaFo0NENSNWFVUEhuaHBhbi9zenlOcVdLVnZPZUVQSi8zVW9uTkh3Z0VqVWU3S2R6TTBaMS9WZkVBWVUyeUY5UVpyc0xYbDVIQWpqd2tlWjlRVFhkNVEwK3N0Y3RXQ1grdVVyNndxNmRyM3k3bERIUncrYzRXdDJnVG1ndDVKdjRPSUxNMDRFNUx5Wk9UWlNLOG1MN1F1VlpPK3k5VVl6UGVtYVU0Q2d3Q2VZMXVKUnBqdVpZODQyb2tiWmU3WlpCNjhIT1ZwRWMxalIyRG5jcGlGQ3ZPbTQ5UUNGY0lTVWZ6Y0tuM1N6RERwY1RkMnBnMXpNbWNrUzVTa1R1S1JmbDhWaFhMS01uUFhsK1ZtWU9rMDlPazF2WGYzbFE1ckVGT2FDaEhDNDVmQ0ZvalRPSkxGcGVzbFR5QTNpL0JqbnhFSFora3hsZm5TL2VwRVk5Ry82cUFWK1hPcTNjZDNKZGhIVVNkWktyNXFtVFBhc29HK3RNaEp1N3FweXhUVlBuSWhOb2NIYmhndTZCWWNjTUxxUUR5cEdDYm9DVWdzajNzNUpxdk1UblYyRWlzcUs4cUpsNWFoUmZoSXZkV2F4eThrdXp4UzA4MGNMTzI4bmhtWkRDVEVQY2NXRmkvbElkbkExdVB2VWEvayt5V2x4K2d0aHdMQy9MMkxySWRYMTN3Sm5GMWU3VjgzODd5NWoxWkM1NVMrRXdnUmhETDUzbCt2OS9VN0hsQWlxZ2ZWVytWVlhrZDdtNSsvU1c2aXVieFphL3RpdllCVmpjVUQzSkNRempoL2pyeHpNSGozNDhhYXFFKzZyVjhkVlUrd2lkdlgyeE9MVFhoSWFNRCtSU2hWN2plamNRMUxVQ1NzYkNvaWZrV05FUlk2OVBneVdGckpsWlJ6ZHhTOGxzQ3ZMZzVKeThhTEU3RmVLNzltMG1FaHZQclRVM1loOHNBbks2TmwrcHR1cVRlMWQrdS9ENkVITlQ1YmlnTllpMHcyRzJnUWYxdjdXemltSXora0s3Y0VSbmptS1VKRGNWVFRYcFdtbWhzQVRIQnR2dWxpZXlXcWxLTittZ2U0SlN0cStKWjdubjlVL1hvNDdua0x5cThjdDcxTCtWY3ZDZjQ0dGNxcWU4N2Z0OHB0YWc4QzkyaXlvN1d6TzE5eHc2TWpDb3RmMjlYaEd5U2xFRG1sejBpTWF0dUQ3NFFFMGlNY2ZUK3A4T2xOTURFd1BXYjBtMnFTSUorazdsRmN6ZTBtZ1o2bnJ1MG00M2IwRHhRdXJnZjJnQU5EVGhtUTNWOHl2Zi9pQ1R0MnpFeUR1WjVOQkdRanpFTVpKLzlqa3Z5RXpBYzFqVk9nSTdEY1FCRGU3QjBMd1V2SzVaY3QrcU1keitBUzhKbmJOc2RwNmJYb2xnajE5eXZmOVgyOXVwamE0ZTY0RncvQkJ2bEVjT1BUYVVidURzRitSekZzUGtCL3NGWmtSaC9WTWVHQk1LRUpYd1hHVGxKZWIrQWlENmw0b2QvbjBINHc1VXdDclJtd3dkUjUwMVM4KzQ2MnhKWDAwMHJON2ozdlFzZDBIbndBSGJibHJCNzZlUnpRMm8rekxJenQ4ekV0eVZsWWFPTUVWV0l6K2JLNmxXbmV1dm55dHVjT2tJSnNYeUVlMUtqT2FRWDBjajRYdk93VVlFM0lOYk1SUm1KWWF6dy82UGJ6NC8wYno1UXpBazYwQVdYclpIYU9QZ3I3ZEFWVnBtc2JFR3FjNFJGM2J2WDhialRMWHNJdUg0UDYyZVNVRnhoUkZkQkJFakJ2WjB3SHFEWnUvZ2dzcXA0UTN4c1kveEJMdlZUTnJoSkFjQ1NpV0wrR2dibTFUZ0FUTzZ6UkdTL2V1QUszSXEyUTFPLzhubHd3Nmt1Wkl3clV6ZkVCV1U5UlVuWVBFY0dRU3FYTWpjTnJPMGc5YzFCd0dmN0ZLMHFlMTRwR3JTbEdObEtjWDg0RFZpZHpIeTdiRmxzTnVXdUNjcWIvcWJuYm9Qd0E2a1hueEl5SmkwdERudzU1TUJtS3h0NmZERFl5Wjg4RitadmVXRHhRNTVMWXZoNHVJYkhreDdqRFRlNHA2NjVIMXhOMzgzWFFJejBRSHJDUlI0YmNxcjFzTkVieDl6THNkb1VQOTBmbUd1NVR4ZytlSC95WllOaStrR1RBWGtYZUc4Q1BaYVZMM1g2c3cwN1p1YW5LK3hHM2RtTUFLRm9DeUZ3ZHhMMmRSd0NKZHhna1M0V0hLblorTkNEQU9nR3c5ekcwbHp6T1RwS3NsMVpqT0dYSmZ0R1pkUU1GL0lwVFlWYiswWGxoRHhHNHJRcXBTaVVUM0VhdU9YWEpnbExxT2sxUlp2QVV4Mnh6Y25taStWYUpTRngxYnVORWRnb3JVbG1nM2QxdlE4WStsZkZUS3pjcU52UG02OU41cHdBMEV4a2ZORGsxMzI2eUd3UUY3dEdRMUZCdnV4eG5YcUxzVUhlc2cvbjhyb0dtTnFPMnYzbUFxY2diK012b0ZpU09XRVRLN1ZKNzZGYWw5ck85TC9iRzRhNDRiUjVOK0w1VnJUd1o1dnQ4N3RtbXk1YSs5QXNmTWtoUGFVd0x0THo5aDdUaS9TM0dGSlhYVWNLVW1zWTVSWm9vK2JiY2k2OEI2QlJEUjhMaWc5SjdyRjI1Vm81eFQwR29INk1SanBlaCs4L1k2ZEd2cUExM3FQNzEraW15STZBU21EcnNZZjJPMGsvYzVKb3YzZmJjVnkzY1JHajNFZXNaSnBJN0hGWXBVQWxGdEdzRmNXeTkxR3pCam9FTFBmZVU5YXFTZzZYUEJkMkQ4Q3JmeXNML3lnOFk4VGJxN3pvRlhCWHJwVDNsWElMbDlMOU9JVGJIeERkVEQ2eUdBTXdVSldUaitQaVpiZEMzSHVDRXVzMWVsUURNQnk0RGJMZU5FNlFuL0xRYm5nZjVhMkMwWndIazJoa1BIZDYyd0xOamJWZTJRR2NQcTVaU29ub3B5YVNHMFVqR0dBUkJtNDQyQVhiMWxRSnZERC9zblJWdlYwbFFLRmF4NGhOMk1maVNjM2RJOTBNTUFtQVBJeFA2RjRJZHVrU0psUnA3aVVQQStxbC9SQkNUWkEzN3ZmZER1R0Z6VmdiT1luZnJocTl0dHRQQnJHMkNCYVU0eW10cjFDTGRPYks0NVpMTXE1VjFnQ1ZoVmVwME5CNlhOM0hqMXdGY0JpVXUrVDVNaDE4RUVINkpWVXp6OXFCaDdFQUo4NkljNEdQcFltUDc3SVhnODUzMzFkU3F0NTl3bStaeHpBNUhia0FKT0txZDArWUloOU9vUHI4Mi95dkNWQ0FUbTk4emdGZjFHVEF0dmlLNzBoaG4rY1JxaWhHQzZxVG95T2lrOUVDcGNDcXBFaHhiSkxwVUg2MXFpZUg2ZHlFNUFUWnJzT0haNzJ3ZnNTcXZ3NTNkMkgzcXA3dXdjT0cxUTgzRWVWRzNwdllNUFN3ZVZodngvcng5S1BjclhsS2ZpbjZsdVpzNitjMFM3VVk0TVlQTTdkSVdmcElKd0xTa3RNWWZ3eXBiOFBHaDlSSGg3dDdPV25aYVNjcVVwQlFKc1U5eXMwNlpWcTlPMVowV2JXTG9BOUt1MFNCUzZMUDBIeVRVZkFiRU1RbnFEQXBSbzJVaitnQkVkcGtFUHhYM3kvQzRPL2RPa0ZCVTMxbTVnZGpCbjlCRXdZbTk0RzZLV0RCL0NCdWZQUldGUFYvZzIrM2ZsRzd4L1hrTFRIMWw4R1hXLzlUTTIrZ09MV2lzVVFSaW9QeXJJNFpTNDVoNytmNWgwU0dKYmw1NzB3cmVWVkZSVWJFUjJHOGFLUnEwVmlDQ0QwUWl2TGFocktKVVNndkRLZG0xWGlSMlp1YTBkMERQQVFWV09TcktUSnZ4NjRlOU4vUmhTb0NndFJESnpDeHA4YURBK1ROMkNPOXpNd1BteFowTHhIS09vOXNkVGM0NFI5WkNMd20ySDU1VGlkL01DZURoWFdUdm9iVW9vN0NiTHNNMzlYWDdmNU5OcUxDL096Vk5wQXA3ZDd1MHVnOWU3V1AxK3ljWGl6TC8yZkhKcjBMTzRUNXdQRWpwdkNmNFZLRHNvU0hoeDcrVGxvRXZRS3JISitSN3VJRGFONVpOSDhqdlNLU1F6NjVDc2pLN3BWRGNTNW1sbzN3cTF6RWpnVXg3bk95by9ndTJ1czB4dGZkTnJIQ20wdmVLYnUvdFVJUnpUOHRQZTh4elFmUFZ4bDBjVGtIakxXN3l3WjJkMitZazBoK3owZ012YjFLZEhIV0NMQ2pBZm9lL2ZuRzhIOW1ycVBtZjFIUnJlb3QvSElGV2U3SUE2dEdQcGxMR3lBZHRZbjdKQURGRnMrMkZKSDVKTFlyd0hHVDN6aUhmM0h5NXByZkE0YVptWVBzaHhsZ081UVpKaTNLdFk5TE1Ba25nQTB0clhZTUl6MmhiNjd6Tk4xNER0TzdUYm5qQVAwTTFvZk9UNjdxL0tuOUoycHQzQUF4Sy9oSU1VV2ROa0dCbENIRXFNRGcvUG0xOEVXUXF4TjNLR05KVjJDS1p2K3VFUlBEK0dKNjk1WkRpeEdpMm9GZlMzV2tRMGxlQlB6OEpvRUZWcUExWmtEV1VvQXozUU9UQ3JGQjJNQWQrUUpoWEQ0bUVCUFVWQWdtZWIyWmdGQTBiOFNoUmxTd0VROXFYcTllaUpmTkhRV3BSUSt2SFVnUzNYNVhpZURhOS9URjlPNXI0eDJsQjBqQXRabnBYZGUyRVB2ODQ4Ykl2MU85OGtjWWluUkZpMWQwTEZPRzRWV0l6aVNKTVo0b3p6cnhXR3pVWmxnNGlyTTlLand5WG96aW9qaDFvdkRRRkRFSVhkQktmeHZxZlVPVXdHK21aVHVtT1JiU25DcWFSQkZmUTNqTFFWbGJLbWdaVHNtT0VocURYVUVIbGl5cDZibTJnT3phd254bWllK3JmM2J3UyszVGluZm1YOXNCUkpiU0x5MUhGQlozRGhtOHNUUDQ5OHJSOGNYTFI3NWIyLzFzUHc1OTFEeEVYWFV5WEp2L1kvTFJqZU0vZ0cxcnprQmMraHlQaTJtTFJRM0VZMU5xNTRadWlpOUlSejQyd3BuKzVBU1M3THhydktaRWZ6b3luYzRzMTNpVGtDTW5vR1M3dkZkU2dqWCtpM0xXOHczT1hoSWc4ejRFeG1WNGRPcTZSbUxjUTA1Z01MN2JCb3VTZ20wQWgydTNQU0w3R0pSOUhuM3Q1WndEbHA4Zmt3OXE5L3BIb0wzUnZNeVF2UUVoYUI3R2V6M0NqdGxBbXdsakNqS3FVUWt5QkZpTjROZlUwVVRwQmVscmRCNnRkazZFOEFJeXdXcXgvNzcyaVdKV0FrQnNXdHJtM1pIUlQ4R2lrK1JFQklYbVdtTU5oUFQvd0lEaWJJYk93aHVENEFoS0tmbEJsV29WVUsweWVtQ0tnQ3Y4UmdMdlQ0OFRoNnFtSElNdDdIT0dMMkZERXIzRHFWek1mTTUvZXRFT1o0dGZmakhCNEw4K0NoK3VoaVpxQmRkTWh3LzF4bitydzM5KzFWRjh4ZEdOWng2bjV6Z2lIQUl1SFJQV1AyZy9Eb2FxVGR0ekI3alRZV29IYVQ5cWZ3QTNXYi9xdGxYaXRnRTNHYkRkdjkyWVFMQ0wrenIrMTZYcUJpdjZiTzRrV0VhT0h0NFJmUHlXTlhUQ1kvemZXK1JnNU94aFlNZklpSDVBbi94cHJFOEFBYXJ5VkdPMEFoYmNDYXRuRTVOTFpad3BzNVRsY2U2NDFjZnp6ODhwOC9qVExKbEduc1Z6Rnl4MG5tUkZ2MVJ2emYrdXZDZGxncFQ5b2VjYVgvM3c5NFg2UkJmUDBzN1EzK0o4cEVLY2U4aCtrQlg5T2FTMU9jdStJT0FNVEUrdGxZK21BVGkyM1lVd1VMSmloSUsxWWhldlhJSVhxNXdDQXpGYThsakVDUmFIN0RDRXJCdGY3dndoRm9kcytDRkdxV1ZZUENVQ0w1bjVPZmVmOHlONE1Oa2pOa2ZTajJCUDRra2ZzcXNMcnRseGVoTjMweHAvZkpNZi9wRVNlYXlyRC9WUENGZm9vUitQU3crQTVwOUUvZVBydHdhSTRhMUlLblNJN1RrQjNYVlJBUTVPWEwvNlhUSCtZRFB4RDY4cEJFS2Y5RU8xRnEzUDNzb1B6cy9wVWFzWC9rVDQzT3p0WXpCNTdnQ0p5emkwU0puVHZyRDI4T3pwb3d1NkZ5ZzNhL0Z0aG90R0QyUWVva3lEUmNjVTBCdk5ndC9LMWxPNWJxZEpIc3BVMmdwWlZlMWRCdkRRK3kvVTZHSHY2UjFiU3pYSGNoeXN5S1cxbGdLTlBMMHVOcnU1NWxTUnloejlLWDNzLy9vNG9GdEdHakRKcjRnc0hacVRsMFZDd3hXbmdNK1hLZGtuZlRSbUdnenlGRk5pOVcycWEzY2J2VnZ1QStGb3l4QnNLSFdKSHFGWWhoS3d1eW9ieHJaRGtsNzJSL0t6QW5Ec25lR0NocHJtQTZybEtzVi9kWGROdW9oY0twTWptWGFSZGp0K3VMa0J4U3Q4MG42dG1UYnk1U3QrZ0kwK09GbURTOEo2RnlYNkl4UmZzZU13YnJqbzJZTG0xaU5ic1dJVU55YVloMUQwUmtSSzBMNjQrSWVsTzhkS2xid0RYMXJiY014VFl0OUlPZGFzdXN3ZWVoS1dKLzRQYk00ek5PR2pmRFhHb3pTQ0VWa1lqbnQzVmYycE9uanltdkNKaGE4a0FNc3VEeFkwVnJUdkp0WVJDaDkyZFU4NlJibnNUUHA5T2xic1ZQekRqUVdlUVpsVmVMZDhxK0VEbzhVT0Q3R2tMUm5rdm5jUDBKMS92UVRyUGZsdzVnZTNYNDJlWGVqR3BndGZCTG8vOTA5V3c3OXVtdHFUR3NocmNpdlJHTTBsYklLNkR4U1NncDlOcVQ0d25zZEhjcUhvd1RSV0dkMEM0SDJHZkNvL1VmMkJMNGx1Mm9YMDIxNmg1SXp3cDlUN2F2cHU5L2R1WVBXemtqNnFRNi84M2xrQ2YzTllRR0ZMeFM1cy8waXdnTzc3eTk2MC9lU1pkdktWSzc1ZzgwK1hLendLdDlpWjBVS3Znb2l2bDdCWXNuTzBCTXYzY2VtKzczbCtRWjJJUzF5OXhSck5aSGRWb3lSMEEyZmRxbGtZME9SNzFQbTFuTVV1TzVMZTU3dlNwRFh6Ri9uUzM5b3pWOHZRVW8rV28rRG9UeHVxMW1VQUlraGpwam9Sb2thZXFXeGZGSURXbzdHbmZqMHZjdEdMMW10Q2twSGFiRTJQTEE2ZUFiWDIxaTcxLzBoRmkzeVRYVFNTVEwzYmdiWjlNVWdFYWgvd0FuNVV4UUxPTEVrQnFxczNVN2pwdjQvUW54V3pxZ1gwOFU0alJLQWVmaC9RalBobmwvWkp3R2JJUUdnazVZVG9jWEg3WUJmblJlMmdTQkJyNVFqUENXMm5sMXBPelpkM2F6bnJMSGdCZlBJN2FLRG1LYVRFSGVuK2t1bmVYUUcvd3BJcDViTUl4WStvRTFhdVhqbTZQNWR1TlZlNHN3VnFTNExuaDhVOXhkK0F2cTB5STdvRVhpVThPNkZIN0FMOG0zTThSMjNXWCt0aWZGZTBWSzMrdmJ3SW1CdjN0T2FxeUhNQWViRHV4akJ6V1RUbFg2RWpKNlVURzJTRWhHc3VHM29Rc09qOEExQ0NHWTkyTTNLNld0aDQ0R1R6ek1ZNlAveGYwd0lVT2l3RXZRZzh6ZFZBVWl6RnIwc1E0Tmd3VjQrMUs5Sy9vZWJGZWdQcHpuZURHOE1MVWJDZFJaQ2dOYUtROC9RTTYxSlFOSDZaank1Q3Y1V25od2ZPVi9PWmhPOGVFNXVuc0duSzRFcGxTS0J1UlhGbGU2K041ekpXNXRPTkRzR0dlYllYNUkrNTVWUWswVkloU0w2RGdJZjJUTXBLdzBaNmR1Y1ZuM0xQcmdzeFNQM2RmVXJWdTJzdW1lUG1FTE5lWXNTb1YxYUZSWGs2QWZxVGx6RzBHNTBSZmh0ejBjZ1JxaUxpWnJoTGlVWjF6dk9LUnNzaW9qcDZRbUxPUC9vazVsZVJFQm9XbllEeHcvaFVKZ0JWZDY5T0N2L040S0pJanNJTVRHZFBxcE5na044c2N0YVIzR3ZhNC90UWw2MWZOOVRGUlF1VndyWTBGbkZXNmp3NXV1NmxhdnJnZCtPY0ZKUEZNRDdDcmNmTGdOdUszd0VzNW9BUmZFakFuRzR3TmJ4djROYXFxZktUNlF0VGZ3Zmtmclo2WFFaZmd2RkZTYW9BSHd2OElaWFgrbnNZRkJKbTdnbUpRUUYyQlNXKzYzazdCTDBkakQra1oxNmhHNm5XYm03c2R4UkJjZXdUa2EwVTZsRExDczF5RHRMcVVnNkJCRU1ZbE9Bb1kzMHVpcjBaMkZmdElMQUtOTEhnNGtxSFNtZ0dzbkdTZzBJZFJMRHlncGlEeVVsdFpIeitBQStsZU5OY2pEYkRRWWFOTHZ0L25ZWDFUZVl4bEE3S2JpbyswMDE4RmYyajI4OWNHWGNtVnBuUXNQSjFXZ0JXS0dDaHFoOTBuMklZbVMya2NScnNEbFp1UEsxMXorc3gwTVJZT0lKeHAxWGZoU3NCV3RQV0lWbDRnOFZDSlhoMjMxcjYwNXVlYzRDaUs5alNrNG9ZRlh5a21LREhlRGhRNllxWUZWQkJtcGljY25wMzUwQzlJK09NdTdrM3JodHlZaWt2M2N0UkJ3Y1JEM0xLV1hMOUQzVTlNb0ZmbkNQUGNxU1gvNzhzaWF2YktWREx0dWJZTU0reFE3YVIxVnQvR1UwNmR4UTVSd1VIZC9RcTgyUnpuTzhjMmdpa0NmWjFDUnRMdXVaempGN3lWdVVwdm1LVVZzbWZxKzZXQ2pDZnRCaUd0R0lhS3V1NTB1YS9VeGgwM1VZSHpWQmpjNzk3cm0ySVF0OGJ5dkdQMjEvSUVkZHloOFArWGFXQzY5L1RGOU82cndORUlET3lnRDg1N2ZhYnJFSXBibDNZUVJocU5mUXZhM3k1U054SjJYSndxNlNMcmpUYTQ1VGZ2SElnTkF2di80eEEveGx6T1ZET1BZVHZBeGFUUzNjR0pIN0k0cm5KQTZ4KzlkQTNKTFZWK1ZpSVdmeEw1ZFhkQ2F5QkJYZjhhQXdXZ0hyb2sxUEtDclpTNm43bEkvSlczQXVVbjRTT2hzL1RrSVQ0ZUFtNG16K2V3cmxMeTlPQS9NM1hEeE9EZC9wM0h0OGQxN2wvTjlULy91Zm5mdDNjK0ptWDAybWhCM25GYWYzL0J2TXJMMi9MNTQwMGNpQkFjTVNEdGZrYktEdi81bWQ4QU41K3gzY3FBUERPWlhmTy9PUFpRT09Qc3JlQjhpa0F3VS9PZXN2amYvOUk5VjdiU1pJQUQ2K2o4dElkZ1FXQUFua09vTDhSMFlsVUZoLzlFb0taRS9hWGpNM3BwYkxYVXROcnQ2R2ZpTEhIME4yYTlrWmRwNkJWWXRyNXV5T0wyQTgwWjVRcGlyVVo1TnFEVmtWZ1Z5WDRqMmQ0VlJXNlZZSWc5RHl0ZG0ra0NWbmlyTWZHWjF4bi84STBqcE40NVFrRk5uVVNXMCtBamIrYmVzMTYyMEdJSmpDMXJmaTZ0KzdYM0FGc25PU2JkNjJ0SjltNUhsSEZNaWg5eEZvQm92YWp0eTVoWGNkK2RXR2FDNU5tdWpKYVhLaG1rUDB3TER1ZkVUd1cyOUtBemZ1SGxkWjNiKzJKL1RjMFlPTnQ4TzF4TVJ0UFVPNWo4Q2pMOUhWTXdiVDFRTGIxVmdPUFJSZVE4MkZnWE0remdsTFIwOW5Rb2ZkQ2tPTlcwSDBpUG1VSmZTeVNPZ04yR3BmMlFpL3V6WjZCMUdzaGRSY3NjczlQRTRWdGYrb2h4OXNRcWh2SEtSU2ZNWVpocHhNeHZzTG8zM2t6Q3pnK05GbXRRbktnemVNcFhSeDZ5MEQyMXhpejFZU3dKNUxWdThudDMvMDZiWHUxMTluZUtpbnRiVVMwM1dCa1BQZXFDdVc1ZzRZNU5LTnZpV0o0WDdmY2xueFgyallHSkd3QkJZRVZaOWQ3TzRhVWFLa21Jb2JtdGcwV0l1Z3FRN0hPQnRaeVcvSzlXTkFPMkFJTEVSQ0VkeDYzSGtkQ1NZMnVUZlFXb0xnTkZoRFV2OTFaUStKZk9IZUQ2YytEWHloSFBFK2cwbXBaekFmMkZGcjZHS25CRGZocWpBR0Npd0VPOElHK05UWWQxd1BzbSsvZUFTQUhDbzlwZFM1bTRiSk05ZSsvRGZqN0dQUXRRdnZYclQ2bXpEY3NaelRUZFBwb2NxWjNyNzR1RS9GUTdFVFZNanJxU1JwWEFPWmtQRnZad2xhRjNZanpUUnhwNXNzTkNlQy96djZsRFpScFRVd01zVytpaS9DcDVWTkxSRG1ya0pZU2tOTmJlYjZRZHpWTXhLajE2R1ByLzFKSURaS3U3dGVPVFJ5eVRpZWtzVDQrb3dGOTJlM3Badi9jTDBlT0tDSnI0eEt3OFErRjdYbWZPalljckxWNFR1dmIwRmZNQ0phVEppRnRzMElxczhLVFFuRG9BdUR1OFF0SzBTRm5ZNStGaVU1TllOY0c5NHM5cHBNRE1GK1NVYjNZbFlBSGN6K1A0TlBWeDVkV3pjSUpoTGxuNE80R0lLWDVaUTBBdEh2bnExblY1c1MyS3lkU1MzUlB3Vlh1MTdNZVJsMGhYU2lYOUcwbGFtcktXS2JmYWc2SzdSc1UrK2owZWZIMzF3MTNBTnhsamlsejErNXlzc3RNbmp3b0ZoanFtNWgrUGRYcDhtOEplZWFnWlNOTHNpWFdJclZVV2JaWm9oT0tPV0ZPV0hySElMb2dqVjdXSW9wd01paW1tSkJpZGoxZ3FnWmhPcE1GTHhQbkFkRHlHSTk2dnZURDZGL2FRd01manRVd3c5M29FLzA2TFFQZzFzVzBDM1QzUWNTUTFkbzZmdmpiV2lYOGF1SVk4ZFRWbnlDYkVWTGZiaGxQdURmM3M3WTB3ZHJ1RGE4NS9YcTF3cTN3SlZIYzh6eklwclUxOERPcS9MN09kMVA4azNqZVplZkRXUXdFOHJJT0dMdkh5UUdtQUtNcnQxWVJrRXNBWnlLZnVaU2JOUmxqRXNWUlN4Y3J5czFjMWZ6SjB5OFArV3hUZ1diYkpLT2xHY3M2c1cyUlUyMjMxa0lwcVFqVHZneUNUUHNWUXE2bEdtMWQ2ZDFwN3liQXlBaEFueXhmUWRScm1ZcnFQOGFPRTVKanpGVE1xa3dqWENPbXF6d3JwbDk4NGJ4VVlNWWNLYVBmdkU4MmlYZFZ6b2lGdGJXQVZLUytxQlVFNGtVYkVHcUxmRXFPUGNRY1JjeUJ0MGI0dWcxREZDYTNVKzBTRm05RHAvZzduRElOUzdnU2xTMUhvVG4xSDdiZ2ZZR1ZoYmxUZnYxVE5QVnU0N1BKaTNhTTdlczQrUytVRnJIeE55ZmRNeTFDTTlGQW9aZ3FaTUdRY3hBd2pHTFRrdk5sRXJLT1FWWVhGdXlKZWdjMFIraWVrd2hja09YcklkbHZCWU9pT2lFZ1R0S01McFh2VWxFRUhXR0pEUkpYQ05QRHVWYWhhTmFVUjhuRU4rYnU2b2t1L0lBSkNHRkZXU2VkMWZlNjBjcUs3RmdUUkVNeUt4WmRPY3RGY3RhYXlJQjZPTTlYbFVHSDNXN3JhS2dpY2FockRqZ21tS0R2VHNTZGp3NTVCeElPVDE5NDJGaks3SXNMak1JWk0yZUd6TzJDU2RnV1pMY29VV3hVY0dFa2NUU3FQODVYU0JuSmhFR2MvRW5iSWJJS1AwVDkra0dDWFJEVzlQZE52UDBCUnlzWUxhMFFQU0NRTHpaek8xa050ZXc5c2hMQmhCcG5JTG81WFJ0UTNOdzBQaWhDQ0NTWlQzU3F5UlRjUjEycFJNcDBpaHNwRWd5TmhPRG53MmNabVJib0dBcUJubTc1Z3cxTWFVNkNDVy82UU95N2VqckVldEVseTJrUkFMdVlsM3VtVnVOanJJOFZ5M2gyRUlDcjZ1TkRSUUZWTEREbnFKNmIraVRxdmpVMi9OclJZZGliZHBZUTZ1NVZKTU9uMUNqcFFPeGJYSEtVSFpFckwyOVBFaExkZEN0SkJWZWJVWnJTS3JOUmlHUlhaU2x4K3FTcWZaaGVRdEQ5NkltMG5Rd2lCSW1zdmpEY1p5a1prQzdhcXYwZ2c3czNDa2lVck1HU29YZmdyczlsZ3dPTmFJMWIxaWNxZ0h3d0QydU1aa3IyQkxuUXh2UmZvR1JjQy9LQXhoU1d5cWc0TzFrRlAwSjl6RkxxYUtGeVVmcXdDU2t6eWV3UnNHN0pEMEFTQXdQRENDWllLS0dScUR0REJOL1NROFV1UWsxaXVab2c1bWV6V05ZS2tYVmxjN0d5Y2sxbmMyVzlzT3NlT0dCRHNQQUtaNXNIdU1PNGxmVkpaZDQ4TVdrNGU3b1QwR2FiRGZpYUwreFlCU1NkTnErSkRZRFJaS2tLcG5ScTZVL0FxTWNYWDltZHFhRmx5TUt4eG9SVGc1bnBBQk0wOXA1YkFWdDFuWlcwLzZvWnY5dGFBdDlJYU5qMlRGWlZ2WWxaYzFqaVdZc2pHUGFNOSszRExOY1A0QytWQUxDYnRYWmpSS01MaE8vZHBhMkpWYjB6L0tnYVJIazU0RXd5K2dnZVpja09ZNjVFaTZBM2RmWTFKaHJoWk5VWnViaWpvNGtsaXd0Q3FoRTBFMHNZc1FWOFpFdk5GMDM5ZG50RncvYkM2TmN5bGQ5M2UyNVVrOWxpdGRrZFRwZmI0L1g1QVNBRUl5aUdFeVJGTXl6SEM0UWlzVVFxaXc4MElqNmF6RWkvL3plN3crbHllN3crc3dZSWlrRE1ITmdhUk9nUVNXUURDVThQamM1Z3N0Z2NMbzh2RUlyRUVxbE1IbnFwa21kZEVKOXNEQXUxZUdFSkFhU3FIS3VDaHJCUlBZb1I2cnZkRnlhTHpmSC8yUVRsOHZnQ29VZ3NrY3JLeVNzb0tpbXJxS3FwYTJocWFldm82dWtiR0JvWm01aWFtVnRZV2xuYjJOclpBNGlnR0U2UUZNMndIQytBQ2lFWVFUR2NJQ21hWVRsZUVDVlpVVFhkTUMzYmNUMWVuMStVWkVYVmRNTzBiTWYxZkVDVTVOMkJvbXE2WVZxMjQzb0FDTUVJaXVFRVNkRU15L0VDb1Vnc2tjcmtDcVZLcmRIcTlBYWp5V3l4MnV3T3A4dnQ4ZnI4UG56Njh1M0hyejhBRUFTR1FHRndCQktGeG1CeGVBS1JSS1pRYVhRR2s4WG1jSGw4Z1ZBa2xraGxjb1ZTcGRab2RYcUQwV1Myc0xTeXRzSGk4QVFpaVV5aFFqUTZnOGxpYzJBRTVmTDRBcUZJTEttLzMvN3VGZ0Rxc1VrQUVTYVVjU0dWTnRhTFN3YUlNS0dNQzZtMHNWNWNDa0NFQ1dWY1NLV045ZUpTQVNKTUtPTkNLbTJzRjVjR0VHRkNHUmRTYVdPOXVIU0FDQlBLdUpCS0d4c3ZDeURDaERJdXBOTEdlbkhaQUJFbWxIRWhsVGJXaThzQmlEQ2hqQXVwdExGZVhDNUFoQWxsWEVpbGpmWGk4Z0ZFbUZER2hWVGFXQzh1RHlEQ2hESXVwTkxHZXVVT2tERnVUMkM2OThCNzZwYVl2YkhjR29aVmNqMlRRSVFKWlZ4SUZaMElFR0ZDR1JkU2FXTzl1Q1NBQ0JQS2VOejRyQU1BQUFBQUFBQUFBQUFBQU5iWWN6a3Z6UjBTU1NaQWhFTnlxY2lhUm5mdnA0NXhJVXZ0UDI3NkFzd3p4c1c5SHdBQUFBQUF3TFZNYzNuS1FJU0wvUEdTNHZoQ0lYdEQzMEY5UTY0SkRabzYydG5UYm0vUGV6WjBWV0NUaGp2aHpIV29MUXR5UGVHWjlHUTJ0NzVoejZRem5kZmVwQjR2bVNPcHovUHYwcm5WeGwvKzVyUlo5Y0k5a25vVkRuTFcrMzQrY0JHVGQ2aHRQMG5SM1VYNmRtVGgrdm5RVXA5RzJYLzRGUGhBTXVocXN1Q0xvbExLbVB3Tm55b0FBQUE9XFxcIikgZm9ybWF0KFxcXCJ3b2ZmMlxcXCIpO1xcbn1cXG5cXG5AZm9udC1mYWNlIHtcXG4gIGZvbnQtZmFtaWx5OiBcXFwiTGVpa29cXFwiO1xcbiAgZm9udC13ZWlnaHQ6IG5vcm1hbDtcXG4gIGZvbnQtc3R5bGU6IG5vcm1hbDtcXG4gIGZvbnQtZGlzcGxheTogc3dhcDtcXG4gIHNyYzogdXJsKFxcXCJkYXRhOmZvbnQvd29mZjI7YmFzZTY0LGQwOUdNZ0FCQUFBQUFEdVlBQTRBQUFBQWdBUUFBRHRBQUFFQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFHa1liMlJnY2dqNEdZQUNDVkJFSUNvR0xLUFF6QzRJWUFBRTJBaVFEaENvRUlBV0lHZ2VET0J1QWNyT2pGV3djQUdqUWp6UWkxV2JrN1A5Nm5Bd1p6TVBFK1Nxb3NzMHRHSUkzN2IycGM1Sndwbkgzb0VkMDJRa2l2TWVQV1k5OW9LWGh3NGUvcGgvZFhsQWx4SVZWQ2hOUjk2MkRQMVM5Y2pIZGwrMEZreDQ5QTl4aFJWT2NQUFIveVh0bmR0Nyswb3Qra0hUNm11T1ZHbkNzY2o5ZWdXSUJxdVNKWm9mbnQ5bWpSTUlFaXhJeENnTStCZ1pDaTRBS0ttV2pZZ1ZtRGhmT21DN1N0VnZmNW0xdTdkeTV6WFZjTEM0WGVWR01qWkY1Lys4NzlTWEhoYVBySkIwaVMxWVRyd1BnUkQ5MlA5MDl3SFFFbEE1QlVCaEJnbnNERE9WWnMzZE9QVkcxS3FSMXFVbUtuQ3F2K1hqOGoySnk4aTFDRHRyRlB6ejBPdlhaSndXK3Z5R0tFZ1ZZQVpJVFg4K1J6VUZRcUFDa0FobEtOS3dkTzNZWWdjYU92VTZkT28zL1pscjE2Yy9uMHVNVlg1K1lnaS8xWGU1Slltak00TTFHbTVwR0RBM0dtTVlZSTR3UlFoZ2hDbU9FUUFnampDNjIvM242UnJUd3dpL0djOTExWHJjM2FIc1dUdFFuc1dFVXJkc3dpZy83RnlTSWZnbDhxS2duNU4yTlBxem4vLy9OUHhzTFFDWnZYdlRLN2owWkZtaEFuWXd5MVVxM3NRY2Q5bkVPZHo3VDFoV3JqdThSWkhqcmdzeVo4Q1Bzek80Q3M0UGhnaFFoQ3R5RGpGOUNsUEUwZjlvRklHa0I4WXluakkzTytvaEdqdEk1VDkxYlo3SXoyVWZHUmw4S0wwM2YralQ1TFB3ay9DQjZLNXZLN2lIT3BZbU5yV1FFdUo3MWVLZjVUdlFUSnlWcDkvKzlNWE9qd1JqakNpSE1Rd2doVEc0TTRxa3lIVkFWdUFHYi9YOUI1N3VCN2hxRWV1MTlXQUFtQVpBd1lQaGdCQVFRaEhMQjVNbURrQzhmaklrSlFvRkZZS3dHd1MyMkJBd01NSTVKQ25IamxqSWRFTysxMUZVQTRxUDgraXBBaEFRWWxBQUMvT0dEdWlwZy96OTJBVVJBQUd0OUdEaWI4NisvM0cwaDRMZStVU1V3THlBQmo4Y25rdU5Ha1BrR2ZoRitENkZIbEpFWEVIc1JQeUFua2E5UWppZ2VLZysxRWpXSldyQ3BzQm16dVdIenlPTWRHb2wraGY1RUV0clNNSTZrTEZJV1JvaHB4NnpGUE1HdUpEVml6K0syNEg3Q2svQmkwZ3krMSs2aWc2dkRlY2RJeDFTbkpOSWI1MEhuV3dRa21VN3dJMVFRWnFoNnFwNndscnFJTUVQNFFqWVNPY1RsTGtxWFRwZHQ1TlV1OTF6UHV4MXlGN3MzdWs5NmpIbXM5dGpoOFk0a0pHV1JHbmVZcWYrR1RLZnF5VWFzeHNKZmh2OVFhQlErcFpVeVJibEhkYVNTcU9GVUlWVlBYY1RpNmhOQnA0TjZIUUs2ZFd2U0s2L1pySk1PT09jMnozMVZwenp6cE8rMVZ5TnZmUmdUNmdPaVpocWFNYnFDVld3N1JoWFNDYmxzcHRwTUQ3MEZyQVdWaThaNDRpQlp4cGZpTHhkb0kyaGVwbzB3bUFVclRLdGduV21EYVJOc2dWMXdLTUFrc2NZY3JkTUU1MTEwSldXVU1nWTN3S01Xcmx2NFRuT1JBYnVXSXJ1Y0QzMno4d25Wd2VPbzdKTllUZmIvTlZFMFVLYXBzalFSaGhwbU1CbmhpdkJrK0IyVUFtbVFBYk9WRHNCOHlGRklQQ1NSa1FLcjJxMzVKQXMyd0daTUlhWVlVbTZqRWxPdFZvdXJWME54VEJ5YjBZeHBCVHBaL1loQnhMalNKR1NxM2MyUWVjaWkyckxhZThaSHhtZXlUaXlLYTdDbHJ5MTFqalpIbDZQUE1lYVljc3dKbGh4cmppM0xudVBNY2VkNFdXYkJQRmdBaTJBWmVHQ25FZUk2ekhGVXIvTnRkWE42T1dOd0hkd0VQdENZQ1dRY1ZVL2VpcGcrc0lFSFpGbnlOcnpkdysxdHFUNjBCcmJCb1RBbTVIeGNqS3R4UFFUMFpvWEpoa2l6dUdZbUdOOTNCM1FubXlSMUZhQ3ZRNW9FUTZMUEVLcmdSU0lRU0NDd2ovMmg5aVZEMGl5YkZRcGl4ZXY0VXFWeSt5cXYzV3FwV29ONkZFcGowdGhBSTZ0WnB0T2hmc0lnWVZ4aTByNHB5ODMyemFFdW9wYjlTY2c0VVlxays4aGhDSmtucjZVaStmcklaRVVieE1weFNSMVFTcmxKZVFJUVltbXdqa3FyUW9OL0dmR3Q3cWVkcGVmVWU1M0JDNkhyMktBQ2RHMHdYdURBdVJnNmRBQ0hTei9JMDZUa1VTSTVRTWloWDNrTkUvZ00zamtkRFpLMEkxQWdkYU5RbHdWRDhnVXVTdlRxd3ZQMU5ZRGtobXYvdzJwQXBKNm9wSE1GU1FsYlgyREJ0MFhRR2FXcVpXN09weXJCN2Q0dHJWVkdrc1R4Q2ZUaDRaZ3B3QlhyMUJxQ3E3aXord003MDNET0xTb1Z1YktvV3VLcGpkZVluMlQvWWl2S0VoelF6TjM3bHlHUzA5dHR2aTlyR2Rhb2EwT1hiMHlRbVNGdkRhTm5ZZG15U05DY3dIbFNsWTVkZ24walpRSmtET3dzR3ZTVm0wYWllaWhPVXk5ZnZvbFNXNThLTjRrT0hXc2wwU2paMzFJNTZhcG04cklzUnpYZnFNQktVVmFoV3dYN3oxamRDaWlqSGxRWWx2UzR1RTY1K2JEaE5Sc1ptN2FwaTd3bGU2L3NnMXY2ckI0WXJWRTRvZUdSOFEzbGJ4QUlCQ3RGNHloZXdEYldIam9pekJMdEJiRTRTVkZEN0NrV1FTbldpemt2ME9RWnBGc0lmTUFEVFgwaW5BSUFFc3dIbHFOZW9SUVNnWVhOZzFKQkdSVlVVYzh6SUxRNjRJQUw4UEJJSlZBS0FBQnNVdXBwM0psekFUUmoxN2lteUVPRGQ0QjNBRkpybkFZR1hnNnNRR3F0RVRSRG5tNGd3dWhuYldtR3JsQ3Z3ZFdLMDFlUUQ1REFKSnRrdDZWYTRTU1NNT3l5dW5YTGlJdjd0VE9aSU9oM3NCNHRvb1A5dHVLUlhtZ3MydUhyNE1yMEJWWlIvRXhjT0VmY0VTWm9DZ3lDQXk2UGJXYUMyMFh5R2hGWEV3VkpOdzNXaWhsR0NsNmVTWktvNkhoS1FRR3NaQlZJMEFGY0toaUlPaVBCOGpCd0UvUGlBdHcyREtpa3hUOEF2QzM0NEpqMWxaUlM1d2VmOTFnNEhIUjd5eXdCUjdUSHhCcEl1b3ZSUFlDNmZSRnFZMXBCQnoyTU1NV2JPODFTWUkyM05iSVhPT0Vtc2lDdHhoTDIzY09zSXlDT3BKcHFra1dPRndFbGNLb2VrcFd5YzdBZDFRM0pLdWw0b2x2UUs4QXpDMWdDSllZREJ1Y0gzS1VzM1RVS2NELzBmYlZnYzdZQ0x6VUtyVmhoblU4U1RkbzdwbG5NYTdPVHprb3Q3RWFNUHpoZzRJd0FJN0orV2FOR09zcm1JcHNZOVNFMGFBK1VKZ1E1Y0JHazljTmFSWHRkZXJXNXJUa1Fra3R3cE5ueWhRd2FuQmJIczNDUDdWQys2eUNBZEZRWVJMdE5ySXlrR3huZHBSRlI5WlVFMnN4ckJ4MmdzNldOc08wYXFoS2FnQ0d3SVVBTWVON1lTUTVYU1lvdnpaZFJramVoNEtEWnFBT2UrYkNqc0hoWW9ra3lMTVd4R2xnVEhEZ0FBREFBR0JBcjFBcjFJTEpMc0ZkQU5ObkJtUE1sK21RRHVlT295YjJPMDhBc2JBNjJBRnRDUFMxelZqam5XMVg3VGNwOHU4S05BMlVlczk2YmZMaUZMdURlMlVRWEczd28zOEdiUlF4WGlVVndzSWRlMTQ0TENUdlJoNDhoZU1BUGJSMGhqQjZhUkJrdXd5VktZRWdRV0ZoUVNDd2YybENZSkVvUUVHeXdTVHdhUGhyKzBOYlc4L1Z0Rm00a0xnVkJFK2h6RUt1dlpiOVdLYmEwZFJtdVdjN1lnTFdDQjlNTUtyTUVoY1lpNkdrYzV4MWtjenhPdFBKT1NLWDBqWnIyQ05DaHZoNGZoRE5FTGNGZTE1aEJoOGtheUNXMWc4NUtHMjF0dDJaaU1vQVA3OEZkZWFhQ1JXT2dHMWNLdVFwamE1SFRyaVljMXd6WU1WVjN4MUFVWG81d2x3eFFOalRkQmJJeWN0QmVTNmw0VlFWTkt3WmRUS3hPdStLSkI5TndFdmFEcDgyMmRLQTkwcTVHeEF1SldJQ0FUdnlIQkltMHF3Q0hTSWFLMWJxZzNoTHFKQWEzbEkxb2xtZ2xkU3IwV3htMENyanNXcXpqcEYzVHRGbGhjMU1YTFMzVjk1aVAxM2FCM2hWRTEyb01JY3FSTVZRYmRDbHBoS3dqOGlLS0xsQ0dxWUFkcFdsT0M2WUQ5TXd3aHhHbWVETVlqN0s2dGhnN21lTVpuTXdGdUcrS3A1cTNaMHoxS2JmYnBMb2o0bDZYUjJSajlzc2RWRGdzZGlURVdTSStkQ291WFNQamwyeGNEbW8rcXZEU0xSWXJkMW9scWxxbDFxNTZDNmlYSGU1MVIrbzFhM1RBQmFEbjlwc2JRQjMycWF2OVh5czNLVGF0TVN0c0RuWFJ3bEs5NkJZVjlXMjFqL3FRWGcvYkdUOUVBSXdPYlNVWmZ6ZTlaZndSZ2JCZ3NWQkl0RU94ZGwzSTRhckNHMnFWc0FYQUVtbE1oYkZPUElMUEN6L0FlRkQ2VzRGdGdvYVoxVlZDMDBvcU9SeUowTjhQdDhTTU9DcnVOTmRuQVI4Ri9SSDFVTUVIV2M4aEl3NnpuZER0cFBkNE5CQjJVSTlXOGZpVjN5YUNzRDVTMHhGd0F0UzZOVUN3QVZGdWVKU2g5dCtPeGpwWDNtbGJSVDlvRWduak5BNHIvVnk5NUxIdXVkcENnQ3g3U3ZVcFVUOWlpSjFIMkVYQkZhNXRPMTlkRjFBSVVGQlFDRkJrQ0lPQ0FpUk5kUlE0NFlKYmVHSlN3UmZuSTA1ckFuaGVMeG9SczJkTWtBREVpeEdkQmpnYUxVVUViU2dvQkFUdy9yanpCaGVOcmdxdUhiNzZFUi8weXQ4VXIrVlBDRVFGK3p5Y0RWSU1pVGdzTWxxUllSZ1ZYNHVtQzRZbG9TVWRFNGRyaXRWVUFNVm9JTVByS1FEREduYlJka1RyVVlBSVo3dWNnQXRnak1EODVYSE5WU2RwQlIzME1NTGtta3RZQ3JkMk1pL1l3WndHOS9Yek5mSm5CVktDWWFHSXFGTGlPbWsvNnhCSFBPNzA4RFpHUEJ5dm9GeXZ4bmFJNHpEWEVkMU8xbzF1YmplcHgvaGhvMUdqc1RVWjN6UmhycDQyT3RQRGNUZ0NyZ1pNNFFCQkF1RXB4TlVLSUFNZWpjSERTZTQwYW9TQ3h4Z0dLWHQwUUVORFB6UU4zYTRoTHN0MjI3RjBRZ3dGQlIvMjBORFFrR0VaUmhLcWw2RWhDN0dzUnVhYzFSOWpFQnh3RmJ6b0U1citDcUgyUmV2RnFyOC9aazgwQXRFeFdqRUxack0rbE9nQnJHelZNbmdXa0VQcUlHelJmZ2I3RGh3ZEZFakJJZUVwZndjalJ4bFV3dXRTSkRDalFNS3g1UzFIaEJyZ1NVVDJ3QnBDeUJnQkxSa0Y0R0VPRHA1b1lRRUFLOHhRb1pLcXZhQVlTdndMQVRGbnBWeXRVbG1WckZidWpQVVlWSWVwdzRKakNhMjBEcmdVTjRoSENEQ3BVZ3loUWdWbXM4T0hZc0NhOWFOc0FGVEJnRkVDeDBPVjVMMnZ2WjQ2VGl2b29JY1JKbGhnaFIxT3VORkZUeEFSOGNxM0lHZ0VUUVFMbzhDa3JDMFRBcFppeFVFYmpZZXBRL3BSM0tTZURma1dhRjBza28va05QRnZBVnI3dnRMdVFBbjVMc1pGQ3pFeU1zNEthcFExVnFQc3ZuRW1hQVFPZkhqb1VxK1JJV3VHN0JyZ05jYkJqbWpjU3U2NEFUMGc0bEJZNEFpYWcrMHlZVGljNDRMb1Rkb01GQmh3TW96d044TGFORVFoUmtZbFhIR0U5Wk1FNXphYTZDMVpSSndXOFNRbWg0ZzNxNUJ0VUF2Sys1SUM4UWM1c3N4cE0xSWFIYWg3ajJoZXYwVXBpWGh0YldNY1FRNjdoZnJrTzBudUxYckRRVWdBMXJRbmZFY0RMeVRlVkIyOUoyR0gzazJydUxuNXJob1BrVEN5S3lOaVpGSkM2Smp0blJJN0dQL2NyK0tJb2lqa2dzb1cyaUZFT0MwVTZaS2pRaWZQMjBNa3AzZUN4VHpKdTVLY3FERUZXWWNReGFoM2VUSkEwSVpQK1cvMVgrOExqTlJBb0l1QWdDVkIyeWFPOEdYMzAzazBpQWV6akhxYzdsZHhRQzA5dGZvNDZ5blZRa3hoQjZrZXpleVc5RnZhZjRsN2g2L3hSSUVNZk9mY2JRbnVLcXFBVWhsQ3NGaTM5N0pxWThPTWEyM1NhUnlnMEs3LzllRFpCemx6RjlOZFl6SlR3WWxlZmhRUE9xNHQ3UDFtYWVMRjdKclpib0hjWmFqU1RmMWVuNm80SENoRFY0dlBzTkhzODZiWTFyZXZxSUpQM0JPSmlYeTFPOXRHSkMyY1d1VHp0cy9BWUQ0ekZ6M1pQelNnOUZzVTNiVDluUzlRMnFRNkJqam5sSnZrWDRzam9Qb3I4VEVzQWl3SEthQWhTMUhoT1R3UEpHSmtZb25NV1ExR1phZU4xWmpZTXdtYnoxSVBPVFd4eUJqR3pmbThxQm96UWtnMlVLZXArV2dtL3VaSE1zR2NFS3dBcDNXVmdOelYwSmlET1dBWXR5amJDN1hZSW5SVFFUUlBGVlhFWEliNk5kejczY3RiUTJMa1RvSDNlbTQ3NnBxdW5YR0xZRHBjQStwTEh2OUVLZis4Q2plRHJaOEk0NGtWemdhR3ZmczhKdUZBKzc1VTgycVY5T1VKamFIZGdUZDdWTjNqYXB1bEhmVkVEeXo4b1NzN25hVkh6RlZScG43RUNteHdieDAvK25zMkozcmFpU1VndFdXbG85bTY4Q29HdFJhWDBMRkgwV3ljMmNQdVZ3UXpxazdhR3JFS3B4VVg1UXRPMElsaDY1TU9ZOFVuLzc1ZlQ5QWxySVJmVUFwdkZXNUs0RGpoVnd4RkdOcmk5RmNCQmRycjJkQTJNV3BvQ1h2NUJOVWU3MnUxbjRRNnlxWEozN2lCZDBsdlg1RmMxTmhxLzQxN2NOcjNia3RYWnM3Rmx0d0ZhU3NLZWU3VXVtdnprbFdGQnZRNXVyS0Q5UjdFK3A5UHI4cWlvVlJDTG1hVGRKUFMvcDdXUGx2WVEyT2ZMVXE4V242M2xPckhtVVVtNVB5dXc4VnNIU1BDTmxTTVVmNFZuVnlsM2pMUC9PajJUR3Uvb1pBc3FocS95NmN5R3JaYnN4S3RYZFk3TEw2VTFFbkpBT0hOTFpUWjNpWHlrSThDeHV1ajFja1VoV3JsK1FpOVcvLzVnZ2ZiWExtMWh5MTNPRFNRTUJWVmxZZC9aazdPUkMwbGhkOFZVM3B3R1BmTm9pcFhuMVRDT0psakk0OU1QT1h0ZzZ1amtpTlVqZ0hqOFRBT25NQXh2bitqK1BCakkwQUlqRERoSExCRmNoSWpsaXNoTlhkcE1nUXd5aFNzVUxVUURkcHhkZXNoWURWSUJBYWxId0lBZnVabllGVDV5Y0JLM1dYSDV5NnpLa0FBRzJRRXdDdy93REUwQ2c5VUFFekRTVHZiNFkvR21TODRMRzltTHBFYjd3ei9vd0NUU0Z4TnExdGkyOTcxRWNDUG9MWjc4c1VvTXhQRzJwRlFISzcwcWZjYzJQNmE3bk1UNGxtYmcrWGtydk5Fa2UxNXcyMFhBRUdaQ0RQYlJkNXEyRkpjaFVROWs3RmxUZyt1TUR3QVduOVVRSStHd000QXpwUjVqdTAxZ2dLWG9qc3ExMnFDWEtDREZJTkQ2MWYwOUZRYWU0VUp1QkVIdG5rOFY4Yk1GZzBmUVNDUENZd2ZCaCsrL0FRSUZDUVlVNGhRRkYwSVI0VEwwY01WRXBPUVNpU1hSRWtsUmFvMDZUSm82ZkYwRUVCekxNNjVEaFp3SkRqTFN3SGVHbzhsRzVIT0tJOVpoVHJOT3ZWYllzUks2MjB4WmI5cHg1MzFpMy9NdStLV2Z6end6QXUvZU9lTGZ3SU9zNFhadzRoZzJkTFdkdkkzb1kzUkxqamtHWTBjUHJNVHVoQU5DOStiNU1BUU5acDljZ2dmVGlGeXRNanlEcmsyRDBlS0VZc3ZFS0pPQ0ZhYlJMeXl4d0pZdUxXTjhoRFhwaEQyUG5GM0FnQkNPZEVPNHNva3ZOS1pqUk1xK1V5eTQ4NCtuUmZzK3RWME9pQitPcG5leVRzbkhPTGVuWXI2OE01TGkvTUI2VkYxUVFXZ0E0TE5sWXh5a2RBY00yaUxNdFZZRFlaR2J5WC9qVE9wb29pb1dmV0JBQ3ZBaE42b0FNRlZyNElraUFrQU1Ma2dHSUllSjZYNmNEYndCaGRVc1lKTEdyN05OaklGUVJrZmRvbzB4M1R1L294MytidEdCUWREUUFGVUJjVUlGTkF1NmlyZ3c4MTU1dy9tbU0zU1V4eU11TXAyVHk4SGNCYllYN0xGLy9zTEdQdVl4bDBBM2dMRTN6d0oySVVsd01IS0Z4dVRtMStNUUFZZmNJa1BCUStZRWl0ZWgwbFQ5cGwyMUt4THJycnRua2VlK043UFh2dm9pNy84a3lkM0MraEVPb2xPb3pQb0VEMkdMcVpyNlBVTVo0YkwvLytES1hUeEVpcmhoRXFndTlNcFQ4bW1jLytyMEF5ZjlYN3d2VE16MC92M2JsMi9abnhzZVBtU3Z1NDJsODZjL2hVZEpybHlaRktTNFVtSWZmZmFZRTRpRUhaNDlYakx5NEEvd01wdEFIYS96NG1MRG5sKy9oRlFFR0JCK0EzZ0t5UEFVeEN4NzA5bU1yZVZKZk5LcjVKYWw2YlFCcThMQkFVZ09lS2MybFJDQnpCdm9ZL25yNkF4UEJKSnFaZ3h6RTAwSHErcEVSTVluRjNUNU9DZE5MemRvSlVRTFd4bUIwMDZlVGpZTlJ3bFk3SFZKTkx1TDQzVjJpQ0RZeDZCL3VTMGFTTVdkMnR2N0RseGROMjZMQ0xrTHFnOXF1dmtUcU9tRG0yVGo4elBzNkdicE1hOEF4MWRiZGtGWndkcEc4ZEhxcG91SFI2cmxYUU10T2ZPdFJ2TVlJbDZ0NEdRa01EYTRMVFI4RE9jYnRLOTVXOGpmbkt2emRMNE5oZmZSdHJYc3VrQ08xanlmRXkxQnVSdVJMVUlGcG5OejhmaU5Rd0NBbWtuUmpqWWdkaFBnYXBwRTBtRUlaYUh4WkV2QlJRU0o4bTJ4UTZPZWx0QkZBcWp5RkdJeDhUSFpNb3FsdmZMMFM3N2Y2UjJkVDFCQTFLS2FSY3NvclZyLzllSzlDTU1uWFk0Z1NpQ3YraGpIK2tHQ2tvb0ZvMGp1ck9rWlB2SXFIRUNNMWY5WEFLOUx1d2c2RGhucG5HdC8zVWEzc2lZVFlSZ3ZOd2lZTlNlQlByZVhLVzlCc2Fuc1I4VlhZK1VkR0dRM3gvUlVhUmR4UlJsNjA0TUphRjJwWU9ETFI1UDFxMDhIVDVmTjJaTW9BVkpRaVNvcWpJYzVIdnJTQXgrdHlaYVYxWVdtVStSTTZtMUMwcFZWQ0MvdkZ4U2NiajNrcyt4VlZVeW1PSjRpeWtzT01LeGt4RGNycHg3VEQvdkFyU3VUdmpqQUxmWmNzNUJnTTZpK2FobU5vNUd3SW9peHlJUkZ1N0tmUXVVR1BkZ2F3ekgrU2NpaWVsaUN4RXJML1JLVjdHdUprT2xyV2xwOGEvdjh0eEVnSzZlN1luT2l5SGYzeG1NdjZJY1pYaHdjQWhqMjk2WkRyUktVdGJiUG5QUmE0ei9tbERnaGRwVVRqZFpHcVhMalFzV2JyS2Q5MTJmcFh2SWIwdUVxRE9aU0ZkVEN3b2owblRpZ2U2U0o5dFkwUlZ2UEE2d1BvWUY1QUlpaUJuNTJYQ09QTHB5QXFtUzJjMUt3TTd4SE1LRFBlQTl2Nk5PU0g0VWxRNG95YWxHWVhOckVUYXMyWlRxdThYcHp2Rm5nN05ONGxLZWRNNElRNVk5WFBEdmZVK3Z1VlRNZW1ZVEpGS05aWlZwcTVhNW5uWHhTNFF6a3ErMlMyMjEzM2hKczBxRTg5eTRnTmhGSmlXRDdQeXZTb25YUE9lTERucUw0QitGZEtlcnE3SGtEWkQwU1pkbjhEYzV2bE5UcW5uWFFURU1MV2hYRGcvb2pDZDdPKys1dEcxVXRkakZObkUxVEVIQXFYSjV0b202VlpyQzdQT0o2TndRemdESGRIcE9YTHZEaGIxWFErTG5LTDkyOU9TWHM3N2hkWDY4MmVzMWhkSzFmVVVJdWg2c3RyTjYvYlJpZE5NOVRhZ1h1TS9nN0pnbjY3eDJHamZFN0QvRGE2NTB1VGdTRlROVDdEeElmaWI0cWl2WHk2NXAxS1VwTjd3SmRVOERSRE44NU1hWWovb2sycUFWVXVkdUVEb0xMNU5Icnc3c3YxcnN6TnpKQjhuVGxNK09KZ2svTXBSQWNWVXlwUkNIUWRBdDZia1BkQTVUSEMzNVF2MjFjZGo5TXlubSsxQWJ2eDFhZHVwcWtzdytPSnhNUXRqRitNaWErWWhwbkhXZnBxbXA4R2NsRDZsZ0pUVGxqWDRGd0RmdHFqVmVZTnlTbFBUYXhxR3BvT3Y5ZVY1SndiZGZrWE9lSm1ocDlTZVRrTmU2ZENhWEZvTjJLWDZnd2U0Nm1LdGFFQnZvckF0bHdzSDlROFlDS0ZIMTJKNy9ZK0pWWHJuSS9heHRzNWEvbXBBY3ZsM0RLdkhFWUhWNGZucU0weEZ2c3p3OG5ad0xYZWZkS0VkRmF1dmZpQ0pXZklGVkdCNFJPb2lrU29hY3hKNllIWC9QRmNhaFpQaVZuVXZOY1RPTXFKZU5XVitLK0taaUxINDAyM2FET2VBOTVOZjF1TmYwTmtEWGk0OVA3dFVZdTVqNjVESmd2ZzI4TXNOVENZMHlzeGNlMmppbGFoV2wvWjZBK29pdnAyZVA2OXJGdDhOc2UwQnh0V0FxcFVtRzF3OVg0QXo1bGEwTEIxaklwUUJPT1dsdDl3YnlKYk03eEtHc2VibVpwUFBYb3lGUFdwczJIVkxIU0x2MXBuYXJmZmVFMFhwdTlQOXNiUUNwUEVWR1pQQnZhVnlGcisyRUFZYlZWR3dOWS81SUtKS3AxYjFsTkhlSUw1NTA4VjQvNVJ6TnVNazZsZkw4b0lrZThka0pxbFkwZGQxcTJ3T1NuNmh2dDUvc21VdjdzWFVac2RMNjJ4ZTBtb2Q4TEtHVUZpOTM5clRlWHI5WXUrc1NrV1Q2akhkWTlJcVdRQnpDelVMbjM5N1dUOGNYUStVQ1MyZTJpNXg3YzBzOUdWYzE4VzNoVzYrR210dHErT01GQ3grMzVTRi9XYXVESWxYdFpnV0hnZUhFNHBKUi8reDVrLzhhR3V6Tk5wV1RjcFhZQlhVMzRHSnpFNlJrRlkyK2QrUHVjMU5sZXRBTy9xZXZKdEIvK1dEVStISkswbTZibm1tVit1b2hEQTZZQnZSVEUyNldUSE1JUktsRzNMVEdxZ2E3OE51MnJrSHUyZitIcmJVaHRzclp6NGY2UW84aGVvcU15THp3dVlhZnRUTVp4WC9raXgyUDdoT2VSTStRaE5lbGowNWZURnU2Ty9UZjA0VS8yTEVlZmJxT0dleFZZL0ZwNW9kYldpamxwM1ExYjczeTdFd1YwUjNiWmFjenZhS0tUSHoyc0dPRUZ3UXZiK1ZNa1dKd3h0UXBNWjc3U3FXeW5DTGwxdzF5RGVmaURObzc4ZXhSbjZOTDVPTzdaNlZzQ2hBMVdGYmpvemY3bDNzZVd4cDBYNUgzWXlLT25GUTBsWWJVeGhpT0NnZkhCVm0zaG15R1ZIVk1xTndPejlSQkhJY2xKdks1SjdZWHlpN2VOWFVacnBNbmkrOXhYckZNdGZ5ZFVMODA4bVJVaktWMVJCT09sanZpeDNZRGx4SVJzK1piR09LaGRyR3hrU3RTbDVsMTIwVGszKzFaS3JBTytFallaZ3hNNmlmbDdMcWsxclN3RzB3Uno1ejFZNzdaU2ZSaXVCanhXZTNWT0JIMnhvMlZWd0RSYUVQWXozVWpqUThjSnpBVWpPeGVBVWw1KzRnYjlBSlFpVkFVT2JZRjM0QkhyNHhwdnM4UVVQNVEzejU5TlRUQU1FRk03cXczaGVNTTNMNklhZm1mVEdjZ204bUVGWHpXWW9PalphSGVPRXk1SElxd2NOYy9CV2Y0aVQvSU45bGxGSjR4c253NU1yUHdRRGZUY3JwTFlhUytncmsrOG5lNnc4K0crYVVYOUVvd1hsaTBadEd4WVZXbWhVbzJrNTlaanF0RmtWVVpsVWZtQWpmTkd4TEtnWkh0bXJuLzJkR1U0SjNKT3pXalhnUWw2M0o2T1g3bjRqT3FSN09nOWlMVkxsZmUwL2NvNWowVTI0emVTWjhhNHlaMzdReUdwMVBGdVBRVTJZVitTbG5LUXFhc2hjcmFzTm8rTUtmNzd0aTh6SXpvWlRGUXladW8vZWZtZU9xQ0UxZUdmN0dkMHVYSE5MbXNPQytFTjdnZ0lPQ2w3T0s0cnBYb1ZvVFYycEtYYXlBVUJTV2hXKzNHd3ppa0pocUZadkxReHVybk10MWNVaHBPdy9PeW12OVFta1BaRUFjWW81dU1EcjNsNjQ2bWI2Yk5lWmhpdTJjSDV3THFuSXVkOGphdXFVdjlSajZjYTIvT0NXSmtnNG5EU0FUTVhBZGp4dXZKb0RaTVBLb28xYUFaY0dyQzkzbGxOYzhoR0M3MVhzUWpTRDF1RFVrRlVKUE9FOEN5N1RybGt1WVN4YklEdGlPcENMVmlTQ1RBOUNqSnZESEdsMUJQREhIQSs1S1dubTRreTdRMkF3TFRWUlR0SW8wb2JxRklzVXlCQjlzWUpvV0xiU0d6dEZ1YU8vTmk3ZTY5b3hHWlJBTEZwK0p6ZFVxMHEza2RrbDNJNTIxb2F1d2V1TWdlVE9idllNUTluY3lsQzdlbFpIaCs2ZGtBSnNNbFpjT1Q5S1E3WHJ4ME45NE9haHI0NzBoR1NOT2VsNFlxNStieit3MUpwM2R3MzBOK3pXaDA2T3d0MHdiMDVneTZIaVNSR0xwM2VJbHNDbk1idmtIRzNjaDRjdmoya2FWbVlkdnNZUlhyMWxCTVVTaGYxN3lrMWVMSUN2WGZGN2pDWUZVbC9Ca2RTVU9pa2JRcW83bUZBNW01bkJiYUxHbFlJaE1NU0cwa0VlRnVrSmp5eG4vOTliR0pvTkhmVDNobDU5MHU2dUdCdWJNanlySnFqNXpreldmVDA2biszb1lYRzNZRjhrbWlONnZQQ3F0WTc4Z1RidzVMdVpNaTAvVmpjTGxJRmRXZVhBeXFqU1lIazNLc210Y3U3elpsMDNIcGV1WjJJNlJCd1c2UUpvN2xXRlo0YWEwZ3N6ZDdjY1VIdmUxSkJKMC92SW15ZW9Oc3huQUtzZXhsMERPS3BZMzY5bkxQc1ozbjVSam9mRmE1SEpIWS8zelp5NVlWN0R0c1pFZmVHRVpYOWxjK1MveHlzNVpic0JoWU0rOUQ2ZjVIYjk3MDZ1cHRHanc2ZWl0MzZkbXdmZ056YmRWaXBqdjdGbk5mRVNzMzRjMXNBZXFhTnJqTDhTSytVV3h4QlJkc1N6cFEvYWsxNEl0NysvQTc1L2MzQS9JK3Z6ZFkzd3ljUFMrV1F4RkRDY284cWhQS0JqSllPNXhGWnVOcXdHZ1NwS2JNY0M4dnZtblVkVDRJdWxhSGpPcE9sUWpGcmMxVHFWVmlsU2VTQWFYblI5d0tQS0RzQzFNSWJTbVd2SkV5RlhST0hOSGF0UXBiOEFYelhoTm5YKzl1VkpqdHZvWUVZMXhDckM3TEJyRSsyR1VYSkpaQWJMSDRsckVQaHd0SWt1T1RZWmRGdnN6TGs2R1h3YXFLOU5hYW1vZmNWcTJoMDZycm5ENy9wNXkydGE3c1lVUnJxbUZvUmViUVhzUFF1QnYwUStuRC9aVVBRZU5XeUhhNnI4aVMwV1JYc1VlVnlKNXF0RDJFeGNtREcxVnA1ZEZ0Sk9rNzZGTXVicHNKVW1Lemc5WFcyeXo4d1IyM3QySUNYeGczcDVyWFpiSHJ5SUtVWktqSFlHaUp0MUxrYjZIM0RaaTl1dWdzZzR0NDB2b3N2RzNmbXRZNHBpa3oyUkFwb2JOL2EwWXM2MGNWRWZ5MVNkSVVhQytJY3pKT1BudS9UaitjWUN3UHN5cnlOWWYydGRSTjNieUYvRnUvUE1GUUVXNU5NbWtPN0cydWhlMjZmbTNYcG04L1VkbGhidlhNQmsweUoxd2xDQ3AwTVRNNVRqVUJ6V3BWTkpTU0VGemdXaElMdTZiNDV1bWs4dTVUbTI5Mjg3SnIvQmZIc1FtV3dHWk5TaVJURWh3b3BPaXdhbjgyb1Nhd1FhTUU4cHErWFZkVzh0VmxpWHZ5d09pdC9UdldudHpjem1XVXFFcUdNdlBwRTVPTFZRWGNKR013SDRMYVpGeURuVFk4cGlTdTBtbFJhNVVvV2hoV0dTN0JRZXV6bDhrcTgxY3ZlT1pzWnk3SlZHK3FuTCt6NVBiR00vUHJoM2JxNWZrdS9XZTFsbVcxNm95ZFBGa3ZxMzFtb1hveGNIaitSc084dkJmOHZGV2JzdFI1dytPVVJQM1JkNXRoMGJubEZMOGk4M1J1dXo1VnZ1NzJNcHhXQm55Q3Z2MElBRGVuZ3Vabk5oL0tPYkMzVEx1MkFGMXYybS8zczVicFpMUTdRMU40bnFCN1h2YWtLZXdxakE2aDJwL3Q5ak9YTUFjUC92MXJWN3ljdnVCSlAwNm55VitYVGt6dHIzOGZEQm9FR2ZYbWxhdk5xeWZNRStQbWNmQUM1MThhRkNWSUNKTW9TalExeWZNeVJXRGIxZURKUFNBUzNuRGZmQi8wNWtNU3Mwc3FIVjcrM2NCaVN5VWdVUnNZSTUzWndyV1pBZTEwM1Zob1NZcW1qdE5OWDJrM25LejMyTS9aclIydHJkcVFrR1g1MmxBem1qUlB1VmhaNW5VMTlVTDl4T0ZNVitTY2VDK0NoU2h5V09uZUg3b2szcFREaTBsYjFPOXRpdHVCU3NkdWN0OGRNcFJRbDh1UFRldnVBa2lma292TEE2QjVHdVI4Tkh6WXBTREkraFFxSkNucnk3NkFuSGhpZVhoZW1DSWo4M2hGMGV1K2pqV09KVXo3Wkc5Rm80SE96VnhUNWk1VWNSZ2U0Y0dHb05DSXdzTE1YYkhGNG1iWDZpaTFKcXdydFhxT2NYWGN3QzlLYldtVXR4TVRqN0EwQ3RyeVdQVDMwRERBME12MmNBbzFuTnd3YjQrUnZGUGVQanRSOGxXWkZST25aeEhyNFJjWDlsL2dVWGwvQ00rVE01aW9nZkV0RFpXajFWM0EzK2R1YVBkTFZ4cW4wS1Rmd1MzU0R2dlZxd1hMY2xpTUhFV09WV01rWDdSNWRHTjdVZnJraU9rSUc3VGVNMEhNdVlPY2c5ZWdhODhaTXVmRGNUejlZKzRsOUlPZDZvVDNUQW1EN0lsRUkyQUw4T1ZJVVBvNVNCY003ZWZsZFN3dHpmbForOXl2eURZM3FGbXlwVGszNGh0SGpzWFp3dXpPMjhBdHpwYTEwam9GVlpwRHkyb094eFZtVDNLS05OdzhVTGM1QnRmaHRRRWEwUzJ0THRyQ3k5dHhlUXB0OUxwU2MvQytFMDRUZFJhMDE2ZE1XUXMxcTZKbjNYWURoVWE3WFZ1YnV6SXExNWpRNHRFdU9FZHd2bHl4ZzE5ZEwvMktkbWRmSDlqQnVCcVltWEZ5amJ4Qkxtbnc3aGNwUEpjSTI1cVQxRDNBNWc3RUx6WnFQRGdhbXBiQlB6cmtVaGhrdlFySm5XZ3pkVm1PeE1QV29ZUnM5K1NZb0dvUTdkUzFhbTEzUW5DVk1MbFluaFYyYWM4ZXUyTzJmZkljdVFsMzJ6OHZ0RzBVbFd1N1ZpUFR5TXNiT2xlMVZ1NmNRcXpvMXF6eTdWVWxXL1V2STA5NzdKNXZhTjF6TnJWUnRUU2dWaVhxVm4rT3krbGMrQzg1c2lzenZTTjYwQjNZZUg5L0JZdC9XTHRMWHRvcE9PVnhvMCtHNmFOdUNPdlhkRmNhTmtibTU0MkhwaXNEMDRPOWJUVm9ocy9lNXZyVUhOdUlRbzg5QnlQRTkwb01GKzU5bUg3TXRNbjFxbzdXbG5DbFVSVis2dGpWdGg3UjJCSzh5dDFNVFFwSlRrMzBESTdPNGZEU1FpdmNTOEFpSFZzcUxSeEhzc05sVXRQSWJrZ3FLUndKaGNra3BqTUZyM0grTFo1VVJGdW1JRW5remtMaGhiRmVGd09vQXJGNTFPdzIvdms3Q3JESTJCdi9FQ2xjVTZGMlkzUjIxbGhRbGlRdXg3V0FFQmFjeXhabmE1ZnFGZEdhOUNMVGx3aGZPL3RQZWVKY29kUnpyVHczYjBxVUtsYm1wT2JDRzJHcGpKeGwreTExM2NVMm9ydTdWUDg2OVJ0Wk1tazRXeVpsUVJJcE8xd3FCVVYycFp5N2xzdGJOcnpOSGJMMXN1MzlWckdoczNvcTRsaGVYY1RSdEpweVpRRTFqRHo2d3NiZGNKYnJpeGFyMCtPUHJ0MXR5bTRiSGtyMTNxUVlLNm1aRU9yS1JEekgwaEViNWpET2RjR1ArRjVIcUhYUWQ3eENia2E5SHZRYzB0ZEloNWY5MHJycWt1WmZhL1NhZlhMTnE3S0I5YitaU2lyTlJmVzBxaDFma1MwSEwyVERXUDJ5eFRQRjBjMzBzd2FadUN4dWtXL1ZYcS8rYVBVVDNqSXdleFdhUHdlZmRlZWZjUlBXZTlScms4blR4WW81SjFrVHgwVjJmQlZxZjMycS84N1JIeUsreHZSc1lyWC8rTTFmSkc2ZC9tUERLRkRETGtxK0luODJ3U2ZBZ1FDZmhmSzFwWEwxZTUvekw2b2RlbG1ETnovRHBoQmZsUjM0YW11QXZNZTFNU0pkeldwTG5yRi9jRWZMZSs4VDlUbnZKeVo2eTZuSmxZM0dZV040Q3ROMGVWbjduZGtmZVJNS0ZvV0lTNS9obC9tS2VXRnE1d3djckVxM09JczZ4eVVDVm8zWFFzS1ovVWxYMm5rL3RYNnphOFVQYWQyTFhoYkx6VzZsREpuMUxvVEtUMTdibGJlSmJUUWZ5MWs2cGY1ajdHeW4vNSs3ZHk4R1RUazFlUW5hMVczcjRxMGVZQ2tKS3NnNnFiL1JKNmJab08wYUVGUmJqeGp0dmg4RUZMK3NYNDU4WnQycUd0K1c5bjdWY09IL3ArWkQ2dDlKRmsyaGJYSDhIRktUOHlWTDJxWEEvTTFyN3FTZEwyR1E4ZllsSXBneXVBSGpLWTV3UEE1NEZ5Tzk4TlRjdFQ5b2Z6NzQ0ZUI1c1ZoR0xua2o5MUhnb1VPVUl4OU45enE0YU4vMFdZZ254dGJDNFJTYVJMZmg5UE9lanRXUlRkVzVEZHYrcFdCR1lwYmRlNFdUd013MHRkaXZIVzZJSDZhajl4Ni9pR1hFVXViZzJXS1JqRnBpci9CUjRkbmo1RFd6aGpQMTdoUzBJMFo1K3RSa21sUzdjZVJuT200Rjk3dDEwTFlyeW9vRnJCRXZibGV2MGhMMWJjUGxuV3ZlWnc3N2pWeDB5ZzFVeS9Ocm9udzJiMmlYNXVPeXM0dkQvdG85YVpoaHk5a2hjdXRsdlFMTjNSVm54UkprTHBhQUlEUFQvdUZQTm5pRnM2cjBwL3M3K3JySzJkNTlXM1lsejQvcGtUSm1kZzJEOUtMTDdYN0tDNDJDWi8wS2lMOENFZnRJN3AzN01YNU16cUs2NE0xVDdnaEExREF2aFFSODhpTFZTYU5leE5lMnJFSXdiSm5LcWJjWlA5UHhKY3VjZGZNWGV1Q3FPRldsb3V5UW9TdVZxKzhaYS8vUEpGWFhTa2dYT01jNFNuUXpNeTlaa1Jra21vLzlOVzZhS1RyeklseHZ5Y24vTXhKNjVIYno0M2Z0a1pMVG41UENoUGwwV0NGWUNlMnlGbUdteWtnK1FaL2grcEE5a3dlbFUwaUJyeGd3c005TzcxL3NkNUxCMmZJOHQvMkRwQ2xZaDdMS2pIRlhvWHVIenJGV2VsR0JpUEFzWVNYeEZ1bEZIVVNYaFBpUzBNb0wyY0lCVFV3Q3hPM3BzTzdaUDRZamtXaEpwaHNjZU8rR2svY2VFTmwxaFExMmNPN2N2Sjh5b1dCVENGZ2diak9GUU5ldnZ6MERKK25TVC9kUFprRDJsZEtJbS9YbnRvNi9OaXdiL1dUY01kRndMdUo2YVVuRWpmcTVyUk92amN0Vy9hSGJObG83eDdwNWNhdzI0WE4wTWM5eWRXUUk1TUoySmx2NjAzYjdUK3NLZ2k3cFQ3V083ZGNYNXU1SWFlaEwzeFV3cmJQUDNvalh3VFhhdGVxQTFJQmpwT2JVMldUMTM2TjZiYThNRmVIZXZvS2hKVVFvZldDemtwaE5xdHRabUF1WjVzMEN3Qjd4V2dIL1lOd3lXalhMdWxaNTlCTUtpL2hGNytXN3EvdXBIeDFZU1pCV2MrWUFBM0RTQlhmVzlYc1RvVm02d3ZmT1AvMlZsVUorbWtCRlk4d1JzbnpPYUU1Ynh2ZG5GUmZzU1dycDBHNEwvRHE3TUdoQmQ3SmxiSy9PbEw4enViRlBPeFh3TlQ5MzRic003SWxqc0tUTXJYSmZ1ZDl3cWd0M2NJa291S0N4U2dmOVRNakkyK1l0SG44eUxwZHVUS1lzNWJNMzVSdXo5VzUxckxYUFo5bStob245eDhhSlM1aFg0cUxpalMyN05qYjR1VWpPYjMrZUhocGdzMWNsQzkvVGdEdG81eEJLTk1hWURFa1Q0WGsxRjR0aURFdVpseWZLR0w3Y1VESEV6ZWthSDBDVkVGd0ZOM3R2YVpnR20xM0p3dUNwS3ZlTnlWNjcvM3UwTUhRamcxL1d6dHdpQUwrN1Zsa3MzcjU4YU1DQjhYOWNkaVlVdlpjK1lqRjN3bnR6RDNoajhuQ3lDNzR5eFZzbVlPeVdvTElvU29GZkExekhCNGpQem9OWGJmcHJiTGNNWGUvYTVXZmlaMnJqMnIxVlErZVhaMy9aQ1VucWpkREJlWEhqcCtSeEJZdnNpbnNJci9FNXJkN2YybnBTMXJMdGFkckFURFIyN2k4RUdZME9FSmR0ZVUwL3FuWUErTHZwa1dGNEtoelU1bWMrZFBUVG1OWUhTZVNuUGc4YktQR09XdS9ybm9qT0I5MnZnRW1PRHBGbjhxL2xObVo1NnZpSE5NOEg2MU9meFZDUkFscWlTNW1iRHRoSG9IazlmdUJVNGFLS3ZWckpwUmJWTkZQMWtNaEhmaDgvVnh4ejZaTDJwSUNveWc5c0xUNjgwYi9lUGRIVGZOS0d0NkJNZTl0Z1dlSW1xZDVTTnZhTnZva2pza21KKzIrRzJadnNoQWhXM09BUkxNMlNpeTZibVlPYm5kTmFZMTAvQ2VLZFZjaVVIY0Q1WWxKZ2dvZ2pnWHg4ZE02WWRzMlRFZzIzYXRXY0tEZnNSMTdBWDl0RUJCZzdZOEY5amhJbTRJalNEZkx2MzZuR09kdlNvTXppUzllWFJyeVNCaStQVFZibFI5SEZveTVTV3RzaFNPV2NORjUydFBjYVJweDc3cFJIcUtSdHZkTTZvaXJFZWhnTVhJWFdWTTdmalBjbDJ5Tk1iQUdySjQ1UkZvL3BkVkpBVXZpVkZiRFBYMm5mQWhNVng2UWpuVVdkdnZ2ay9ncFptb0Q4Z2JPRms0MGE2RTljeHRUdUt3NVFubGlSYkhaUk9BZU4vOUVDblRxRUtQakxOZmlybEhab2NXU2E0OTVlaTEwcVVvcmtUMUdsSWVQQ1diWTA4a1RPYk4yZ3BKaVdLdlhyZ090NXcxNWdIdU1MYkltK05lTUFIVGdPdEhuRE1aRXpSNksveklBNGpFL05Db0FPWE5IbUEvSVBkMzN0K1pIeDYxUWord2pRZ3VlL2x2d0tiQ2M2blBFaTJORnVkMmJUSHNKeUlMbVZhdWl4cXZaQmF3alNyaENVekUzWGt1UVBDUnZFbDU3eU9ERitsanUrUWxPZDBrdk5xRHgrWWc1MmZKcmlkRHByN2IwS1ZIK01OYkoyZEhUUHhBYnJiRDlDWmtnUnByYkZDT0kxUXVSUWdGV2EwUUJncUQ2cjBOVGNmUElTbXZKcmwvN0IyUEFaZGNtcDZuWldwZ3lnZkpQU0QydEhwa1VEdkpkeWh3K2pCOTdOc3V3cXlXM3NLcUV4THdLbzZFdWZ0eTc1c0xrMGVXRncwNExKc3VQT0dyUFBEL1JBaHBkM2FleVNyY1BIdjl5OGNzeHBCYTd5YUU2TVlibTg2VjBMeUhEL2hDZThqbHN0TUhjazlVRUVBT1ZLYzlxb2FMMFFxWDlIQ0xPQ1JnV3FralBxc1dIOUE3c2liaDVIYUdCWFV0cnNxdG16Qjk2TmZuQ1F2eHpnZ1l4L1I3citlTE5tNG5CdFZiMXd0L3krczkwUjl2U2VtY25xL05wYlRkWUg1RURVaThhTlU1NGJoOVcyWWJNdDdRQUJQYWRPclRUU0I1VEZneEVGL2lwN3BlZC9nWDRJMzVFN0RJL2JKWUlPanlYNHhPNGhGNnJMVzVyOTV1QzIrY0wwVjk1YkloK2g4OTBHWks2bW5yNHExSklrK2hDTmdWYTJXeHBiNDJzM2xUZDJuWnJMcjFqV3A4WmxEVmJySXN6aHRLK1pqUHU1dVhCYVMzM3RzcnFXNmJuc3VpR2xYbkx1bnhIcU5wdFc1Q0h2QVltd1RwMnE3eC9XSEFqSkdyZ2NWcC9DelZFN0dsQ1pEVWdwdXZqMDZPcjlCU201cWJxb0tIbXRmN2RqTm13eXo4WVdHVlRXODNYM1JQdDhkVXFGbnRtVHpLZTJSNVptQ29EdzN1MDZZMVk0eFJYL1NtZTN3K0tTeHhyaW1YUWIrTGxINTErOGFwSDRTQmZhWEV4QjFwa1VLQ2RlSHp1YzI1T2hxOTNTM29UcFZUVFBUWEZ0OCsyZG40ZGpBTGtOeE9PUnRqNWV0QU54SS9pVFdRdGxYQWV0WTBkWTZiTVFnU0NFS1JBeVEvbjhrTnZyQVE0ZjlXWDRCaDBKT3NQbWhQSXZIZWk5emxCSWNXaWpTM2I0VURialI0bzBvWmxNdGJNb2l1UjNvYjhkT3I1SndCZmxCWHVRUEpZWTRrSEV2WG5IS3RTY3VaRnNFRHN0bzRxcGtYTFMweXVYbmsxc0dPVTk0M1ViSXZ2L1g2NklGQThxeVV6b2hHdEY3bTVwQXV2TEJjMEV6WE1rcG1tdUNWZk10QjREaUlpT0lUNUF1ZnI1RUdjVm5GWkJpdnNFdEdGd2RoNGRDZ1J5OXVXTFlZM1BhWjBVcGM1ckJoTmpqeWpUcDdjK1FMdzNJVlgwQTRIUWp2QkF0VUllUm42RHVCMnozRzl2N2N2M2NFb0o5cDJIRTRjU2RmUFZPQVBIT2d6SkhFK0ZFZzF1U213TnBaZ2xTUFdOaXU2T1hMbVhuL0JCMVZtQVhGOFloVk9zSU1RMURmZm42ZlBSeFBSRFc1LzladktQSmh3SW5ORWR3V2I2Ymc5RzkwU3VIRlZaWVhMWHp0Y3Z5S0EvRFBENy9xTy85TkhRYjRzV3Z4bGJiMFc5WG5WYTVOTStMdEZWaWNwalJka2hiVTVOOFF2U29jRFVobUlsdnpSV2xCdmFSbWdHVG9qakpPK2VlTWI3dTRRWmhzM1NqaTc1cktVcjQvSHlpVlBweGYyMW9oZ0tQUFo4c25oeHM0czVXSlhHblAvY2JQS2oxRWc2ODBkN2t1NzFpeHc3bUgyUzNMcDRlZXlpQ0pERytJVkFlOTJodVRjMGVsWmRrVjRUdDA5bjBBT1VHdzN3RHFlSXJFMUVNOU02RTU5dlBDNTdPc0YzSXNUajN2QXRQa2dPTm0rc1hYRzlDN044clR6RjFGVWpJWDBvWUFKNTNKQ1NDdHVGaENOQjZybitJbDVhUWdMekluTTZRcERaNmhlbzVRYit5VTMwaHN6ZkgwcC85M1ZXc05XSytBNy9GTGFlb2laeEdpcnhUb09wSEx2bHZSTTl4cXBNUHBsVzRPSW5vMWVQSEhxUjdIOG0veHhSN0tlSWF5aVN0dm1JYXZlbHhaaHJHV0w2WUI3SHZXZlhaTE4rTUYwVjZNTlBnbVNNZ1JYUnZTT1p3QkgxVGFTN2N3aXhlcXErQnBXQld4SThsaVFzeW5BVkxHZGtEdGZrZEticnZndHFSRFFPRFZHSGZPdlRac2V0NnYvekpDYnJwR0c2SHZrZUlSNk5xMHZHY1J6UndYR3RLMzVtVGx0YzhrS1h4bjVBNC8zZ0k0bk5ENFpkOG9LczNJWjR3VmRwK293V3B0WWN1TGRURC9QRisyZ09JdGNBOEx6RmVyZWUvdUJQT0RuVmUvTng0cjlWcUp2NlRTOU9RV0xvZ1NBL1luQlBEbWFmaGpIQlNMYTErRXQzYVIwQm1HdXgycHhrSHd6c24xUThneDkyVDcraGNrOE1xRkZHYlZ2VUNkdmlkNmJzMFJWbjFmUVVWQWpwZGFsVW83UEZTM011Tkh6WVhXb1N6SjBOVGY3L0ZWdStSNkpCNndqT2ZUd2xQM1lKdmJSUGR4bXJLbS9iYXJZMlFrSzlZUzhGckRuMnZTVFgyd3RCL0FaS2hSQVB6NUtQN1g0dkxwRm1iRGhCeXI2RnZjM2VqRmxZWjEwS1Jib1gzY1BzK1dWKzlJbHJDVTRaYWRVRHU5dVMrWlB3aGRzY2k3ZXZOczFDVXJqekYxU2J6MEVDNkM5WnVtY1NUYXQwK2YvU1Vqd3p3dHU4K0tHYU5mb0RESkdXSCtmRDhzbjczdFBCWThBNWpKMFdyczdCSmV5TnJJTlpnVVlxKzhsYjJXSjhYRys4aW5iK3RVd3RyaTZCdDBMVnNaRFBWcVR6L2V0T1oyZDdINWNiV0M0aUZ5bThGbW9BZHY5RE4xYnFMRFVRNFJXdmxyRmFVN1lzckpRTGlmTzltenl6TVpuOFlCSTh2S0Y3b0lDSXpIZm9IVzRKSVVVeHMxM2F1YmtsekJTSWUzbnkxdk00QXBWZHEydXFCT3lncGFBa1lRMXcvejJsaE1uTmRXblBacEtpUWxyNmh2TWRrQVhFbm9HR2NCSThXSXJOOHpTTzU5REVFTGQwV1ppbWpMRzZsa2Q0QmRYb0xKVmhMTnlCcGxvMmdScjNmUExXWlM3d0h2L0VQS2s5eFF3OHBUMzVLdTVwZENEenQ5K2JnanAvZXcraEpaVENPQXJEaTV4ZlBBQ0RtL1lHbTc5aUxhOWZiWktILytEL01CekxESUhjYW43R3FjeWxwZnN2ZXBHTC9zTTNvN2s1VS9WSE0xdCtLZDVqYS91K0ZkN3JZNWtoSExlYW4vRlF4a0UxWG0xZ3o2dmF4WFVUT0VkWUpzNDQrdE1maHVQMGNyeUNsazByT280SjBSQWNIVDJwdWVqUm9RSitXSmExd202VE5Wc1ptcndmTFA0eTV0NjdGcERlSjNDSHd1bnVqM0ZWYk5ZMnpnLzRseCtXK21MM3JMQlhnYjJkS2V4U2xxdTVHK3NyMVF1VTA3aHg2cm5jZjA2eUVxcEsvQVhicWx6Rnd5TlBLTzFWN3IvWWxqOE04THRCeWYrNS9QL29OLzFnK1ZRU0xiK3NERVYyMS9OdWxOcE9hUHNlNzkrTllMZDgxUjFCQTBITTc4aTJ3YjQ2K1VLaUlyRHRTdkRrSHZkLzNDUytKSjBOb0Y1aC9jdG04d3A0WVJKRnNhYkhRZ0Z0bDVsYnJzVGY3UWdQMVc0emJ3T21RNmxHdnUyd3pnb0FxQmVqa0o0TTQ4TDEvdjNRd3l2MFF6NkhVajlhYWVxaXBZczFLUzVSajBEeDNLN053RE03b05xSlBTbEVMYnI1bHdGVkVIeEo2ZWw0ZFh1ZUZaRDV6bmo0bDRLaWY3c1A3d2ZUKzd1N3BnK0F3d2NBeVFiNU4xcEcyK2RkekYyTXFmdkxvY2FPeGJNTkNoTHdsNzlFanFIQXRmQndYZ0ovQlFvNS9GTEFEd29DQ2I1dGNSUHJWWnpZdXp2QWNwL0VpSWtzZGVMMnBmQzdaT2VtQ29UWm0va1IreXRkSU0xVGh3aDgvdjQxYXB3dWxPV21odkM5c1k4OTNXZGYzZ3dPNHZ0dzhRQWxHbGpGaVlENTFjSGtscFhmNWQrUWhNU09CSW9GTHNaYzlaK0lISkJ4dEhpMEdJUVZuV1pHaHFUNUJmdEZBN3ZEejZlb1V5dlhiREszSjU4TmxjRkxuU1MwU3BKSEQxa1ptc0FQRFQ3OWI1cGtLY2NrRS9RTWplQVJhQ3B1YldMNW8zT0RTamJkMWR0bW5yamN2S0VBd1FGVHNLOFBQRHZ3RWFUQ3cyNFRzemh3NEgzazdLWE1TZjgzT09EZEJKT1NLcUlOUldHSmJDMWRLUTN1TThMMlhjcHVhZ29NaWg1YTFTbzk5SmM3R1NpZnlNQ0NyMExueEtYenVRNXhuMjF4dGdBQUFCNTlvbjhQQUFDUEZUZkwvbGYrZTlPV2lGNnJBQUdqNEgzb2IvaG1SLzQ5aVp4YUJaakVnUzhMY3JrZWZHdmZOWjd6dW00cmNXTTEzV2RKYjE3UzdOS1ZHaUJmOHkwa1VEU2VOamJBdWo5YlBML3Jld01TNm5lVzNPQmJDWEphejFnQmo4cFMxazBzZTFCSWRXcXBuVTBCNEZsSWh2dS9EYnRBZURuTXorYi9ULzJwOXEyUzh6NnI3V3RLcG42T0tPL2kxV1ovNS80Ni9ET045NlJOMi8xR3hxTm9PS09jUGxSTHJRVTJ2KzRYYStwT0lUMFNKRFR1OE1kK1psK3ZPVGZuNFZPUDZmT3RMVzhnNXZJVGozNUMyN3VqSVVoZ0xJMjArem1XUUhvZjAxWkxtMmxRVlVqc05SRXBrVFNIQm1VcElwSUZHZ21SMU9lVW5aYmVhMkpyQSsyMlM5cHBaZmxUY00yTEtDeXc3MHZnaXl1a3VHekxCbWl5bDMwOHRDVjdlU1FKNkZhMVJXOXhrQ0FyQUx5WUJablhrMG9taTZiM1I0SUVRbzlTY21TU01JbSsvMk1SWkRGTW5GRmdVZXkwTTZ4M25IVVc1RXdoYUJHbG9SckpndEpWZFl4Z25yOWxiWmhpamhJR3o5bHJ3K1A1WUhpNTBoZkpRT0QvLzMwQU5UaUFLTDFSTEFZRHZGSU9CU0FCQVFhNEFnRG1QUU1ERUZDQVhwZlFVSFdkSVBpNllpY1NMU3dLOXMzcXh1Q2sxbzFiSmZPcUp6RjhnQUFyRElEQkJsR3RnN01QV2gxQytqRHJrRWpSRFZSNGJkQkdyY053amVrNmJJVEd3aGJ3eFBuanNsdGFYdTFvYklNaDFtSjV2NWZIQmtXSWFjVnlHczRlSzFWcTVTR1JuMzdOMzRzMm1WNWtvUXVxbnRWWXhjRnJDTW0yTk9VN2ptWk1kVU9kUmpkVjhjb2EwckhFOXh3TWtXV1BUSjR1ZlUrRTg0ajNWbTI1UkcveUZVTnUxQ3ZsMTY2c3JzdW5FL1c1L05mOGh5MU9WVUVSWTZEVlNKcmw5MzFVQTZVaXBjcDlRVFBjWWcwcTVLdWpWYVNPUmFscVZlaFlRb1VuRWV2cG8xWUl6QnVMTFJ5N0cwam4xWklMRVZubjFaY05rdDZVRlhtTVRrRDZWVDlLVndJNnFiTWJJN0Y2TGYzVnFGT3RUSkVDRk9tYTVPdnoxcXRHVnpBc0oxOTlsRlU3cjh2ekpsUld1WTh2Vk1xc1ZCR25WemtXTlNUSmtMbVpIaGttTjFWYkRhamFIc1VpSDlrcDBqZ1pwTGxUb1FXUmxaaGpVWVJBS01iWEtHS1dyNkE5RkowY3lIQXBxazZWV3F3U0tOZUhYcU54Um1sbm1KblNlVjI3RXJQVkRWV2lQdGV2WVJFalRHN0toektCbDZEcCtFdFdLVkl2VE9Qc0Z2bVdxRDRRWFVqL2Z6QkxIUFVWRUFsREFBVGY2UnVGTFF3c0hEdzc5aHc0Y3VLTWdNaUZLemZ1UEpDUVVWRFIwREY0ZjlGbFJmNHdqb1g5WFJjVzVad0xWeFVuSGs4Q1BnRWgwWmRlaEF5NEFuZ3lqRlBUZlBPRjZad2I0T1dUSlZ1T1hIbURCTXNIQlliTXVhVElGVGNVdTZORXFab0Y5VnB0MTZsbmJHQm9tQzA0NUxBampqcHYydGUrWVIwTURBdE9PK1BrNEdCNDhEYWk0S3paaU1FYzBBMVBTc05QUm40UDhkNkNjRmw4RUZzb0RJa0l6MnJHaHI4ell5TmhxVGRwam1DcjBTak9SbXhXQk5iZnpZaTdsRE91bkphaTRFK21rTitvdElvRTZRPT1cXFwiKSBmb3JtYXQoXFxcIndvZmYyXFxcIik7XFxufVxcblwiLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIkM6L1VzZXJzL3BhdWxvL0Rlc2t0b3AvV29yay9Qcm9qZWN0cy9QZXJzb25hbC9XZWIvcGF1bG9ibWFyY29zL25vZGVfbW9kdWxlcy9ub3JtYWxpemUuY3NzL25vcm1hbGl6ZS5jc3NcIixcIkM6L1VzZXJzL3BhdWxvL0Rlc2t0b3AvV29yay9Qcm9qZWN0cy9QZXJzb25hbC9XZWIvcGF1bG9ibWFyY29zL25vZGVfbW9kdWxlcy9AbW94eS9yZWFjdC1jYXJvdXNlbC9kaXN0L3N0eWxlcy5jc3NcIixcIkM6L1VzZXJzL3BhdWxvL0Rlc2t0b3AvV29yay9Qcm9qZWN0cy9QZXJzb25hbC9XZWIvcGF1bG9ibWFyY29zL3d3dy9zaGFyZWQvc3R5bGVzL2dsb2JhbC9pbmRleC5jc3NcIixcIkM6L1VzZXJzL3BhdWxvL0Rlc2t0b3AvV29yay9Qcm9qZWN0cy9QZXJzb25hbC9XZWIvcGF1bG9ibWFyY29zL3d3dy9zaGFyZWQvc3R5bGVzL2ltcG9ydHMvY3VzdG9tLW1lZGlhcy5jc3NcIixcIkM6L1VzZXJzL3BhdWxvL0Rlc2t0b3AvV29yay9Qcm9qZWN0cy9QZXJzb25hbC9XZWIvcGF1bG9ibWFyY29zL3d3dy9zaGFyZWQvc3R5bGVzL2ltcG9ydHMvdmFyaWFibGVzLmNzc1wiLFwiQzovVXNlcnMvcGF1bG8vRGVza3RvcC9Xb3JrL1Byb2plY3RzL1BlcnNvbmFsL1dlYi9wYXVsb2JtYXJjb3Mvd3d3L3NoYXJlZC9zdHlsZXMvZ2xvYmFsL2xheW91dC5jc3NcIixcIkM6L1VzZXJzL3BhdWxvL0Rlc2t0b3AvV29yay9Qcm9qZWN0cy9QZXJzb25hbC9XZWIvcGF1bG9ibWFyY29zL3d3dy9zaGFyZWQvc3R5bGVzL2ltcG9ydHMvbWl4aW5zL3R5cG9ncmFwaHkuY3NzXCIsXCJDOi9Vc2Vycy9wYXVsby9EZXNrdG9wL1dvcmsvUHJvamVjdHMvUGVyc29uYWwvV2ViL3BhdWxvYm1hcmNvcy93d3cvc2hhcmVkL3N0eWxlcy9pbXBvcnRzL21peGlucy90ZXh0LmNzc1wiLFwiQzovVXNlcnMvcGF1bG8vRGVza3RvcC9Xb3JrL1Byb2plY3RzL1BlcnNvbmFsL1dlYi9wYXVsb2JtYXJjb3Mvd3d3L3NoYXJlZC9zdHlsZXMvZ2xvYmFsL3R5cG9ncmFwaHkuY3NzXCIsXCJDOi9Vc2Vycy9wYXVsby9EZXNrdG9wL1dvcmsvUHJvamVjdHMvUGVyc29uYWwvV2ViL3BhdWxvYm1hcmNvcy93d3cvc2hhcmVkL3N0eWxlcy9nbG9iYWwvZm9udC1mYWNlcy5jc3NcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIkFBQUEsMkVBQTJFOztBQUUzRTsrRUFDK0U7O0FBRS9FOzs7RUFHRTs7QUFFRjtFQUNFLGlCQUFpQixFQUFFLE1BQU07RUFDekIsOEJBQThCLEVBQUUsTUFBTTtBQUN4Qzs7QUFFQTsrRUFDK0U7O0FBRS9FOztFQUVFOztBQUVGO0VBQ0UsU0FBUztBQUNYOztBQUVBOztFQUVFOztBQUVGO0VBQ0UsY0FBYztBQUNoQjs7QUFFQTs7O0VBR0U7O0FBRUY7RUFDRSxjQUFjO0VBQ2QsZ0JBQWdCO0FBQ2xCOztBQUVBOytFQUMrRTs7QUFFL0U7OztFQUdFOztBQUVGO0VBQ0UsdUJBQXVCLEVBQUUsTUFBTTtFQUMvQixTQUFTLEVBQUUsTUFBTTtFQUNqQixpQkFBaUIsRUFBRSxNQUFNO0FBQzNCOztBQUVBOzs7RUFHRTs7QUFFRjtFQUNFLGlDQUFpQyxFQUFFLE1BQU07RUFDekMsY0FBYyxFQUFFLE1BQU07QUFDeEI7O0FBRUE7K0VBQytFOztBQUUv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QUF5RTtBQUN0SDs7QUFFQTs7OEVBRThFOztBQUU5RTs7OztFQUlFLGVBQWU7QUFDakI7O0FBRUE7RUZ4QkUsbUNBQW1DO0VBQ25DLG1CQUEwQjtFQVcxQixlQUFtQjtBRWNyQjs7QUFFQTtFRjVCRSxtQ0FBbUM7RUFDbkMsaUJBQTBCO0VBZ0IxQixpQkFBcUI7QUVhdkI7O0FDckNBOzs7O29GQUlvRjs7QUFFcEYsK0RBQStEOztBQUUvRDtFQUNFLHVCQUF1QjtFQUN2QixtQkFBbUI7RUFDbkIsa0JBQWtCO0VBQ2xCLGtCQUFrQjtFQUNsQixteTlCQUFrRjtBQUNwRjs7QUFFQTtFQUNFLHVCQUF1QjtFQUN2QixpQkFBaUI7RUFDakIsa0JBQWtCO0VBQ2xCLGtCQUFrQjtFQUNsQixtczRCQUFnRjtBQUNsRjs7QUFFQTtFQUNFLHVCQUF1QjtFQUN2QixnQkFBZ0I7RUFDaEIsa0JBQWtCO0VBQ2xCLGtCQUFrQjtFQUNsQiwyajRCQUFpRjtBQUNuRjs7QUFFQTtFQUNFLHVCQUF1QjtFQUN2QixnQkFBZ0I7RUFDaEIsa0JBQWtCO0VBQ2xCLGtCQUFrQjtFQUNsQiwrcWhDQUF1RjtBQUN6Rjs7QUFFQTtFQUNFLG9CQUFvQjtFQUNwQixtQkFBbUI7RUFDbkIsa0JBQWtCO0VBQ2xCLGtCQUFrQjtFQUNsQiwyNm5CQUF1RTtBQUN6RVwiLFwiZmlsZVwiOlwiaW5kZXguY3NzXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIi8qISBub3JtYWxpemUuY3NzIHY4LjAuMSB8IE1JVCBMaWNlbnNlIHwgZ2l0aHViLmNvbS9uZWNvbGFzL25vcm1hbGl6ZS5jc3MgKi9cXG5cXG4vKiBEb2N1bWVudFxcbiAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXFxuXFxuLyoqXFxuICogMS4gQ29ycmVjdCB0aGUgbGluZSBoZWlnaHQgaW4gYWxsIGJyb3dzZXJzLlxcbiAqIDIuIFByZXZlbnQgYWRqdXN0bWVudHMgb2YgZm9udCBzaXplIGFmdGVyIG9yaWVudGF0aW9uIGNoYW5nZXMgaW4gaU9TLlxcbiAqL1xcblxcbmh0bWwge1xcbiAgbGluZS1oZWlnaHQ6IDEuMTU7IC8qIDEgKi9cXG4gIC13ZWJraXQtdGV4dC1zaXplLWFkanVzdDogMTAwJTsgLyogMiAqL1xcbn1cXG5cXG4vKiBTZWN0aW9uc1xcbiAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXFxuXFxuLyoqXFxuICogUmVtb3ZlIHRoZSBtYXJnaW4gaW4gYWxsIGJyb3dzZXJzLlxcbiAqL1xcblxcbmJvZHkge1xcbiAgbWFyZ2luOiAwO1xcbn1cXG5cXG4vKipcXG4gKiBSZW5kZXIgdGhlIGBtYWluYCBlbGVtZW50IGNvbnNpc3RlbnRseSBpbiBJRS5cXG4gKi9cXG5cXG5tYWluIHtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbn1cXG5cXG4vKipcXG4gKiBDb3JyZWN0IHRoZSBmb250IHNpemUgYW5kIG1hcmdpbiBvbiBgaDFgIGVsZW1lbnRzIHdpdGhpbiBgc2VjdGlvbmAgYW5kXFxuICogYGFydGljbGVgIGNvbnRleHRzIGluIENocm9tZSwgRmlyZWZveCwgYW5kIFNhZmFyaS5cXG4gKi9cXG5cXG5oMSB7XFxuICBmb250LXNpemU6IDJlbTtcXG4gIG1hcmdpbjogMC42N2VtIDA7XFxufVxcblxcbi8qIEdyb3VwaW5nIGNvbnRlbnRcXG4gICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xcblxcbi8qKlxcbiAqIDEuIEFkZCB0aGUgY29ycmVjdCBib3ggc2l6aW5nIGluIEZpcmVmb3guXFxuICogMi4gU2hvdyB0aGUgb3ZlcmZsb3cgaW4gRWRnZSBhbmQgSUUuXFxuICovXFxuXFxuaHIge1xcbiAgYm94LXNpemluZzogY29udGVudC1ib3g7IC8qIDEgKi9cXG4gIGhlaWdodDogMDsgLyogMSAqL1xcbiAgb3ZlcmZsb3c6IHZpc2libGU7IC8qIDIgKi9cXG59XFxuXFxuLyoqXFxuICogMS4gQ29ycmVjdCB0aGUgaW5oZXJpdGFuY2UgYW5kIHNjYWxpbmcgb2YgZm9udCBzaXplIGluIGFsbCBicm93c2Vycy5cXG4gKiAyLiBDb3JyZWN0IHRoZSBvZGQgYGVtYCBmb250IHNpemluZyBpbiBhbGwgYnJvd3NlcnMuXFxuICovXFxuXFxucHJlIHtcXG4gIGZvbnQtZmFtaWx5OiBtb25vc3BhY2UsIG1vbm9zcGFjZTsgLyogMSAqL1xcbiAgZm9udC1zaXplOiAxZW07IC8qIDIgKi9cXG59XFxuXFxuLyogVGV4dC1sZXZlbCBzZW1hbnRpY3NcXG4gICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xcblxcbi8qKlxcbiAqIFJlbW92ZSB0aGUgZ3JheSBiYWNrZ3JvdW5kIG9uIGFjdGl2ZSBsaW5rcyBpbiBJRSAxMC5cXG4gKi9cXG5cXG5hIHtcXG4gIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xcbn1cXG5cXG4vKipcXG4gKiAxLiBSZW1vdmUgdGhlIGJvdHRvbSBib3JkZXIgaW4gQ2hyb21lIDU3LVxcbiAqIDIuIEFkZCB0aGUgY29ycmVjdCB0ZXh0IGRlY29yYXRpb24gaW4gQ2hyb21lLCBFZGdlLCBJRSwgT3BlcmEsIGFuZCBTYWZhcmkuXFxuICovXFxuXFxuYWJiclt0aXRsZV0ge1xcbiAgYm9yZGVyLWJvdHRvbTogbm9uZTsgLyogMSAqL1xcbiAgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmU7IC8qIDIgKi9cXG4gIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lIGRvdHRlZDsgLyogMiAqL1xcbn1cXG5cXG4vKipcXG4gKiBBZGQgdGhlIGNvcnJlY3QgZm9udCB3ZWlnaHQgaW4gQ2hyb21lLCBFZGdlLCBhbmQgU2FmYXJpLlxcbiAqL1xcblxcbmIsXFxuc3Ryb25nIHtcXG4gIGZvbnQtd2VpZ2h0OiBib2xkZXI7XFxufVxcblxcbi8qKlxcbiAqIDEuIENvcnJlY3QgdGhlIGluaGVyaXRhbmNlIGFuZCBzY2FsaW5nIG9mIGZvbnQgc2l6ZSBpbiBhbGwgYnJvd3NlcnMuXFxuICogMi4gQ29ycmVjdCB0aGUgb2RkIGBlbWAgZm9udCBzaXppbmcgaW4gYWxsIGJyb3dzZXJzLlxcbiAqL1xcblxcbmNvZGUsXFxua2JkLFxcbnNhbXAge1xcbiAgZm9udC1mYW1pbHk6IG1vbm9zcGFjZSwgbW9ub3NwYWNlOyAvKiAxICovXFxuICBmb250LXNpemU6IDFlbTsgLyogMiAqL1xcbn1cXG5cXG4vKipcXG4gKiBBZGQgdGhlIGNvcnJlY3QgZm9udCBzaXplIGluIGFsbCBicm93c2Vycy5cXG4gKi9cXG5cXG5zbWFsbCB7XFxuICBmb250LXNpemU6IDgwJTtcXG59XFxuXFxuLyoqXFxuICogUHJldmVudCBgc3ViYCBhbmQgYHN1cGAgZWxlbWVudHMgZnJvbSBhZmZlY3RpbmcgdGhlIGxpbmUgaGVpZ2h0IGluXFxuICogYWxsIGJyb3dzZXJzLlxcbiAqL1xcblxcbnN1YixcXG5zdXAge1xcbiAgZm9udC1zaXplOiA3NSU7XFxuICBsaW5lLWhlaWdodDogMDtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIHZlcnRpY2FsLWFsaWduOiBiYXNlbGluZTtcXG59XFxuXFxuc3ViIHtcXG4gIGJvdHRvbTogLTAuMjVlbTtcXG59XFxuXFxuc3VwIHtcXG4gIHRvcDogLTAuNWVtO1xcbn1cXG5cXG4vKiBFbWJlZGRlZCBjb250ZW50XFxuICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cXG5cXG4vKipcXG4gKiBSZW1vdmUgdGhlIGJvcmRlciBvbiBpbWFnZXMgaW5zaWRlIGxpbmtzIGluIElFIDEwLlxcbiAqL1xcblxcbmltZyB7XFxuICBib3JkZXItc3R5bGU6IG5vbmU7XFxufVxcblxcbi8qIEZvcm1zXFxuICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cXG5cXG4vKipcXG4gKiAxLiBDaGFuZ2UgdGhlIGZvbnQgc3R5bGVzIGluIGFsbCBicm93c2Vycy5cXG4gKiAyLiBSZW1vdmUgdGhlIG1hcmdpbiBpbiBGaXJlZm94IGFuZCBTYWZhcmkuXFxuICovXFxuXFxuYnV0dG9uLFxcbmlucHV0LFxcbm9wdGdyb3VwLFxcbnNlbGVjdCxcXG50ZXh0YXJlYSB7XFxuICBmb250LWZhbWlseTogaW5oZXJpdDsgLyogMSAqL1xcbiAgZm9udC1zaXplOiAxMDAlOyAvKiAxICovXFxuICBsaW5lLWhlaWdodDogMS4xNTsgLyogMSAqL1xcbiAgbWFyZ2luOiAwOyAvKiAyICovXFxufVxcblxcbi8qKlxcbiAqIFNob3cgdGhlIG92ZXJmbG93IGluIElFLlxcbiAqIDEuIFNob3cgdGhlIG92ZXJmbG93IGluIEVkZ2UuXFxuICovXFxuXFxuYnV0dG9uLFxcbmlucHV0IHsgLyogMSAqL1xcbiAgb3ZlcmZsb3c6IHZpc2libGU7XFxufVxcblxcbi8qKlxcbiAqIFJlbW92ZSB0aGUgaW5oZXJpdGFuY2Ugb2YgdGV4dCB0cmFuc2Zvcm0gaW4gRWRnZSwgRmlyZWZveCwgYW5kIElFLlxcbiAqIDEuIFJlbW92ZSB0aGUgaW5oZXJpdGFuY2Ugb2YgdGV4dCB0cmFuc2Zvcm0gaW4gRmlyZWZveC5cXG4gKi9cXG5cXG5idXR0b24sXFxuc2VsZWN0IHsgLyogMSAqL1xcbiAgdGV4dC10cmFuc2Zvcm06IG5vbmU7XFxufVxcblxcbi8qKlxcbiAqIENvcnJlY3QgdGhlIGluYWJpbGl0eSB0byBzdHlsZSBjbGlja2FibGUgdHlwZXMgaW4gaU9TIGFuZCBTYWZhcmkuXFxuICovXFxuXFxuYnV0dG9uLFxcblt0eXBlPVxcXCJidXR0b25cXFwiXSxcXG5bdHlwZT1cXFwicmVzZXRcXFwiXSxcXG5bdHlwZT1cXFwic3VibWl0XFxcIl0ge1xcbiAgLXdlYmtpdC1hcHBlYXJhbmNlOiBidXR0b247XFxufVxcblxcbi8qKlxcbiAqIFJlbW92ZSB0aGUgaW5uZXIgYm9yZGVyIGFuZCBwYWRkaW5nIGluIEZpcmVmb3guXFxuICovXFxuXFxuYnV0dG9uOjotbW96LWZvY3VzLWlubmVyLFxcblt0eXBlPVxcXCJidXR0b25cXFwiXTo6LW1vei1mb2N1cy1pbm5lcixcXG5bdHlwZT1cXFwicmVzZXRcXFwiXTo6LW1vei1mb2N1cy1pbm5lcixcXG5bdHlwZT1cXFwic3VibWl0XFxcIl06Oi1tb3otZm9jdXMtaW5uZXIge1xcbiAgYm9yZGVyLXN0eWxlOiBub25lO1xcbiAgcGFkZGluZzogMDtcXG59XFxuXFxuLyoqXFxuICogUmVzdG9yZSB0aGUgZm9jdXMgc3R5bGVzIHVuc2V0IGJ5IHRoZSBwcmV2aW91cyBydWxlLlxcbiAqL1xcblxcbmJ1dHRvbjotbW96LWZvY3VzcmluZyxcXG5bdHlwZT1cXFwiYnV0dG9uXFxcIl06LW1vei1mb2N1c3JpbmcsXFxuW3R5cGU9XFxcInJlc2V0XFxcIl06LW1vei1mb2N1c3JpbmcsXFxuW3R5cGU9XFxcInN1Ym1pdFxcXCJdOi1tb3otZm9jdXNyaW5nIHtcXG4gIG91dGxpbmU6IDFweCBkb3R0ZWQgQnV0dG9uVGV4dDtcXG59XFxuXFxuLyoqXFxuICogQ29ycmVjdCB0aGUgcGFkZGluZyBpbiBGaXJlZm94LlxcbiAqL1xcblxcbmZpZWxkc2V0IHtcXG4gIHBhZGRpbmc6IDAuMzVlbSAwLjc1ZW0gMC42MjVlbTtcXG59XFxuXFxuLyoqXFxuICogMS4gQ29ycmVjdCB0aGUgdGV4dCB3cmFwcGluZyBpbiBFZGdlIGFuZCBJRS5cXG4gKiAyLiBDb3JyZWN0IHRoZSBjb2xvciBpbmhlcml0YW5jZSBmcm9tIGBmaWVsZHNldGAgZWxlbWVudHMgaW4gSUUuXFxuICogMy4gUmVtb3ZlIHRoZSBwYWRkaW5nIHNvIGRldmVsb3BlcnMgYXJlIG5vdCBjYXVnaHQgb3V0IHdoZW4gdGhleSB6ZXJvIG91dFxcbiAqICAgIGBmaWVsZHNldGAgZWxlbWVudHMgaW4gYWxsIGJyb3dzZXJzLlxcbiAqL1xcblxcbmxlZ2VuZCB7XFxuICBib3gtc2l6aW5nOiBib3JkZXItYm94OyAvKiAxICovXFxuICBjb2xvcjogaW5oZXJpdDsgLyogMiAqL1xcbiAgZGlzcGxheTogdGFibGU7IC8qIDEgKi9cXG4gIG1heC13aWR0aDogMTAwJTsgLyogMSAqL1xcbiAgcGFkZGluZzogMDsgLyogMyAqL1xcbiAgd2hpdGUtc3BhY2U6IG5vcm1hbDsgLyogMSAqL1xcbn1cXG5cXG4vKipcXG4gKiBBZGQgdGhlIGNvcnJlY3QgdmVydGljYWwgYWxpZ25tZW50IGluIENocm9tZSwgRmlyZWZveCwgYW5kIE9wZXJhLlxcbiAqL1xcblxcbnByb2dyZXNzIHtcXG4gIHZlcnRpY2FsLWFsaWduOiBiYXNlbGluZTtcXG59XFxuXFxuLyoqXFxuICogUmVtb3ZlIHRoZSBkZWZhdWx0IHZlcnRpY2FsIHNjcm9sbGJhciBpbiBJRSAxMCsuXFxuICovXFxuXFxudGV4dGFyZWEge1xcbiAgb3ZlcmZsb3c6IGF1dG87XFxufVxcblxcbi8qKlxcbiAqIDEuIEFkZCB0aGUgY29ycmVjdCBib3ggc2l6aW5nIGluIElFIDEwLlxcbiAqIDIuIFJlbW92ZSB0aGUgcGFkZGluZyBpbiBJRSAxMC5cXG4gKi9cXG5cXG5bdHlwZT1cXFwiY2hlY2tib3hcXFwiXSxcXG5bdHlwZT1cXFwicmFkaW9cXFwiXSB7XFxuICBib3gtc2l6aW5nOiBib3JkZXItYm94OyAvKiAxICovXFxuICBwYWRkaW5nOiAwOyAvKiAyICovXFxufVxcblxcbi8qKlxcbiAqIENvcnJlY3QgdGhlIGN1cnNvciBzdHlsZSBvZiBpbmNyZW1lbnQgYW5kIGRlY3JlbWVudCBidXR0b25zIGluIENocm9tZS5cXG4gKi9cXG5cXG5bdHlwZT1cXFwibnVtYmVyXFxcIl06Oi13ZWJraXQtaW5uZXItc3Bpbi1idXR0b24sXFxuW3R5cGU9XFxcIm51bWJlclxcXCJdOjotd2Via2l0LW91dGVyLXNwaW4tYnV0dG9uIHtcXG4gIGhlaWdodDogYXV0bztcXG59XFxuXFxuLyoqXFxuICogMS4gQ29ycmVjdCB0aGUgb2RkIGFwcGVhcmFuY2UgaW4gQ2hyb21lIGFuZCBTYWZhcmkuXFxuICogMi4gQ29ycmVjdCB0aGUgb3V0bGluZSBzdHlsZSBpbiBTYWZhcmkuXFxuICovXFxuXFxuW3R5cGU9XFxcInNlYXJjaFxcXCJdIHtcXG4gIC13ZWJraXQtYXBwZWFyYW5jZTogdGV4dGZpZWxkOyAvKiAxICovXFxuICBvdXRsaW5lLW9mZnNldDogLTJweDsgLyogMiAqL1xcbn1cXG5cXG4vKipcXG4gKiBSZW1vdmUgdGhlIGlubmVyIHBhZGRpbmcgaW4gQ2hyb21lIGFuZCBTYWZhcmkgb24gbWFjT1MuXFxuICovXFxuXFxuW3R5cGU9XFxcInNlYXJjaFxcXCJdOjotd2Via2l0LXNlYXJjaC1kZWNvcmF0aW9uIHtcXG4gIC13ZWJraXQtYXBwZWFyYW5jZTogbm9uZTtcXG59XFxuXFxuLyoqXFxuICogMS4gQ29ycmVjdCB0aGUgaW5hYmlsaXR5IHRvIHN0eWxlIGNsaWNrYWJsZSB0eXBlcyBpbiBpT1MgYW5kIFNhZmFyaS5cXG4gKiAyLiBDaGFuZ2UgZm9udCBwcm9wZXJ0aWVzIHRvIGBpbmhlcml0YCBpbiBTYWZhcmkuXFxuICovXFxuXFxuOjotd2Via2l0LWZpbGUtdXBsb2FkLWJ1dHRvbiB7XFxuICAtd2Via2l0LWFwcGVhcmFuY2U6IGJ1dHRvbjsgLyogMSAqL1xcbiAgZm9udDogaW5oZXJpdDsgLyogMiAqL1xcbn1cXG5cXG4vKiBJbnRlcmFjdGl2ZVxcbiAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXFxuXFxuLypcXG4gKiBBZGQgdGhlIGNvcnJlY3QgZGlzcGxheSBpbiBFZGdlLCBJRSAxMCssIGFuZCBGaXJlZm94LlxcbiAqL1xcblxcbmRldGFpbHMge1xcbiAgZGlzcGxheTogYmxvY2s7XFxufVxcblxcbi8qXFxuICogQWRkIHRoZSBjb3JyZWN0IGRpc3BsYXkgaW4gYWxsIGJyb3dzZXJzLlxcbiAqL1xcblxcbnN1bW1hcnkge1xcbiAgZGlzcGxheTogbGlzdC1pdGVtO1xcbn1cXG5cXG4vKiBNaXNjXFxuICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cXG5cXG4vKipcXG4gKiBBZGQgdGhlIGNvcnJlY3QgZGlzcGxheSBpbiBJRSAxMCsuXFxuICovXFxuXFxudGVtcGxhdGUge1xcbiAgZGlzcGxheTogbm9uZTtcXG59XFxuXFxuLyoqXFxuICogQWRkIHRoZSBjb3JyZWN0IGRpc3BsYXkgaW4gSUUgMTAuXFxuICovXFxuXFxuW2hpZGRlbl0ge1xcbiAgZGlzcGxheTogbm9uZTtcXG59XFxuXCIsXCIucmMtd3JhcHBlcixcXG4ucmMsXFxuLnJjLXNsaWRlciB7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG59XFxuXFxuLnJjIHtcXG4gICAgb3ZlcmZsb3cteDogYXV0bztcXG4gICAgLXdlYmtpdC1vdmVyZmxvdy1zY3JvbGxpbmc6IHRvdWNoO1xcbn1cXG5cXG4ucmMuLW5vLXNjcm9sbCB7XFxuICAgIG92ZXJmbG93LXg6IGhpZGRlbjtcXG59XFxuXFxuLnJjLXNsaWRlciB7XFxuICAgIHdpZHRoOiBmaXQtY29udGVudDtcXG4gICAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcXG59XFxuXFxuLnJjLXNsaWRlIHtcXG4gICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbn1cXG5cXG4ucmMtc2xpZGU6aG92ZXIge1xcbiAgICBjdXJzb3I6IHBvaW50ZXI7XFxufVxcblxcbi5yYy1zbGlkZXIuLWRyYWdnYWJsZTpob3ZlciB7XFxuICAgIGN1cnNvcjogZ3JhYjtcXG59XFxuXFxuLnJjLXNsaWRlci4tZHJhZ2dhYmxlLi1kcmFnZ2luZyxcXG4ucmMtc2xpZGVyLi1kcmFnZ2FibGUuLWRyYWdnaW5nIC5yYy1zbGlkZSB7XFxuICAgIGN1cnNvcjogZ3JhYmJpbmc7XFxufVxcblxcbi5yYy1hcnJvdyB7XFxuICAgIHBvc2l0aW9uOiAgYWJzb2x1dGU7XFxuICAgIHRvcDogNTAlO1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoLTUwJSk7XFxufVxcblxcbi5yYy1hcnJvdy4tbGVmdCB7IGxlZnQ6IDE1cHg7IH1cXG4ucmMtYXJyb3cuLXJpZ2h0IHsgcmlnaHQ6IDE1cHg7IH1cXG5cXG4ucmMtZG90cyB7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbn1cXG5cXG4ucmMtZG90IHtcXG4gICAgbWFyZ2luOiAwIDVweDtcXG4gICAgb3BhY2l0eTogMC41O1xcbn1cXG5cXG4ucmMtZG90Li1jdXJyZW50IHtcXG4gICAgb3BhY2l0eTogMTtcXG59XFxuXFxuXCIsXCJAaW1wb3J0IFxcXCJub3JtYWxpemUuY3NzXFxcIjtcXG5AaW1wb3J0IFxcXCJAbW94eS9yZWFjdC1jYXJvdXNlbC9kaXN0L3N0eWxlcy5jc3NcXFwiO1xcblxcbi8qIEludGVybmFsICovXFxuQGltcG9ydCBcXFwiLi9sYXlvdXRcXFwiO1xcbkBpbXBvcnQgXFxcIi4vdHlwb2dyYXBoeVxcXCI7XFxuQGltcG9ydCBcXFwiLi9mb250LWZhY2VzXFxcIjtcXG5cIixcIi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxuICAgQ3VzdG9tIG1lZGlhIHF1ZXJpZXNcXG5cXG4gICBVc2UgaXQgbGlrZSBzbzogQG1lZGlhICgtLWxheW91dC1zbWFsbCkgeyAuLi4gfVxcbiAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXFxuXFxuQGN1c3RvbS1tZWRpYSAtLWxheW91dC1sdGUteHhzbWFsbCAod2lkdGggPD0gMjMuNDM3NWVtKTsgLyogMzc1cHggKi9cXG5AY3VzdG9tLW1lZGlhIC0tbGF5b3V0LWx0ZS14c21hbGwgKHdpZHRoIDw9IDMwZW0pOyAvKiA0ODBweCAqL1xcbkBjdXN0b20tbWVkaWEgLS1sYXlvdXQtbHRlLXNtYWxsICh3aWR0aCA8PSA0OGVtKTsgLyogNzY4cHggKi9cXG5AY3VzdG9tLW1lZGlhIC0tbGF5b3V0LWx0ZS1tZWRpdW0gKHdpZHRoIDw9IDY0ZW0pOyAvKiAxMDI0cHggKi9cXG5AY3VzdG9tLW1lZGlhIC0tbGF5b3V0LWx0ZS1sYXJnZSAod2lkdGggPD0gODBlbSk7IC8qIDEyODBweCAqL1xcbkBjdXN0b20tbWVkaWEgLS1sYXlvdXQtbHRlLXhsYXJnZSAod2lkdGggPD0gOTBlbSk7IC8qIDE0NDBweCAqL1xcbkBjdXN0b20tbWVkaWEgLS1sYXlvdXQtbHRlLXh4bGFyZ2UgKHdpZHRoIDw9IDEyMGVtKTsgLyogMTkyMHB4ICovXFxuXCIsXCJAaW1wb3J0IFxcXCIuL2N1c3RvbS1tZWRpYXNcXFwiO1xcblxcbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxuICAgQ29sb3JzXFxuICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cXG5cXG46cm9vdCB7XFxuICAtLWNvbG9yLXdoaXRlOiAjZmZmO1xcbiAgLS1jb2xvci1ibGFjazogIzAwMDtcXG4gIC0tY29sb3ItZGFyazogIzBmMGYxMTtcXG4gIC0tY29sb3ItZ3JheTogIzJkMmUzMjtcXG4gIC0tY29sb3ItbGlnaHQtZ3JheTogI2MxYzVkNDtcXG4gIC0tY29sb3ItZGFyay1ncmF5OiAjMTkxYTFkO1xcbiAgLS1jb2xvci1ncmVlbjogIzY0ZjRhYztcXG4gIC0tY29sb3ItZ3JlZW4tZGFyazogIzI4NjE0NDtcXG59XFxuXFxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXG4gICBaLUluZGV4ZXNcXG4gICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xcblxcbjpyb290IHtcXG4gIC0tei1pbmRleC1iYXNlOiAxO1xcbiAgLS16LWluZGV4LWhlYWRlcjogNTtcXG4gIC0tei1pbmRleC1mcmFtZTogNjtcXG59XFxuXFxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXG4gICBTaXplc1xcbiAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXFxuXFxuOnJvb3Qge1xcbiAgLS1sYXlvdXQtd2lkdGg6IDEwMHZ3O1xcbiAgLS1sYXlvdXQtaGVpZ2h0OiAxMDB2aDtcXG4gIC0tbGF5b3V0LW1heC13aWR0aDogMTUwcmVtO1xcbiAgLS1sYXlvdXQtcGFkZGluZzogMi4ycmVtO1xcblxcbiAgLS1oZWFkZXItaGVpZ2h0OiA0cmVtO1xcbiAgLS1oZWFkZXItZnJhbWUtdG9wOiBjYWxjKHZhcigtLWxheW91dC1wYWRkaW5nKSAqIDIpO1xcblxcbiAgLS1jb250ZW50LXZpZXdwb3J0LWhlaWdodDogY2FsYygxMDB2aCAtICh2YXIoLS1sYXlvdXQtcGFkZGluZykgKiAyKSk7XFxuXFxuICAtLWNhcm91c2VsLWl0ZW0td2lkdGg6IDYwdnc7XFxuICAtLWNhcm91c2VsLWl0ZW0taGVpZ2h0OiAzMHZ3O1xcbn1cXG5cXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcbiAgICBMYW5kc2NhcGVcXG4gICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cXG5cXG5AbWVkaWEgKG9yaWVudGF0aW9uOiBsYW5kc2NhcGUpIHtcXG4gIDpyb290IHtcXG4gICAgLS1jYXJvdXNlbC1pdGVtLXdpZHRoOiA2MHZ3O1xcbiAgICAtLWNhcm91c2VsLWl0ZW0taGVpZ2h0OiAzM3Z3O1xcbiAgfVxcbn1cXG5cXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcbiAgICBQb3J0cmFpdFxcbiAgICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xcblxcbkBtZWRpYSAob3JpZW50YXRpb246IHBvcnRyYWl0KSB7XFxuICA6cm9vdCB7XFxuICAgIC0tY2Fyb3VzZWwtaXRlbS13aWR0aDogODB2dztcXG4gICAgLS1jYXJvdXNlbC1pdGVtLWhlaWdodDogODB2dztcXG4gIH1cXG59XFxuXFxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXG4gICBDdXN0b20gbWVkaWFzXFxuICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cXG5cXG5AbWVkaWEgKC0tbGF5b3V0LWx0ZS1zbWFsbCkge1xcbiAgOnJvb3Qge1xcbiAgICAtLWxheW91dC1wYWRkaW5nOiAydnc7XFxuICB9XFxufVxcblwiLFwiQGltcG9ydCBcXFwiLi4vaW1wb3J0cy92YXJpYWJsZXMuY3NzXFxcIjtcXG5cXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcbiAgIFByb3BlciBib3gtc2l6aW5nIG1vZGVsXFxuICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cXG5cXG4qLFxcbio6OmJlZm9yZSxcXG4qOjphZnRlciB7XFxuICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxufVxcblxcbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxuICAgRG9jdW1lbnRcXG4gICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xcblxcbi8qXFxuICAgMS4gU3RyZXRjaCA8aHRtbD4gc3RyZXRjaCB0byBmaWxsIG91ciBzY3JlZW4gaGVpZ2h0XFxuICAgMi4gTWFrZSBjaGlsZHJlbiBvZiBodG1sIChib2R5KSBvY2N1cHkgYXQgbGVhc3QgMTAwJSBvZiB0aGUgc2NyZWVuXFxuICAgMy4gVmlld3BvcnQgaXMgc2NhbGFibGUgYW5kIG9jY3VwaWVzIGF0IGxlYXN0IDMyMHB4IChpUGhvbmUgU0UpXFxuKi9cXG5cXG5odG1sIHtcXG4gICAgbWluLXdpZHRoOiAzMmVtO1xcbiAgICBoZWlnaHQ6IDA7IC8qIDMgKi9cXG4gICAgbWluLWhlaWdodDogMTAwJTsgLyogMSAqL1xcbiAgICBkaXNwbGF5OiBmbGV4OyAvKiAyICovXFxuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47IC8qIDIgKi9cXG59XFxuXFxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXG4gICBCb2R5ICYgI3Jvb3RcXG4gICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xcblxcbmJvZHkge1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBmbGV4OiAxIDAgYXV0bztcXG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG59XFxuXFxuOmdsb2JhbCgjX19uZXh0KSB7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGZsZXg6IDEgMCBhdXRvO1xcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbn1cXG5cIixcIkBpbXBvcnQgXFxcIi4uL2N1c3RvbS1tZWRpYXNcXFwiO1xcblxcbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxuICBGb250c1xcbiAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cXG5cXG5AZGVmaW5lLW1peGluIF9mb250LWthcmFzdW1hICRmb250V2VpZ2h0OiBub3JtYWwge1xcbiAgZm9udC1mYW1pbHk6IFxcXCJLYXJhc3VtYVxcXCIsIHNhbnMtc2VyaWY7XFxuICBmb250LXdlaWdodDogJChmb250V2VpZ2h0KTtcXG59XFxuXFxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXG4gIEFsbCB0eXBvZ3JhcGh5IHZhcmlhbnRzXFxuXFxuICAkdW5pdCAtIEVpdGhlciBlbSBvciByZW1cXG4gID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXFxuXFxuQGRlZmluZS1taXhpbiB0eXBvZ3JhcGh5LWgxICR1bml0OiByZW0ge1xcbiAgQG1peGluIF9mb250LWthcmFzdW1hIGJvbGRlcjtcXG4gIGZvbnQtc2l6ZTogOCQodW5pdCk7XFxufVxcblxcbkBkZWZpbmUtbWl4aW4gdHlwb2dyYXBoeS1oMiAkdW5pdDogcmVtIHtcXG4gIEBtaXhpbiBfZm9udC1rYXJhc3VtYSBib2xkO1xcbiAgZm9udC1zaXplOiA0LjgkKHVuaXQpO1xcbn1cXG5cXG5AZGVmaW5lLW1peGluIHR5cG9ncmFwaHktYm9keSAkdW5pdDogcmVtIHtcXG4gIEBtaXhpbiBfZm9udC1rYXJhc3VtYTtcXG4gIGZvbnQtc2l6ZTogMS42JCh1bml0KTtcXG59XFxuXFxuQGRlZmluZS1taXhpbiB0eXBvZ3JhcGh5LWJvZHkgJHVuaXQ6IHJlbSB7XFxuICBAbWl4aW4gX2ZvbnQta2FyYXN1bWE7XFxuICBmb250LXNpemU6IDEuNiQodW5pdCk7XFxufVxcblwiLFwiLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXG4gICBTbW9vdGggJiBzaGFycCBtaXhpbnNcXG4gICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xcblxcbkBkZWZpbmUtbWl4aW4gdGV4dC1zbW9vdGgge1xcbiAgICAtbW96LW9zeC1mb250LXNtb290aGluZzogZ3JheXNjYWxlOyAgLyogRm9udCBzbW9vdGhpbmcgdHdlYWtzIGZvciBNYWNPU3ggaW4gR2Vja28gKi9cXG4gICAgLXdlYmtpdC1mb250LXNtb290aGluZzogYW50aWFsaWFzZWQ7IC8qIEZvbnQgc21vb3RoaW5nIHR3ZWFrcyBmb3IgTWFjT1N4IGluIFdlYmtpdCAqL1xcbn1cXG5cXG5AZGVmaW5lLW1peGluIHRleHQtc2hhcnAge1xcbiAgICAtbW96LW9zeC1mb250LXNtb290aGluZzogaW5pdGlhbDsgICAvKiBUdXJuIG9mZiBmb250IHNtb290aGluZyB0d2Vha3MgZm9yIE1hY09TeCBpbiBHZWNrbyAqL1xcbiAgICAtd2Via2l0LWZvbnQtc21vb3RoaW5nOiBpbml0aWFsOyAgICAvKiBUdXJuIG9mZiBmb250IHNtb290aGluZyB0d2Vha3MgZm9yIE1hY09TeCBpbiBXZWJraXQgKi9cXG59XFxuXFxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXG4gICBFbGxpcHNpcyBtaXhpblxcblxcbiAgIFRoZSBjb250YWluZXIgbmVlZHMgdG8gaGF2ZSBhIHdpZHRoIGZvciBpdCB0byB3b3JrXFxuICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cXG5cXG5AZGVmaW5lLW1peGluIHRleHQtZWxsaXBzaXMge1xcbiAgICBvdmVyZmxvdzogaGlkZGVuOyAvKiBcXFwib3ZlcmZsb3dcXFwiIHZhbHVlIG11c3QgYmUgZGlmZmVyZW50IGZyb20gXFxcInZpc2libGVcXFwiICovXFxuICAgIHRleHQtb3ZlcmZsb3c6IGVsbGlwc2lzO1xcbiAgICB3aGl0ZS1zcGFjZTogbm93cmFwO1xcbiAgICBvdmVyZmxvdy13cmFwOiBub3JtYWw7XFxufVxcblxcbkBkZWZpbmUtbWl4aW4gdGV4dC1lbGxpcHNpcy1tdWx0aWxpbmUgJG1heC1saW5lLWNvdW50LCAkbWF4LWhlaWdodCB7XFxuICAgIG1heC1oZWlnaHQ6ICRtYXgtaGVpZ2h0O1xcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgICAvKiBzdHlsZWxpbnQtZGlzYWJsZSAqL1xcbiAgICBkaXNwbGF5OiAtd2Via2l0LWJveDtcXG4gICAgdGV4dC1vdmVyZmxvdzogZWxsaXBzaXM7XFxuICAgIC13ZWJraXQtbGluZS1jbGFtcDogJG1heC1saW5lLWNvdW50O1xcbiAgICAtd2Via2l0LWJveC1vcmllbnQ6IHZlcnRpY2FsO1xcbiAgICAvKiBzdHlsZWxpbnQtZW5hYmxlICovXFxufVxcblwiLFwiQGltcG9ydCBcXFwiLi4vaW1wb3J0cy92YXJpYWJsZXMuY3NzXFxcIjtcXG5AaW1wb3J0IFxcXCIuLi9pbXBvcnRzL21peGlucy90eXBvZ3JhcGh5LmNzc1xcXCI7XFxuQGltcG9ydCBcXFwiLi4vaW1wb3J0cy9taXhpbnMvdGV4dC5jc3NcXFwiO1xcblxcbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxuICAgVHlwb2dyYXBoeSBEZWZhdWx0c1xcbiAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXFxuXFxuaHRtbCB7XFxuICBmb250LXNpemU6IDYyLjUlOyAvKiA2Mi41JSBzbyB0aGF0IGFsbCB0aGUgUkVNIG1lYXN1cmVtZW50cyByZSBiYXNlZCBvbiAxMHB4IHNpemluZyAqL1xcbn1cXG5cXG5ib2R5IHtcXG4gIEBtaXhpbiB0eXBvZ3JhcGh5LWJvZHk7XFxuICBAbWl4aW4gdGV4dC1zbW9vdGg7XFxuXFxuICBvdmVyZmxvdy13cmFwOiBicmVhay13b3JkOyAgLyogQnJlYWsgbG9uZyB3b3JkcyBieSBkZWZhdWx0ICovXFxuICAtd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3I6IHRyYW5zcGFyZW50OyAgLyogRG8gbm90IHNob3cgYSBoaWdobGlnaHQgKHJlY3RhbmdsZSBhcm91bmQgdGhlIGxpbmspIHdoaWxlIHRhcHBpbmcgaXQgKi9cXG59XFxuXFxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXG4gIEhlYWRpbmdzXFxuICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xcblxcbmgxLFxcbmgyLFxcbmgzLFxcbmg0IHtcXG4gIG1hcmdpbjogMC43ZW0gMDtcXG59XFxuXFxuaDEge1xcbiAgQG1peGluIHR5cG9ncmFwaHktaDE7XFxufVxcblxcbmgyIHtcXG4gIEBtaXhpbiB0eXBvZ3JhcGh5LWgyO1xcbn1cXG5cIixcIi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxuICBGb250c1xcbiAgSWYgeW91IGFyZSBnb2luZyB0byBpbmNsdWRlIGN1c3RvbSBmb250cyBwbGVhc2UgdXNlIHRoZSAvd3d3L3NoYXJlZC9tZWRpYS9mb250c1xcbiAgZGlyZWN0b3J5LlxcbiAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cXG5cXG4vKiBzdHlsZWxpbnQtZGlzYWJsZSBzY2FsZS11bmxpbWl0ZWQvZGVjbGFyYXRpb24tc3RyaWN0LXZhbHVlICovXFxuXFxuQGZvbnQtZmFjZSB7XFxuICBmb250LWZhbWlseTogXFxcIkthcmFzdW1hXFxcIjtcXG4gIGZvbnQtd2VpZ2h0OiBub3JtYWw7XFxuICBmb250LXN0eWxlOiBub3JtYWw7XFxuICBmb250LWRpc3BsYXk6IHN3YXA7XFxuICBzcmM6IHVybChcXFwiLi4vLi4vbWVkaWEvZm9udHMva2FyYXN1bWEvS2FyYXN1bWFHb3RoaWMtTWVkaXVtLndvZmYyXFxcIikgZm9ybWF0KFxcXCJ3b2ZmMlxcXCIpO1xcbn1cXG5cXG5AZm9udC1mYWNlIHtcXG4gIGZvbnQtZmFtaWx5OiBcXFwiS2FyYXN1bWFcXFwiO1xcbiAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxuICBmb250LXN0eWxlOiBub3JtYWw7XFxuICBmb250LWRpc3BsYXk6IHN3YXA7XFxuICBzcmM6IHVybChcXFwiLi4vLi4vbWVkaWEvZm9udHMva2FyYXN1bWEvS2FyYXN1bWFHb3RoaWMtQm9sZC53b2ZmMlxcXCIpIGZvcm1hdChcXFwid29mZjJcXFwiKTtcXG59XFxuXFxuQGZvbnQtZmFjZSB7XFxuICBmb250LWZhbWlseTogXFxcIkthcmFzdW1hXFxcIjtcXG4gIGZvbnQtd2VpZ2h0OiA5MDA7XFxuICBmb250LXN0eWxlOiBub3JtYWw7XFxuICBmb250LWRpc3BsYXk6IHN3YXA7XFxuICBzcmM6IHVybChcXFwiLi4vLi4vbWVkaWEvZm9udHMva2FyYXN1bWEvS2FyYXN1bWFHb3RoaWMtQmxhY2sud29mZjJcXFwiKSBmb3JtYXQoXFxcIndvZmYyXFxcIik7XFxufVxcblxcbkBmb250LWZhY2Uge1xcbiAgZm9udC1mYW1pbHk6IFxcXCJLYXJhc3VtYVxcXCI7XFxuICBmb250LXdlaWdodDogOTAwO1xcbiAgZm9udC1zdHlsZTogaXRhbGljO1xcbiAgZm9udC1kaXNwbGF5OiBzd2FwO1xcbiAgc3JjOiB1cmwoXFxcIi4uLy4uL21lZGlhL2ZvbnRzL2thcmFzdW1hL0thcmFzdW1hR290aGljLUJsYWNrSXRhbGljLndvZmYyXFxcIikgZm9ybWF0KFxcXCJ3b2ZmMlxcXCIpO1xcbn1cXG5cXG5AZm9udC1mYWNlIHtcXG4gIGZvbnQtZmFtaWx5OiBcXFwiTGVpa29cXFwiO1xcbiAgZm9udC13ZWlnaHQ6IG5vcm1hbDtcXG4gIGZvbnQtc3R5bGU6IG5vcm1hbDtcXG4gIGZvbnQtZGlzcGxheTogc3dhcDtcXG4gIHNyYzogdXJsKFxcXCIuLi8uLi9tZWRpYS9mb250cy9sZWlrby9MZWlrby1SZWd1bGFyLndvZmYyXFxcIikgZm9ybWF0KFxcXCJ3b2ZmMlxcXCIpO1xcbn1cXG5cIl19XSk7XG4vLyBFeHBvcnRzXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHM7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLypcbiAgTUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcbiAgQXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cbi8vIGNzcyBiYXNlIGNvZGUsIGluamVjdGVkIGJ5IHRoZSBjc3MtbG9hZGVyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodXNlU291cmNlTWFwKSB7XG4gIHZhciBsaXN0ID0gW107IC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcblxuICBsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICB2YXIgY29udGVudCA9IGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKTtcblxuICAgICAgaWYgKGl0ZW1bMl0pIHtcbiAgICAgICAgcmV0dXJuIFwiQG1lZGlhIFwiLmNvbmNhdChpdGVtWzJdLCBcIiB7XCIpLmNvbmNhdChjb250ZW50LCBcIn1cIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb250ZW50O1xuICAgIH0pLmpvaW4oJycpO1xuICB9OyAvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuXG5cbiAgbGlzdC5pID0gZnVuY3Rpb24gKG1vZHVsZXMsIG1lZGlhUXVlcnksIGRlZHVwZSkge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgbW9kdWxlcyA9IFtbbnVsbCwgbW9kdWxlcywgJyddXTtcbiAgICB9XG5cbiAgICB2YXIgYWxyZWFkeUltcG9ydGVkTW9kdWxlcyA9IHt9O1xuXG4gICAgaWYgKGRlZHVwZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItZGVzdHJ1Y3R1cmluZ1xuICAgICAgICB2YXIgaWQgPSB0aGlzW2ldWzBdO1xuXG4gICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG1vZHVsZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgaXRlbSA9IFtdLmNvbmNhdChtb2R1bGVzW19pXSk7XG5cbiAgICAgIGlmIChkZWR1cGUgJiYgYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udGludWVcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChtZWRpYVF1ZXJ5KSB7XG4gICAgICAgIGlmICghaXRlbVsyXSkge1xuICAgICAgICAgIGl0ZW1bMl0gPSBtZWRpYVF1ZXJ5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZW1bMl0gPSBcIlwiLmNvbmNhdChtZWRpYVF1ZXJ5LCBcIiBhbmQgXCIpLmNvbmNhdChpdGVtWzJdKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsaXN0LnB1c2goaXRlbSk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBsaXN0O1xufTtcblxuZnVuY3Rpb24gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApIHtcbiAgdmFyIGNvbnRlbnQgPSBpdGVtWzFdIHx8ICcnOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWRlc3RydWN0dXJpbmdcblxuICB2YXIgY3NzTWFwcGluZyA9IGl0ZW1bM107XG5cbiAgaWYgKCFjc3NNYXBwaW5nKSB7XG4gICAgcmV0dXJuIGNvbnRlbnQ7XG4gIH1cblxuICBpZiAodXNlU291cmNlTWFwICYmIHR5cGVvZiBidG9hID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIHNvdXJjZU1hcHBpbmcgPSB0b0NvbW1lbnQoY3NzTWFwcGluZyk7XG4gICAgdmFyIHNvdXJjZVVSTHMgPSBjc3NNYXBwaW5nLnNvdXJjZXMubWFwKGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgIHJldHVybiBcIi8qIyBzb3VyY2VVUkw9XCIuY29uY2F0KGNzc01hcHBpbmcuc291cmNlUm9vdCB8fCAnJykuY29uY2F0KHNvdXJjZSwgXCIgKi9cIik7XG4gICAgfSk7XG4gICAgcmV0dXJuIFtjb250ZW50XS5jb25jYXQoc291cmNlVVJMcykuY29uY2F0KFtzb3VyY2VNYXBwaW5nXSkuam9pbignXFxuJyk7XG4gIH1cblxuICByZXR1cm4gW2NvbnRlbnRdLmpvaW4oJ1xcbicpO1xufSAvLyBBZGFwdGVkIGZyb20gY29udmVydC1zb3VyY2UtbWFwIChNSVQpXG5cblxuZnVuY3Rpb24gdG9Db21tZW50KHNvdXJjZU1hcCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgdmFyIGJhc2U2NCA9IGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSk7XG4gIHZhciBkYXRhID0gXCJzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxcIi5jb25jYXQoYmFzZTY0KTtcbiAgcmV0dXJuIFwiLyojIFwiLmNvbmNhdChkYXRhLCBcIiAqL1wiKTtcbn0iLCIvKiFcbiAgQ29weXJpZ2h0IChjKSAyMDE1IEplZCBXYXRzb24uXG4gIEJhc2VkIG9uIGNvZGUgdGhhdCBpcyBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKi9cbi8qIGdsb2JhbCBkZWZpbmUgKi9cblxuKGZ1bmN0aW9uICgpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdHZhciBjYW5Vc2VET00gPSAhIShcblx0XHR0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuXHRcdHdpbmRvdy5kb2N1bWVudCAmJlxuXHRcdHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50XG5cdCk7XG5cblx0dmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0ge1xuXG5cdFx0Y2FuVXNlRE9NOiBjYW5Vc2VET00sXG5cblx0XHRjYW5Vc2VXb3JrZXJzOiB0eXBlb2YgV29ya2VyICE9PSAndW5kZWZpbmVkJyxcblxuXHRcdGNhblVzZUV2ZW50TGlzdGVuZXJzOlxuXHRcdFx0Y2FuVXNlRE9NICYmICEhKHdpbmRvdy5hZGRFdmVudExpc3RlbmVyIHx8IHdpbmRvdy5hdHRhY2hFdmVudCksXG5cblx0XHRjYW5Vc2VWaWV3cG9ydDogY2FuVXNlRE9NICYmICEhd2luZG93LnNjcmVlblxuXG5cdH07XG5cblx0aWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGRlZmluZS5hbWQgPT09ICdvYmplY3QnICYmIGRlZmluZS5hbWQpIHtcblx0XHRkZWZpbmUoZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIEV4ZWN1dGlvbkVudmlyb25tZW50O1xuXHRcdH0pO1xuXHR9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBFeGVjdXRpb25FbnZpcm9ubWVudDtcblx0fSBlbHNlIHtcblx0XHR3aW5kb3cuRXhlY3V0aW9uRW52aXJvbm1lbnQgPSBFeGVjdXRpb25FbnZpcm9ubWVudDtcblx0fVxuXG59KCkpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKiBlc2xpbnQgbm8taW52YWxpZC10aGlzOiAxICovXG5cbnZhciBFUlJPUl9NRVNTQUdFID0gJ0Z1bmN0aW9uLnByb3RvdHlwZS5iaW5kIGNhbGxlZCBvbiBpbmNvbXBhdGlibGUgJztcbnZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbnZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgZnVuY1R5cGUgPSAnW29iamVjdCBGdW5jdGlvbl0nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJpbmQodGhhdCkge1xuICAgIHZhciB0YXJnZXQgPSB0aGlzO1xuICAgIGlmICh0eXBlb2YgdGFyZ2V0ICE9PSAnZnVuY3Rpb24nIHx8IHRvU3RyLmNhbGwodGFyZ2V0KSAhPT0gZnVuY1R5cGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihFUlJPUl9NRVNTQUdFICsgdGFyZ2V0KTtcbiAgICB9XG4gICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cbiAgICB2YXIgYm91bmQ7XG4gICAgdmFyIGJpbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBib3VuZCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRhcmdldC5hcHBseShcbiAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgIGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoT2JqZWN0KHJlc3VsdCkgPT09IHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQuYXBwbHkoXG4gICAgICAgICAgICAgICAgdGhhdCxcbiAgICAgICAgICAgICAgICBhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBib3VuZExlbmd0aCA9IE1hdGgubWF4KDAsIHRhcmdldC5sZW5ndGggLSBhcmdzLmxlbmd0aCk7XG4gICAgdmFyIGJvdW5kQXJncyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm91bmRMZW5ndGg7IGkrKykge1xuICAgICAgICBib3VuZEFyZ3MucHVzaCgnJCcgKyBpKTtcbiAgICB9XG5cbiAgICBib3VuZCA9IEZ1bmN0aW9uKCdiaW5kZXInLCAncmV0dXJuIGZ1bmN0aW9uICgnICsgYm91bmRBcmdzLmpvaW4oJywnKSArICcpeyByZXR1cm4gYmluZGVyLmFwcGx5KHRoaXMsYXJndW1lbnRzKTsgfScpKGJpbmRlcik7XG5cbiAgICBpZiAodGFyZ2V0LnByb3RvdHlwZSkge1xuICAgICAgICB2YXIgRW1wdHkgPSBmdW5jdGlvbiBFbXB0eSgpIHt9O1xuICAgICAgICBFbXB0eS5wcm90b3R5cGUgPSB0YXJnZXQucHJvdG90eXBlO1xuICAgICAgICBib3VuZC5wcm90b3R5cGUgPSBuZXcgRW1wdHkoKTtcbiAgICAgICAgRW1wdHkucHJvdG90eXBlID0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gYm91bmQ7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW1wbGVtZW50YXRpb24gPSByZXF1aXJlKCcuL2ltcGxlbWVudGF0aW9uJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgfHwgaW1wbGVtZW50YXRpb247XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBiaW5kID0gcmVxdWlyZSgnZnVuY3Rpb24tYmluZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJpbmQuY2FsbChGdW5jdGlvbi5jYWxsLCBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KTtcbiIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBTeW1ib2wgPSByb290LlN5bWJvbDtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW1ib2w7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNsYW1wYCB3aGljaCBkb2Vzbid0IGNvZXJjZSBhcmd1bWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXIgVGhlIG51bWJlciB0byBjbGFtcC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbG93ZXJdIFRoZSBsb3dlciBib3VuZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB1cHBlciBUaGUgdXBwZXIgYm91bmQuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjbGFtcGVkIG51bWJlci5cbiAqL1xuZnVuY3Rpb24gYmFzZUNsYW1wKG51bWJlciwgbG93ZXIsIHVwcGVyKSB7XG4gIGlmIChudW1iZXIgPT09IG51bWJlcikge1xuICAgIGlmICh1cHBlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBudW1iZXIgPSBudW1iZXIgPD0gdXBwZXIgPyBudW1iZXIgOiB1cHBlcjtcbiAgICB9XG4gICAgaWYgKGxvd2VyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIG51bWJlciA9IG51bWJlciA+PSBsb3dlciA/IG51bWJlciA6IGxvd2VyO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVtYmVyO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VDbGFtcDtcbiIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKSxcbiAgICBnZXRSYXdUYWcgPSByZXF1aXJlKCcuL19nZXRSYXdUYWcnKSxcbiAgICBvYmplY3RUb1N0cmluZyA9IHJlcXVpcmUoJy4vX29iamVjdFRvU3RyaW5nJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBudWxsVGFnID0gJ1tvYmplY3QgTnVsbF0nLFxuICAgIHVuZGVmaW5lZFRhZyA9ICdbb2JqZWN0IFVuZGVmaW5lZF0nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0VGFnYCB3aXRob3V0IGZhbGxiYWNrcyBmb3IgYnVnZ3kgZW52aXJvbm1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXRUYWcodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZFRhZyA6IG51bGxUYWc7XG4gIH1cbiAgcmV0dXJuIChzeW1Ub1N0cmluZ1RhZyAmJiBzeW1Ub1N0cmluZ1RhZyBpbiBPYmplY3QodmFsdWUpKVxuICAgID8gZ2V0UmF3VGFnKHZhbHVlKVxuICAgIDogb2JqZWN0VG9TdHJpbmcodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VHZXRUYWc7XG4iLCIvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZyZWVHbG9iYWw7XG4iLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VHZXRUYWdgIHdoaWNoIGlnbm9yZXMgYFN5bWJvbC50b1N0cmluZ1RhZ2AgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJhdyBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBnZXRSYXdUYWcodmFsdWUpIHtcbiAgdmFyIGlzT3duID0gaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgc3ltVG9TdHJpbmdUYWcpLFxuICAgICAgdGFnID0gdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuXG4gIHRyeSB7XG4gICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdW5kZWZpbmVkO1xuICAgIHZhciB1bm1hc2tlZCA9IHRydWU7XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgdmFyIHJlc3VsdCA9IG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICBpZiAodW5tYXNrZWQpIHtcbiAgICBpZiAoaXNPd24pIHtcbiAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHRhZztcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRSYXdUYWc7XG4iLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIHVzaW5nIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvYmplY3RUb1N0cmluZztcbiIsInZhciBmcmVlR2xvYmFsID0gcmVxdWlyZSgnLi9fZnJlZUdsb2JhbCcpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gcm9vdDtcbiIsInZhciBiYXNlQ2xhbXAgPSByZXF1aXJlKCcuL19iYXNlQ2xhbXAnKSxcbiAgICB0b051bWJlciA9IHJlcXVpcmUoJy4vdG9OdW1iZXInKTtcblxuLyoqXG4gKiBDbGFtcHMgYG51bWJlcmAgd2l0aGluIHRoZSBpbmNsdXNpdmUgYGxvd2VyYCBhbmQgYHVwcGVyYCBib3VuZHMuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IE51bWJlclxuICogQHBhcmFtIHtudW1iZXJ9IG51bWJlciBUaGUgbnVtYmVyIHRvIGNsYW1wLlxuICogQHBhcmFtIHtudW1iZXJ9IFtsb3dlcl0gVGhlIGxvd2VyIGJvdW5kLlxuICogQHBhcmFtIHtudW1iZXJ9IHVwcGVyIFRoZSB1cHBlciBib3VuZC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNsYW1wZWQgbnVtYmVyLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmNsYW1wKC0xMCwgLTUsIDUpO1xuICogLy8gPT4gLTVcbiAqXG4gKiBfLmNsYW1wKDEwLCAtNSwgNSk7XG4gKiAvLyA9PiA1XG4gKi9cbmZ1bmN0aW9uIGNsYW1wKG51bWJlciwgbG93ZXIsIHVwcGVyKSB7XG4gIGlmICh1cHBlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdXBwZXIgPSBsb3dlcjtcbiAgICBsb3dlciA9IHVuZGVmaW5lZDtcbiAgfVxuICBpZiAodXBwZXIgIT09IHVuZGVmaW5lZCkge1xuICAgIHVwcGVyID0gdG9OdW1iZXIodXBwZXIpO1xuICAgIHVwcGVyID0gdXBwZXIgPT09IHVwcGVyID8gdXBwZXIgOiAwO1xuICB9XG4gIGlmIChsb3dlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgbG93ZXIgPSB0b051bWJlcihsb3dlcik7XG4gICAgbG93ZXIgPSBsb3dlciA9PT0gbG93ZXIgPyBsb3dlciA6IDA7XG4gIH1cbiAgcmV0dXJuIGJhc2VDbGFtcCh0b051bWJlcihudW1iZXIpLCBsb3dlciwgdXBwZXIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYW1wO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNPYmplY3Q7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc09iamVjdExpa2U7XG4iLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTeW1ib2xgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzeW1ib2wsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1N5bWJvbChTeW1ib2wuaXRlcmF0b3IpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTeW1ib2woJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3ltYm9sJyB8fFxuICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IHN5bWJvbFRhZyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNTeW1ib2w7XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAgaXNTeW1ib2wgPSByZXF1aXJlKCcuL2lzU3ltYm9sJyk7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE5BTiA9IDAgLyAwO1xuXG4vKiogVXNlZCB0byBtYXRjaCBsZWFkaW5nIGFuZCB0cmFpbGluZyB3aGl0ZXNwYWNlLiAqL1xudmFyIHJlVHJpbSA9IC9eXFxzK3xcXHMrJC9nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgYmFkIHNpZ25lZCBoZXhhZGVjaW1hbCBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNCYWRIZXggPSAvXlstK10weFswLTlhLWZdKyQvaTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGJpbmFyeSBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNCaW5hcnkgPSAvXjBiWzAxXSskL2k7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBvY3RhbCBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNPY3RhbCA9IC9eMG9bMC03XSskL2k7XG5cbi8qKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB3aXRob3V0IGEgZGVwZW5kZW5jeSBvbiBgcm9vdGAuICovXG52YXIgZnJlZVBhcnNlSW50ID0gcGFyc2VJbnQ7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIG51bWJlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG51bWJlci5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b051bWJlcigzLjIpO1xuICogLy8gPT4gMy4yXG4gKlxuICogXy50b051bWJlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IDVlLTMyNFxuICpcbiAqIF8udG9OdW1iZXIoSW5maW5pdHkpO1xuICogLy8gPT4gSW5maW5pdHlcbiAqXG4gKiBfLnRvTnVtYmVyKCczLjInKTtcbiAqIC8vID0+IDMuMlxuICovXG5mdW5jdGlvbiB0b051bWJlcih2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gTkFOO1xuICB9XG4gIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICB2YXIgb3RoZXIgPSB0eXBlb2YgdmFsdWUudmFsdWVPZiA9PSAnZnVuY3Rpb24nID8gdmFsdWUudmFsdWVPZigpIDogdmFsdWU7XG4gICAgdmFsdWUgPSBpc09iamVjdChvdGhlcikgPyAob3RoZXIgKyAnJykgOiBvdGhlcjtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSAwID8gdmFsdWUgOiArdmFsdWU7XG4gIH1cbiAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKHJlVHJpbSwgJycpO1xuICB2YXIgaXNCaW5hcnkgPSByZUlzQmluYXJ5LnRlc3QodmFsdWUpO1xuICByZXR1cm4gKGlzQmluYXJ5IHx8IHJlSXNPY3RhbC50ZXN0KHZhbHVlKSlcbiAgICA/IGZyZWVQYXJzZUludCh2YWx1ZS5zbGljZSgyKSwgaXNCaW5hcnkgPyAyIDogOClcbiAgICA6IChyZUlzQmFkSGV4LnRlc3QodmFsdWUpID8gTkFOIDogK3ZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b051bWJlcjtcbiIsIlwidXNlIHN0cmljdFwiO3ZhciBhc3NpZ249T2JqZWN0LmFzc2lnbi5iaW5kKE9iamVjdCk7bW9kdWxlLmV4cG9ydHM9YXNzaWduO21vZHVsZS5leHBvcnRzLmRlZmF1bHQ9bW9kdWxlLmV4cG9ydHM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vYmplY3QtYXNzaWduLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO3ZhciBhc3NpZ249T2JqZWN0LmFzc2lnbi5iaW5kKE9iamVjdCk7ZnVuY3Rpb24gZygpe3JldHVybiBhc3NpZ247fU9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGcoKSx7aW1wbGVtZW50YXRpb246e2dldDpnfSxzaGltOnt2YWx1ZTpnfSxnZXRQb2x5ZmlsbDp7dmFsdWU6Z319KTttb2R1bGUuZXhwb3J0cz1nKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcbiAgICAod2luZG93Ll9fTkVYVF9QID0gd2luZG93Ll9fTkVYVF9QIHx8IFtdKS5wdXNoKFtcbiAgICAgIFwiL19hcHBcIixcbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHJlcXVpcmUoXCJwcml2YXRlLW5leHQtcGFnZXMvX2FwcC5qc1wiKTtcbiAgICAgIH1cbiAgICBdKTtcbiAgIiwiaW1wb3J0IFJlYWN0LCB7IENoaWxkcmVuIH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgeyBVcmxPYmplY3QgfSBmcm9tICd1cmwnXG5pbXBvcnQge1xuICBQcmVmZXRjaE9wdGlvbnMsXG4gIE5leHRSb3V0ZXIsXG4gIGlzTG9jYWxVUkwsXG59IGZyb20gJy4uL25leHQtc2VydmVyL2xpYi9yb3V0ZXIvcm91dGVyJ1xuaW1wb3J0IHsgZXhlY09uY2UgfSBmcm9tICcuLi9uZXh0LXNlcnZlci9saWIvdXRpbHMnXG5pbXBvcnQgeyB1c2VSb3V0ZXIgfSBmcm9tICcuL3JvdXRlcidcbmltcG9ydCB7IGFkZEJhc2VQYXRoLCByZXNvbHZlSHJlZiB9IGZyb20gJy4uL25leHQtc2VydmVyL2xpYi9yb3V0ZXIvcm91dGVyJ1xuXG50eXBlIFVybCA9IHN0cmluZyB8IFVybE9iamVjdFxuXG5leHBvcnQgdHlwZSBMaW5rUHJvcHMgPSB7XG4gIGhyZWY6IFVybFxuICBhcz86IFVybFxuICByZXBsYWNlPzogYm9vbGVhblxuICBzY3JvbGw/OiBib29sZWFuXG4gIHNoYWxsb3c/OiBib29sZWFuXG4gIHBhc3NIcmVmPzogYm9vbGVhblxuICBwcmVmZXRjaD86IGJvb2xlYW5cbn1cblxubGV0IGNhY2hlZE9ic2VydmVyOiBJbnRlcnNlY3Rpb25PYnNlcnZlclxuY29uc3QgbGlzdGVuZXJzID0gbmV3IE1hcDxFbGVtZW50LCAoKSA9PiB2b2lkPigpXG5jb25zdCBJbnRlcnNlY3Rpb25PYnNlcnZlciA9XG4gIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93LkludGVyc2VjdGlvbk9ic2VydmVyIDogbnVsbFxuY29uc3QgcHJlZmV0Y2hlZDogeyBbY2FjaGVLZXk6IHN0cmluZ106IGJvb2xlYW4gfSA9IHt9XG5cbmZ1bmN0aW9uIGdldE9ic2VydmVyKCk6IEludGVyc2VjdGlvbk9ic2VydmVyIHwgdW5kZWZpbmVkIHtcbiAgLy8gUmV0dXJuIHNoYXJlZCBpbnN0YW5jZSBvZiBJbnRlcnNlY3Rpb25PYnNlcnZlciBpZiBhbHJlYWR5IGNyZWF0ZWRcbiAgaWYgKGNhY2hlZE9ic2VydmVyKSB7XG4gICAgcmV0dXJuIGNhY2hlZE9ic2VydmVyXG4gIH1cblxuICAvLyBPbmx5IGNyZWF0ZSBzaGFyZWQgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgaWYgc3VwcG9ydGVkIGluIGJyb3dzZXJcbiAgaWYgKCFJbnRlcnNlY3Rpb25PYnNlcnZlcikge1xuICAgIHJldHVybiB1bmRlZmluZWRcbiAgfVxuXG4gIHJldHVybiAoY2FjaGVkT2JzZXJ2ZXIgPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoXG4gICAgKGVudHJpZXMpID0+IHtcbiAgICAgIGVudHJpZXMuZm9yRWFjaCgoZW50cnkpID0+IHtcbiAgICAgICAgaWYgKCFsaXN0ZW5lcnMuaGFzKGVudHJ5LnRhcmdldCkpIHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNiID0gbGlzdGVuZXJzLmdldChlbnRyeS50YXJnZXQpIVxuICAgICAgICBpZiAoZW50cnkuaXNJbnRlcnNlY3RpbmcgfHwgZW50cnkuaW50ZXJzZWN0aW9uUmF0aW8gPiAwKSB7XG4gICAgICAgICAgY2FjaGVkT2JzZXJ2ZXIudW5vYnNlcnZlKGVudHJ5LnRhcmdldClcbiAgICAgICAgICBsaXN0ZW5lcnMuZGVsZXRlKGVudHJ5LnRhcmdldClcbiAgICAgICAgICBjYigpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSxcbiAgICB7IHJvb3RNYXJnaW46ICcyMDBweCcgfVxuICApKVxufVxuXG5jb25zdCBsaXN0ZW5Ub0ludGVyc2VjdGlvbnMgPSAoZWw6IEVsZW1lbnQsIGNiOiAoKSA9PiB2b2lkKSA9PiB7XG4gIGNvbnN0IG9ic2VydmVyID0gZ2V0T2JzZXJ2ZXIoKVxuICBpZiAoIW9ic2VydmVyKSB7XG4gICAgcmV0dXJuICgpID0+IHt9XG4gIH1cblxuICBvYnNlcnZlci5vYnNlcnZlKGVsKVxuICBsaXN0ZW5lcnMuc2V0KGVsLCBjYilcbiAgcmV0dXJuICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgb2JzZXJ2ZXIudW5vYnNlcnZlKGVsKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5lcnJvcihlcnIpXG4gICAgfVxuICAgIGxpc3RlbmVycy5kZWxldGUoZWwpXG4gIH1cbn1cblxuZnVuY3Rpb24gcHJlZmV0Y2goXG4gIHJvdXRlcjogTmV4dFJvdXRlcixcbiAgaHJlZjogc3RyaW5nLFxuICBhczogc3RyaW5nLFxuICBvcHRpb25zPzogUHJlZmV0Y2hPcHRpb25zXG4pOiB2b2lkIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm5cbiAgaWYgKCFpc0xvY2FsVVJMKGhyZWYpKSByZXR1cm5cbiAgLy8gUHJlZmV0Y2ggdGhlIEpTT04gcGFnZSBpZiBhc2tlZCAob25seSBpbiB0aGUgY2xpZW50KVxuICAvLyBXZSBuZWVkIHRvIGhhbmRsZSBhIHByZWZldGNoIGVycm9yIGhlcmUgc2luY2Ugd2UgbWF5IGJlXG4gIC8vIGxvYWRpbmcgd2l0aCBwcmlvcml0eSB3aGljaCBjYW4gcmVqZWN0IGJ1dCB3ZSBkb24ndFxuICAvLyB3YW50IHRvIGZvcmNlIG5hdmlnYXRpb24gc2luY2UgdGhpcyBpcyBvbmx5IGEgcHJlZmV0Y2hcbiAgcm91dGVyLnByZWZldGNoKGhyZWYsIGFzLCBvcHRpb25zKS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIC8vIHJldGhyb3cgdG8gc2hvdyBpbnZhbGlkIFVSTCBlcnJvcnNcbiAgICAgIHRocm93IGVyclxuICAgIH1cbiAgfSlcbiAgLy8gSm9pbiBvbiBhbiBpbnZhbGlkIFVSSSBjaGFyYWN0ZXJcbiAgcHJlZmV0Y2hlZFtocmVmICsgJyUnICsgYXNdID0gdHJ1ZVxufVxuXG5mdW5jdGlvbiBpc01vZGlmaWVkRXZlbnQoZXZlbnQ6IFJlYWN0Lk1vdXNlRXZlbnQpIHtcbiAgY29uc3QgeyB0YXJnZXQgfSA9IGV2ZW50LmN1cnJlbnRUYXJnZXQgYXMgSFRNTEFuY2hvckVsZW1lbnRcbiAgcmV0dXJuIChcbiAgICAodGFyZ2V0ICYmIHRhcmdldCAhPT0gJ19zZWxmJykgfHxcbiAgICBldmVudC5tZXRhS2V5IHx8XG4gICAgZXZlbnQuY3RybEtleSB8fFxuICAgIGV2ZW50LnNoaWZ0S2V5IHx8XG4gICAgZXZlbnQuYWx0S2V5IHx8IC8vIHRyaWdnZXJzIHJlc291cmNlIGRvd25sb2FkXG4gICAgKGV2ZW50Lm5hdGl2ZUV2ZW50ICYmIGV2ZW50Lm5hdGl2ZUV2ZW50LndoaWNoID09PSAyKVxuICApXG59XG5cbmZ1bmN0aW9uIGxpbmtDbGlja2VkKFxuICBlOiBSZWFjdC5Nb3VzZUV2ZW50LFxuICByb3V0ZXI6IE5leHRSb3V0ZXIsXG4gIGhyZWY6IHN0cmluZyxcbiAgYXM6IHN0cmluZyxcbiAgcmVwbGFjZT86IGJvb2xlYW4sXG4gIHNoYWxsb3c/OiBib29sZWFuLFxuICBzY3JvbGw/OiBib29sZWFuXG4pOiB2b2lkIHtcbiAgY29uc3QgeyBub2RlTmFtZSB9ID0gZS5jdXJyZW50VGFyZ2V0XG5cbiAgaWYgKG5vZGVOYW1lID09PSAnQScgJiYgKGlzTW9kaWZpZWRFdmVudChlKSB8fCAhaXNMb2NhbFVSTChocmVmKSkpIHtcbiAgICAvLyBpZ25vcmUgY2xpY2sgZm9yIGJyb3dzZXLigJlzIGRlZmF1bHQgYmVoYXZpb3JcbiAgICByZXR1cm5cbiAgfVxuXG4gIGUucHJldmVudERlZmF1bHQoKVxuXG4gIC8vICBhdm9pZCBzY3JvbGwgZm9yIHVybHMgd2l0aCBhbmNob3IgcmVmc1xuICBpZiAoc2Nyb2xsID09IG51bGwpIHtcbiAgICBzY3JvbGwgPSBhcy5pbmRleE9mKCcjJykgPCAwXG4gIH1cblxuICAvLyByZXBsYWNlIHN0YXRlIGluc3RlYWQgb2YgcHVzaCBpZiBwcm9wIGlzIHByZXNlbnRcbiAgcm91dGVyW3JlcGxhY2UgPyAncmVwbGFjZScgOiAncHVzaCddKGhyZWYsIGFzLCB7IHNoYWxsb3cgfSkudGhlbihcbiAgICAoc3VjY2VzczogYm9vbGVhbikgPT4ge1xuICAgICAgaWYgKCFzdWNjZXNzKSByZXR1cm5cbiAgICAgIGlmIChzY3JvbGwpIHtcbiAgICAgICAgd2luZG93LnNjcm9sbFRvKDAsIDApXG4gICAgICAgIGRvY3VtZW50LmJvZHkuZm9jdXMoKVxuICAgICAgfVxuICAgIH1cbiAgKVxufVxuXG5mdW5jdGlvbiBMaW5rKHByb3BzOiBSZWFjdC5Qcm9wc1dpdGhDaGlsZHJlbjxMaW5rUHJvcHM+KSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgLy8gVGhpcyBob29rIGlzIGluIGEgY29uZGl0aW9uYWwgYnV0IHRoYXQgaXMgb2sgYmVjYXVzZSBgcHJvY2Vzcy5lbnYuTk9ERV9FTlZgIG5ldmVyIGNoYW5nZXNcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcbiAgICBjb25zdCBoYXNXYXJuZWQgPSBSZWFjdC51c2VSZWYoZmFsc2UpXG4gICAgaWYgKHByb3BzLnByZWZldGNoICYmICFoYXNXYXJuZWQuY3VycmVudCkge1xuICAgICAgaGFzV2FybmVkLmN1cnJlbnQgPSB0cnVlXG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICdOZXh0LmpzIGF1dG8tcHJlZmV0Y2hlcyBhdXRvbWF0aWNhbGx5IGJhc2VkIG9uIHZpZXdwb3J0LiBUaGUgcHJlZmV0Y2ggYXR0cmlidXRlIGlzIG5vIGxvbmdlciBuZWVkZWQuIE1vcmU6IGh0dHBzOi8vZXJyLnNoL3ZlcmNlbC9uZXh0LmpzL3ByZWZldGNoLXRydWUtZGVwcmVjYXRlZCdcbiAgICAgIClcbiAgICB9XG4gIH1cbiAgY29uc3QgcCA9IHByb3BzLnByZWZldGNoICE9PSBmYWxzZVxuXG4gIGNvbnN0IFtjaGlsZEVsbSwgc2V0Q2hpbGRFbG1dID0gUmVhY3QudXNlU3RhdGU8RWxlbWVudD4oKVxuXG4gIGNvbnN0IHJvdXRlciA9IHVzZVJvdXRlcigpXG4gIGNvbnN0IHBhdGhuYW1lID0gKHJvdXRlciAmJiByb3V0ZXIucGF0aG5hbWUpIHx8ICcvJ1xuXG4gIGNvbnN0IHsgaHJlZiwgYXMgfSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIGNvbnN0IHJlc29sdmVkSHJlZiA9IHJlc29sdmVIcmVmKHBhdGhuYW1lLCBwcm9wcy5ocmVmKVxuICAgIHJldHVybiB7XG4gICAgICBocmVmOiByZXNvbHZlZEhyZWYsXG4gICAgICBhczogcHJvcHMuYXMgPyByZXNvbHZlSHJlZihwYXRobmFtZSwgcHJvcHMuYXMpIDogcmVzb2x2ZWRIcmVmLFxuICAgIH1cbiAgfSwgW3BhdGhuYW1lLCBwcm9wcy5ocmVmLCBwcm9wcy5hc10pXG5cbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoXG4gICAgICBwICYmXG4gICAgICBJbnRlcnNlY3Rpb25PYnNlcnZlciAmJlxuICAgICAgY2hpbGRFbG0gJiZcbiAgICAgIGNoaWxkRWxtLnRhZ05hbWUgJiZcbiAgICAgIGlzTG9jYWxVUkwoaHJlZilcbiAgICApIHtcbiAgICAgIC8vIEpvaW4gb24gYW4gaW52YWxpZCBVUkkgY2hhcmFjdGVyXG4gICAgICBjb25zdCBpc1ByZWZldGNoZWQgPSBwcmVmZXRjaGVkW2hyZWYgKyAnJScgKyBhc11cbiAgICAgIGlmICghaXNQcmVmZXRjaGVkKSB7XG4gICAgICAgIHJldHVybiBsaXN0ZW5Ub0ludGVyc2VjdGlvbnMoY2hpbGRFbG0sICgpID0+IHtcbiAgICAgICAgICBwcmVmZXRjaChyb3V0ZXIsIGhyZWYsIGFzKVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cbiAgfSwgW3AsIGNoaWxkRWxtLCBocmVmLCBhcywgcm91dGVyXSlcblxuICBsZXQgeyBjaGlsZHJlbiwgcmVwbGFjZSwgc2hhbGxvdywgc2Nyb2xsIH0gPSBwcm9wc1xuICAvLyBEZXByZWNhdGVkLiBXYXJuaW5nIHNob3duIGJ5IHByb3BUeXBlIGNoZWNrLiBJZiB0aGUgY2hpbGRyZW4gcHJvdmlkZWQgaXMgYSBzdHJpbmcgKDxMaW5rPmV4YW1wbGU8L0xpbms+KSB3ZSB3cmFwIGl0IGluIGFuIDxhPiB0YWdcbiAgaWYgKHR5cGVvZiBjaGlsZHJlbiA9PT0gJ3N0cmluZycpIHtcbiAgICBjaGlsZHJlbiA9IDxhPntjaGlsZHJlbn08L2E+XG4gIH1cblxuICAvLyBUaGlzIHdpbGwgcmV0dXJuIHRoZSBmaXJzdCBjaGlsZCwgaWYgbXVsdGlwbGUgYXJlIHByb3ZpZGVkIGl0IHdpbGwgdGhyb3cgYW4gZXJyb3JcbiAgY29uc3QgY2hpbGQ6IGFueSA9IENoaWxkcmVuLm9ubHkoY2hpbGRyZW4pXG4gIGNvbnN0IGNoaWxkUHJvcHM6IHtcbiAgICBvbk1vdXNlRW50ZXI/OiBSZWFjdC5Nb3VzZUV2ZW50SGFuZGxlclxuICAgIG9uQ2xpY2s6IFJlYWN0Lk1vdXNlRXZlbnRIYW5kbGVyXG4gICAgaHJlZj86IHN0cmluZ1xuICAgIHJlZj86IGFueVxuICB9ID0ge1xuICAgIHJlZjogKGVsOiBhbnkpID0+IHtcbiAgICAgIGlmIChlbCkgc2V0Q2hpbGRFbG0oZWwpXG5cbiAgICAgIGlmIChjaGlsZCAmJiB0eXBlb2YgY2hpbGQgPT09ICdvYmplY3QnICYmIGNoaWxkLnJlZikge1xuICAgICAgICBpZiAodHlwZW9mIGNoaWxkLnJlZiA9PT0gJ2Z1bmN0aW9uJykgY2hpbGQucmVmKGVsKVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgY2hpbGQucmVmID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIGNoaWxkLnJlZi5jdXJyZW50ID0gZWxcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgb25DbGljazogKGU6IFJlYWN0Lk1vdXNlRXZlbnQpID0+IHtcbiAgICAgIGlmIChjaGlsZC5wcm9wcyAmJiB0eXBlb2YgY2hpbGQucHJvcHMub25DbGljayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjaGlsZC5wcm9wcy5vbkNsaWNrKGUpXG4gICAgICB9XG4gICAgICBpZiAoIWUuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICBsaW5rQ2xpY2tlZChlLCByb3V0ZXIsIGhyZWYsIGFzLCByZXBsYWNlLCBzaGFsbG93LCBzY3JvbGwpXG4gICAgICB9XG4gICAgfSxcbiAgfVxuXG4gIGlmIChwKSB7XG4gICAgY2hpbGRQcm9wcy5vbk1vdXNlRW50ZXIgPSAoZTogUmVhY3QuTW91c2VFdmVudCkgPT4ge1xuICAgICAgaWYgKCFpc0xvY2FsVVJMKGhyZWYpKSByZXR1cm5cbiAgICAgIGlmIChjaGlsZC5wcm9wcyAmJiB0eXBlb2YgY2hpbGQucHJvcHMub25Nb3VzZUVudGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNoaWxkLnByb3BzLm9uTW91c2VFbnRlcihlKVxuICAgICAgfVxuICAgICAgcHJlZmV0Y2gocm91dGVyLCBocmVmLCBhcywgeyBwcmlvcml0eTogdHJ1ZSB9KVxuICAgIH1cbiAgfVxuXG4gIC8vIElmIGNoaWxkIGlzIGFuIDxhPiB0YWcgYW5kIGRvZXNuJ3QgaGF2ZSBhIGhyZWYgYXR0cmlidXRlLCBvciBpZiB0aGUgJ3Bhc3NIcmVmJyBwcm9wZXJ0eSBpc1xuICAvLyBkZWZpbmVkLCB3ZSBzcGVjaWZ5IHRoZSBjdXJyZW50ICdocmVmJywgc28gdGhhdCByZXBldGl0aW9uIGlzIG5vdCBuZWVkZWQgYnkgdGhlIHVzZXJcbiAgaWYgKHByb3BzLnBhc3NIcmVmIHx8IChjaGlsZC50eXBlID09PSAnYScgJiYgISgnaHJlZicgaW4gY2hpbGQucHJvcHMpKSkge1xuICAgIGNoaWxkUHJvcHMuaHJlZiA9IGFkZEJhc2VQYXRoKGFzKVxuICB9XG5cbiAgcmV0dXJuIFJlYWN0LmNsb25lRWxlbWVudChjaGlsZCwgY2hpbGRQcm9wcylcbn1cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gIGNvbnN0IHdhcm4gPSBleGVjT25jZShjb25zb2xlLmVycm9yKVxuXG4gIC8vIFRoaXMgbW9kdWxlIGdldHMgcmVtb3ZlZCBieSB3ZWJwYWNrLklnbm9yZVBsdWdpblxuICBjb25zdCBQcm9wVHlwZXMgPSByZXF1aXJlKCdwcm9wLXR5cGVzJylcbiAgY29uc3QgZXhhY3QgPSByZXF1aXJlKCdwcm9wLXR5cGVzLWV4YWN0JylcbiAgLy8gQHRzLWlnbm9yZSB0aGUgcHJvcGVydHkgaXMgc3VwcG9ydGVkLCB3aGVuIGRlY2xhcmluZyBpdCBvbiB0aGUgY2xhc3MgaXQgb3V0cHV0cyBhbiBleHRyYSBiaXQgb2YgY29kZSB3aGljaCBpcyBub3QgbmVlZGVkLlxuICBMaW5rLnByb3BUeXBlcyA9IGV4YWN0KHtcbiAgICBocmVmOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMub2JqZWN0XSkuaXNSZXF1aXJlZCxcbiAgICBhczogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLnN0cmluZywgUHJvcFR5cGVzLm9iamVjdF0pLFxuICAgIHByZWZldGNoOiBQcm9wVHlwZXMuYm9vbCxcbiAgICByZXBsYWNlOiBQcm9wVHlwZXMuYm9vbCxcbiAgICBzaGFsbG93OiBQcm9wVHlwZXMuYm9vbCxcbiAgICBwYXNzSHJlZjogUHJvcFR5cGVzLmJvb2wsXG4gICAgc2Nyb2xsOiBQcm9wVHlwZXMuYm9vbCxcbiAgICBjaGlsZHJlbjogUHJvcFR5cGVzLm9uZU9mVHlwZShbXG4gICAgICBQcm9wVHlwZXMuZWxlbWVudCxcbiAgICAgIChwcm9wczogYW55LCBwcm9wTmFtZTogc3RyaW5nKSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gcHJvcHNbcHJvcE5hbWVdXG5cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgYFdhcm5pbmc6IFlvdSdyZSB1c2luZyBhIHN0cmluZyBkaXJlY3RseSBpbnNpZGUgPExpbms+LiBUaGlzIHVzYWdlIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFBsZWFzZSBhZGQgYW4gPGE+IHRhZyBhcyBjaGlsZCBvZiA8TGluaz5gXG4gICAgICAgICAgKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgIH0sXG4gICAgXSkuaXNSZXF1aXJlZCxcbiAgfSlcbn1cblxuZXhwb3J0IGRlZmF1bHQgTGlua1xuIiwiLyoqXG4gKiBSZW1vdmVzIHRoZSB0cmFpbGluZyBzbGFzaCBvZiBhIHBhdGggaWYgdGhlcmUgaXMgb25lLiBQcmVzZXJ2ZXMgdGhlIHJvb3QgcGF0aCBgL2AuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVQYXRoVHJhaWxpbmdTbGFzaChwYXRoOiBzdHJpbmcpOiBzdHJpbmcge1xuICByZXR1cm4gcGF0aC5lbmRzV2l0aCgnLycpICYmIHBhdGggIT09ICcvJyA/IHBhdGguc2xpY2UoMCwgLTEpIDogcGF0aFxufVxuXG4vKipcbiAqIE5vcm1hbGl6ZXMgdGhlIHRyYWlsaW5nIHNsYXNoIG9mIGEgcGF0aCBhY2NvcmRpbmcgdG8gdGhlIGB0cmFpbGluZ1NsYXNoYCBvcHRpb25cbiAqIGluIGBuZXh0LmNvbmZpZy5qc2AuXG4gKi9cbmV4cG9ydCBjb25zdCBub3JtYWxpemVQYXRoVHJhaWxpbmdTbGFzaCA9IHByb2Nlc3MuZW52Ll9fTkVYVF9UUkFJTElOR19TTEFTSFxuICA/IChwYXRoOiBzdHJpbmcpOiBzdHJpbmcgPT4ge1xuICAgICAgaWYgKC9cXC5bXi9dK1xcLz8kLy50ZXN0KHBhdGgpKSB7XG4gICAgICAgIHJldHVybiByZW1vdmVQYXRoVHJhaWxpbmdTbGFzaChwYXRoKVxuICAgICAgfSBlbHNlIGlmIChwYXRoLmVuZHNXaXRoKCcvJykpIHtcbiAgICAgICAgcmV0dXJuIHBhdGhcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBwYXRoICsgJy8nXG4gICAgICB9XG4gICAgfVxuICA6IHJlbW92ZVBhdGhUcmFpbGluZ1NsYXNoXG4iLCIvKiBnbG9iYWwgd2luZG93ICovXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG5pbXBvcnQgUm91dGVyLCB7IE5leHRSb3V0ZXIgfSBmcm9tICcuLi9uZXh0LXNlcnZlci9saWIvcm91dGVyL3JvdXRlcidcbmltcG9ydCB7IFJvdXRlckNvbnRleHQgfSBmcm9tICcuLi9uZXh0LXNlcnZlci9saWIvcm91dGVyLWNvbnRleHQnXG5cbnR5cGUgQ2xhc3NBcmd1bWVudHM8VD4gPSBUIGV4dGVuZHMgbmV3ICguLi5hcmdzOiBpbmZlciBVKSA9PiBhbnkgPyBVIDogYW55XG5cbnR5cGUgUm91dGVyQXJncyA9IENsYXNzQXJndW1lbnRzPHR5cGVvZiBSb3V0ZXI+XG5cbnR5cGUgU2luZ2xldG9uUm91dGVyQmFzZSA9IHtcbiAgcm91dGVyOiBSb3V0ZXIgfCBudWxsXG4gIHJlYWR5Q2FsbGJhY2tzOiBBcnJheTwoKSA9PiBhbnk+XG4gIHJlYWR5KGNiOiAoKSA9PiBhbnkpOiB2b2lkXG59XG5cbmV4cG9ydCB7IFJvdXRlciwgTmV4dFJvdXRlciB9XG5cbmV4cG9ydCB0eXBlIFNpbmdsZXRvblJvdXRlciA9IFNpbmdsZXRvblJvdXRlckJhc2UgJiBOZXh0Um91dGVyXG5cbmNvbnN0IHNpbmdsZXRvblJvdXRlcjogU2luZ2xldG9uUm91dGVyQmFzZSA9IHtcbiAgcm91dGVyOiBudWxsLCAvLyBob2xkcyB0aGUgYWN0dWFsIHJvdXRlciBpbnN0YW5jZVxuICByZWFkeUNhbGxiYWNrczogW10sXG4gIHJlYWR5KGNiOiAoKSA9PiB2b2lkKSB7XG4gICAgaWYgKHRoaXMucm91dGVyKSByZXR1cm4gY2IoKVxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy5yZWFkeUNhbGxiYWNrcy5wdXNoKGNiKVxuICAgIH1cbiAgfSxcbn1cblxuLy8gQ3JlYXRlIHB1YmxpYyBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzIG9mIHRoZSByb3V0ZXIgaW4gdGhlIHNpbmdsZXRvblJvdXRlclxuY29uc3QgdXJsUHJvcGVydHlGaWVsZHMgPSBbXG4gICdwYXRobmFtZScsXG4gICdyb3V0ZScsXG4gICdxdWVyeScsXG4gICdhc1BhdGgnLFxuICAnY29tcG9uZW50cycsXG4gICdpc0ZhbGxiYWNrJyxcbiAgJ2Jhc2VQYXRoJyxcbl1cbmNvbnN0IHJvdXRlckV2ZW50cyA9IFtcbiAgJ3JvdXRlQ2hhbmdlU3RhcnQnLFxuICAnYmVmb3JlSGlzdG9yeUNoYW5nZScsXG4gICdyb3V0ZUNoYW5nZUNvbXBsZXRlJyxcbiAgJ3JvdXRlQ2hhbmdlRXJyb3InLFxuICAnaGFzaENoYW5nZVN0YXJ0JyxcbiAgJ2hhc2hDaGFuZ2VDb21wbGV0ZScsXG5dXG5jb25zdCBjb3JlTWV0aG9kRmllbGRzID0gW1xuICAncHVzaCcsXG4gICdyZXBsYWNlJyxcbiAgJ3JlbG9hZCcsXG4gICdiYWNrJyxcbiAgJ3ByZWZldGNoJyxcbiAgJ2JlZm9yZVBvcFN0YXRlJyxcbl1cblxuLy8gRXZlbnRzIGlzIGEgc3RhdGljIHByb3BlcnR5IG9uIHRoZSByb3V0ZXIsIHRoZSByb3V0ZXIgZG9lc24ndCBoYXZlIHRvIGJlIGluaXRpYWxpemVkIHRvIHVzZSBpdFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHNpbmdsZXRvblJvdXRlciwgJ2V2ZW50cycsIHtcbiAgZ2V0KCkge1xuICAgIHJldHVybiBSb3V0ZXIuZXZlbnRzXG4gIH0sXG59KVxuXG51cmxQcm9wZXJ0eUZpZWxkcy5mb3JFYWNoKChmaWVsZCkgPT4ge1xuICAvLyBIZXJlIHdlIG5lZWQgdG8gdXNlIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSBiZWNhdXNlLCB3ZSBuZWVkIHRvIHJldHVyblxuICAvLyB0aGUgcHJvcGVydHkgYXNzaWduZWQgdG8gdGhlIGFjdHVhbCByb3V0ZXJcbiAgLy8gVGhlIHZhbHVlIG1pZ2h0IGdldCBjaGFuZ2VkIGFzIHdlIGNoYW5nZSByb3V0ZXMgYW5kIHRoaXMgaXMgdGhlXG4gIC8vIHByb3BlciB3YXkgdG8gYWNjZXNzIGl0XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzaW5nbGV0b25Sb3V0ZXIsIGZpZWxkLCB7XG4gICAgZ2V0KCkge1xuICAgICAgY29uc3Qgcm91dGVyID0gZ2V0Um91dGVyKCkgYXMgYW55XG4gICAgICByZXR1cm4gcm91dGVyW2ZpZWxkXSBhcyBzdHJpbmdcbiAgICB9LFxuICB9KVxufSlcblxuY29yZU1ldGhvZEZpZWxkcy5mb3JFYWNoKChmaWVsZCkgPT4ge1xuICAvLyBXZSBkb24ndCByZWFsbHkga25vdyB0aGUgdHlwZXMgaGVyZSwgc28gd2UgYWRkIHRoZW0gbGF0ZXIgaW5zdGVhZFxuICA7KHNpbmdsZXRvblJvdXRlciBhcyBhbnkpW2ZpZWxkXSA9ICguLi5hcmdzOiBhbnlbXSkgPT4ge1xuICAgIGNvbnN0IHJvdXRlciA9IGdldFJvdXRlcigpIGFzIGFueVxuICAgIHJldHVybiByb3V0ZXJbZmllbGRdKC4uLmFyZ3MpXG4gIH1cbn0pXG5cbnJvdXRlckV2ZW50cy5mb3JFYWNoKChldmVudCkgPT4ge1xuICBzaW5nbGV0b25Sb3V0ZXIucmVhZHkoKCkgPT4ge1xuICAgIFJvdXRlci5ldmVudHMub24oZXZlbnQsICguLi5hcmdzKSA9PiB7XG4gICAgICBjb25zdCBldmVudEZpZWxkID0gYG9uJHtldmVudC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKX0ke2V2ZW50LnN1YnN0cmluZyhcbiAgICAgICAgMVxuICAgICAgKX1gXG4gICAgICBjb25zdCBfc2luZ2xldG9uUm91dGVyID0gc2luZ2xldG9uUm91dGVyIGFzIGFueVxuICAgICAgaWYgKF9zaW5nbGV0b25Sb3V0ZXJbZXZlbnRGaWVsZF0pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBfc2luZ2xldG9uUm91dGVyW2V2ZW50RmllbGRdKC4uLmFyZ3MpXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1jb25zb2xlXG4gICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3Igd2hlbiBydW5uaW5nIHRoZSBSb3V0ZXIgZXZlbnQ6ICR7ZXZlbnRGaWVsZH1gKVxuICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1jb25zb2xlXG4gICAgICAgICAgY29uc29sZS5lcnJvcihgJHtlcnIubWVzc2FnZX1cXG4ke2Vyci5zdGFja31gKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcbiAgfSlcbn0pXG5cbmZ1bmN0aW9uIGdldFJvdXRlcigpOiBSb3V0ZXIge1xuICBpZiAoIXNpbmdsZXRvblJvdXRlci5yb3V0ZXIpIHtcbiAgICBjb25zdCBtZXNzYWdlID1cbiAgICAgICdObyByb3V0ZXIgaW5zdGFuY2UgZm91bmQuXFxuJyArXG4gICAgICAnWW91IHNob3VsZCBvbmx5IHVzZSBcIm5leHQvcm91dGVyXCIgaW5zaWRlIHRoZSBjbGllbnQgc2lkZSBvZiB5b3VyIGFwcC5cXG4nXG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpXG4gIH1cbiAgcmV0dXJuIHNpbmdsZXRvblJvdXRlci5yb3V0ZXJcbn1cblxuLy8gRXhwb3J0IHRoZSBzaW5nbGV0b25Sb3V0ZXIgYW5kIHRoaXMgaXMgdGhlIHB1YmxpYyBBUEkuXG5leHBvcnQgZGVmYXVsdCBzaW5nbGV0b25Sb3V0ZXIgYXMgU2luZ2xldG9uUm91dGVyXG5cbi8vIFJlZXhwb3J0IHRoZSB3aXRoUm91dGUgSE9DXG5leHBvcnQgeyBkZWZhdWx0IGFzIHdpdGhSb3V0ZXIgfSBmcm9tICcuL3dpdGgtcm91dGVyJ1xuXG5leHBvcnQgZnVuY3Rpb24gdXNlUm91dGVyKCk6IE5leHRSb3V0ZXIge1xuICByZXR1cm4gUmVhY3QudXNlQ29udGV4dChSb3V0ZXJDb250ZXh0KVxufVxuXG4vLyBJTlRFUk5BTCBBUElTXG4vLyAtLS0tLS0tLS0tLS0tXG4vLyAoZG8gbm90IHVzZSBmb2xsb3dpbmcgZXhwb3J0cyBpbnNpZGUgdGhlIGFwcClcblxuLy8gQ3JlYXRlIGEgcm91dGVyIGFuZCBhc3NpZ24gaXQgYXMgdGhlIHNpbmdsZXRvbiBpbnN0YW5jZS5cbi8vIFRoaXMgaXMgdXNlZCBpbiBjbGllbnQgc2lkZSB3aGVuIHdlIGFyZSBpbml0aWxpemluZyB0aGUgYXBwLlxuLy8gVGhpcyBzaG91bGQgKipub3QqKiB1c2UgaW5zaWRlIHRoZSBzZXJ2ZXIuXG5leHBvcnQgY29uc3QgY3JlYXRlUm91dGVyID0gKC4uLmFyZ3M6IFJvdXRlckFyZ3MpOiBSb3V0ZXIgPT4ge1xuICBzaW5nbGV0b25Sb3V0ZXIucm91dGVyID0gbmV3IFJvdXRlciguLi5hcmdzKVxuICBzaW5nbGV0b25Sb3V0ZXIucmVhZHlDYWxsYmFja3MuZm9yRWFjaCgoY2IpID0+IGNiKCkpXG4gIHNpbmdsZXRvblJvdXRlci5yZWFkeUNhbGxiYWNrcyA9IFtdXG5cbiAgcmV0dXJuIHNpbmdsZXRvblJvdXRlci5yb3V0ZXJcbn1cblxuLy8gVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHRvIGNyZWF0ZSB0aGUgYHdpdGhSb3V0ZXJgIHJvdXRlciBpbnN0YW5jZVxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VQdWJsaWNSb3V0ZXJJbnN0YW5jZShyb3V0ZXI6IFJvdXRlcik6IE5leHRSb3V0ZXIge1xuICBjb25zdCBfcm91dGVyID0gcm91dGVyIGFzIGFueVxuICBjb25zdCBpbnN0YW5jZSA9IHt9IGFzIGFueVxuXG4gIGZvciAoY29uc3QgcHJvcGVydHkgb2YgdXJsUHJvcGVydHlGaWVsZHMpIHtcbiAgICBpZiAodHlwZW9mIF9yb3V0ZXJbcHJvcGVydHldID09PSAnb2JqZWN0Jykge1xuICAgICAgaW5zdGFuY2VbcHJvcGVydHldID0gT2JqZWN0LmFzc2lnbih7fSwgX3JvdXRlcltwcm9wZXJ0eV0pIC8vIG1ha2VzIHN1cmUgcXVlcnkgaXMgbm90IHN0YXRlZnVsXG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIGluc3RhbmNlW3Byb3BlcnR5XSA9IF9yb3V0ZXJbcHJvcGVydHldXG4gIH1cblxuICAvLyBFdmVudHMgaXMgYSBzdGF0aWMgcHJvcGVydHkgb24gdGhlIHJvdXRlciwgdGhlIHJvdXRlciBkb2Vzbid0IGhhdmUgdG8gYmUgaW5pdGlhbGl6ZWQgdG8gdXNlIGl0XG4gIGluc3RhbmNlLmV2ZW50cyA9IFJvdXRlci5ldmVudHNcblxuICBjb3JlTWV0aG9kRmllbGRzLmZvckVhY2goKGZpZWxkKSA9PiB7XG4gICAgaW5zdGFuY2VbZmllbGRdID0gKC4uLmFyZ3M6IGFueVtdKSA9PiB7XG4gICAgICByZXR1cm4gX3JvdXRlcltmaWVsZF0oLi4uYXJncylcbiAgICB9XG4gIH0pXG5cbiAgcmV0dXJuIGluc3RhbmNlXG59XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG5pbXBvcnQgeyBOZXh0Q29tcG9uZW50VHlwZSwgTmV4dFBhZ2VDb250ZXh0IH0gZnJvbSAnLi4vbmV4dC1zZXJ2ZXIvbGliL3V0aWxzJ1xuaW1wb3J0IHsgTmV4dFJvdXRlciwgdXNlUm91dGVyIH0gZnJvbSAnLi9yb3V0ZXInXG5cbmV4cG9ydCB0eXBlIFdpdGhSb3V0ZXJQcm9wcyA9IHtcbiAgcm91dGVyOiBOZXh0Um91dGVyXG59XG5cbmV4cG9ydCB0eXBlIEV4Y2x1ZGVSb3V0ZXJQcm9wczxQPiA9IFBpY2s8XG4gIFAsXG4gIEV4Y2x1ZGU8a2V5b2YgUCwga2V5b2YgV2l0aFJvdXRlclByb3BzPlxuPlxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB3aXRoUm91dGVyPFxuICBQIGV4dGVuZHMgV2l0aFJvdXRlclByb3BzLFxuICBDID0gTmV4dFBhZ2VDb250ZXh0XG4+KFxuICBDb21wb3NlZENvbXBvbmVudDogTmV4dENvbXBvbmVudFR5cGU8QywgYW55LCBQPlxuKTogUmVhY3QuQ29tcG9uZW50VHlwZTxFeGNsdWRlUm91dGVyUHJvcHM8UD4+IHtcbiAgZnVuY3Rpb24gV2l0aFJvdXRlcldyYXBwZXIocHJvcHM6IGFueSkge1xuICAgIHJldHVybiA8Q29tcG9zZWRDb21wb25lbnQgcm91dGVyPXt1c2VSb3V0ZXIoKX0gey4uLnByb3BzfSAvPlxuICB9XG5cbiAgV2l0aFJvdXRlcldyYXBwZXIuZ2V0SW5pdGlhbFByb3BzID0gQ29tcG9zZWRDb21wb25lbnQuZ2V0SW5pdGlhbFByb3BzXG4gIC8vIFRoaXMgaXMgbmVlZGVkIHRvIGFsbG93IGNoZWNraW5nIGZvciBjdXN0b20gZ2V0SW5pdGlhbFByb3BzIGluIF9hcHBcbiAgOyhXaXRoUm91dGVyV3JhcHBlciBhcyBhbnkpLm9yaWdHZXRJbml0aWFsUHJvcHMgPSAoQ29tcG9zZWRDb21wb25lbnQgYXMgYW55KS5vcmlnR2V0SW5pdGlhbFByb3BzXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgY29uc3QgbmFtZSA9XG4gICAgICBDb21wb3NlZENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb3NlZENvbXBvbmVudC5uYW1lIHx8ICdVbmtub3duJ1xuICAgIFdpdGhSb3V0ZXJXcmFwcGVyLmRpc3BsYXlOYW1lID0gYHdpdGhSb3V0ZXIoJHtuYW1lfSlgXG4gIH1cblxuICByZXR1cm4gV2l0aFJvdXRlcldyYXBwZXJcbn1cbiIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcblxuZXhwb3J0IGNvbnN0IEFtcFN0YXRlQ29udGV4dDogUmVhY3QuQ29udGV4dDxhbnk+ID0gUmVhY3QuY3JlYXRlQ29udGV4dCh7fSlcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgQW1wU3RhdGVDb250ZXh0LmRpc3BsYXlOYW1lID0gJ0FtcFN0YXRlQ29udGV4dCdcbn1cbiIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcbmltcG9ydCB7IEFtcFN0YXRlQ29udGV4dCB9IGZyb20gJy4vYW1wLWNvbnRleHQnXG5cbmV4cG9ydCBmdW5jdGlvbiBpc0luQW1wTW9kZSh7XG4gIGFtcEZpcnN0ID0gZmFsc2UsXG4gIGh5YnJpZCA9IGZhbHNlLFxuICBoYXNRdWVyeSA9IGZhbHNlLFxufSA9IHt9KTogYm9vbGVhbiB7XG4gIHJldHVybiBhbXBGaXJzdCB8fCAoaHlicmlkICYmIGhhc1F1ZXJ5KVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlQW1wKCk6IGJvb2xlYW4ge1xuICAvLyBEb24ndCBhc3NpZ24gdGhlIGNvbnRleHQgdmFsdWUgdG8gYSB2YXJpYWJsZSB0byBzYXZlIGJ5dGVzXG4gIHJldHVybiBpc0luQW1wTW9kZShSZWFjdC51c2VDb250ZXh0KEFtcFN0YXRlQ29udGV4dCkpXG59XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG5cbmV4cG9ydCBjb25zdCBIZWFkTWFuYWdlckNvbnRleHQ6IFJlYWN0LkNvbnRleHQ8e1xuICB1cGRhdGVIZWFkPzogKHN0YXRlOiBhbnkpID0+IHZvaWRcbiAgbW91bnRlZEluc3RhbmNlcz86IGFueVxufT4gPSBSZWFjdC5jcmVhdGVDb250ZXh0KHt9KVxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBIZWFkTWFuYWdlckNvbnRleHQuZGlzcGxheU5hbWUgPSAnSGVhZE1hbmFnZXJDb250ZXh0J1xufVxuIiwiaW1wb3J0IFJlYWN0LCB7IHVzZUNvbnRleHQgfSBmcm9tICdyZWFjdCdcbmltcG9ydCBFZmZlY3QgZnJvbSAnLi9zaWRlLWVmZmVjdCdcbmltcG9ydCB7IEFtcFN0YXRlQ29udGV4dCB9IGZyb20gJy4vYW1wLWNvbnRleHQnXG5pbXBvcnQgeyBIZWFkTWFuYWdlckNvbnRleHQgfSBmcm9tICcuL2hlYWQtbWFuYWdlci1jb250ZXh0J1xuaW1wb3J0IHsgaXNJbkFtcE1vZGUgfSBmcm9tICcuL2FtcCdcblxudHlwZSBXaXRoSW5BbXBNb2RlID0ge1xuICBpbkFtcE1vZGU/OiBib29sZWFuXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0SGVhZChpbkFtcE1vZGUgPSBmYWxzZSk6IEpTWC5FbGVtZW50W10ge1xuICBjb25zdCBoZWFkID0gWzxtZXRhIGNoYXJTZXQ9XCJ1dGYtOFwiIC8+XVxuICBpZiAoIWluQW1wTW9kZSkge1xuICAgIGhlYWQucHVzaCg8bWV0YSBuYW1lPVwidmlld3BvcnRcIiBjb250ZW50PVwid2lkdGg9ZGV2aWNlLXdpZHRoXCIgLz4pXG4gIH1cbiAgcmV0dXJuIGhlYWRcbn1cblxuZnVuY3Rpb24gb25seVJlYWN0RWxlbWVudChcbiAgbGlzdDogQXJyYXk8UmVhY3QuUmVhY3RFbGVtZW50PGFueT4+LFxuICBjaGlsZDogUmVhY3QuUmVhY3RDaGlsZFxuKTogQXJyYXk8UmVhY3QuUmVhY3RFbGVtZW50PGFueT4+IHtcbiAgLy8gUmVhY3QgY2hpbGRyZW4gY2FuIGJlIFwic3RyaW5nXCIgb3IgXCJudW1iZXJcIiBpbiB0aGlzIGNhc2Ugd2UgaWdub3JlIHRoZW0gZm9yIGJhY2t3YXJkcyBjb21wYXRcbiAgaWYgKHR5cGVvZiBjaGlsZCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGNoaWxkID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBsaXN0XG4gIH1cbiAgLy8gQWRkcyBzdXBwb3J0IGZvciBSZWFjdC5GcmFnbWVudFxuICBpZiAoY2hpbGQudHlwZSA9PT0gUmVhY3QuRnJhZ21lbnQpIHtcbiAgICByZXR1cm4gbGlzdC5jb25jYXQoXG4gICAgICBSZWFjdC5DaGlsZHJlbi50b0FycmF5KGNoaWxkLnByb3BzLmNoaWxkcmVuKS5yZWR1Y2UoXG4gICAgICAgIChcbiAgICAgICAgICBmcmFnbWVudExpc3Q6IEFycmF5PFJlYWN0LlJlYWN0RWxlbWVudDxhbnk+PixcbiAgICAgICAgICBmcmFnbWVudENoaWxkOiBSZWFjdC5SZWFjdENoaWxkXG4gICAgICAgICk6IEFycmF5PFJlYWN0LlJlYWN0RWxlbWVudDxhbnk+PiA9PiB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgdHlwZW9mIGZyYWdtZW50Q2hpbGQgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICAgICB0eXBlb2YgZnJhZ21lbnRDaGlsZCA9PT0gJ251bWJlcidcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiBmcmFnbWVudExpc3RcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZyYWdtZW50TGlzdC5jb25jYXQoZnJhZ21lbnRDaGlsZClcbiAgICAgICAgfSxcbiAgICAgICAgW11cbiAgICAgIClcbiAgICApXG4gIH1cbiAgcmV0dXJuIGxpc3QuY29uY2F0KGNoaWxkKVxufVxuXG5jb25zdCBNRVRBVFlQRVMgPSBbJ25hbWUnLCAnaHR0cEVxdWl2JywgJ2NoYXJTZXQnLCAnaXRlbVByb3AnXVxuXG4vKlxuIHJldHVybnMgYSBmdW5jdGlvbiBmb3IgZmlsdGVyaW5nIGhlYWQgY2hpbGQgZWxlbWVudHNcbiB3aGljaCBzaG91bGRuJ3QgYmUgZHVwbGljYXRlZCwgbGlrZSA8dGl0bGUvPlxuIEFsc28gYWRkcyBzdXBwb3J0IGZvciBkZWR1cGxpY2F0ZWQgYGtleWAgcHJvcGVydGllc1xuKi9cbmZ1bmN0aW9uIHVuaXF1ZSgpIHtcbiAgY29uc3Qga2V5cyA9IG5ldyBTZXQoKVxuICBjb25zdCB0YWdzID0gbmV3IFNldCgpXG4gIGNvbnN0IG1ldGFUeXBlcyA9IG5ldyBTZXQoKVxuICBjb25zdCBtZXRhQ2F0ZWdvcmllczogeyBbbWV0YXR5cGU6IHN0cmluZ106IFNldDxzdHJpbmc+IH0gPSB7fVxuXG4gIHJldHVybiAoaDogUmVhY3QuUmVhY3RFbGVtZW50PGFueT4pID0+IHtcbiAgICBsZXQgaXNVbmlxdWUgPSB0cnVlXG5cbiAgICBpZiAoaC5rZXkgJiYgdHlwZW9mIGgua2V5ICE9PSAnbnVtYmVyJyAmJiBoLmtleS5pbmRleE9mKCckJykgPiAwKSB7XG4gICAgICBjb25zdCBrZXkgPSBoLmtleS5zbGljZShoLmtleS5pbmRleE9mKCckJykgKyAxKVxuICAgICAgaWYgKGtleXMuaGFzKGtleSkpIHtcbiAgICAgICAgaXNVbmlxdWUgPSBmYWxzZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAga2V5cy5hZGQoa2V5KVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZWZhdWx0LWNhc2VcbiAgICBzd2l0Y2ggKGgudHlwZSkge1xuICAgICAgY2FzZSAndGl0bGUnOlxuICAgICAgY2FzZSAnYmFzZSc6XG4gICAgICAgIGlmICh0YWdzLmhhcyhoLnR5cGUpKSB7XG4gICAgICAgICAgaXNVbmlxdWUgPSBmYWxzZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRhZ3MuYWRkKGgudHlwZSlcbiAgICAgICAgfVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAnbWV0YSc6XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBNRVRBVFlQRVMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBtZXRhdHlwZSA9IE1FVEFUWVBFU1tpXVxuICAgICAgICAgIGlmICghaC5wcm9wcy5oYXNPd25Qcm9wZXJ0eShtZXRhdHlwZSkpIGNvbnRpbnVlXG5cbiAgICAgICAgICBpZiAobWV0YXR5cGUgPT09ICdjaGFyU2V0Jykge1xuICAgICAgICAgICAgaWYgKG1ldGFUeXBlcy5oYXMobWV0YXR5cGUpKSB7XG4gICAgICAgICAgICAgIGlzVW5pcXVlID0gZmFsc2VcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG1ldGFUeXBlcy5hZGQobWV0YXR5cGUpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGNhdGVnb3J5ID0gaC5wcm9wc1ttZXRhdHlwZV1cbiAgICAgICAgICAgIGNvbnN0IGNhdGVnb3JpZXMgPSBtZXRhQ2F0ZWdvcmllc1ttZXRhdHlwZV0gfHwgbmV3IFNldCgpXG4gICAgICAgICAgICBpZiAoY2F0ZWdvcmllcy5oYXMoY2F0ZWdvcnkpKSB7XG4gICAgICAgICAgICAgIGlzVW5pcXVlID0gZmFsc2VcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNhdGVnb3JpZXMuYWRkKGNhdGVnb3J5KVxuICAgICAgICAgICAgICBtZXRhQ2F0ZWdvcmllc1ttZXRhdHlwZV0gPSBjYXRlZ29yaWVzXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG4gICAgfVxuXG4gICAgcmV0dXJuIGlzVW5pcXVlXG4gIH1cbn1cblxuLyoqXG4gKlxuICogQHBhcmFtIGhlYWRFbGVtZW50cyBMaXN0IG9mIG11bHRpcGxlIDxIZWFkPiBpbnN0YW5jZXNcbiAqL1xuZnVuY3Rpb24gcmVkdWNlQ29tcG9uZW50cyhcbiAgaGVhZEVsZW1lbnRzOiBBcnJheTxSZWFjdC5SZWFjdEVsZW1lbnQ8YW55Pj4sXG4gIHByb3BzOiBXaXRoSW5BbXBNb2RlXG4pIHtcbiAgcmV0dXJuIGhlYWRFbGVtZW50c1xuICAgIC5yZWR1Y2UoXG4gICAgICAobGlzdDogUmVhY3QuUmVhY3RDaGlsZFtdLCBoZWFkRWxlbWVudDogUmVhY3QuUmVhY3RFbGVtZW50PGFueT4pID0+IHtcbiAgICAgICAgY29uc3QgaGVhZEVsZW1lbnRDaGlsZHJlbiA9IFJlYWN0LkNoaWxkcmVuLnRvQXJyYXkoXG4gICAgICAgICAgaGVhZEVsZW1lbnQucHJvcHMuY2hpbGRyZW5cbiAgICAgICAgKVxuICAgICAgICByZXR1cm4gbGlzdC5jb25jYXQoaGVhZEVsZW1lbnRDaGlsZHJlbilcbiAgICAgIH0sXG4gICAgICBbXVxuICAgIClcbiAgICAucmVkdWNlKG9ubHlSZWFjdEVsZW1lbnQsIFtdKVxuICAgIC5yZXZlcnNlKClcbiAgICAuY29uY2F0KGRlZmF1bHRIZWFkKHByb3BzLmluQW1wTW9kZSkpXG4gICAgLmZpbHRlcih1bmlxdWUoKSlcbiAgICAucmV2ZXJzZSgpXG4gICAgLm1hcCgoYzogUmVhY3QuUmVhY3RFbGVtZW50PGFueT4sIGk6IG51bWJlcikgPT4ge1xuICAgICAgY29uc3Qga2V5ID0gYy5rZXkgfHwgaVxuICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9PUFRJTUlaRV9GT05UUykge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgYy50eXBlID09PSAnbGluaycgJiZcbiAgICAgICAgICBjLnByb3BzWydocmVmJ10gJiZcbiAgICAgICAgICAvLyBUT0RPKHByYXRlZWtiaEApOiBSZXBsYWNlIHRoaXMgd2l0aCBjb25zdCBmcm9tIGBjb25zdGFudHNgIHdoZW4gdGhlIHRyZWUgc2hha2luZyB3b3Jrcy5cbiAgICAgICAgICBbJ2h0dHBzOi8vZm9udHMuZ29vZ2xlYXBpcy5jb20vY3NzJ10uc29tZSgodXJsKSA9PlxuICAgICAgICAgICAgYy5wcm9wc1snaHJlZiddLnN0YXJ0c1dpdGgodXJsKVxuICAgICAgICAgIClcbiAgICAgICAgKSB7XG4gICAgICAgICAgY29uc3QgbmV3UHJvcHMgPSB7IC4uLihjLnByb3BzIHx8IHt9KSB9XG4gICAgICAgICAgbmV3UHJvcHNbJ2RhdGEtaHJlZiddID0gbmV3UHJvcHNbJ2hyZWYnXVxuICAgICAgICAgIG5ld1Byb3BzWydocmVmJ10gPSB1bmRlZmluZWRcbiAgICAgICAgICByZXR1cm4gUmVhY3QuY2xvbmVFbGVtZW50KGMsIG5ld1Byb3BzKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gUmVhY3QuY2xvbmVFbGVtZW50KGMsIHsga2V5IH0pXG4gICAgfSlcbn1cblxuLyoqXG4gKiBUaGlzIGNvbXBvbmVudCBpbmplY3RzIGVsZW1lbnRzIHRvIGA8aGVhZD5gIG9mIHlvdXIgcGFnZS5cbiAqIFRvIGF2b2lkIGR1cGxpY2F0ZWQgYHRhZ3NgIGluIGA8aGVhZD5gIHlvdSBjYW4gdXNlIHRoZSBga2V5YCBwcm9wZXJ0eSwgd2hpY2ggd2lsbCBtYWtlIHN1cmUgZXZlcnkgdGFnIGlzIG9ubHkgcmVuZGVyZWQgb25jZS5cbiAqL1xuZnVuY3Rpb24gSGVhZCh7IGNoaWxkcmVuIH06IHsgY2hpbGRyZW46IFJlYWN0LlJlYWN0Tm9kZSB9KSB7XG4gIGNvbnN0IGFtcFN0YXRlID0gdXNlQ29udGV4dChBbXBTdGF0ZUNvbnRleHQpXG4gIGNvbnN0IGhlYWRNYW5hZ2VyID0gdXNlQ29udGV4dChIZWFkTWFuYWdlckNvbnRleHQpXG4gIHJldHVybiAoXG4gICAgPEVmZmVjdFxuICAgICAgcmVkdWNlQ29tcG9uZW50c1RvU3RhdGU9e3JlZHVjZUNvbXBvbmVudHN9XG4gICAgICBoZWFkTWFuYWdlcj17aGVhZE1hbmFnZXJ9XG4gICAgICBpbkFtcE1vZGU9e2lzSW5BbXBNb2RlKGFtcFN0YXRlKX1cbiAgICA+XG4gICAgICB7Y2hpbGRyZW59XG4gICAgPC9FZmZlY3Q+XG4gIClcbn1cblxuLy8gVE9ETzogUmVtb3ZlIGluIHRoZSBuZXh0IG1ham9yIHJlbGVhc2VcbkhlYWQucmV3aW5kID0gKCkgPT4ge31cblxuZXhwb3J0IGRlZmF1bHQgSGVhZFxuIiwiLypcbk1JVCBMaWNlbnNlXG5cbkNvcHlyaWdodCAoYykgSmFzb24gTWlsbGVyIChodHRwczovL2phc29uZm9ybWF0LmNvbS8pXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiovXG5cbi8vIFRoaXMgZmlsZSBpcyBiYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vZGV2ZWxvcGl0L21pdHQvYmxvYi92MS4xLjMvc3JjL2luZGV4LmpzXG4vLyBJdCdzIGJlZW4gZWRpdGVkIGZvciB0aGUgbmVlZHMgb2YgdGhpcyBzY3JpcHRcbi8vIFNlZSB0aGUgTElDRU5TRSBhdCB0aGUgdG9wIG9mIHRoZSBmaWxlXG5cbnR5cGUgSGFuZGxlciA9ICguLi5ldnRzOiBhbnlbXSkgPT4gdm9pZFxuXG5leHBvcnQgdHlwZSBNaXR0RW1pdHRlciA9IHtcbiAgb24odHlwZTogc3RyaW5nLCBoYW5kbGVyOiBIYW5kbGVyKTogdm9pZFxuICBvZmYodHlwZTogc3RyaW5nLCBoYW5kbGVyOiBIYW5kbGVyKTogdm9pZFxuICBlbWl0KHR5cGU6IHN0cmluZywgLi4uZXZ0czogYW55W10pOiB2b2lkXG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG1pdHQoKTogTWl0dEVtaXR0ZXIge1xuICBjb25zdCBhbGw6IHsgW3M6IHN0cmluZ106IEhhbmRsZXJbXSB9ID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuXG4gIHJldHVybiB7XG4gICAgb24odHlwZTogc3RyaW5nLCBoYW5kbGVyOiBIYW5kbGVyKSB7XG4gICAgICA7KGFsbFt0eXBlXSB8fCAoYWxsW3R5cGVdID0gW10pKS5wdXNoKGhhbmRsZXIpXG4gICAgfSxcblxuICAgIG9mZih0eXBlOiBzdHJpbmcsIGhhbmRsZXI6IEhhbmRsZXIpIHtcbiAgICAgIGlmIChhbGxbdHlwZV0pIHtcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWJpdHdpc2VcbiAgICAgICAgYWxsW3R5cGVdLnNwbGljZShhbGxbdHlwZV0uaW5kZXhPZihoYW5kbGVyKSA+Pj4gMCwgMSlcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZW1pdCh0eXBlOiBzdHJpbmcsIC4uLmV2dHM6IGFueVtdKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgYXJyYXktY2FsbGJhY2stcmV0dXJuXG4gICAgICA7KGFsbFt0eXBlXSB8fCBbXSkuc2xpY2UoKS5tYXAoKGhhbmRsZXI6IEhhbmRsZXIpID0+IHtcbiAgICAgICAgaGFuZGxlciguLi5ldnRzKVxuICAgICAgfSlcbiAgICB9LFxuICB9XG59XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG5pbXBvcnQgeyBOZXh0Um91dGVyIH0gZnJvbSAnLi9yb3V0ZXIvcm91dGVyJ1xuXG5leHBvcnQgY29uc3QgUm91dGVyQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQ8TmV4dFJvdXRlcj4obnVsbCBhcyBhbnkpXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIFJvdXRlckNvbnRleHQuZGlzcGxheU5hbWUgPSAnUm91dGVyQ29udGV4dCdcbn1cbiIsIi8qIGdsb2JhbCBfX05FWFRfREFUQV9fICovXG4vLyB0c2xpbnQ6ZGlzYWJsZTpuby1jb25zb2xlXG5pbXBvcnQgeyBQYXJzZWRVcmxRdWVyeSB9IGZyb20gJ3F1ZXJ5c3RyaW5nJ1xuaW1wb3J0IHsgQ29tcG9uZW50VHlwZSB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgVXJsT2JqZWN0IH0gZnJvbSAndXJsJ1xuaW1wb3J0IG1pdHQsIHsgTWl0dEVtaXR0ZXIgfSBmcm9tICcuLi9taXR0J1xuaW1wb3J0IHtcbiAgQXBwQ29udGV4dFR5cGUsXG4gIGZvcm1hdFdpdGhWYWxpZGF0aW9uLFxuICBnZXRVUkwsXG4gIGxvYWRHZXRJbml0aWFsUHJvcHMsXG4gIE5leHRQYWdlQ29udGV4dCxcbiAgU1QsXG4gIGdldExvY2F0aW9uT3JpZ2luLFxufSBmcm9tICcuLi91dGlscydcbmltcG9ydCB7IGlzRHluYW1pY1JvdXRlIH0gZnJvbSAnLi91dGlscy9pcy1keW5hbWljJ1xuaW1wb3J0IHsgZ2V0Um91dGVNYXRjaGVyIH0gZnJvbSAnLi91dGlscy9yb3V0ZS1tYXRjaGVyJ1xuaW1wb3J0IHsgZ2V0Um91dGVSZWdleCB9IGZyb20gJy4vdXRpbHMvcm91dGUtcmVnZXgnXG5pbXBvcnQgeyBzZWFyY2hQYXJhbXNUb1VybFF1ZXJ5IH0gZnJvbSAnLi91dGlscy9xdWVyeXN0cmluZydcbmltcG9ydCB7IHBhcnNlUmVsYXRpdmVVcmwgfSBmcm9tICcuL3V0aWxzL3BhcnNlLXJlbGF0aXZlLXVybCdcbmltcG9ydCB7XG4gIHJlbW92ZVBhdGhUcmFpbGluZ1NsYXNoLFxuICBub3JtYWxpemVQYXRoVHJhaWxpbmdTbGFzaCxcbn0gZnJvbSAnLi4vLi4vLi4vY2xpZW50L25vcm1hbGl6ZS10cmFpbGluZy1zbGFzaCdcblxuaW50ZXJmYWNlIFRyYW5zaXRpb25PcHRpb25zIHtcbiAgc2hhbGxvdz86IGJvb2xlYW5cbn1cblxuaW50ZXJmYWNlIE5leHRIaXN0b3J5U3RhdGUge1xuICB1cmw6IHN0cmluZ1xuICBhczogc3RyaW5nXG4gIG9wdGlvbnM6IFRyYW5zaXRpb25PcHRpb25zXG59XG5cbnR5cGUgSGlzdG9yeVN0YXRlID0gbnVsbCB8IHsgX19OOiBmYWxzZSB9IHwgKHsgX19OOiB0cnVlIH0gJiBOZXh0SGlzdG9yeVN0YXRlKVxuXG5jb25zdCBiYXNlUGF0aCA9IChwcm9jZXNzLmVudi5fX05FWFRfUk9VVEVSX0JBU0VQQVRIIGFzIHN0cmluZykgfHwgJydcblxuZnVuY3Rpb24gYnVpbGRDYW5jZWxsYXRpb25FcnJvcigpIHtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24obmV3IEVycm9yKCdSb3V0ZSBDYW5jZWxsZWQnKSwge1xuICAgIGNhbmNlbGxlZDogdHJ1ZSxcbiAgfSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhhc0Jhc2VQYXRoKHBhdGg6IHN0cmluZyk6IGJvb2xlYW4ge1xuICByZXR1cm4gcGF0aCA9PT0gYmFzZVBhdGggfHwgcGF0aC5zdGFydHNXaXRoKGJhc2VQYXRoICsgJy8nKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYWRkQmFzZVBhdGgocGF0aDogc3RyaW5nKTogc3RyaW5nIHtcbiAgLy8gd2Ugb25seSBhZGQgdGhlIGJhc2VwYXRoIG9uIHJlbGF0aXZlIHVybHNcbiAgcmV0dXJuIGJhc2VQYXRoICYmIHBhdGguc3RhcnRzV2l0aCgnLycpXG4gICAgPyBwYXRoID09PSAnLydcbiAgICAgID8gbm9ybWFsaXplUGF0aFRyYWlsaW5nU2xhc2goYmFzZVBhdGgpXG4gICAgICA6IGJhc2VQYXRoICsgcGF0aFxuICAgIDogcGF0aFxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVsQmFzZVBhdGgocGF0aDogc3RyaW5nKTogc3RyaW5nIHtcbiAgcmV0dXJuIHBhdGguc2xpY2UoYmFzZVBhdGgubGVuZ3RoKSB8fCAnLydcbn1cblxuLyoqXG4gKiBEZXRlY3RzIHdoZXRoZXIgYSBnaXZlbiB1cmwgaXMgcm91dGFibGUgYnkgdGhlIE5leHQuanMgcm91dGVyIChicm93c2VyIG9ubHkpLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNMb2NhbFVSTCh1cmw6IHN0cmluZyk6IGJvb2xlYW4ge1xuICBpZiAodXJsLnN0YXJ0c1dpdGgoJy8nKSkgcmV0dXJuIHRydWVcbiAgdHJ5IHtcbiAgICAvLyBhYnNvbHV0ZSB1cmxzIGNhbiBiZSBsb2NhbCBpZiB0aGV5IGFyZSBvbiB0aGUgc2FtZSBvcmlnaW5cbiAgICBjb25zdCBsb2NhdGlvbk9yaWdpbiA9IGdldExvY2F0aW9uT3JpZ2luKClcbiAgICBjb25zdCByZXNvbHZlZCA9IG5ldyBVUkwodXJsLCBsb2NhdGlvbk9yaWdpbilcbiAgICByZXR1cm4gcmVzb2x2ZWQub3JpZ2luID09PSBsb2NhdGlvbk9yaWdpbiAmJiBoYXNCYXNlUGF0aChyZXNvbHZlZC5wYXRobmFtZSlcbiAgfSBjYXRjaCAoXykge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbnR5cGUgVXJsID0gVXJsT2JqZWN0IHwgc3RyaW5nXG5cbi8qKlxuICogUmVzb2x2ZXMgYSBnaXZlbiBoeXBlcmxpbmsgd2l0aCBhIGNlcnRhaW4gcm91dGVyIHN0YXRlIChiYXNlUGF0aCBub3QgaW5jbHVkZWQpLlxuICogUHJlc2VydmVzIGFic29sdXRlIHVybHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlSHJlZihjdXJyZW50UGF0aDogc3RyaW5nLCBocmVmOiBVcmwpOiBzdHJpbmcge1xuICAvLyB3ZSB1c2UgYSBkdW1teSBiYXNlIHVybCBmb3IgcmVsYXRpdmUgdXJsc1xuICBjb25zdCBiYXNlID0gbmV3IFVSTChjdXJyZW50UGF0aCwgJ2h0dHA6Ly9uJylcbiAgY29uc3QgdXJsQXNTdHJpbmcgPVxuICAgIHR5cGVvZiBocmVmID09PSAnc3RyaW5nJyA/IGhyZWYgOiBmb3JtYXRXaXRoVmFsaWRhdGlvbihocmVmKVxuICB0cnkge1xuICAgIGNvbnN0IGZpbmFsVXJsID0gbmV3IFVSTCh1cmxBc1N0cmluZywgYmFzZSlcbiAgICBmaW5hbFVybC5wYXRobmFtZSA9IG5vcm1hbGl6ZVBhdGhUcmFpbGluZ1NsYXNoKGZpbmFsVXJsLnBhdGhuYW1lKVxuICAgIC8vIGlmIHRoZSBvcmlnaW4gZGlkbid0IGNoYW5nZSwgaXQgbWVhbnMgd2UgcmVjZWl2ZWQgYSByZWxhdGl2ZSBocmVmXG4gICAgcmV0dXJuIGZpbmFsVXJsLm9yaWdpbiA9PT0gYmFzZS5vcmlnaW5cbiAgICAgID8gZmluYWxVcmwuaHJlZi5zbGljZShmaW5hbFVybC5vcmlnaW4ubGVuZ3RoKVxuICAgICAgOiBmaW5hbFVybC5ocmVmXG4gIH0gY2F0Y2ggKF8pIHtcbiAgICByZXR1cm4gdXJsQXNTdHJpbmdcbiAgfVxufVxuXG5jb25zdCBQQUdFX0xPQURfRVJST1IgPSBTeW1ib2woJ1BBR0VfTE9BRF9FUlJPUicpXG5leHBvcnQgZnVuY3Rpb24gbWFya0xvYWRpbmdFcnJvcihlcnI6IEVycm9yKTogRXJyb3Ige1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGVyciwgUEFHRV9MT0FEX0VSUk9SLCB7fSlcbn1cblxuZnVuY3Rpb24gcHJlcGFyZVVybEFzKHJvdXRlcjogTmV4dFJvdXRlciwgdXJsOiBVcmwsIGFzOiBVcmwpIHtcbiAgLy8gSWYgdXJsIGFuZCBhcyBwcm92aWRlZCBhcyBhbiBvYmplY3QgcmVwcmVzZW50YXRpb24sXG4gIC8vIHdlJ2xsIGZvcm1hdCB0aGVtIGludG8gdGhlIHN0cmluZyB2ZXJzaW9uIGhlcmUuXG4gIHJldHVybiB7XG4gICAgdXJsOiBhZGRCYXNlUGF0aChyZXNvbHZlSHJlZihyb3V0ZXIucGF0aG5hbWUsIHVybCkpLFxuICAgIGFzOiBhcyA/IGFkZEJhc2VQYXRoKHJlc29sdmVIcmVmKHJvdXRlci5wYXRobmFtZSwgYXMpKSA6IGFzLFxuICB9XG59XG5cbmZ1bmN0aW9uIHRyeVBhcnNlUmVsYXRpdmVVcmwoXG4gIHVybDogc3RyaW5nXG4pOiBudWxsIHwgUmV0dXJuVHlwZTx0eXBlb2YgcGFyc2VSZWxhdGl2ZVVybD4ge1xuICB0cnkge1xuICAgIHJldHVybiBwYXJzZVJlbGF0aXZlVXJsKHVybClcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYEludmFsaWQgaHJlZiBwYXNzZWQgdG8gcm91dGVyOiAke3VybH0gaHR0cHM6Ly9lcnIuc2gvdmVyY2VsL25leHQuanMvaW52YWxpZC1ocmVmLXBhc3NlZGBcbiAgICAgICAgKVxuICAgICAgfSwgMClcbiAgICB9XG4gICAgcmV0dXJuIG51bGxcbiAgfVxufVxuXG50eXBlIENvbXBvbmVudFJlcyA9IHsgcGFnZTogQ29tcG9uZW50VHlwZTsgbW9kOiBhbnkgfVxuXG5leHBvcnQgdHlwZSBCYXNlUm91dGVyID0ge1xuICByb3V0ZTogc3RyaW5nXG4gIHBhdGhuYW1lOiBzdHJpbmdcbiAgcXVlcnk6IFBhcnNlZFVybFF1ZXJ5XG4gIGFzUGF0aDogc3RyaW5nXG4gIGJhc2VQYXRoOiBzdHJpbmdcbn1cblxuZXhwb3J0IHR5cGUgTmV4dFJvdXRlciA9IEJhc2VSb3V0ZXIgJlxuICBQaWNrPFxuICAgIFJvdXRlcixcbiAgICB8ICdwdXNoJ1xuICAgIHwgJ3JlcGxhY2UnXG4gICAgfCAncmVsb2FkJ1xuICAgIHwgJ2JhY2snXG4gICAgfCAncHJlZmV0Y2gnXG4gICAgfCAnYmVmb3JlUG9wU3RhdGUnXG4gICAgfCAnZXZlbnRzJ1xuICAgIHwgJ2lzRmFsbGJhY2snXG4gID5cblxuZXhwb3J0IHR5cGUgUHJlZmV0Y2hPcHRpb25zID0ge1xuICBwcmlvcml0eT86IGJvb2xlYW5cbn1cblxudHlwZSBSb3V0ZUluZm8gPSB7XG4gIENvbXBvbmVudDogQ29tcG9uZW50VHlwZVxuICBfX05fU1NHPzogYm9vbGVhblxuICBfX05fU1NQPzogYm9vbGVhblxuICBwcm9wcz86IGFueVxuICBlcnI/OiBFcnJvclxuICBlcnJvcj86IGFueVxufVxuXG50eXBlIFN1YnNjcmlwdGlvbiA9IChkYXRhOiBSb3V0ZUluZm8sIEFwcD86IENvbXBvbmVudFR5cGUpID0+IFByb21pc2U8dm9pZD5cblxudHlwZSBCZWZvcmVQb3BTdGF0ZUNhbGxiYWNrID0gKHN0YXRlOiBOZXh0SGlzdG9yeVN0YXRlKSA9PiBib29sZWFuXG5cbnR5cGUgQ29tcG9uZW50TG9hZENhbmNlbCA9ICgoKSA9PiB2b2lkKSB8IG51bGxcblxudHlwZSBIaXN0b3J5TWV0aG9kID0gJ3JlcGxhY2VTdGF0ZScgfCAncHVzaFN0YXRlJ1xuXG5jb25zdCBtYW51YWxTY3JvbGxSZXN0b3JhdGlvbiA9XG4gIHByb2Nlc3MuZW52Ll9fTkVYVF9TQ1JPTExfUkVTVE9SQVRJT04gJiZcbiAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgJ3Njcm9sbFJlc3RvcmF0aW9uJyBpbiB3aW5kb3cuaGlzdG9yeVxuXG5mdW5jdGlvbiBmZXRjaFJldHJ5KHVybDogc3RyaW5nLCBhdHRlbXB0czogbnVtYmVyKTogUHJvbWlzZTxhbnk+IHtcbiAgcmV0dXJuIGZldGNoKHVybCwge1xuICAgIC8vIENvb2tpZXMgYXJlIHJlcXVpcmVkIHRvIGJlIHByZXNlbnQgZm9yIE5leHQuanMnIFNTRyBcIlByZXZpZXcgTW9kZVwiLlxuICAgIC8vIENvb2tpZXMgbWF5IGFsc28gYmUgcmVxdWlyZWQgZm9yIGBnZXRTZXJ2ZXJTaWRlUHJvcHNgLlxuICAgIC8vXG4gICAgLy8gPiBgZmV0Y2hgIHdvbuKAmXQgc2VuZCBjb29raWVzLCB1bmxlc3MgeW91IHNldCB0aGUgY3JlZGVudGlhbHMgaW5pdFxuICAgIC8vID4gb3B0aW9uLlxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9GZXRjaF9BUEkvVXNpbmdfRmV0Y2hcbiAgICAvL1xuICAgIC8vID4gRm9yIG1heGltdW0gYnJvd3NlciBjb21wYXRpYmlsaXR5IHdoZW4gaXQgY29tZXMgdG8gc2VuZGluZyAmXG4gICAgLy8gPiByZWNlaXZpbmcgY29va2llcywgYWx3YXlzIHN1cHBseSB0aGUgYGNyZWRlbnRpYWxzOiAnc2FtZS1vcmlnaW4nYFxuICAgIC8vID4gb3B0aW9uIGluc3RlYWQgb2YgcmVseWluZyBvbiB0aGUgZGVmYXVsdC5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZ2l0aHViL2ZldGNoI2NhdmVhdHNcbiAgICBjcmVkZW50aWFsczogJ3NhbWUtb3JpZ2luJyxcbiAgfSkudGhlbigocmVzKSA9PiB7XG4gICAgaWYgKCFyZXMub2spIHtcbiAgICAgIGlmIChhdHRlbXB0cyA+IDEgJiYgcmVzLnN0YXR1cyA+PSA1MDApIHtcbiAgICAgICAgcmV0dXJuIGZldGNoUmV0cnkodXJsLCBhdHRlbXB0cyAtIDEpXG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBsb2FkIHN0YXRpYyBwcm9wc2ApXG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcy5qc29uKClcbiAgfSlcbn1cblxuZnVuY3Rpb24gZmV0Y2hOZXh0RGF0YShkYXRhSHJlZjogc3RyaW5nLCBpc1NlcnZlclJlbmRlcjogYm9vbGVhbikge1xuICByZXR1cm4gZmV0Y2hSZXRyeShkYXRhSHJlZiwgaXNTZXJ2ZXJSZW5kZXIgPyAzIDogMSkuY2F0Y2goKGVycjogRXJyb3IpID0+IHtcbiAgICAvLyBXZSBzaG91bGQgb25seSB0cmlnZ2VyIGEgc2VydmVyLXNpZGUgdHJhbnNpdGlvbiBpZiB0aGlzIHdhcyBjYXVzZWRcbiAgICAvLyBvbiBhIGNsaWVudC1zaWRlIHRyYW5zaXRpb24uIE90aGVyd2lzZSwgd2UnZCBnZXQgaW50byBhbiBpbmZpbml0ZVxuICAgIC8vIGxvb3AuXG4gICAgaWYgKCFpc1NlcnZlclJlbmRlcikge1xuICAgICAgbWFya0xvYWRpbmdFcnJvcihlcnIpXG4gICAgfVxuICAgIHRocm93IGVyclxuICB9KVxufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSb3V0ZXIgaW1wbGVtZW50cyBCYXNlUm91dGVyIHtcbiAgcm91dGU6IHN0cmluZ1xuICBwYXRobmFtZTogc3RyaW5nXG4gIHF1ZXJ5OiBQYXJzZWRVcmxRdWVyeVxuICBhc1BhdGg6IHN0cmluZ1xuICBiYXNlUGF0aDogc3RyaW5nXG5cbiAgLyoqXG4gICAqIE1hcCBvZiBhbGwgY29tcG9uZW50cyBsb2FkZWQgaW4gYFJvdXRlcmBcbiAgICovXG4gIGNvbXBvbmVudHM6IHsgW3BhdGhuYW1lOiBzdHJpbmddOiBSb3V0ZUluZm8gfVxuICAvLyBTdGF0aWMgRGF0YSBDYWNoZVxuICBzZGM6IHsgW2FzUGF0aDogc3RyaW5nXTogb2JqZWN0IH0gPSB7fVxuICBzdWI6IFN1YnNjcmlwdGlvblxuICBjbGM6IENvbXBvbmVudExvYWRDYW5jZWxcbiAgcGFnZUxvYWRlcjogYW55XG4gIF9icHM6IEJlZm9yZVBvcFN0YXRlQ2FsbGJhY2sgfCB1bmRlZmluZWRcbiAgZXZlbnRzOiBNaXR0RW1pdHRlclxuICBfd3JhcEFwcDogKEFwcDogQ29tcG9uZW50VHlwZSkgPT4gYW55XG4gIGlzU3NyOiBib29sZWFuXG4gIGlzRmFsbGJhY2s6IGJvb2xlYW5cbiAgX2luRmxpZ2h0Um91dGU/OiBzdHJpbmdcblxuICBzdGF0aWMgZXZlbnRzOiBNaXR0RW1pdHRlciA9IG1pdHQoKVxuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHBhdGhuYW1lOiBzdHJpbmcsXG4gICAgcXVlcnk6IFBhcnNlZFVybFF1ZXJ5LFxuICAgIGFzOiBzdHJpbmcsXG4gICAge1xuICAgICAgaW5pdGlhbFByb3BzLFxuICAgICAgcGFnZUxvYWRlcixcbiAgICAgIEFwcCxcbiAgICAgIHdyYXBBcHAsXG4gICAgICBDb21wb25lbnQsXG4gICAgICBlcnIsXG4gICAgICBzdWJzY3JpcHRpb24sXG4gICAgICBpc0ZhbGxiYWNrLFxuICAgIH06IHtcbiAgICAgIHN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uXG4gICAgICBpbml0aWFsUHJvcHM6IGFueVxuICAgICAgcGFnZUxvYWRlcjogYW55XG4gICAgICBDb21wb25lbnQ6IENvbXBvbmVudFR5cGVcbiAgICAgIEFwcDogQ29tcG9uZW50VHlwZVxuICAgICAgd3JhcEFwcDogKEFwcDogQ29tcG9uZW50VHlwZSkgPT4gYW55XG4gICAgICBlcnI/OiBFcnJvclxuICAgICAgaXNGYWxsYmFjazogYm9vbGVhblxuICAgIH1cbiAgKSB7XG4gICAgLy8gcmVwcmVzZW50cyB0aGUgY3VycmVudCBjb21wb25lbnQga2V5XG4gICAgdGhpcy5yb3V0ZSA9IHJlbW92ZVBhdGhUcmFpbGluZ1NsYXNoKHBhdGhuYW1lKVxuXG4gICAgLy8gc2V0IHVwIHRoZSBjb21wb25lbnQgY2FjaGUgKGJ5IHJvdXRlIGtleXMpXG4gICAgdGhpcy5jb21wb25lbnRzID0ge31cbiAgICAvLyBXZSBzaG91bGQgbm90IGtlZXAgdGhlIGNhY2hlLCBpZiB0aGVyZSdzIGFuIGVycm9yXG4gICAgLy8gT3RoZXJ3aXNlLCB0aGlzIGNhdXNlIGlzc3VlcyB3aGVuIHdoZW4gZ29pbmcgYmFjayBhbmRcbiAgICAvLyBjb21lIGFnYWluIHRvIHRoZSBlcnJvcmVkIHBhZ2UuXG4gICAgaWYgKHBhdGhuYW1lICE9PSAnL19lcnJvcicpIHtcbiAgICAgIHRoaXMuY29tcG9uZW50c1t0aGlzLnJvdXRlXSA9IHtcbiAgICAgICAgQ29tcG9uZW50LFxuICAgICAgICBwcm9wczogaW5pdGlhbFByb3BzLFxuICAgICAgICBlcnIsXG4gICAgICAgIF9fTl9TU0c6IGluaXRpYWxQcm9wcyAmJiBpbml0aWFsUHJvcHMuX19OX1NTRyxcbiAgICAgICAgX19OX1NTUDogaW5pdGlhbFByb3BzICYmIGluaXRpYWxQcm9wcy5fX05fU1NQLFxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuY29tcG9uZW50c1snL19hcHAnXSA9IHsgQ29tcG9uZW50OiBBcHAgfVxuXG4gICAgLy8gQmFja3dhcmRzIGNvbXBhdCBmb3IgUm91dGVyLnJvdXRlci5ldmVudHNcbiAgICAvLyBUT0RPOiBTaG91bGQgYmUgcmVtb3ZlIHRoZSBmb2xsb3dpbmcgbWFqb3IgdmVyc2lvbiBhcyBpdCB3YXMgbmV2ZXIgZG9jdW1lbnRlZFxuICAgIHRoaXMuZXZlbnRzID0gUm91dGVyLmV2ZW50c1xuXG4gICAgdGhpcy5wYWdlTG9hZGVyID0gcGFnZUxvYWRlclxuICAgIHRoaXMucGF0aG5hbWUgPSBwYXRobmFtZVxuICAgIHRoaXMucXVlcnkgPSBxdWVyeVxuICAgIC8vIGlmIGF1dG8gcHJlcmVuZGVyZWQgYW5kIGR5bmFtaWMgcm91dGUgd2FpdCB0byB1cGRhdGUgYXNQYXRoXG4gICAgLy8gdW50aWwgYWZ0ZXIgbW91bnQgdG8gcHJldmVudCBoeWRyYXRpb24gbWlzbWF0Y2hcbiAgICB0aGlzLmFzUGF0aCA9XG4gICAgICAvLyBAdHMtaWdub3JlIHRoaXMgaXMgdGVtcG9yYXJpbHkgZ2xvYmFsIChhdHRhY2hlZCB0byB3aW5kb3cpXG4gICAgICBpc0R5bmFtaWNSb3V0ZShwYXRobmFtZSkgJiYgX19ORVhUX0RBVEFfXy5hdXRvRXhwb3J0ID8gcGF0aG5hbWUgOiBhc1xuICAgIHRoaXMuYmFzZVBhdGggPSBiYXNlUGF0aFxuICAgIHRoaXMuc3ViID0gc3Vic2NyaXB0aW9uXG4gICAgdGhpcy5jbGMgPSBudWxsXG4gICAgdGhpcy5fd3JhcEFwcCA9IHdyYXBBcHBcbiAgICAvLyBtYWtlIHN1cmUgdG8gaWdub3JlIGV4dHJhIHBvcFN0YXRlIGluIHNhZmFyaSBvbiBuYXZpZ2F0aW5nXG4gICAgLy8gYmFjayBmcm9tIGV4dGVybmFsIHNpdGVcbiAgICB0aGlzLmlzU3NyID0gdHJ1ZVxuXG4gICAgdGhpcy5pc0ZhbGxiYWNrID0gaXNGYWxsYmFja1xuXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyBtYWtlIHN1cmUgXCJhc1wiIGRvZXNuJ3Qgc3RhcnQgd2l0aCBkb3VibGUgc2xhc2hlcyBvciBlbHNlIGl0IGNhblxuICAgICAgLy8gdGhyb3cgYW4gZXJyb3IgYXMgaXQncyBjb25zaWRlcmVkIGludmFsaWRcbiAgICAgIGlmIChhcy5zdWJzdHIoMCwgMikgIT09ICcvLycpIHtcbiAgICAgICAgLy8gaW4gb3JkZXIgZm9yIGBlLnN0YXRlYCB0byB3b3JrIG9uIHRoZSBgb25wb3BzdGF0ZWAgZXZlbnRcbiAgICAgICAgLy8gd2UgaGF2ZSB0byByZWdpc3RlciB0aGUgaW5pdGlhbCByb3V0ZSB1cG9uIGluaXRpYWxpemF0aW9uXG4gICAgICAgIHRoaXMuY2hhbmdlU3RhdGUoXG4gICAgICAgICAgJ3JlcGxhY2VTdGF0ZScsXG4gICAgICAgICAgZm9ybWF0V2l0aFZhbGlkYXRpb24oeyBwYXRobmFtZTogYWRkQmFzZVBhdGgocGF0aG5hbWUpLCBxdWVyeSB9KSxcbiAgICAgICAgICBnZXRVUkwoKVxuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwb3BzdGF0ZScsIHRoaXMub25Qb3BTdGF0ZSlcblxuICAgICAgLy8gZW5hYmxlIGN1c3RvbSBzY3JvbGwgcmVzdG9yYXRpb24gaGFuZGxpbmcgd2hlbiBhdmFpbGFibGVcbiAgICAgIC8vIG90aGVyd2lzZSBmYWxsYmFjayB0byBicm93c2VyJ3MgZGVmYXVsdCBoYW5kbGluZ1xuICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9TQ1JPTExfUkVTVE9SQVRJT04pIHtcbiAgICAgICAgaWYgKG1hbnVhbFNjcm9sbFJlc3RvcmF0aW9uKSB7XG4gICAgICAgICAgd2luZG93Lmhpc3Rvcnkuc2Nyb2xsUmVzdG9yYXRpb24gPSAnbWFudWFsJ1xuXG4gICAgICAgICAgbGV0IHNjcm9sbERlYm91bmNlVGltZW91dDogdW5kZWZpbmVkIHwgTm9kZUpTLlRpbWVvdXRcblxuICAgICAgICAgIGNvbnN0IGRlYm91bmNlZFNjcm9sbFNhdmUgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoc2Nyb2xsRGVib3VuY2VUaW1lb3V0KSBjbGVhclRpbWVvdXQoc2Nyb2xsRGVib3VuY2VUaW1lb3V0KVxuXG4gICAgICAgICAgICBzY3JvbGxEZWJvdW5jZVRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgeyB1cmwsIGFzOiBjdXJBcywgb3B0aW9ucyB9ID0gaGlzdG9yeS5zdGF0ZVxuICAgICAgICAgICAgICB0aGlzLmNoYW5nZVN0YXRlKFxuICAgICAgICAgICAgICAgICdyZXBsYWNlU3RhdGUnLFxuICAgICAgICAgICAgICAgIHVybCxcbiAgICAgICAgICAgICAgICBjdXJBcyxcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCB7XG4gICAgICAgICAgICAgICAgICBfTl9YOiB3aW5kb3cuc2Nyb2xsWCxcbiAgICAgICAgICAgICAgICAgIF9OX1k6IHdpbmRvdy5zY3JvbGxZLFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH0sIDEwKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBkZWJvdW5jZWRTY3JvbGxTYXZlKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgb25Qb3BTdGF0ZSA9IChlOiBQb3BTdGF0ZUV2ZW50KTogdm9pZCA9PiB7XG4gICAgY29uc3Qgc3RhdGUgPSBlLnN0YXRlIGFzIEhpc3RvcnlTdGF0ZVxuXG4gICAgaWYgKCFzdGF0ZSkge1xuICAgICAgLy8gV2UgZ2V0IHN0YXRlIGFzIHVuZGVmaW5lZCBmb3IgdHdvIHJlYXNvbnMuXG4gICAgICAvLyAgMS4gV2l0aCBvbGRlciBzYWZhcmkgKDwgOCkgYW5kIG9sZGVyIGNocm9tZSAoPCAzNClcbiAgICAgIC8vICAyLiBXaGVuIHRoZSBVUkwgY2hhbmdlZCB3aXRoICNcbiAgICAgIC8vXG4gICAgICAvLyBJbiB0aGUgYm90aCBjYXNlcywgd2UgZG9uJ3QgbmVlZCB0byBwcm9jZWVkIGFuZCBjaGFuZ2UgdGhlIHJvdXRlLlxuICAgICAgLy8gKGFzIGl0J3MgYWxyZWFkeSBjaGFuZ2VkKVxuICAgICAgLy8gQnV0IHdlIGNhbiBzaW1wbHkgcmVwbGFjZSB0aGUgc3RhdGUgd2l0aCB0aGUgbmV3IGNoYW5nZXMuXG4gICAgICAvLyBBY3R1YWxseSwgZm9yICgxKSB3ZSBkb24ndCBuZWVkIHRvIG5vdGhpbmcuIEJ1dCBpdCdzIGhhcmQgdG8gZGV0ZWN0IHRoYXQgZXZlbnQuXG4gICAgICAvLyBTbywgZG9pbmcgdGhlIGZvbGxvd2luZyBmb3IgKDEpIGRvZXMgbm8gaGFybS5cbiAgICAgIGNvbnN0IHsgcGF0aG5hbWUsIHF1ZXJ5IH0gPSB0aGlzXG4gICAgICB0aGlzLmNoYW5nZVN0YXRlKFxuICAgICAgICAncmVwbGFjZVN0YXRlJyxcbiAgICAgICAgZm9ybWF0V2l0aFZhbGlkYXRpb24oeyBwYXRobmFtZTogYWRkQmFzZVBhdGgocGF0aG5hbWUpLCBxdWVyeSB9KSxcbiAgICAgICAgZ2V0VVJMKClcbiAgICAgIClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmICghc3RhdGUuX19OKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCB7IHVybCwgYXMsIG9wdGlvbnMgfSA9IHN0YXRlXG5cbiAgICBjb25zdCB7IHBhdGhuYW1lIH0gPSBwYXJzZVJlbGF0aXZlVXJsKHVybClcblxuICAgIC8vIE1ha2Ugc3VyZSB3ZSBkb24ndCByZS1yZW5kZXIgb24gaW5pdGlhbCBsb2FkLFxuICAgIC8vIGNhbiBiZSBjYXVzZWQgYnkgbmF2aWdhdGluZyBiYWNrIGZyb20gYW4gZXh0ZXJuYWwgc2l0ZVxuICAgIGlmICh0aGlzLmlzU3NyICYmIGFzID09PSB0aGlzLmFzUGF0aCAmJiBwYXRobmFtZSA9PT0gdGhpcy5wYXRobmFtZSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIGRvd25zdHJlYW0gYXBwbGljYXRpb24gcmV0dXJucyBmYWxzeSwgcmV0dXJuLlxuICAgIC8vIFRoZXkgd2lsbCB0aGVuIGJlIHJlc3BvbnNpYmxlIGZvciBoYW5kbGluZyB0aGUgZXZlbnQuXG4gICAgaWYgKHRoaXMuX2JwcyAmJiAhdGhpcy5fYnBzKHN0YXRlKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy5jaGFuZ2UoJ3JlcGxhY2VTdGF0ZScsIHVybCwgYXMsIG9wdGlvbnMpXG4gIH1cblxuICB1cGRhdGUocm91dGU6IHN0cmluZywgbW9kOiBhbnkpIHtcbiAgICBjb25zdCBDb21wb25lbnQ6IENvbXBvbmVudFR5cGUgPSBtb2QuZGVmYXVsdCB8fCBtb2RcbiAgICBjb25zdCBkYXRhID0gdGhpcy5jb21wb25lbnRzW3JvdXRlXVxuICAgIGlmICghZGF0YSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgdXBkYXRlIHVuYXZhaWxhYmxlIHJvdXRlOiAke3JvdXRlfWApXG4gICAgfVxuXG4gICAgY29uc3QgbmV3RGF0YSA9IE9iamVjdC5hc3NpZ24oe30sIGRhdGEsIHtcbiAgICAgIENvbXBvbmVudCxcbiAgICAgIF9fTl9TU0c6IG1vZC5fX05fU1NHLFxuICAgICAgX19OX1NTUDogbW9kLl9fTl9TU1AsXG4gICAgfSlcbiAgICB0aGlzLmNvbXBvbmVudHNbcm91dGVdID0gbmV3RGF0YVxuXG4gICAgLy8gcGFnZXMvX2FwcC5qcyB1cGRhdGVkXG4gICAgaWYgKHJvdXRlID09PSAnL19hcHAnKSB7XG4gICAgICB0aGlzLm5vdGlmeSh0aGlzLmNvbXBvbmVudHNbdGhpcy5yb3V0ZV0pXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAocm91dGUgPT09IHRoaXMucm91dGUpIHtcbiAgICAgIHRoaXMubm90aWZ5KG5ld0RhdGEpXG4gICAgfVxuICB9XG5cbiAgcmVsb2FkKCk6IHZvaWQge1xuICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKVxuICB9XG5cbiAgLyoqXG4gICAqIEdvIGJhY2sgaW4gaGlzdG9yeVxuICAgKi9cbiAgYmFjaygpIHtcbiAgICB3aW5kb3cuaGlzdG9yeS5iYWNrKClcbiAgfVxuXG4gIC8qKlxuICAgKiBQZXJmb3JtcyBhIGBwdXNoU3RhdGVgIHdpdGggYXJndW1lbnRzXG4gICAqIEBwYXJhbSB1cmwgb2YgdGhlIHJvdXRlXG4gICAqIEBwYXJhbSBhcyBtYXNrcyBgdXJsYCBmb3IgdGhlIGJyb3dzZXJcbiAgICogQHBhcmFtIG9wdGlvbnMgb2JqZWN0IHlvdSBjYW4gZGVmaW5lIGBzaGFsbG93YCBhbmQgb3RoZXIgb3B0aW9uc1xuICAgKi9cbiAgcHVzaCh1cmw6IFVybCwgYXM6IFVybCA9IHVybCwgb3B0aW9uczogVHJhbnNpdGlvbk9wdGlvbnMgPSB7fSkge1xuICAgIDsoeyB1cmwsIGFzIH0gPSBwcmVwYXJlVXJsQXModGhpcywgdXJsLCBhcykpXG4gICAgcmV0dXJuIHRoaXMuY2hhbmdlKCdwdXNoU3RhdGUnLCB1cmwsIGFzLCBvcHRpb25zKVxuICB9XG5cbiAgLyoqXG4gICAqIFBlcmZvcm1zIGEgYHJlcGxhY2VTdGF0ZWAgd2l0aCBhcmd1bWVudHNcbiAgICogQHBhcmFtIHVybCBvZiB0aGUgcm91dGVcbiAgICogQHBhcmFtIGFzIG1hc2tzIGB1cmxgIGZvciB0aGUgYnJvd3NlclxuICAgKiBAcGFyYW0gb3B0aW9ucyBvYmplY3QgeW91IGNhbiBkZWZpbmUgYHNoYWxsb3dgIGFuZCBvdGhlciBvcHRpb25zXG4gICAqL1xuICByZXBsYWNlKHVybDogVXJsLCBhczogVXJsID0gdXJsLCBvcHRpb25zOiBUcmFuc2l0aW9uT3B0aW9ucyA9IHt9KSB7XG4gICAgOyh7IHVybCwgYXMgfSA9IHByZXBhcmVVcmxBcyh0aGlzLCB1cmwsIGFzKSlcbiAgICByZXR1cm4gdGhpcy5jaGFuZ2UoJ3JlcGxhY2VTdGF0ZScsIHVybCwgYXMsIG9wdGlvbnMpXG4gIH1cblxuICBhc3luYyBjaGFuZ2UoXG4gICAgbWV0aG9kOiBIaXN0b3J5TWV0aG9kLFxuICAgIHVybDogc3RyaW5nLFxuICAgIGFzOiBzdHJpbmcsXG4gICAgb3B0aW9uczogVHJhbnNpdGlvbk9wdGlvbnNcbiAgKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgaWYgKCFpc0xvY2FsVVJMKHVybCkpIHtcbiAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gdXJsXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICBpZiAoIShvcHRpb25zIGFzIGFueSkuX2gpIHtcbiAgICAgIHRoaXMuaXNTc3IgPSBmYWxzZVxuICAgIH1cbiAgICAvLyBtYXJraW5nIHJvdXRlIGNoYW5nZXMgYXMgYSBuYXZpZ2F0aW9uIHN0YXJ0IGVudHJ5XG4gICAgaWYgKFNUKSB7XG4gICAgICBwZXJmb3JtYW5jZS5tYXJrKCdyb3V0ZUNoYW5nZScpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2luRmxpZ2h0Um91dGUpIHtcbiAgICAgIHRoaXMuYWJvcnRDb21wb25lbnRMb2FkKHRoaXMuX2luRmxpZ2h0Um91dGUpXG4gICAgfVxuXG4gICAgY29uc3QgY2xlYW5lZEFzID0gaGFzQmFzZVBhdGgoYXMpID8gZGVsQmFzZVBhdGgoYXMpIDogYXNcbiAgICB0aGlzLl9pbkZsaWdodFJvdXRlID0gYXNcblxuICAgIC8vIElmIHRoZSB1cmwgY2hhbmdlIGlzIG9ubHkgcmVsYXRlZCB0byBhIGhhc2ggY2hhbmdlXG4gICAgLy8gV2Ugc2hvdWxkIG5vdCBwcm9jZWVkLiBXZSBzaG91bGQgb25seSBjaGFuZ2UgdGhlIHN0YXRlLlxuXG4gICAgLy8gV0FSTklORzogYF9oYCBpcyBhbiBpbnRlcm5hbCBvcHRpb24gZm9yIGhhbmRpbmcgTmV4dC5qcyBjbGllbnQtc2lkZVxuICAgIC8vIGh5ZHJhdGlvbi4gWW91ciBhcHAgc2hvdWxkIF9uZXZlcl8gdXNlIHRoaXMgcHJvcGVydHkuIEl0IG1heSBjaGFuZ2UgYXRcbiAgICAvLyBhbnkgdGltZSB3aXRob3V0IG5vdGljZS5cbiAgICBpZiAoIShvcHRpb25zIGFzIGFueSkuX2ggJiYgdGhpcy5vbmx5QUhhc2hDaGFuZ2UoY2xlYW5lZEFzKSkge1xuICAgICAgdGhpcy5hc1BhdGggPSBjbGVhbmVkQXNcbiAgICAgIFJvdXRlci5ldmVudHMuZW1pdCgnaGFzaENoYW5nZVN0YXJ0JywgYXMpXG4gICAgICB0aGlzLmNoYW5nZVN0YXRlKG1ldGhvZCwgdXJsLCBhcywgb3B0aW9ucylcbiAgICAgIHRoaXMuc2Nyb2xsVG9IYXNoKGNsZWFuZWRBcylcbiAgICAgIHRoaXMubm90aWZ5KHRoaXMuY29tcG9uZW50c1t0aGlzLnJvdXRlXSlcbiAgICAgIFJvdXRlci5ldmVudHMuZW1pdCgnaGFzaENoYW5nZUNvbXBsZXRlJywgYXMpXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIGNvbnN0IHBhcnNlZCA9IHRyeVBhcnNlUmVsYXRpdmVVcmwodXJsKVxuXG4gICAgaWYgKCFwYXJzZWQpIHJldHVybiBmYWxzZVxuXG4gICAgbGV0IHsgcGF0aG5hbWUsIHNlYXJjaFBhcmFtcyB9ID0gcGFyc2VkXG4gICAgY29uc3QgcXVlcnkgPSBzZWFyY2hQYXJhbXNUb1VybFF1ZXJ5KHNlYXJjaFBhcmFtcylcblxuICAgIC8vIHVybCBhbmQgYXMgc2hvdWxkIGFsd2F5cyBiZSBwcmVmaXhlZCB3aXRoIGJhc2VQYXRoIGJ5IHRoaXNcbiAgICAvLyBwb2ludCBieSBlaXRoZXIgbmV4dC9saW5rIG9yIHJvdXRlci5wdXNoL3JlcGxhY2Ugc28gc3RyaXAgdGhlXG4gICAgLy8gYmFzZVBhdGggZnJvbSB0aGUgcGF0aG5hbWUgdG8gbWF0Y2ggdGhlIHBhZ2VzIGRpciAxLXRvLTFcbiAgICBwYXRobmFtZSA9IHBhdGhuYW1lXG4gICAgICA/IHJlbW92ZVBhdGhUcmFpbGluZ1NsYXNoKGRlbEJhc2VQYXRoKHBhdGhuYW1lKSlcbiAgICAgIDogcGF0aG5hbWVcblxuICAgIC8vIElmIGFza2VkIHRvIGNoYW5nZSB0aGUgY3VycmVudCBVUkwgd2Ugc2hvdWxkIHJlbG9hZCB0aGUgY3VycmVudCBwYWdlXG4gICAgLy8gKG5vdCBsb2NhdGlvbi5yZWxvYWQoKSBidXQgcmVsb2FkIGdldEluaXRpYWxQcm9wcyBhbmQgb3RoZXIgTmV4dC5qcyBzdHVmZnMpXG4gICAgLy8gV2UgYWxzbyBuZWVkIHRvIHNldCB0aGUgbWV0aG9kID0gcmVwbGFjZVN0YXRlIGFsd2F5c1xuICAgIC8vIGFzIHRoaXMgc2hvdWxkIG5vdCBnbyBpbnRvIHRoZSBoaXN0b3J5IChUaGF0J3MgaG93IGJyb3dzZXJzIHdvcmspXG4gICAgLy8gV2Ugc2hvdWxkIGNvbXBhcmUgdGhlIG5ldyBhc1BhdGggdG8gdGhlIGN1cnJlbnQgYXNQYXRoLCBub3QgdGhlIHVybFxuICAgIGlmICghdGhpcy51cmxJc05ldyhjbGVhbmVkQXMpKSB7XG4gICAgICBtZXRob2QgPSAncmVwbGFjZVN0YXRlJ1xuICAgIH1cblxuICAgIGNvbnN0IHJvdXRlID0gcmVtb3ZlUGF0aFRyYWlsaW5nU2xhc2gocGF0aG5hbWUpXG4gICAgY29uc3QgeyBzaGFsbG93ID0gZmFsc2UgfSA9IG9wdGlvbnNcblxuICAgIGlmIChpc0R5bmFtaWNSb3V0ZShyb3V0ZSkpIHtcbiAgICAgIGNvbnN0IHsgcGF0aG5hbWU6IGFzUGF0aG5hbWUgfSA9IHBhcnNlUmVsYXRpdmVVcmwoY2xlYW5lZEFzKVxuICAgICAgY29uc3Qgcm91dGVSZWdleCA9IGdldFJvdXRlUmVnZXgocm91dGUpXG4gICAgICBjb25zdCByb3V0ZU1hdGNoID0gZ2V0Um91dGVNYXRjaGVyKHJvdXRlUmVnZXgpKGFzUGF0aG5hbWUpXG4gICAgICBpZiAoIXJvdXRlTWF0Y2gpIHtcbiAgICAgICAgY29uc3QgbWlzc2luZ1BhcmFtcyA9IE9iamVjdC5rZXlzKHJvdXRlUmVnZXguZ3JvdXBzKS5maWx0ZXIoXG4gICAgICAgICAgKHBhcmFtKSA9PiAhcXVlcnlbcGFyYW1dXG4gICAgICAgIClcblxuICAgICAgICBpZiAobWlzc2luZ1BhcmFtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgYE1pc21hdGNoaW5nIFxcYGFzXFxgIGFuZCBcXGBocmVmXFxgIGZhaWxlZCB0byBtYW51YWxseSBwcm92aWRlIGAgK1xuICAgICAgICAgICAgICAgIGB0aGUgcGFyYW1zOiAke21pc3NpbmdQYXJhbXMuam9pbihcbiAgICAgICAgICAgICAgICAgICcsICdcbiAgICAgICAgICAgICAgICApfSBpbiB0aGUgXFxgaHJlZlxcYCdzIFxcYHF1ZXJ5XFxgYFxuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBUaGUgcHJvdmlkZWQgXFxgYXNcXGAgdmFsdWUgKCR7YXNQYXRobmFtZX0pIGlzIGluY29tcGF0aWJsZSB3aXRoIHRoZSBcXGBocmVmXFxgIHZhbHVlICgke3JvdXRlfSkuIGAgK1xuICAgICAgICAgICAgICBgUmVhZCBtb3JlOiBodHRwczovL2Vyci5zaC92ZXJjZWwvbmV4dC5qcy9pbmNvbXBhdGlibGUtaHJlZi1hc2BcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE1lcmdlIHBhcmFtcyBpbnRvIGBxdWVyeWAsIG92ZXJ3cml0aW5nIGFueSBzcGVjaWZpZWQgaW4gc2VhcmNoXG4gICAgICAgIE9iamVjdC5hc3NpZ24ocXVlcnksIHJvdXRlTWF0Y2gpXG4gICAgICB9XG4gICAgfVxuXG4gICAgUm91dGVyLmV2ZW50cy5lbWl0KCdyb3V0ZUNoYW5nZVN0YXJ0JywgYXMpXG5cbiAgICB0cnkge1xuICAgICAgY29uc3Qgcm91dGVJbmZvID0gYXdhaXQgdGhpcy5nZXRSb3V0ZUluZm8oXG4gICAgICAgIHJvdXRlLFxuICAgICAgICBwYXRobmFtZSxcbiAgICAgICAgcXVlcnksXG4gICAgICAgIGFzLFxuICAgICAgICBzaGFsbG93XG4gICAgICApXG4gICAgICBjb25zdCB7IGVycm9yIH0gPSByb3V0ZUluZm9cblxuICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KCdiZWZvcmVIaXN0b3J5Q2hhbmdlJywgYXMpXG4gICAgICB0aGlzLmNoYW5nZVN0YXRlKG1ldGhvZCwgdXJsLCBhcywgb3B0aW9ucylcblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgY29uc3QgYXBwQ29tcDogYW55ID0gdGhpcy5jb21wb25lbnRzWycvX2FwcCddLkNvbXBvbmVudFxuICAgICAgICA7KHdpbmRvdyBhcyBhbnkpLm5leHQuaXNQcmVyZW5kZXJlZCA9XG4gICAgICAgICAgYXBwQ29tcC5nZXRJbml0aWFsUHJvcHMgPT09IGFwcENvbXAub3JpZ0dldEluaXRpYWxQcm9wcyAmJlxuICAgICAgICAgICEocm91dGVJbmZvLkNvbXBvbmVudCBhcyBhbnkpLmdldEluaXRpYWxQcm9wc1xuICAgICAgfVxuXG4gICAgICBhd2FpdCB0aGlzLnNldChyb3V0ZSwgcGF0aG5hbWUhLCBxdWVyeSwgY2xlYW5lZEFzLCByb3V0ZUluZm8pXG5cbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoJ3JvdXRlQ2hhbmdlRXJyb3InLCBlcnJvciwgY2xlYW5lZEFzKVxuICAgICAgICB0aHJvdyBlcnJvclxuICAgICAgfVxuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX1NDUk9MTF9SRVNUT1JBVElPTikge1xuICAgICAgICBpZiAobWFudWFsU2Nyb2xsUmVzdG9yYXRpb24gJiYgJ19OX1gnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICB3aW5kb3cuc2Nyb2xsVG8oKG9wdGlvbnMgYXMgYW55KS5fTl9YLCAob3B0aW9ucyBhcyBhbnkpLl9OX1kpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFJvdXRlci5ldmVudHMuZW1pdCgncm91dGVDaGFuZ2VDb21wbGV0ZScsIGFzKVxuXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKGVyci5jYW5jZWxsZWQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJcbiAgICB9XG4gIH1cblxuICBjaGFuZ2VTdGF0ZShcbiAgICBtZXRob2Q6IEhpc3RvcnlNZXRob2QsXG4gICAgdXJsOiBzdHJpbmcsXG4gICAgYXM6IHN0cmluZyxcbiAgICBvcHRpb25zOiBUcmFuc2l0aW9uT3B0aW9ucyA9IHt9XG4gICk6IHZvaWQge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAodHlwZW9mIHdpbmRvdy5oaXN0b3J5ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBXYXJuaW5nOiB3aW5kb3cuaGlzdG9yeSBpcyBub3QgYXZhaWxhYmxlLmApXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHdpbmRvdy5oaXN0b3J5W21ldGhvZF0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYFdhcm5pbmc6IHdpbmRvdy5oaXN0b3J5LiR7bWV0aG9kfSBpcyBub3QgYXZhaWxhYmxlYClcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG1ldGhvZCAhPT0gJ3B1c2hTdGF0ZScgfHwgZ2V0VVJMKCkgIT09IGFzKSB7XG4gICAgICB3aW5kb3cuaGlzdG9yeVttZXRob2RdKFxuICAgICAgICB7XG4gICAgICAgICAgdXJsLFxuICAgICAgICAgIGFzLFxuICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgX19OOiB0cnVlLFxuICAgICAgICB9IGFzIEhpc3RvcnlTdGF0ZSxcbiAgICAgICAgLy8gTW9zdCBicm93c2VycyBjdXJyZW50bHkgaWdub3JlcyB0aGlzIHBhcmFtZXRlciwgYWx0aG91Z2ggdGhleSBtYXkgdXNlIGl0IGluIHRoZSBmdXR1cmUuXG4gICAgICAgIC8vIFBhc3NpbmcgdGhlIGVtcHR5IHN0cmluZyBoZXJlIHNob3VsZCBiZSBzYWZlIGFnYWluc3QgZnV0dXJlIGNoYW5nZXMgdG8gdGhlIG1ldGhvZC5cbiAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0hpc3RvcnkvcmVwbGFjZVN0YXRlXG4gICAgICAgICcnLFxuICAgICAgICBhc1xuICAgICAgKVxuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGhhbmRsZVJvdXRlSW5mb0Vycm9yKFxuICAgIGVycjogRXJyb3IgJiB7IGNvZGU6IGFueTsgY2FuY2VsbGVkOiBib29sZWFuIH0sXG4gICAgcGF0aG5hbWU6IHN0cmluZyxcbiAgICBxdWVyeTogUGFyc2VkVXJsUXVlcnksXG4gICAgYXM6IHN0cmluZyxcbiAgICBsb2FkRXJyb3JGYWlsPzogYm9vbGVhblxuICApOiBQcm9taXNlPFJvdXRlSW5mbz4ge1xuICAgIGlmIChlcnIuY2FuY2VsbGVkKSB7XG4gICAgICAvLyBidWJibGUgdXAgY2FuY2VsbGF0aW9uIGVycm9yc1xuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuXG4gICAgaWYgKFBBR0VfTE9BRF9FUlJPUiBpbiBlcnIgfHwgbG9hZEVycm9yRmFpbCkge1xuICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KCdyb3V0ZUNoYW5nZUVycm9yJywgZXJyLCBhcylcblxuICAgICAgLy8gSWYgd2UgY2FuJ3QgbG9hZCB0aGUgcGFnZSBpdCBjb3VsZCBiZSBvbmUgb2YgZm9sbG93aW5nIHJlYXNvbnNcbiAgICAgIC8vICAxLiBQYWdlIGRvZXNuJ3QgZXhpc3RzXG4gICAgICAvLyAgMi4gUGFnZSBkb2VzIGV4aXN0IGluIGEgZGlmZmVyZW50IHpvbmVcbiAgICAgIC8vICAzLiBJbnRlcm5hbCBlcnJvciB3aGlsZSBsb2FkaW5nIHRoZSBwYWdlXG5cbiAgICAgIC8vIFNvLCBkb2luZyBhIGhhcmQgcmVsb2FkIGlzIHRoZSBwcm9wZXIgd2F5IHRvIGRlYWwgd2l0aCB0aGlzLlxuICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBhc1xuXG4gICAgICAvLyBDaGFuZ2luZyB0aGUgVVJMIGRvZXNuJ3QgYmxvY2sgZXhlY3V0aW5nIHRoZSBjdXJyZW50IGNvZGUgcGF0aC5cbiAgICAgIC8vIFNvIGxldCdzIHRocm93IGEgY2FuY2VsbGF0aW9uIGVycm9yIHN0b3AgdGhlIHJvdXRpbmcgbG9naWMuXG4gICAgICB0aHJvdyBidWlsZENhbmNlbGxhdGlvbkVycm9yKClcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgeyBwYWdlOiBDb21wb25lbnQgfSA9IGF3YWl0IHRoaXMuZmV0Y2hDb21wb25lbnQoJy9fZXJyb3InKVxuICAgICAgY29uc3Qgcm91dGVJbmZvOiBSb3V0ZUluZm8gPSB7IENvbXBvbmVudCwgZXJyLCBlcnJvcjogZXJyIH1cblxuICAgICAgdHJ5IHtcbiAgICAgICAgcm91dGVJbmZvLnByb3BzID0gYXdhaXQgdGhpcy5nZXRJbml0aWFsUHJvcHMoQ29tcG9uZW50LCB7XG4gICAgICAgICAgZXJyLFxuICAgICAgICAgIHBhdGhuYW1lLFxuICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICB9IGFzIGFueSlcbiAgICAgIH0gY2F0Y2ggKGdpcEVycikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiBlcnJvciBwYWdlIGBnZXRJbml0aWFsUHJvcHNgOiAnLCBnaXBFcnIpXG4gICAgICAgIHJvdXRlSW5mby5wcm9wcyA9IHt9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByb3V0ZUluZm9cbiAgICB9IGNhdGNoIChyb3V0ZUluZm9FcnIpIHtcbiAgICAgIHJldHVybiB0aGlzLmhhbmRsZVJvdXRlSW5mb0Vycm9yKHJvdXRlSW5mb0VyciwgcGF0aG5hbWUsIHF1ZXJ5LCBhcywgdHJ1ZSlcbiAgICB9XG4gIH1cblxuICBhc3luYyBnZXRSb3V0ZUluZm8oXG4gICAgcm91dGU6IHN0cmluZyxcbiAgICBwYXRobmFtZTogc3RyaW5nLFxuICAgIHF1ZXJ5OiBhbnksXG4gICAgYXM6IHN0cmluZyxcbiAgICBzaGFsbG93OiBib29sZWFuID0gZmFsc2VcbiAgKTogUHJvbWlzZTxSb3V0ZUluZm8+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgY2FjaGVkUm91dGVJbmZvID0gdGhpcy5jb21wb25lbnRzW3JvdXRlXVxuXG4gICAgICBpZiAoc2hhbGxvdyAmJiBjYWNoZWRSb3V0ZUluZm8gJiYgdGhpcy5yb3V0ZSA9PT0gcm91dGUpIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlZFJvdXRlSW5mb1xuICAgICAgfVxuXG4gICAgICBjb25zdCByb3V0ZUluZm8gPSBjYWNoZWRSb3V0ZUluZm9cbiAgICAgICAgPyBjYWNoZWRSb3V0ZUluZm9cbiAgICAgICAgOiBhd2FpdCB0aGlzLmZldGNoQ29tcG9uZW50KHJvdXRlKS50aGVuKFxuICAgICAgICAgICAgKHJlcykgPT5cbiAgICAgICAgICAgICAgKHtcbiAgICAgICAgICAgICAgICBDb21wb25lbnQ6IHJlcy5wYWdlLFxuICAgICAgICAgICAgICAgIF9fTl9TU0c6IHJlcy5tb2QuX19OX1NTRyxcbiAgICAgICAgICAgICAgICBfX05fU1NQOiByZXMubW9kLl9fTl9TU1AsXG4gICAgICAgICAgICAgIH0gYXMgUm91dGVJbmZvKVxuICAgICAgICAgIClcblxuICAgICAgY29uc3QgeyBDb21wb25lbnQsIF9fTl9TU0csIF9fTl9TU1AgfSA9IHJvdXRlSW5mb1xuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBjb25zdCB7IGlzVmFsaWRFbGVtZW50VHlwZSB9ID0gcmVxdWlyZSgncmVhY3QtaXMnKVxuICAgICAgICBpZiAoIWlzVmFsaWRFbGVtZW50VHlwZShDb21wb25lbnQpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYFRoZSBkZWZhdWx0IGV4cG9ydCBpcyBub3QgYSBSZWFjdCBDb21wb25lbnQgaW4gcGFnZTogXCIke3BhdGhuYW1lfVwiYFxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsZXQgZGF0YUhyZWY6IHN0cmluZyB8IHVuZGVmaW5lZFxuXG4gICAgICBpZiAoX19OX1NTRyB8fCBfX05fU1NQKSB7XG4gICAgICAgIGRhdGFIcmVmID0gdGhpcy5wYWdlTG9hZGVyLmdldERhdGFIcmVmKFxuICAgICAgICAgIGZvcm1hdFdpdGhWYWxpZGF0aW9uKHsgcGF0aG5hbWUsIHF1ZXJ5IH0pLFxuICAgICAgICAgIGFzLFxuICAgICAgICAgIF9fTl9TU0dcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICBjb25zdCBwcm9wcyA9IGF3YWl0IHRoaXMuX2dldERhdGE8Um91dGVJbmZvPigoKSA9PlxuICAgICAgICBfX05fU1NHXG4gICAgICAgICAgPyB0aGlzLl9nZXRTdGF0aWNEYXRhKGRhdGFIcmVmISlcbiAgICAgICAgICA6IF9fTl9TU1BcbiAgICAgICAgICA/IHRoaXMuX2dldFNlcnZlckRhdGEoZGF0YUhyZWYhKVxuICAgICAgICAgIDogdGhpcy5nZXRJbml0aWFsUHJvcHMoXG4gICAgICAgICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgICAgICAgLy8gd2UgcHJvdmlkZSBBcHBUcmVlIGxhdGVyIHNvIHRoaXMgbmVlZHMgdG8gYmUgYGFueWBcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHBhdGhuYW1lLFxuICAgICAgICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgICAgICAgIGFzUGF0aDogYXMsXG4gICAgICAgICAgICAgIH0gYXMgYW55XG4gICAgICAgICAgICApXG4gICAgICApXG4gICAgICByb3V0ZUluZm8ucHJvcHMgPSBwcm9wc1xuICAgICAgdGhpcy5jb21wb25lbnRzW3JvdXRlXSA9IHJvdXRlSW5mb1xuICAgICAgcmV0dXJuIHJvdXRlSW5mb1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlUm91dGVJbmZvRXJyb3IoZXJyLCBwYXRobmFtZSwgcXVlcnksIGFzKVxuICAgIH1cbiAgfVxuXG4gIHNldChcbiAgICByb3V0ZTogc3RyaW5nLFxuICAgIHBhdGhuYW1lOiBzdHJpbmcsXG4gICAgcXVlcnk6IFBhcnNlZFVybFF1ZXJ5LFxuICAgIGFzOiBzdHJpbmcsXG4gICAgZGF0YTogUm91dGVJbmZvXG4gICk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRoaXMuaXNGYWxsYmFjayA9IGZhbHNlXG5cbiAgICB0aGlzLnJvdXRlID0gcm91dGVcbiAgICB0aGlzLnBhdGhuYW1lID0gcGF0aG5hbWVcbiAgICB0aGlzLnF1ZXJ5ID0gcXVlcnlcbiAgICB0aGlzLmFzUGF0aCA9IGFzXG4gICAgcmV0dXJuIHRoaXMubm90aWZ5KGRhdGEpXG4gIH1cblxuICAvKipcbiAgICogQ2FsbGJhY2sgdG8gZXhlY3V0ZSBiZWZvcmUgcmVwbGFjaW5nIHJvdXRlciBzdGF0ZVxuICAgKiBAcGFyYW0gY2IgY2FsbGJhY2sgdG8gYmUgZXhlY3V0ZWRcbiAgICovXG4gIGJlZm9yZVBvcFN0YXRlKGNiOiBCZWZvcmVQb3BTdGF0ZUNhbGxiYWNrKSB7XG4gICAgdGhpcy5fYnBzID0gY2JcbiAgfVxuXG4gIG9ubHlBSGFzaENoYW5nZShhczogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgaWYgKCF0aGlzLmFzUGF0aCkgcmV0dXJuIGZhbHNlXG4gICAgY29uc3QgW29sZFVybE5vSGFzaCwgb2xkSGFzaF0gPSB0aGlzLmFzUGF0aC5zcGxpdCgnIycpXG4gICAgY29uc3QgW25ld1VybE5vSGFzaCwgbmV3SGFzaF0gPSBhcy5zcGxpdCgnIycpXG5cbiAgICAvLyBNYWtlcyBzdXJlIHdlIHNjcm9sbCB0byB0aGUgcHJvdmlkZWQgaGFzaCBpZiB0aGUgdXJsL2hhc2ggYXJlIHRoZSBzYW1lXG4gICAgaWYgKG5ld0hhc2ggJiYgb2xkVXJsTm9IYXNoID09PSBuZXdVcmxOb0hhc2ggJiYgb2xkSGFzaCA9PT0gbmV3SGFzaCkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgdXJscyBhcmUgY2hhbmdlLCB0aGVyZSdzIG1vcmUgdGhhbiBhIGhhc2ggY2hhbmdlXG4gICAgaWYgKG9sZFVybE5vSGFzaCAhPT0gbmV3VXJsTm9IYXNoKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgaGFzaCBoYXMgY2hhbmdlZCwgdGhlbiBpdCdzIGEgaGFzaCBvbmx5IGNoYW5nZS5cbiAgICAvLyBUaGlzIGNoZWNrIGlzIG5lY2Vzc2FyeSB0byBoYW5kbGUgYm90aCB0aGUgZW50ZXIgYW5kXG4gICAgLy8gbGVhdmUgaGFzaCA9PT0gJycgY2FzZXMuIFRoZSBpZGVudGl0eSBjYXNlIGZhbGxzIHRocm91Z2hcbiAgICAvLyBhbmQgaXMgdHJlYXRlZCBhcyBhIG5leHQgcmVsb2FkLlxuICAgIHJldHVybiBvbGRIYXNoICE9PSBuZXdIYXNoXG4gIH1cblxuICBzY3JvbGxUb0hhc2goYXM6IHN0cmluZyk6IHZvaWQge1xuICAgIGNvbnN0IFssIGhhc2hdID0gYXMuc3BsaXQoJyMnKVxuICAgIC8vIFNjcm9sbCB0byB0b3AgaWYgdGhlIGhhc2ggaXMganVzdCBgI2Agd2l0aCBubyB2YWx1ZVxuICAgIGlmIChoYXNoID09PSAnJykge1xuICAgICAgd2luZG93LnNjcm9sbFRvKDAsIDApXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBGaXJzdCB3ZSBjaGVjayBpZiB0aGUgZWxlbWVudCBieSBpZCBpcyBmb3VuZFxuICAgIGNvbnN0IGlkRWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChoYXNoKVxuICAgIGlmIChpZEVsKSB7XG4gICAgICBpZEVsLnNjcm9sbEludG9WaWV3KClcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICAvLyBJZiB0aGVyZSdzIG5vIGVsZW1lbnQgd2l0aCB0aGUgaWQsIHdlIGNoZWNrIHRoZSBgbmFtZWAgcHJvcGVydHlcbiAgICAvLyBUbyBtaXJyb3IgYnJvd3NlcnNcbiAgICBjb25zdCBuYW1lRWwgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZShoYXNoKVswXVxuICAgIGlmIChuYW1lRWwpIHtcbiAgICAgIG5hbWVFbC5zY3JvbGxJbnRvVmlldygpXG4gICAgfVxuICB9XG5cbiAgdXJsSXNOZXcoYXNQYXRoOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5hc1BhdGggIT09IGFzUGF0aFxuICB9XG5cbiAgLyoqXG4gICAqIFByZWZldGNoIHBhZ2UgY29kZSwgeW91IG1heSB3YWl0IGZvciB0aGUgZGF0YSBkdXJpbmcgcGFnZSByZW5kZXJpbmcuXG4gICAqIFRoaXMgZmVhdHVyZSBvbmx5IHdvcmtzIGluIHByb2R1Y3Rpb24hXG4gICAqIEBwYXJhbSB1cmwgdGhlIGhyZWYgb2YgcHJlZmV0Y2hlZCBwYWdlXG4gICAqIEBwYXJhbSBhc1BhdGggdGhlIGFzIHBhdGggb2YgdGhlIHByZWZldGNoZWQgcGFnZVxuICAgKi9cbiAgYXN5bmMgcHJlZmV0Y2goXG4gICAgdXJsOiBzdHJpbmcsXG4gICAgYXNQYXRoOiBzdHJpbmcgPSB1cmwsXG4gICAgb3B0aW9uczogUHJlZmV0Y2hPcHRpb25zID0ge31cbiAgKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgcGFyc2VkID0gdHJ5UGFyc2VSZWxhdGl2ZVVybCh1cmwpXG5cbiAgICBpZiAoIXBhcnNlZCkgcmV0dXJuXG5cbiAgICBjb25zdCB7IHBhdGhuYW1lIH0gPSBwYXJzZWRcblxuICAgIC8vIFByZWZldGNoIGlzIG5vdCBzdXBwb3J0ZWQgaW4gZGV2ZWxvcG1lbnQgbW9kZSBiZWNhdXNlIGl0IHdvdWxkIHRyaWdnZXIgb24tZGVtYW5kLWVudHJpZXNcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3Qgcm91dGUgPSByZW1vdmVQYXRoVHJhaWxpbmdTbGFzaChwYXRobmFtZSlcbiAgICBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICB0aGlzLnBhZ2VMb2FkZXIucHJlZmV0Y2hEYXRhKHVybCwgYXNQYXRoKSxcbiAgICAgIHRoaXMucGFnZUxvYWRlcltvcHRpb25zLnByaW9yaXR5ID8gJ2xvYWRQYWdlJyA6ICdwcmVmZXRjaCddKHJvdXRlKSxcbiAgICBdKVxuICB9XG5cbiAgYXN5bmMgZmV0Y2hDb21wb25lbnQocm91dGU6IHN0cmluZyk6IFByb21pc2U8Q29tcG9uZW50UmVzPiB7XG4gICAgbGV0IGNhbmNlbGxlZCA9IGZhbHNlXG4gICAgY29uc3QgY2FuY2VsID0gKHRoaXMuY2xjID0gKCkgPT4ge1xuICAgICAgY2FuY2VsbGVkID0gdHJ1ZVxuICAgIH0pXG5cbiAgICBjb25zdCBjb21wb25lbnRSZXN1bHQgPSBhd2FpdCB0aGlzLnBhZ2VMb2FkZXIubG9hZFBhZ2Uocm91dGUpXG5cbiAgICBpZiAoY2FuY2VsbGVkKSB7XG4gICAgICBjb25zdCBlcnJvcjogYW55ID0gbmV3IEVycm9yKFxuICAgICAgICBgQWJvcnQgZmV0Y2hpbmcgY29tcG9uZW50IGZvciByb3V0ZTogXCIke3JvdXRlfVwiYFxuICAgICAgKVxuICAgICAgZXJyb3IuY2FuY2VsbGVkID0gdHJ1ZVxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG5cbiAgICBpZiAoY2FuY2VsID09PSB0aGlzLmNsYykge1xuICAgICAgdGhpcy5jbGMgPSBudWxsXG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbXBvbmVudFJlc3VsdFxuICB9XG5cbiAgX2dldERhdGE8VD4oZm46ICgpID0+IFByb21pc2U8VD4pOiBQcm9taXNlPFQ+IHtcbiAgICBsZXQgY2FuY2VsbGVkID0gZmFsc2VcbiAgICBjb25zdCBjYW5jZWwgPSAoKSA9PiB7XG4gICAgICBjYW5jZWxsZWQgPSB0cnVlXG4gICAgfVxuICAgIHRoaXMuY2xjID0gY2FuY2VsXG4gICAgcmV0dXJuIGZuKCkudGhlbigoZGF0YSkgPT4ge1xuICAgICAgaWYgKGNhbmNlbCA9PT0gdGhpcy5jbGMpIHtcbiAgICAgICAgdGhpcy5jbGMgPSBudWxsXG4gICAgICB9XG5cbiAgICAgIGlmIChjYW5jZWxsZWQpIHtcbiAgICAgICAgY29uc3QgZXJyOiBhbnkgPSBuZXcgRXJyb3IoJ0xvYWRpbmcgaW5pdGlhbCBwcm9wcyBjYW5jZWxsZWQnKVxuICAgICAgICBlcnIuY2FuY2VsbGVkID0gdHJ1ZVxuICAgICAgICB0aHJvdyBlcnJcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRhdGFcbiAgICB9KVxuICB9XG5cbiAgX2dldFN0YXRpY0RhdGEoZGF0YUhyZWY6IHN0cmluZyk6IFByb21pc2U8b2JqZWN0PiB7XG4gICAgY29uc3QgeyBocmVmOiBjYWNoZUtleSB9ID0gbmV3IFVSTChkYXRhSHJlZiwgd2luZG93LmxvY2F0aW9uLmhyZWYpXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicgJiYgdGhpcy5zZGNbY2FjaGVLZXldKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuc2RjW2NhY2hlS2V5XSlcbiAgICB9XG4gICAgcmV0dXJuIGZldGNoTmV4dERhdGEoZGF0YUhyZWYsIHRoaXMuaXNTc3IpLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgIHRoaXMuc2RjW2NhY2hlS2V5XSA9IGRhdGFcbiAgICAgIHJldHVybiBkYXRhXG4gICAgfSlcbiAgfVxuXG4gIF9nZXRTZXJ2ZXJEYXRhKGRhdGFIcmVmOiBzdHJpbmcpOiBQcm9taXNlPG9iamVjdD4ge1xuICAgIHJldHVybiBmZXRjaE5leHREYXRhKGRhdGFIcmVmLCB0aGlzLmlzU3NyKVxuICB9XG5cbiAgZ2V0SW5pdGlhbFByb3BzKFxuICAgIENvbXBvbmVudDogQ29tcG9uZW50VHlwZSxcbiAgICBjdHg6IE5leHRQYWdlQ29udGV4dFxuICApOiBQcm9taXNlPGFueT4ge1xuICAgIGNvbnN0IHsgQ29tcG9uZW50OiBBcHAgfSA9IHRoaXMuY29tcG9uZW50c1snL19hcHAnXVxuICAgIGNvbnN0IEFwcFRyZWUgPSB0aGlzLl93cmFwQXBwKEFwcClcbiAgICBjdHguQXBwVHJlZSA9IEFwcFRyZWVcbiAgICByZXR1cm4gbG9hZEdldEluaXRpYWxQcm9wczxBcHBDb250ZXh0VHlwZTxSb3V0ZXI+PihBcHAsIHtcbiAgICAgIEFwcFRyZWUsXG4gICAgICBDb21wb25lbnQsXG4gICAgICByb3V0ZXI6IHRoaXMsXG4gICAgICBjdHgsXG4gICAgfSlcbiAgfVxuXG4gIGFib3J0Q29tcG9uZW50TG9hZChhczogc3RyaW5nKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuY2xjKSB7XG4gICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoJ3JvdXRlQ2hhbmdlRXJyb3InLCBidWlsZENhbmNlbGxhdGlvbkVycm9yKCksIGFzKVxuICAgICAgdGhpcy5jbGMoKVxuICAgICAgdGhpcy5jbGMgPSBudWxsXG4gICAgfVxuICB9XG5cbiAgbm90aWZ5KGRhdGE6IFJvdXRlSW5mbyk6IFByb21pc2U8dm9pZD4ge1xuICAgIHJldHVybiB0aGlzLnN1YihkYXRhLCB0aGlzLmNvbXBvbmVudHNbJy9fYXBwJ10uQ29tcG9uZW50KVxuICB9XG59XG4iLCIvLyBGb3JtYXQgZnVuY3Rpb24gbW9kaWZpZWQgZnJvbSBub2RlanNcbi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5pbXBvcnQgeyBVcmxPYmplY3QgfSBmcm9tICd1cmwnXG5pbXBvcnQgeyBQYXJzZWRVcmxRdWVyeSB9IGZyb20gJ3F1ZXJ5c3RyaW5nJ1xuaW1wb3J0ICogYXMgcXVlcnlzdHJpbmcgZnJvbSAnLi9xdWVyeXN0cmluZydcblxuY29uc3Qgc2xhc2hlZFByb3RvY29scyA9IC9odHRwcz98ZnRwfGdvcGhlcnxmaWxlL1xuXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0VXJsKHVybE9iajogVXJsT2JqZWN0KSB7XG4gIGxldCB7IGF1dGgsIGhvc3RuYW1lIH0gPSB1cmxPYmpcbiAgbGV0IHByb3RvY29sID0gdXJsT2JqLnByb3RvY29sIHx8ICcnXG4gIGxldCBwYXRobmFtZSA9IHVybE9iai5wYXRobmFtZSB8fCAnJ1xuICBsZXQgaGFzaCA9IHVybE9iai5oYXNoIHx8ICcnXG4gIGxldCBxdWVyeSA9IHVybE9iai5xdWVyeSB8fCAnJ1xuICBsZXQgaG9zdDogc3RyaW5nIHwgZmFsc2UgPSBmYWxzZVxuXG4gIGF1dGggPSBhdXRoID8gZW5jb2RlVVJJQ29tcG9uZW50KGF1dGgpLnJlcGxhY2UoLyUzQS9pLCAnOicpICsgJ0AnIDogJydcblxuICBpZiAodXJsT2JqLmhvc3QpIHtcbiAgICBob3N0ID0gYXV0aCArIHVybE9iai5ob3N0XG4gIH0gZWxzZSBpZiAoaG9zdG5hbWUpIHtcbiAgICBob3N0ID0gYXV0aCArICh+aG9zdG5hbWUuaW5kZXhPZignOicpID8gYFske2hvc3RuYW1lfV1gIDogaG9zdG5hbWUpXG4gICAgaWYgKHVybE9iai5wb3J0KSB7XG4gICAgICBob3N0ICs9ICc6JyArIHVybE9iai5wb3J0XG4gICAgfVxuICB9XG5cbiAgaWYgKHF1ZXJ5ICYmIHR5cGVvZiBxdWVyeSA9PT0gJ29iamVjdCcpIHtcbiAgICBxdWVyeSA9IFN0cmluZyhxdWVyeXN0cmluZy51cmxRdWVyeVRvU2VhcmNoUGFyYW1zKHF1ZXJ5IGFzIFBhcnNlZFVybFF1ZXJ5KSlcbiAgfVxuXG4gIGxldCBzZWFyY2ggPSB1cmxPYmouc2VhcmNoIHx8IChxdWVyeSAmJiBgPyR7cXVlcnl9YCkgfHwgJydcblxuICBpZiAocHJvdG9jb2wgJiYgcHJvdG9jb2wuc3Vic3RyKC0xKSAhPT0gJzonKSBwcm90b2NvbCArPSAnOidcblxuICBpZiAoXG4gICAgdXJsT2JqLnNsYXNoZXMgfHxcbiAgICAoKCFwcm90b2NvbCB8fCBzbGFzaGVkUHJvdG9jb2xzLnRlc3QocHJvdG9jb2wpKSAmJiBob3N0ICE9PSBmYWxzZSlcbiAgKSB7XG4gICAgaG9zdCA9ICcvLycgKyAoaG9zdCB8fCAnJylcbiAgICBpZiAocGF0aG5hbWUgJiYgcGF0aG5hbWVbMF0gIT09ICcvJykgcGF0aG5hbWUgPSAnLycgKyBwYXRobmFtZVxuICB9IGVsc2UgaWYgKCFob3N0KSB7XG4gICAgaG9zdCA9ICcnXG4gIH1cblxuICBpZiAoaGFzaCAmJiBoYXNoWzBdICE9PSAnIycpIGhhc2ggPSAnIycgKyBoYXNoXG4gIGlmIChzZWFyY2ggJiYgc2VhcmNoWzBdICE9PSAnPycpIHNlYXJjaCA9ICc/JyArIHNlYXJjaFxuXG4gIHBhdGhuYW1lID0gcGF0aG5hbWUucmVwbGFjZSgvWz8jXS9nLCBlbmNvZGVVUklDb21wb25lbnQpXG4gIHNlYXJjaCA9IHNlYXJjaC5yZXBsYWNlKCcjJywgJyUyMycpXG5cbiAgcmV0dXJuIGAke3Byb3RvY29sfSR7aG9zdH0ke3BhdGhuYW1lfSR7c2VhcmNofSR7aGFzaH1gXG59XG4iLCIvLyBJZGVudGlmeSAvW3BhcmFtXS8gaW4gcm91dGUgc3RyaW5nXG5jb25zdCBURVNUX1JPVVRFID0gL1xcL1xcW1teL10rP1xcXSg/PVxcL3wkKS9cblxuZXhwb3J0IGZ1bmN0aW9uIGlzRHluYW1pY1JvdXRlKHJvdXRlOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgcmV0dXJuIFRFU1RfUk9VVEUudGVzdChyb3V0ZSlcbn1cbiIsImltcG9ydCB7IGdldExvY2F0aW9uT3JpZ2luIH0gZnJvbSAnLi4vLi4vdXRpbHMnXG5cbmNvbnN0IERVTU1ZX0JBU0UgPSBuZXcgVVJMKFxuICB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/ICdodHRwOi8vbicgOiBnZXRMb2NhdGlvbk9yaWdpbigpXG4pXG5cbi8qKlxuICogUGFyc2VzIHBhdGgtcmVsYXRpdmUgdXJscyAoZS5nLiBgL2hlbGxvL3dvcmxkP2Zvbz1iYXJgKS4gSWYgdXJsIGlzbid0IHBhdGgtcmVsYXRpdmVcbiAqIChlLmcuIGAuL2hlbGxvYCkgdGhlbiBhdCBsZWFzdCBiYXNlIG11c3QgYmUuXG4gKiBBYnNvbHV0ZSB1cmxzIGFyZSByZWplY3RlZCB3aXRoIG9uZSBleGNlcHRpb24sIGluIHRoZSBicm93c2VyLCBhYnNvbHV0ZSB1cmxzIHRoYXQgYXJlIG9uXG4gKiB0aGUgY3VycmVudCBvcmlnaW4gd2lsbCBiZSBwYXJzZWQgYXMgcmVsYXRpdmVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlUmVsYXRpdmVVcmwodXJsOiBzdHJpbmcsIGJhc2U/OiBzdHJpbmcpIHtcbiAgY29uc3QgcmVzb2x2ZWRCYXNlID0gYmFzZSA/IG5ldyBVUkwoYmFzZSwgRFVNTVlfQkFTRSkgOiBEVU1NWV9CQVNFXG4gIGNvbnN0IHtcbiAgICBwYXRobmFtZSxcbiAgICBzZWFyY2hQYXJhbXMsXG4gICAgc2VhcmNoLFxuICAgIGhhc2gsXG4gICAgaHJlZixcbiAgICBvcmlnaW4sXG4gICAgcHJvdG9jb2wsXG4gIH0gPSBuZXcgVVJMKHVybCwgcmVzb2x2ZWRCYXNlKVxuICBpZiAoXG4gICAgb3JpZ2luICE9PSBEVU1NWV9CQVNFLm9yaWdpbiB8fFxuICAgIChwcm90b2NvbCAhPT0gJ2h0dHA6JyAmJiBwcm90b2NvbCAhPT0gJ2h0dHBzOicpXG4gICkge1xuICAgIHRocm93IG5ldyBFcnJvcignaW52YXJpYW50OiBpbnZhbGlkIHJlbGF0aXZlIFVSTCcpXG4gIH1cbiAgcmV0dXJuIHtcbiAgICBwYXRobmFtZSxcbiAgICBzZWFyY2hQYXJhbXMsXG4gICAgc2VhcmNoLFxuICAgIGhhc2gsXG4gICAgaHJlZjogaHJlZi5zbGljZShEVU1NWV9CQVNFLm9yaWdpbi5sZW5ndGgpLFxuICB9XG59XG4iLCJpbXBvcnQgeyBQYXJzZWRVcmxRdWVyeSB9IGZyb20gJ3F1ZXJ5c3RyaW5nJ1xuXG5leHBvcnQgZnVuY3Rpb24gc2VhcmNoUGFyYW1zVG9VcmxRdWVyeShcbiAgc2VhcmNoUGFyYW1zOiBVUkxTZWFyY2hQYXJhbXNcbik6IFBhcnNlZFVybFF1ZXJ5IHtcbiAgY29uc3QgcXVlcnk6IFBhcnNlZFVybFF1ZXJ5ID0ge31cbiAgc2VhcmNoUGFyYW1zLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICBpZiAodHlwZW9mIHF1ZXJ5W2tleV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBxdWVyeVtrZXldID0gdmFsdWVcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocXVlcnlba2V5XSkpIHtcbiAgICAgIDsocXVlcnlba2V5XSBhcyBzdHJpbmdbXSkucHVzaCh2YWx1ZSlcbiAgICB9IGVsc2Uge1xuICAgICAgcXVlcnlba2V5XSA9IFtxdWVyeVtrZXldIGFzIHN0cmluZywgdmFsdWVdXG4gICAgfVxuICB9KVxuICByZXR1cm4gcXVlcnlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVybFF1ZXJ5VG9TZWFyY2hQYXJhbXMoXG4gIHVybFF1ZXJ5OiBQYXJzZWRVcmxRdWVyeVxuKTogVVJMU2VhcmNoUGFyYW1zIHtcbiAgY29uc3QgcmVzdWx0ID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpXG4gIE9iamVjdC5lbnRyaWVzKHVybFF1ZXJ5KS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHZhbHVlLmZvckVhY2goKGl0ZW0pID0+IHJlc3VsdC5hcHBlbmQoa2V5LCBpdGVtKSlcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnNldChrZXksIHZhbHVlKVxuICAgIH1cbiAgfSlcbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5leHBvcnQgZnVuY3Rpb24gYXNzaWduKFxuICB0YXJnZXQ6IFVSTFNlYXJjaFBhcmFtcyxcbiAgLi4uc2VhcmNoUGFyYW1zTGlzdDogVVJMU2VhcmNoUGFyYW1zW11cbik6IFVSTFNlYXJjaFBhcmFtcyB7XG4gIHNlYXJjaFBhcmFtc0xpc3QuZm9yRWFjaCgoc2VhcmNoUGFyYW1zKSA9PiB7XG4gICAgQXJyYXkuZnJvbShzZWFyY2hQYXJhbXMua2V5cygpKS5mb3JFYWNoKChrZXkpID0+IHRhcmdldC5kZWxldGUoa2V5KSlcbiAgICBzZWFyY2hQYXJhbXMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4gdGFyZ2V0LmFwcGVuZChrZXksIHZhbHVlKSlcbiAgfSlcbiAgcmV0dXJuIHRhcmdldFxufVxuIiwiaW1wb3J0IHsgZ2V0Um91dGVSZWdleCB9IGZyb20gJy4vcm91dGUtcmVnZXgnXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRSb3V0ZU1hdGNoZXIocm91dGVSZWdleDogUmV0dXJuVHlwZTx0eXBlb2YgZ2V0Um91dGVSZWdleD4pIHtcbiAgY29uc3QgeyByZSwgZ3JvdXBzIH0gPSByb3V0ZVJlZ2V4XG4gIHJldHVybiAocGF0aG5hbWU6IHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWQpID0+IHtcbiAgICBjb25zdCByb3V0ZU1hdGNoID0gcmUuZXhlYyhwYXRobmFtZSEpXG4gICAgaWYgKCFyb3V0ZU1hdGNoKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICBjb25zdCBkZWNvZGUgPSAocGFyYW06IHN0cmluZykgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChwYXJhbSlcbiAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgY29uc3QgZXJyOiBFcnJvciAmIHsgY29kZT86IHN0cmluZyB9ID0gbmV3IEVycm9yKFxuICAgICAgICAgICdmYWlsZWQgdG8gZGVjb2RlIHBhcmFtJ1xuICAgICAgICApXG4gICAgICAgIGVyci5jb2RlID0gJ0RFQ09ERV9GQUlMRUQnXG4gICAgICAgIHRocm93IGVyclxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBwYXJhbXM6IHsgW3BhcmFtTmFtZTogc3RyaW5nXTogc3RyaW5nIHwgc3RyaW5nW10gfSA9IHt9XG5cbiAgICBPYmplY3Qua2V5cyhncm91cHMpLmZvckVhY2goKHNsdWdOYW1lOiBzdHJpbmcpID0+IHtcbiAgICAgIGNvbnN0IGcgPSBncm91cHNbc2x1Z05hbWVdXG4gICAgICBjb25zdCBtID0gcm91dGVNYXRjaFtnLnBvc11cbiAgICAgIGlmIChtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcGFyYW1zW3NsdWdOYW1lXSA9IH5tLmluZGV4T2YoJy8nKVxuICAgICAgICAgID8gbS5zcGxpdCgnLycpLm1hcCgoZW50cnkpID0+IGRlY29kZShlbnRyeSkpXG4gICAgICAgICAgOiBnLnJlcGVhdFxuICAgICAgICAgID8gW2RlY29kZShtKV1cbiAgICAgICAgICA6IGRlY29kZShtKVxuICAgICAgfVxuICAgIH0pXG4gICAgcmV0dXJuIHBhcmFtc1xuICB9XG59XG4iLCJpbnRlcmZhY2UgR3JvdXAge1xuICBwb3M6IG51bWJlclxuICByZXBlYXQ6IGJvb2xlYW5cbiAgb3B0aW9uYWw6IGJvb2xlYW5cbn1cblxuLy8gdGhpcyBpc24ndCBpbXBvcnRpbmcgdGhlIGVzY2FwZS1zdHJpbmctcmVnZXggbW9kdWxlXG4vLyB0byByZWR1Y2UgYnl0ZXNcbmZ1bmN0aW9uIGVzY2FwZVJlZ2V4KHN0cjogc3RyaW5nKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvW3xcXFxce30oKVtcXF1eJCsqPy4tXS9nLCAnXFxcXCQmJylcbn1cblxuZnVuY3Rpb24gcGFyc2VQYXJhbWV0ZXIocGFyYW06IHN0cmluZykge1xuICBjb25zdCBvcHRpb25hbCA9IHBhcmFtLnN0YXJ0c1dpdGgoJ1snKSAmJiBwYXJhbS5lbmRzV2l0aCgnXScpXG4gIGlmIChvcHRpb25hbCkge1xuICAgIHBhcmFtID0gcGFyYW0uc2xpY2UoMSwgLTEpXG4gIH1cbiAgY29uc3QgcmVwZWF0ID0gcGFyYW0uc3RhcnRzV2l0aCgnLi4uJylcbiAgaWYgKHJlcGVhdCkge1xuICAgIHBhcmFtID0gcGFyYW0uc2xpY2UoMylcbiAgfVxuICByZXR1cm4geyBrZXk6IHBhcmFtLCByZXBlYXQsIG9wdGlvbmFsIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFJvdXRlUmVnZXgoXG4gIG5vcm1hbGl6ZWRSb3V0ZTogc3RyaW5nXG4pOiB7XG4gIHJlOiBSZWdFeHBcbiAgbmFtZWRSZWdleD86IHN0cmluZ1xuICByb3V0ZUtleXM/OiB7IFtuYW1lZDogc3RyaW5nXTogc3RyaW5nIH1cbiAgZ3JvdXBzOiB7IFtncm91cE5hbWU6IHN0cmluZ106IEdyb3VwIH1cbn0ge1xuICBjb25zdCBzZWdtZW50cyA9IChub3JtYWxpemVkUm91dGUucmVwbGFjZSgvXFwvJC8sICcnKSB8fCAnLycpXG4gICAgLnNsaWNlKDEpXG4gICAgLnNwbGl0KCcvJylcblxuICBjb25zdCBncm91cHM6IHsgW2dyb3VwTmFtZTogc3RyaW5nXTogR3JvdXAgfSA9IHt9XG4gIGxldCBncm91cEluZGV4ID0gMVxuICBjb25zdCBwYXJhbWV0ZXJpemVkUm91dGUgPSBzZWdtZW50c1xuICAgIC5tYXAoKHNlZ21lbnQpID0+IHtcbiAgICAgIGlmIChzZWdtZW50LnN0YXJ0c1dpdGgoJ1snKSAmJiBzZWdtZW50LmVuZHNXaXRoKCddJykpIHtcbiAgICAgICAgY29uc3QgeyBrZXksIG9wdGlvbmFsLCByZXBlYXQgfSA9IHBhcnNlUGFyYW1ldGVyKHNlZ21lbnQuc2xpY2UoMSwgLTEpKVxuICAgICAgICBncm91cHNba2V5XSA9IHsgcG9zOiBncm91cEluZGV4KyssIHJlcGVhdCwgb3B0aW9uYWwgfVxuICAgICAgICByZXR1cm4gcmVwZWF0ID8gKG9wdGlvbmFsID8gJyg/Oi8oLis/KSk/JyA6ICcvKC4rPyknKSA6ICcvKFteL10rPyknXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYC8ke2VzY2FwZVJlZ2V4KHNlZ21lbnQpfWBcbiAgICAgIH1cbiAgICB9KVxuICAgIC5qb2luKCcnKVxuXG4gIC8vIGRlYWQgY29kZSBlbGltaW5hdGUgZm9yIGJyb3dzZXIgc2luY2UgaXQncyBvbmx5IG5lZWRlZFxuICAvLyB3aGlsZSBnZW5lcmF0aW5nIHJvdXRlcy1tYW5pZmVzdFxuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBsZXQgcm91dGVLZXlDaGFyQ29kZSA9IDk3XG4gICAgbGV0IHJvdXRlS2V5Q2hhckxlbmd0aCA9IDFcblxuICAgIC8vIGJ1aWxkcyBhIG1pbmltYWwgcm91dGVLZXkgdXNpbmcgb25seSBhLXogYW5kIG1pbmltYWwgbnVtYmVyIG9mIGNoYXJhY3RlcnNcbiAgICBjb25zdCBnZXRTYWZlUm91dGVLZXkgPSAoKSA9PiB7XG4gICAgICBsZXQgcm91dGVLZXkgPSAnJ1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJvdXRlS2V5Q2hhckxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJvdXRlS2V5ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUocm91dGVLZXlDaGFyQ29kZSlcbiAgICAgICAgcm91dGVLZXlDaGFyQ29kZSsrXG5cbiAgICAgICAgaWYgKHJvdXRlS2V5Q2hhckNvZGUgPiAxMjIpIHtcbiAgICAgICAgICByb3V0ZUtleUNoYXJMZW5ndGgrK1xuICAgICAgICAgIHJvdXRlS2V5Q2hhckNvZGUgPSA5N1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcm91dGVLZXlcbiAgICB9XG5cbiAgICBjb25zdCByb3V0ZUtleXM6IHsgW25hbWVkOiBzdHJpbmddOiBzdHJpbmcgfSA9IHt9XG5cbiAgICBsZXQgbmFtZWRQYXJhbWV0ZXJpemVkUm91dGUgPSBzZWdtZW50c1xuICAgICAgLm1hcCgoc2VnbWVudCkgPT4ge1xuICAgICAgICBpZiAoc2VnbWVudC5zdGFydHNXaXRoKCdbJykgJiYgc2VnbWVudC5lbmRzV2l0aCgnXScpKSB7XG4gICAgICAgICAgY29uc3QgeyBrZXksIG9wdGlvbmFsLCByZXBlYXQgfSA9IHBhcnNlUGFyYW1ldGVyKHNlZ21lbnQuc2xpY2UoMSwgLTEpKVxuICAgICAgICAgIC8vIHJlcGxhY2UgYW55IG5vbi13b3JkIGNoYXJhY3RlcnMgc2luY2UgdGhleSBjYW4gYnJlYWtcbiAgICAgICAgICAvLyB0aGUgbmFtZWQgcmVnZXhcbiAgICAgICAgICBsZXQgY2xlYW5lZEtleSA9IGtleS5yZXBsYWNlKC9cXFcvZywgJycpXG4gICAgICAgICAgbGV0IGludmFsaWRLZXkgPSBmYWxzZVxuXG4gICAgICAgICAgLy8gY2hlY2sgaWYgdGhlIGtleSBpcyBzdGlsbCBpbnZhbGlkIGFuZCBmYWxsYmFjayB0byB1c2luZyBhIGtub3duXG4gICAgICAgICAgLy8gc2FmZSBrZXlcbiAgICAgICAgICBpZiAoY2xlYW5lZEtleS5sZW5ndGggPT09IDAgfHwgY2xlYW5lZEtleS5sZW5ndGggPiAzMCkge1xuICAgICAgICAgICAgaW52YWxpZEtleSA9IHRydWVcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFpc05hTihwYXJzZUludChjbGVhbmVkS2V5LnN1YnN0cigwLCAxKSkpKSB7XG4gICAgICAgICAgICBpbnZhbGlkS2V5ID0gdHJ1ZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpbnZhbGlkS2V5KSB7XG4gICAgICAgICAgICBjbGVhbmVkS2V5ID0gZ2V0U2FmZVJvdXRlS2V5KClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByb3V0ZUtleXNbY2xlYW5lZEtleV0gPSBrZXlcbiAgICAgICAgICByZXR1cm4gcmVwZWF0XG4gICAgICAgICAgICA/IG9wdGlvbmFsXG4gICAgICAgICAgICAgID8gYCg/Oi8oPzwke2NsZWFuZWRLZXl9Pi4rPykpP2BcbiAgICAgICAgICAgICAgOiBgLyg/PCR7Y2xlYW5lZEtleX0+Lis/KWBcbiAgICAgICAgICAgIDogYC8oPzwke2NsZWFuZWRLZXl9PlteL10rPylgXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGAvJHtlc2NhcGVSZWdleChzZWdtZW50KX1gXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICAuam9pbignJylcblxuICAgIHJldHVybiB7XG4gICAgICByZTogbmV3IFJlZ0V4cChgXiR7cGFyYW1ldGVyaXplZFJvdXRlfSg/Oi8pPyRgKSxcbiAgICAgIGdyb3VwcyxcbiAgICAgIHJvdXRlS2V5cyxcbiAgICAgIG5hbWVkUmVnZXg6IGBeJHtuYW1lZFBhcmFtZXRlcml6ZWRSb3V0ZX0oPzovKT8kYCxcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHJlOiBuZXcgUmVnRXhwKGBeJHtwYXJhbWV0ZXJpemVkUm91dGV9KD86Lyk/JGApLFxuICAgIGdyb3VwcyxcbiAgfVxufVxuIiwiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0J1xuXG5jb25zdCBpc1NlcnZlciA9IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnXG5cbnR5cGUgU3RhdGUgPSBKU1guRWxlbWVudFtdIHwgdW5kZWZpbmVkXG5cbnR5cGUgU2lkZUVmZmVjdFByb3BzID0ge1xuICByZWR1Y2VDb21wb25lbnRzVG9TdGF0ZTogPFQ+KFxuICAgIGNvbXBvbmVudHM6IEFycmF5PFJlYWN0LlJlYWN0RWxlbWVudDxhbnk+PixcbiAgICBwcm9wczogVFxuICApID0+IFN0YXRlXG4gIGhhbmRsZVN0YXRlQ2hhbmdlPzogKHN0YXRlOiBTdGF0ZSkgPT4gdm9pZFxuICBoZWFkTWFuYWdlcjogYW55XG4gIGluQW1wTW9kZT86IGJvb2xlYW5cbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgZXh0ZW5kcyBDb21wb25lbnQ8U2lkZUVmZmVjdFByb3BzPiB7XG4gIHByaXZhdGUgX2hhc0hlYWRNYW5hZ2VyOiBib29sZWFuXG5cbiAgZW1pdENoYW5nZSA9ICgpOiB2b2lkID0+IHtcbiAgICBpZiAodGhpcy5faGFzSGVhZE1hbmFnZXIpIHtcbiAgICAgIHRoaXMucHJvcHMuaGVhZE1hbmFnZXIudXBkYXRlSGVhZChcbiAgICAgICAgdGhpcy5wcm9wcy5yZWR1Y2VDb21wb25lbnRzVG9TdGF0ZShcbiAgICAgICAgICBbLi4udGhpcy5wcm9wcy5oZWFkTWFuYWdlci5tb3VudGVkSW5zdGFuY2VzXSxcbiAgICAgICAgICB0aGlzLnByb3BzXG4gICAgICAgIClcbiAgICAgIClcbiAgICB9XG4gIH1cblxuICBjb25zdHJ1Y3Rvcihwcm9wczogYW55KSB7XG4gICAgc3VwZXIocHJvcHMpXG4gICAgdGhpcy5faGFzSGVhZE1hbmFnZXIgPVxuICAgICAgdGhpcy5wcm9wcy5oZWFkTWFuYWdlciAmJiB0aGlzLnByb3BzLmhlYWRNYW5hZ2VyLm1vdW50ZWRJbnN0YW5jZXNcblxuICAgIGlmIChpc1NlcnZlciAmJiB0aGlzLl9oYXNIZWFkTWFuYWdlcikge1xuICAgICAgdGhpcy5wcm9wcy5oZWFkTWFuYWdlci5tb3VudGVkSW5zdGFuY2VzLmFkZCh0aGlzKVxuICAgICAgdGhpcy5lbWl0Q2hhbmdlKClcbiAgICB9XG4gIH1cbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgaWYgKHRoaXMuX2hhc0hlYWRNYW5hZ2VyKSB7XG4gICAgICB0aGlzLnByb3BzLmhlYWRNYW5hZ2VyLm1vdW50ZWRJbnN0YW5jZXMuYWRkKHRoaXMpXG4gICAgfVxuICAgIHRoaXMuZW1pdENoYW5nZSgpXG4gIH1cbiAgY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgIHRoaXMuZW1pdENoYW5nZSgpXG4gIH1cbiAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgaWYgKHRoaXMuX2hhc0hlYWRNYW5hZ2VyKSB7XG4gICAgICB0aGlzLnByb3BzLmhlYWRNYW5hZ2VyLm1vdW50ZWRJbnN0YW5jZXMuZGVsZXRlKHRoaXMpXG4gICAgfVxuICAgIHRoaXMuZW1pdENoYW5nZSgpXG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxufVxuIiwiaW1wb3J0IHsgSW5jb21pbmdNZXNzYWdlLCBTZXJ2ZXJSZXNwb25zZSB9IGZyb20gJ2h0dHAnXG5pbXBvcnQgeyBQYXJzZWRVcmxRdWVyeSB9IGZyb20gJ3F1ZXJ5c3RyaW5nJ1xuaW1wb3J0IHsgQ29tcG9uZW50VHlwZSB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgVXJsT2JqZWN0IH0gZnJvbSAndXJsJ1xuaW1wb3J0IHsgZm9ybWF0VXJsIH0gZnJvbSAnLi9yb3V0ZXIvdXRpbHMvZm9ybWF0LXVybCdcbmltcG9ydCB7IE1hbmlmZXN0SXRlbSB9IGZyb20gJy4uL3NlcnZlci9sb2FkLWNvbXBvbmVudHMnXG5pbXBvcnQgeyBOZXh0Um91dGVyIH0gZnJvbSAnLi9yb3V0ZXIvcm91dGVyJ1xuaW1wb3J0IHsgRW52IH0gZnJvbSAnLi4vLi4vbGliL2xvYWQtZW52LWNvbmZpZydcbmltcG9ydCB7IEJ1aWxkTWFuaWZlc3QgfSBmcm9tICcuLi9zZXJ2ZXIvZ2V0LXBhZ2UtZmlsZXMnXG5cbi8qKlxuICogVHlwZXMgdXNlZCBieSBib3RoIG5leHQgYW5kIG5leHQtc2VydmVyXG4gKi9cblxuZXhwb3J0IHR5cGUgTmV4dENvbXBvbmVudFR5cGU8XG4gIEMgZXh0ZW5kcyBCYXNlQ29udGV4dCA9IE5leHRQYWdlQ29udGV4dCxcbiAgSVAgPSB7fSxcbiAgUCA9IHt9XG4+ID0gQ29tcG9uZW50VHlwZTxQPiAmIHtcbiAgLyoqXG4gICAqIFVzZWQgZm9yIGluaXRpYWwgcGFnZSBsb2FkIGRhdGEgcG9wdWxhdGlvbi4gRGF0YSByZXR1cm5lZCBmcm9tIGBnZXRJbml0aWFsUHJvcHNgIGlzIHNlcmlhbGl6ZWQgd2hlbiBzZXJ2ZXIgcmVuZGVyZWQuXG4gICAqIE1ha2Ugc3VyZSB0byByZXR1cm4gcGxhaW4gYE9iamVjdGAgd2l0aG91dCB1c2luZyBgRGF0ZWAsIGBNYXBgLCBgU2V0YC5cbiAgICogQHBhcmFtIGN0eCBDb250ZXh0IG9mIGBwYWdlYFxuICAgKi9cbiAgZ2V0SW5pdGlhbFByb3BzPyhjb250ZXh0OiBDKTogSVAgfCBQcm9taXNlPElQPlxufVxuXG5leHBvcnQgdHlwZSBEb2N1bWVudFR5cGUgPSBOZXh0Q29tcG9uZW50VHlwZTxcbiAgRG9jdW1lbnRDb250ZXh0LFxuICBEb2N1bWVudEluaXRpYWxQcm9wcyxcbiAgRG9jdW1lbnRQcm9wc1xuPiAmIHtcbiAgcmVuZGVyRG9jdW1lbnQoXG4gICAgRG9jdW1lbnQ6IERvY3VtZW50VHlwZSxcbiAgICBwcm9wczogRG9jdW1lbnRQcm9wc1xuICApOiBSZWFjdC5SZWFjdEVsZW1lbnRcbn1cblxuZXhwb3J0IHR5cGUgQXBwVHlwZSA9IE5leHRDb21wb25lbnRUeXBlPFxuICBBcHBDb250ZXh0VHlwZSxcbiAgQXBwSW5pdGlhbFByb3BzLFxuICBBcHBQcm9wc1R5cGVcbj5cblxuZXhwb3J0IHR5cGUgQXBwVHJlZVR5cGUgPSBDb21wb25lbnRUeXBlPFxuICBBcHBJbml0aWFsUHJvcHMgJiB7IFtuYW1lOiBzdHJpbmddOiBhbnkgfVxuPlxuXG4vKipcbiAqIFdlYiB2aXRhbHMgcHJvdmlkZWQgdG8gX2FwcC5yZXBvcnRXZWJWaXRhbHMgYnkgQ29yZSBXZWIgVml0YWxzIHBsdWdpbiBkZXZlbG9wZWQgYnkgR29vZ2xlIENocm9tZSB0ZWFtLlxuICogaHR0cHM6Ly9uZXh0anMub3JnL2Jsb2cvbmV4dC05LTQjaW50ZWdyYXRlZC13ZWItdml0YWxzLXJlcG9ydGluZ1xuICovXG5leHBvcnQgdHlwZSBOZXh0V2ViVml0YWxzTWV0cmljID0ge1xuICBpZDogc3RyaW5nXG4gIGxhYmVsOiBzdHJpbmdcbiAgbmFtZTogc3RyaW5nXG4gIHN0YXJ0VGltZTogbnVtYmVyXG4gIHZhbHVlOiBudW1iZXJcbn1cblxuZXhwb3J0IHR5cGUgRW5oYW5jZXI8Qz4gPSAoQ29tcG9uZW50OiBDKSA9PiBDXG5cbmV4cG9ydCB0eXBlIENvbXBvbmVudHNFbmhhbmNlciA9XG4gIHwge1xuICAgICAgZW5oYW5jZUFwcD86IEVuaGFuY2VyPEFwcFR5cGU+XG4gICAgICBlbmhhbmNlQ29tcG9uZW50PzogRW5oYW5jZXI8TmV4dENvbXBvbmVudFR5cGU+XG4gICAgfVxuICB8IEVuaGFuY2VyPE5leHRDb21wb25lbnRUeXBlPlxuXG5leHBvcnQgdHlwZSBSZW5kZXJQYWdlUmVzdWx0ID0ge1xuICBodG1sOiBzdHJpbmdcbiAgaGVhZD86IEFycmF5PEpTWC5FbGVtZW50IHwgbnVsbD5cbn1cblxuZXhwb3J0IHR5cGUgUmVuZGVyUGFnZSA9IChcbiAgb3B0aW9ucz86IENvbXBvbmVudHNFbmhhbmNlclxuKSA9PiBSZW5kZXJQYWdlUmVzdWx0IHwgUHJvbWlzZTxSZW5kZXJQYWdlUmVzdWx0PlxuXG5leHBvcnQgdHlwZSBCYXNlQ29udGV4dCA9IHtcbiAgcmVzPzogU2VydmVyUmVzcG9uc2VcbiAgW2s6IHN0cmluZ106IGFueVxufVxuXG5leHBvcnQgdHlwZSBORVhUX0RBVEEgPSB7XG4gIHByb3BzOiBhbnlcbiAgcGFnZTogc3RyaW5nXG4gIHF1ZXJ5OiBQYXJzZWRVcmxRdWVyeVxuICBidWlsZElkOiBzdHJpbmdcbiAgYXNzZXRQcmVmaXg/OiBzdHJpbmdcbiAgcnVudGltZUNvbmZpZz86IHsgW2tleTogc3RyaW5nXTogYW55IH1cbiAgbmV4dEV4cG9ydD86IGJvb2xlYW5cbiAgYXV0b0V4cG9ydD86IGJvb2xlYW5cbiAgaXNGYWxsYmFjaz86IGJvb2xlYW5cbiAgZHluYW1pY0lkcz86IHN0cmluZ1tdXG4gIGVycj86IEVycm9yICYgeyBzdGF0dXNDb2RlPzogbnVtYmVyIH1cbiAgZ3NwPzogYm9vbGVhblxuICBnc3NwPzogYm9vbGVhblxuICBjdXN0b21TZXJ2ZXI/OiBib29sZWFuXG4gIGdpcD86IGJvb2xlYW5cbiAgYXBwR2lwPzogYm9vbGVhblxufVxuXG4vKipcbiAqIGBOZXh0YCBjb250ZXh0XG4gKi9cbi8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZSBpbnRlcmZhY2UtbmFtZVxuZXhwb3J0IGludGVyZmFjZSBOZXh0UGFnZUNvbnRleHQge1xuICAvKipcbiAgICogRXJyb3Igb2JqZWN0IGlmIGVuY291bnRlcmVkIGR1cmluZyByZW5kZXJpbmdcbiAgICovXG4gIGVycj86IChFcnJvciAmIHsgc3RhdHVzQ29kZT86IG51bWJlciB9KSB8IG51bGxcbiAgLyoqXG4gICAqIGBIVFRQYCByZXF1ZXN0IG9iamVjdC5cbiAgICovXG4gIHJlcT86IEluY29taW5nTWVzc2FnZVxuICAvKipcbiAgICogYEhUVFBgIHJlc3BvbnNlIG9iamVjdC5cbiAgICovXG4gIHJlcz86IFNlcnZlclJlc3BvbnNlXG4gIC8qKlxuICAgKiBQYXRoIHNlY3Rpb24gb2YgYFVSTGAuXG4gICAqL1xuICBwYXRobmFtZTogc3RyaW5nXG4gIC8qKlxuICAgKiBRdWVyeSBzdHJpbmcgc2VjdGlvbiBvZiBgVVJMYCBwYXJzZWQgYXMgYW4gb2JqZWN0LlxuICAgKi9cbiAgcXVlcnk6IFBhcnNlZFVybFF1ZXJ5XG4gIC8qKlxuICAgKiBgU3RyaW5nYCBvZiB0aGUgYWN0dWFsIHBhdGggaW5jbHVkaW5nIHF1ZXJ5LlxuICAgKi9cbiAgYXNQYXRoPzogc3RyaW5nXG4gIC8qKlxuICAgKiBgQ29tcG9uZW50YCB0aGUgdHJlZSBvZiB0aGUgQXBwIHRvIHVzZSBpZiBuZWVkaW5nIHRvIHJlbmRlciBzZXBhcmF0ZWx5XG4gICAqL1xuICBBcHBUcmVlOiBBcHBUcmVlVHlwZVxufVxuXG5leHBvcnQgdHlwZSBBcHBDb250ZXh0VHlwZTxSIGV4dGVuZHMgTmV4dFJvdXRlciA9IE5leHRSb3V0ZXI+ID0ge1xuICBDb21wb25lbnQ6IE5leHRDb21wb25lbnRUeXBlPE5leHRQYWdlQ29udGV4dD5cbiAgQXBwVHJlZTogQXBwVHJlZVR5cGVcbiAgY3R4OiBOZXh0UGFnZUNvbnRleHRcbiAgcm91dGVyOiBSXG59XG5cbmV4cG9ydCB0eXBlIEFwcEluaXRpYWxQcm9wcyA9IHtcbiAgcGFnZVByb3BzOiBhbnlcbn1cblxuZXhwb3J0IHR5cGUgQXBwUHJvcHNUeXBlPFxuICBSIGV4dGVuZHMgTmV4dFJvdXRlciA9IE5leHRSb3V0ZXIsXG4gIFAgPSB7fVxuPiA9IEFwcEluaXRpYWxQcm9wcyAmIHtcbiAgQ29tcG9uZW50OiBOZXh0Q29tcG9uZW50VHlwZTxOZXh0UGFnZUNvbnRleHQsIGFueSwgUD5cbiAgcm91dGVyOiBSXG4gIF9fTl9TU0c/OiBib29sZWFuXG4gIF9fTl9TU1A/OiBib29sZWFuXG59XG5cbmV4cG9ydCB0eXBlIERvY3VtZW50Q29udGV4dCA9IE5leHRQYWdlQ29udGV4dCAmIHtcbiAgcmVuZGVyUGFnZTogUmVuZGVyUGFnZVxufVxuXG5leHBvcnQgdHlwZSBEb2N1bWVudEluaXRpYWxQcm9wcyA9IFJlbmRlclBhZ2VSZXN1bHQgJiB7XG4gIHN0eWxlcz86IFJlYWN0LlJlYWN0RWxlbWVudFtdIHwgUmVhY3QuUmVhY3RGcmFnbWVudFxufVxuXG5leHBvcnQgdHlwZSBEb2N1bWVudFByb3BzID0gRG9jdW1lbnRJbml0aWFsUHJvcHMgJiB7XG4gIF9fTkVYVF9EQVRBX186IE5FWFRfREFUQVxuICBkYW5nZXJvdXNBc1BhdGg6IHN0cmluZ1xuICBidWlsZE1hbmlmZXN0OiBCdWlsZE1hbmlmZXN0XG4gIGFtcFBhdGg6IHN0cmluZ1xuICBpbkFtcE1vZGU6IGJvb2xlYW5cbiAgaHlicmlkQW1wOiBib29sZWFuXG4gIGlzRGV2ZWxvcG1lbnQ6IGJvb2xlYW5cbiAgZmlsZXM6IHN0cmluZ1tdXG4gIGR5bmFtaWNJbXBvcnRzOiBNYW5pZmVzdEl0ZW1bXVxuICBhc3NldFByZWZpeD86IHN0cmluZ1xuICBjYW5vbmljYWxCYXNlOiBzdHJpbmdcbiAgaGVhZFRhZ3M6IGFueVtdXG4gIHVuc3RhYmxlX3J1bnRpbWVKUz86IGZhbHNlXG4gIGRldk9ubHlDYWNoZUJ1c3RlclF1ZXJ5U3RyaW5nOiBzdHJpbmdcbn1cblxuLyoqXG4gKiBOZXh0IGBBUElgIHJvdXRlIHJlcXVlc3RcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBOZXh0QXBpUmVxdWVzdCBleHRlbmRzIEluY29taW5nTWVzc2FnZSB7XG4gIC8qKlxuICAgKiBPYmplY3Qgb2YgYHF1ZXJ5YCB2YWx1ZXMgZnJvbSB1cmxcbiAgICovXG4gIHF1ZXJ5OiB7XG4gICAgW2tleTogc3RyaW5nXTogc3RyaW5nIHwgc3RyaW5nW11cbiAgfVxuICAvKipcbiAgICogT2JqZWN0IG9mIGBjb29raWVzYCBmcm9tIGhlYWRlclxuICAgKi9cbiAgY29va2llczoge1xuICAgIFtrZXk6IHN0cmluZ106IHN0cmluZ1xuICB9XG5cbiAgYm9keTogYW55XG5cbiAgZW52OiBFbnZcblxuICBwcmV2aWV3PzogYm9vbGVhblxuICAvKipcbiAgICogUHJldmlldyBkYXRhIHNldCBvbiB0aGUgcmVxdWVzdCwgaWYgYW55XG4gICAqICovXG4gIHByZXZpZXdEYXRhPzogYW55XG59XG5cbi8qKlxuICogU2VuZCBib2R5IG9mIHJlc3BvbnNlXG4gKi9cbnR5cGUgU2VuZDxUPiA9IChib2R5OiBUKSA9PiB2b2lkXG5cbi8qKlxuICogTmV4dCBgQVBJYCByb3V0ZSByZXNwb25zZVxuICovXG5leHBvcnQgdHlwZSBOZXh0QXBpUmVzcG9uc2U8VCA9IGFueT4gPSBTZXJ2ZXJSZXNwb25zZSAmIHtcbiAgLyoqXG4gICAqIFNlbmQgZGF0YSBgYW55YCBkYXRhIGluIHJlc3BvbnNlXG4gICAqL1xuICBzZW5kOiBTZW5kPFQ+XG4gIC8qKlxuICAgKiBTZW5kIGRhdGEgYGpzb25gIGRhdGEgaW4gcmVzcG9uc2VcbiAgICovXG4gIGpzb246IFNlbmQ8VD5cbiAgc3RhdHVzOiAoc3RhdHVzQ29kZTogbnVtYmVyKSA9PiBOZXh0QXBpUmVzcG9uc2U8VD5cbiAgcmVkaXJlY3QodXJsOiBzdHJpbmcpOiBOZXh0QXBpUmVzcG9uc2U8VD5cbiAgcmVkaXJlY3Qoc3RhdHVzOiBudW1iZXIsIHVybDogc3RyaW5nKTogTmV4dEFwaVJlc3BvbnNlPFQ+XG5cbiAgLyoqXG4gICAqIFNldCBwcmV2aWV3IGRhdGEgZm9yIE5leHQuanMnIHByZXJlbmRlciBtb2RlXG4gICAqL1xuICBzZXRQcmV2aWV3RGF0YTogKFxuICAgIGRhdGE6IG9iamVjdCB8IHN0cmluZyxcbiAgICBvcHRpb25zPzoge1xuICAgICAgLyoqXG4gICAgICAgKiBTcGVjaWZpZXMgdGhlIG51bWJlciAoaW4gc2Vjb25kcykgZm9yIHRoZSBwcmV2aWV3IHNlc3Npb24gdG8gbGFzdCBmb3IuXG4gICAgICAgKiBUaGUgZ2l2ZW4gbnVtYmVyIHdpbGwgYmUgY29udmVydGVkIHRvIGFuIGludGVnZXIgYnkgcm91bmRpbmcgZG93bi5cbiAgICAgICAqIEJ5IGRlZmF1bHQsIG5vIG1heGltdW0gYWdlIGlzIHNldCBhbmQgdGhlIHByZXZpZXcgc2Vzc2lvbiBmaW5pc2hlc1xuICAgICAgICogd2hlbiB0aGUgY2xpZW50IHNodXRzIGRvd24gKGJyb3dzZXIgaXMgY2xvc2VkKS5cbiAgICAgICAqL1xuICAgICAgbWF4QWdlPzogbnVtYmVyXG4gICAgfVxuICApID0+IE5leHRBcGlSZXNwb25zZTxUPlxuICBjbGVhclByZXZpZXdEYXRhOiAoKSA9PiBOZXh0QXBpUmVzcG9uc2U8VD5cbn1cblxuLyoqXG4gKiBOZXh0IGBBUElgIHJvdXRlIGhhbmRsZXJcbiAqL1xuZXhwb3J0IHR5cGUgTmV4dEFwaUhhbmRsZXI8VCA9IGFueT4gPSAoXG4gIHJlcTogTmV4dEFwaVJlcXVlc3QsXG4gIHJlczogTmV4dEFwaVJlc3BvbnNlPFQ+XG4pID0+IHZvaWQgfCBQcm9taXNlPHZvaWQ+XG5cbi8qKlxuICogVXRpbHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4ZWNPbmNlPFQgZXh0ZW5kcyAoLi4uYXJnczogYW55W10pID0+IFJldHVyblR5cGU8VD4+KFxuICBmbjogVFxuKTogVCB7XG4gIGxldCB1c2VkID0gZmFsc2VcbiAgbGV0IHJlc3VsdDogUmV0dXJuVHlwZTxUPlxuXG4gIHJldHVybiAoKC4uLmFyZ3M6IGFueVtdKSA9PiB7XG4gICAgaWYgKCF1c2VkKSB7XG4gICAgICB1c2VkID0gdHJ1ZVxuICAgICAgcmVzdWx0ID0gZm4oLi4uYXJncylcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9KSBhcyBUXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRMb2NhdGlvbk9yaWdpbigpIHtcbiAgY29uc3QgeyBwcm90b2NvbCwgaG9zdG5hbWUsIHBvcnQgfSA9IHdpbmRvdy5sb2NhdGlvblxuICByZXR1cm4gYCR7cHJvdG9jb2x9Ly8ke2hvc3RuYW1lfSR7cG9ydCA/ICc6JyArIHBvcnQgOiAnJ31gXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRVUkwoKSB7XG4gIGNvbnN0IHsgaHJlZiB9ID0gd2luZG93LmxvY2F0aW9uXG4gIGNvbnN0IG9yaWdpbiA9IGdldExvY2F0aW9uT3JpZ2luKClcbiAgcmV0dXJuIGhyZWYuc3Vic3RyaW5nKG9yaWdpbi5sZW5ndGgpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXREaXNwbGF5TmFtZTxQPihDb21wb25lbnQ6IENvbXBvbmVudFR5cGU8UD4pIHtcbiAgcmV0dXJuIHR5cGVvZiBDb21wb25lbnQgPT09ICdzdHJpbmcnXG4gICAgPyBDb21wb25lbnRcbiAgICA6IENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb25lbnQubmFtZSB8fCAnVW5rbm93bidcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzUmVzU2VudChyZXM6IFNlcnZlclJlc3BvbnNlKSB7XG4gIHJldHVybiByZXMuZmluaXNoZWQgfHwgcmVzLmhlYWRlcnNTZW50XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBsb2FkR2V0SW5pdGlhbFByb3BzPFxuICBDIGV4dGVuZHMgQmFzZUNvbnRleHQsXG4gIElQID0ge30sXG4gIFAgPSB7fVxuPihBcHA6IE5leHRDb21wb25lbnRUeXBlPEMsIElQLCBQPiwgY3R4OiBDKTogUHJvbWlzZTxJUD4ge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmIChBcHAucHJvdG90eXBlPy5nZXRJbml0aWFsUHJvcHMpIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBgXCIke2dldERpc3BsYXlOYW1lKFxuICAgICAgICBBcHBcbiAgICAgICl9LmdldEluaXRpYWxQcm9wcygpXCIgaXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBtZXRob2QgLSB2aXNpdCBodHRwczovL2Vyci5zaC92ZXJjZWwvbmV4dC5qcy9nZXQtaW5pdGlhbC1wcm9wcy1hcy1hbi1pbnN0YW5jZS1tZXRob2QgZm9yIG1vcmUgaW5mb3JtYXRpb24uYFxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpXG4gICAgfVxuICB9XG4gIC8vIHdoZW4gY2FsbGVkIGZyb20gX2FwcCBgY3R4YCBpcyBuZXN0ZWQgaW4gYGN0eGBcbiAgY29uc3QgcmVzID0gY3R4LnJlcyB8fCAoY3R4LmN0eCAmJiBjdHguY3R4LnJlcylcblxuICBpZiAoIUFwcC5nZXRJbml0aWFsUHJvcHMpIHtcbiAgICBpZiAoY3R4LmN0eCAmJiBjdHguQ29tcG9uZW50KSB7XG4gICAgICAvLyBAdHMtaWdub3JlIHBhZ2VQcm9wcyBkZWZhdWx0XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwYWdlUHJvcHM6IGF3YWl0IGxvYWRHZXRJbml0aWFsUHJvcHMoY3R4LkNvbXBvbmVudCwgY3R4LmN0eCksXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7fSBhcyBJUFxuICB9XG5cbiAgY29uc3QgcHJvcHMgPSBhd2FpdCBBcHAuZ2V0SW5pdGlhbFByb3BzKGN0eClcblxuICBpZiAocmVzICYmIGlzUmVzU2VudChyZXMpKSB7XG4gICAgcmV0dXJuIHByb3BzXG4gIH1cblxuICBpZiAoIXByb3BzKSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IGBcIiR7Z2V0RGlzcGxheU5hbWUoXG4gICAgICBBcHBcbiAgICApfS5nZXRJbml0aWFsUHJvcHMoKVwiIHNob3VsZCByZXNvbHZlIHRvIGFuIG9iamVjdC4gQnV0IGZvdW5kIFwiJHtwcm9wc31cIiBpbnN0ZWFkLmBcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSlcbiAgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKE9iamVjdC5rZXlzKHByb3BzKS5sZW5ndGggPT09IDAgJiYgIWN0eC5jdHgpIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgYCR7Z2V0RGlzcGxheU5hbWUoXG4gICAgICAgICAgQXBwXG4gICAgICAgICl9IHJldHVybmVkIGFuIGVtcHR5IG9iamVjdCBmcm9tIFxcYGdldEluaXRpYWxQcm9wc1xcYC4gVGhpcyBkZS1vcHRpbWl6ZXMgYW5kIHByZXZlbnRzIGF1dG9tYXRpYyBzdGF0aWMgb3B0aW1pemF0aW9uLiBodHRwczovL2Vyci5zaC92ZXJjZWwvbmV4dC5qcy9lbXB0eS1vYmplY3QtZ2V0SW5pdGlhbFByb3BzYFxuICAgICAgKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwcm9wc1xufVxuXG5leHBvcnQgY29uc3QgdXJsT2JqZWN0S2V5cyA9IFtcbiAgJ2F1dGgnLFxuICAnaGFzaCcsXG4gICdob3N0JyxcbiAgJ2hvc3RuYW1lJyxcbiAgJ2hyZWYnLFxuICAncGF0aCcsXG4gICdwYXRobmFtZScsXG4gICdwb3J0JyxcbiAgJ3Byb3RvY29sJyxcbiAgJ3F1ZXJ5JyxcbiAgJ3NlYXJjaCcsXG4gICdzbGFzaGVzJyxcbl1cblxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdFdpdGhWYWxpZGF0aW9uKHVybDogVXJsT2JqZWN0KTogc3RyaW5nIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgaWYgKHVybCAhPT0gbnVsbCAmJiB0eXBlb2YgdXJsID09PSAnb2JqZWN0Jykge1xuICAgICAgT2JqZWN0LmtleXModXJsKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgaWYgKHVybE9iamVjdEtleXMuaW5kZXhPZihrZXkpID09PSAtMSkge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgIGBVbmtub3duIGtleSBwYXNzZWQgdmlhIHVybE9iamVjdCBpbnRvIHVybC5mb3JtYXQ6ICR7a2V5fWBcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZvcm1hdFVybCh1cmwpXG59XG5cbmV4cG9ydCBjb25zdCBTUCA9IHR5cGVvZiBwZXJmb3JtYW5jZSAhPT0gJ3VuZGVmaW5lZCdcbmV4cG9ydCBjb25zdCBTVCA9XG4gIFNQICYmXG4gIHR5cGVvZiBwZXJmb3JtYW5jZS5tYXJrID09PSAnZnVuY3Rpb24nICYmXG4gIHR5cGVvZiBwZXJmb3JtYW5jZS5tZWFzdXJlID09PSAnZnVuY3Rpb24nXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGlzdC9jbGllbnQvbGluaycpXG4iLCJPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGlzUGxhaW5PYmplY3Q7XG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHgpIHtcbiAgcmV0dXJuIHggJiYgKHR5cGVvZiB4ID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih4KSkgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHgpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pc1BsYWluT2JqZWN0LmpzLm1hcCIsIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzWydkZWZhdWx0J10gPSBmb3JiaWRFeHRyYVByb3BzO1xuXG52YXIgX29iamVjdCA9IHJlcXVpcmUoJ29iamVjdC5hc3NpZ24nKTtcblxudmFyIF9vYmplY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfb2JqZWN0KTtcblxudmFyIF9oYXMgPSByZXF1aXJlKCdoYXMnKTtcblxudmFyIF9oYXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaGFzKTtcblxudmFyIF9pc1BsYWluT2JqZWN0ID0gcmVxdWlyZSgnLi9oZWxwZXJzL2lzUGxhaW5PYmplY3QnKTtcblxudmFyIF9pc1BsYWluT2JqZWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2lzUGxhaW5PYmplY3QpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbnZhciB6ZXJvV2lkdGhTcGFjZSA9ICdcXHUyMDBCJztcbnZhciBzcGVjaWFsUHJvcGVydHkgPSAncHJvcC10eXBlcy1leGFjdDogJyArIHplcm9XaWR0aFNwYWNlO1xudmFyIHNlbWFwaG9yZSA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbFsnZm9yJ10gPT09ICdmdW5jdGlvbicgPyBTeW1ib2xbJ2ZvciddKHNwZWNpYWxQcm9wZXJ0eSkgOiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL3NwZWNpYWxQcm9wZXJ0eTtcblxuZnVuY3Rpb24gYnJhbmQoZm4pIHtcbiAgcmV0dXJuICgwLCBfb2JqZWN0MlsnZGVmYXVsdCddKShmbiwgX2RlZmluZVByb3BlcnR5KHt9LCBzcGVjaWFsUHJvcGVydHksIHNlbWFwaG9yZSkpO1xufVxuXG5mdW5jdGlvbiBpc0JyYW5kZWQodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICYmIHZhbHVlW3NwZWNpYWxQcm9wZXJ0eV0gPT09IHNlbWFwaG9yZTtcbn1cblxuZnVuY3Rpb24gZm9yYmlkRXh0cmFQcm9wcyhwcm9wVHlwZXMpIHtcbiAgaWYgKCEoMCwgX2lzUGxhaW5PYmplY3QyWydkZWZhdWx0J10pKHByb3BUeXBlcykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdnaXZlbiBwcm9wVHlwZXMgbXVzdCBiZSBhbiBvYmplY3QnKTtcbiAgfVxuICBpZiAoKDAsIF9oYXMyWydkZWZhdWx0J10pKHByb3BUeXBlcywgc3BlY2lhbFByb3BlcnR5KSAmJiAhaXNCcmFuZGVkKHByb3BUeXBlc1tzcGVjaWFsUHJvcGVydHldKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FnYWluc3QgYWxsIG9kZHMsIHlvdSBjcmVhdGVkIGEgcHJvcFR5cGUgZm9yIGEgcHJvcCB0aGF0IHVzZXMgYm90aCB0aGUgemVyby13aWR0aCBzcGFjZSBhbmQgb3VyIGN1c3RvbSBzdHJpbmcgLSB3aGljaCwgc2FkbHksIGNvbmZsaWN0cyB3aXRoIGBwcm9wLXR5cGVzLWV4YWN0YCcpO1xuICB9XG5cbiAgcmV0dXJuICgwLCBfb2JqZWN0MlsnZGVmYXVsdCddKSh7fSwgcHJvcFR5cGVzLCBfZGVmaW5lUHJvcGVydHkoe30sIHNwZWNpYWxQcm9wZXJ0eSwgYnJhbmQoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIGZvcmJpZFVua25vd25Qcm9wcyhwcm9wcywgXywgY29tcG9uZW50TmFtZSkge1xuICAgICAgdmFyIHVua25vd25Qcm9wcyA9IE9iamVjdC5rZXlzKHByb3BzKS5maWx0ZXIoZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgcmV0dXJuICEoMCwgX2hhczJbJ2RlZmF1bHQnXSkocHJvcFR5cGVzLCBwcm9wKTtcbiAgICAgIH0pO1xuICAgICAgaWYgKHVua25vd25Qcm9wcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiBuZXcgVHlwZUVycm9yKFN0cmluZyhjb21wb25lbnROYW1lKSArICc6IHVua25vd24gcHJvcHMgZm91bmQ6ICcgKyBTdHJpbmcodW5rbm93blByb3BzLmpvaW4oJywgJykpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBmb3JiaWRVbmtub3duUHJvcHM7XG4gIH0oKSkpKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBwcmludFdhcm5pbmcgPSBmdW5jdGlvbigpIHt9O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSByZXF1aXJlKCcuL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldCcpO1xuICB2YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG4gIHZhciBoYXMgPSBGdW5jdGlvbi5jYWxsLmJpbmQoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSk7XG5cbiAgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24odGV4dCkge1xuICAgIHZhciBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgKyB0ZXh0O1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAvLyAtLS0gV2VsY29tZSB0byBkZWJ1Z2dpbmcgUmVhY3QgLS0tXG4gICAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IHlvdSBjYW4gdXNlIHRoaXMgc3RhY2tcbiAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIH0gY2F0Y2ggKHgpIHt9XG4gIH07XG59XG5cbi8qKlxuICogQXNzZXJ0IHRoYXQgdGhlIHZhbHVlcyBtYXRjaCB3aXRoIHRoZSB0eXBlIHNwZWNzLlxuICogRXJyb3IgbWVzc2FnZXMgYXJlIG1lbW9yaXplZCBhbmQgd2lsbCBvbmx5IGJlIHNob3duIG9uY2UuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IHR5cGVTcGVjcyBNYXAgb2YgbmFtZSB0byBhIFJlYWN0UHJvcFR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSB2YWx1ZXMgUnVudGltZSB2YWx1ZXMgdGhhdCBuZWVkIHRvIGJlIHR5cGUtY2hlY2tlZFxuICogQHBhcmFtIHtzdHJpbmd9IGxvY2F0aW9uIGUuZy4gXCJwcm9wXCIsIFwiY29udGV4dFwiLCBcImNoaWxkIGNvbnRleHRcIlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbXBvbmVudE5hbWUgTmFtZSBvZiB0aGUgY29tcG9uZW50IGZvciBlcnJvciBtZXNzYWdlcy5cbiAqIEBwYXJhbSB7P0Z1bmN0aW9ufSBnZXRTdGFjayBSZXR1cm5zIHRoZSBjb21wb25lbnQgc3RhY2suXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjaGVja1Byb3BUeXBlcyh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24sIGNvbXBvbmVudE5hbWUsIGdldFN0YWNrKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xuICAgICAgaWYgKGhhcyh0eXBlU3BlY3MsIHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yO1xuICAgICAgICAvLyBQcm9wIHR5cGUgdmFsaWRhdGlvbiBtYXkgdGhyb3cuIEluIGNhc2UgdGhleSBkbywgd2UgZG9uJ3Qgd2FudCB0b1xuICAgICAgICAvLyBmYWlsIHRoZSByZW5kZXIgcGhhc2Ugd2hlcmUgaXQgZGlkbid0IGZhaWwgYmVmb3JlLiBTbyB3ZSBsb2cgaXQuXG4gICAgICAgIC8vIEFmdGVyIHRoZXNlIGhhdmUgYmVlbiBjbGVhbmVkIHVwLCB3ZSdsbCBsZXQgdGhlbSB0aHJvdy5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcbiAgICAgICAgICAvLyBiZWhhdmlvciBhcyB3aXRob3V0IHRoaXMgc3RhdGVtZW50IGV4Y2VwdCB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UuXG4gICAgICAgICAgaWYgKHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdmFyIGVyciA9IEVycm9yKFxuICAgICAgICAgICAgICAoY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnKSArICc6ICcgKyBsb2NhdGlvbiArICcgdHlwZSBgJyArIHR5cGVTcGVjTmFtZSArICdgIGlzIGludmFsaWQ7ICcgK1xuICAgICAgICAgICAgICAnaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYCcgKyB0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gKyAnYC4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZXJyLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVycm9yID0gdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0odmFsdWVzLCB0eXBlU3BlY05hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBudWxsLCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgZXJyb3IgPSBleDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyb3IgJiYgIShlcnJvciBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAgIChjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycpICsgJzogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICcgK1xuICAgICAgICAgICAgbG9jYXRpb24gKyAnIGAnICsgdHlwZVNwZWNOYW1lICsgJ2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICtcbiAgICAgICAgICAgICdmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAnICsgdHlwZW9mIGVycm9yICsgJy4gJyArXG4gICAgICAgICAgICAnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJyArXG4gICAgICAgICAgICAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICtcbiAgICAgICAgICAgICdzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuJ1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvci5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvci5tZXNzYWdlXSA9IHRydWU7XG5cbiAgICAgICAgICB2YXIgc3RhY2sgPSBnZXRTdGFjayA/IGdldFN0YWNrKCkgOiAnJztcblxuICAgICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAgICdGYWlsZWQgJyArIGxvY2F0aW9uICsgJyB0eXBlOiAnICsgZXJyb3IubWVzc2FnZSArIChzdGFjayAhPSBudWxsID8gc3RhY2sgOiAnJylcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUmVzZXRzIHdhcm5pbmcgY2FjaGUgd2hlbiB0ZXN0aW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmNoZWNrUHJvcFR5cGVzLnJlc2V0V2FybmluZ0NhY2hlID0gZnVuY3Rpb24oKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjaGVja1Byb3BUeXBlcztcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RJcyA9IHJlcXVpcmUoJ3JlYWN0LWlzJyk7XG52YXIgYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSByZXF1aXJlKCcuL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldCcpO1xudmFyIGNoZWNrUHJvcFR5cGVzID0gcmVxdWlyZSgnLi9jaGVja1Byb3BUeXBlcycpO1xuXG52YXIgaGFzID0gRnVuY3Rpb24uY2FsbC5iaW5kKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkpO1xudmFyIHByaW50V2FybmluZyA9IGZ1bmN0aW9uKCkge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHByaW50V2FybmluZyA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICsgdGV4dDtcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgLy8gLS0tIFdlbGNvbWUgdG8gZGVidWdnaW5nIFJlYWN0IC0tLVxuICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9IGNhdGNoICh4KSB7fVxuICB9O1xufVxuXG5mdW5jdGlvbiBlbXB0eUZ1bmN0aW9uVGhhdFJldHVybnNOdWxsKCkge1xuICByZXR1cm4gbnVsbDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpc1ZhbGlkRWxlbWVudCwgdGhyb3dPbkRpcmVjdEFjY2Vzcykge1xuICAvKiBnbG9iYWwgU3ltYm9sICovXG4gIHZhciBJVEVSQVRPUl9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5pdGVyYXRvcjtcbiAgdmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InOyAvLyBCZWZvcmUgU3ltYm9sIHNwZWMuXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGl0ZXJhdG9yIG1ldGhvZCBmdW5jdGlvbiBjb250YWluZWQgb24gdGhlIGl0ZXJhYmxlIG9iamVjdC5cbiAgICpcbiAgICogQmUgc3VyZSB0byBpbnZva2UgdGhlIGZ1bmN0aW9uIHdpdGggdGhlIGl0ZXJhYmxlIGFzIGNvbnRleHQ6XG4gICAqXG4gICAqICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obXlJdGVyYWJsZSk7XG4gICAqICAgICBpZiAoaXRlcmF0b3JGbikge1xuICAgKiAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobXlJdGVyYWJsZSk7XG4gICAqICAgICAgIC4uLlxuICAgKiAgICAgfVxuICAgKlxuICAgKiBAcGFyYW0gez9vYmplY3R9IG1heWJlSXRlcmFibGVcbiAgICogQHJldHVybiB7P2Z1bmN0aW9ufVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBtYXliZUl0ZXJhYmxlICYmIChJVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtJVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdKTtcbiAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBpdGVyYXRvckZuO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb2xsZWN0aW9uIG9mIG1ldGhvZHMgdGhhdCBhbGxvdyBkZWNsYXJhdGlvbiBhbmQgdmFsaWRhdGlvbiBvZiBwcm9wcyB0aGF0IGFyZVxuICAgKiBzdXBwbGllZCB0byBSZWFjdCBjb21wb25lbnRzLiBFeGFtcGxlIHVzYWdlOlxuICAgKlxuICAgKiAgIHZhciBQcm9wcyA9IHJlcXVpcmUoJ1JlYWN0UHJvcFR5cGVzJyk7XG4gICAqICAgdmFyIE15QXJ0aWNsZSA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgICogICAgIHByb3BUeXBlczoge1xuICAgKiAgICAgICAvLyBBbiBvcHRpb25hbCBzdHJpbmcgcHJvcCBuYW1lZCBcImRlc2NyaXB0aW9uXCIuXG4gICAqICAgICAgIGRlc2NyaXB0aW9uOiBQcm9wcy5zdHJpbmcsXG4gICAqXG4gICAqICAgICAgIC8vIEEgcmVxdWlyZWQgZW51bSBwcm9wIG5hbWVkIFwiY2F0ZWdvcnlcIi5cbiAgICogICAgICAgY2F0ZWdvcnk6IFByb3BzLm9uZU9mKFsnTmV3cycsJ1Bob3RvcyddKS5pc1JlcXVpcmVkLFxuICAgKlxuICAgKiAgICAgICAvLyBBIHByb3AgbmFtZWQgXCJkaWFsb2dcIiB0aGF0IHJlcXVpcmVzIGFuIGluc3RhbmNlIG9mIERpYWxvZy5cbiAgICogICAgICAgZGlhbG9nOiBQcm9wcy5pbnN0YW5jZU9mKERpYWxvZykuaXNSZXF1aXJlZFxuICAgKiAgICAgfSxcbiAgICogICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7IC4uLiB9XG4gICAqICAgfSk7XG4gICAqXG4gICAqIEEgbW9yZSBmb3JtYWwgc3BlY2lmaWNhdGlvbiBvZiBob3cgdGhlc2UgbWV0aG9kcyBhcmUgdXNlZDpcbiAgICpcbiAgICogICB0eXBlIDo9IGFycmF5fGJvb2x8ZnVuY3xvYmplY3R8bnVtYmVyfHN0cmluZ3xvbmVPZihbLi4uXSl8aW5zdGFuY2VPZiguLi4pXG4gICAqICAgZGVjbCA6PSBSZWFjdFByb3BUeXBlcy57dHlwZX0oLmlzUmVxdWlyZWQpP1xuICAgKlxuICAgKiBFYWNoIGFuZCBldmVyeSBkZWNsYXJhdGlvbiBwcm9kdWNlcyBhIGZ1bmN0aW9uIHdpdGggdGhlIHNhbWUgc2lnbmF0dXJlLiBUaGlzXG4gICAqIGFsbG93cyB0aGUgY3JlYXRpb24gb2YgY3VzdG9tIHZhbGlkYXRpb24gZnVuY3Rpb25zLiBGb3IgZXhhbXBsZTpcbiAgICpcbiAgICogIHZhciBNeUxpbmsgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gICAqICAgIHByb3BUeXBlczoge1xuICAgKiAgICAgIC8vIEFuIG9wdGlvbmFsIHN0cmluZyBvciBVUkkgcHJvcCBuYW1lZCBcImhyZWZcIi5cbiAgICogICAgICBocmVmOiBmdW5jdGlvbihwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpIHtcbiAgICogICAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAqICAgICAgICBpZiAocHJvcFZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHByb3BWYWx1ZSAhPT0gJ3N0cmluZycgJiZcbiAgICogICAgICAgICAgICAhKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFVSSSkpIHtcbiAgICogICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihcbiAgICogICAgICAgICAgICAnRXhwZWN0ZWQgYSBzdHJpbmcgb3IgYW4gVVJJIGZvciAnICsgcHJvcE5hbWUgKyAnIGluICcgK1xuICAgKiAgICAgICAgICAgIGNvbXBvbmVudE5hbWVcbiAgICogICAgICAgICAgKTtcbiAgICogICAgICAgIH1cbiAgICogICAgICB9XG4gICAqICAgIH0sXG4gICAqICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7Li4ufVxuICAgKiAgfSk7XG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cblxuICB2YXIgQU5PTllNT1VTID0gJzw8YW5vbnltb3VzPj4nO1xuXG4gIC8vIEltcG9ydGFudCFcbiAgLy8gS2VlcCB0aGlzIGxpc3QgaW4gc3luYyB3aXRoIHByb2R1Y3Rpb24gdmVyc2lvbiBpbiBgLi9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMuanNgLlxuICB2YXIgUmVhY3RQcm9wVHlwZXMgPSB7XG4gICAgYXJyYXk6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdhcnJheScpLFxuICAgIGJvb2w6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdib29sZWFuJyksXG4gICAgZnVuYzogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2Z1bmN0aW9uJyksXG4gICAgbnVtYmVyOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignbnVtYmVyJyksXG4gICAgb2JqZWN0OiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignb2JqZWN0JyksXG4gICAgc3RyaW5nOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignc3RyaW5nJyksXG4gICAgc3ltYm9sOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignc3ltYm9sJyksXG5cbiAgICBhbnk6IGNyZWF0ZUFueVR5cGVDaGVja2VyKCksXG4gICAgYXJyYXlPZjogY3JlYXRlQXJyYXlPZlR5cGVDaGVja2VyLFxuICAgIGVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnRUeXBlQ2hlY2tlcigpLFxuICAgIGVsZW1lbnRUeXBlOiBjcmVhdGVFbGVtZW50VHlwZVR5cGVDaGVja2VyKCksXG4gICAgaW5zdGFuY2VPZjogY3JlYXRlSW5zdGFuY2VUeXBlQ2hlY2tlcixcbiAgICBub2RlOiBjcmVhdGVOb2RlQ2hlY2tlcigpLFxuICAgIG9iamVjdE9mOiBjcmVhdGVPYmplY3RPZlR5cGVDaGVja2VyLFxuICAgIG9uZU9mOiBjcmVhdGVFbnVtVHlwZUNoZWNrZXIsXG4gICAgb25lT2ZUeXBlOiBjcmVhdGVVbmlvblR5cGVDaGVja2VyLFxuICAgIHNoYXBlOiBjcmVhdGVTaGFwZVR5cGVDaGVja2VyLFxuICAgIGV4YWN0OiBjcmVhdGVTdHJpY3RTaGFwZVR5cGVDaGVja2VyLFxuICB9O1xuXG4gIC8qKlxuICAgKiBpbmxpbmVkIE9iamVjdC5pcyBwb2x5ZmlsbCB0byBhdm9pZCByZXF1aXJpbmcgY29uc3VtZXJzIHNoaXAgdGhlaXIgb3duXG4gICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9pc1xuICAgKi9cbiAgLyplc2xpbnQtZGlzYWJsZSBuby1zZWxmLWNvbXBhcmUqL1xuICBmdW5jdGlvbiBpcyh4LCB5KSB7XG4gICAgLy8gU2FtZVZhbHVlIGFsZ29yaXRobVxuICAgIGlmICh4ID09PSB5KSB7XG4gICAgICAvLyBTdGVwcyAxLTUsIDctMTBcbiAgICAgIC8vIFN0ZXBzIDYuYi02LmU6ICswICE9IC0wXG4gICAgICByZXR1cm4geCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFN0ZXAgNi5hOiBOYU4gPT0gTmFOXG4gICAgICByZXR1cm4geCAhPT0geCAmJiB5ICE9PSB5O1xuICAgIH1cbiAgfVxuICAvKmVzbGludC1lbmFibGUgbm8tc2VsZi1jb21wYXJlKi9cblxuICAvKipcbiAgICogV2UgdXNlIGFuIEVycm9yLWxpa2Ugb2JqZWN0IGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IGFzIHBlb3BsZSBtYXkgY2FsbFxuICAgKiBQcm9wVHlwZXMgZGlyZWN0bHkgYW5kIGluc3BlY3QgdGhlaXIgb3V0cHV0LiBIb3dldmVyLCB3ZSBkb24ndCB1c2UgcmVhbFxuICAgKiBFcnJvcnMgYW55bW9yZS4gV2UgZG9uJ3QgaW5zcGVjdCB0aGVpciBzdGFjayBhbnl3YXksIGFuZCBjcmVhdGluZyB0aGVtXG4gICAqIGlzIHByb2hpYml0aXZlbHkgZXhwZW5zaXZlIGlmIHRoZXkgYXJlIGNyZWF0ZWQgdG9vIG9mdGVuLCBzdWNoIGFzIHdoYXRcbiAgICogaGFwcGVucyBpbiBvbmVPZlR5cGUoKSBmb3IgYW55IHR5cGUgYmVmb3JlIHRoZSBvbmUgdGhhdCBtYXRjaGVkLlxuICAgKi9cbiAgZnVuY3Rpb24gUHJvcFR5cGVFcnJvcihtZXNzYWdlKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICB0aGlzLnN0YWNrID0gJyc7XG4gIH1cbiAgLy8gTWFrZSBgaW5zdGFuY2VvZiBFcnJvcmAgc3RpbGwgd29yayBmb3IgcmV0dXJuZWQgZXJyb3JzLlxuICBQcm9wVHlwZUVycm9yLnByb3RvdHlwZSA9IEVycm9yLnByb3RvdHlwZTtcblxuICBmdW5jdGlvbiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGUgPSB7fTtcbiAgICAgIHZhciBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCA9IDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrVHlwZShpc1JlcXVpcmVkLCBwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgICAgY29tcG9uZW50TmFtZSA9IGNvbXBvbmVudE5hbWUgfHwgQU5PTllNT1VTO1xuICAgICAgcHJvcEZ1bGxOYW1lID0gcHJvcEZ1bGxOYW1lIHx8IHByb3BOYW1lO1xuXG4gICAgICBpZiAoc2VjcmV0ICE9PSBSZWFjdFByb3BUeXBlc1NlY3JldCkge1xuICAgICAgICBpZiAodGhyb3dPbkRpcmVjdEFjY2Vzcykge1xuICAgICAgICAgIC8vIE5ldyBiZWhhdmlvciBvbmx5IGZvciB1c2VycyBvZiBgcHJvcC10eXBlc2AgcGFja2FnZVxuICAgICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnQ2FsbGluZyBQcm9wVHlwZXMgdmFsaWRhdG9ycyBkaXJlY3RseSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZS4gJyArXG4gICAgICAgICAgICAnVXNlIGBQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMoKWAgdG8gY2FsbCB0aGVtLiAnICtcbiAgICAgICAgICAgICdSZWFkIG1vcmUgYXQgaHR0cDovL2ZiLm1lL3VzZS1jaGVjay1wcm9wLXR5cGVzJ1xuICAgICAgICAgICk7XG4gICAgICAgICAgZXJyLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgLy8gT2xkIGJlaGF2aW9yIGZvciBwZW9wbGUgdXNpbmcgUmVhY3QuUHJvcFR5cGVzXG4gICAgICAgICAgdmFyIGNhY2hlS2V5ID0gY29tcG9uZW50TmFtZSArICc6JyArIHByb3BOYW1lO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICFtYW51YWxQcm9wVHlwZUNhbGxDYWNoZVtjYWNoZUtleV0gJiZcbiAgICAgICAgICAgIC8vIEF2b2lkIHNwYW1taW5nIHRoZSBjb25zb2xlIGJlY2F1c2UgdGhleSBhcmUgb2Z0ZW4gbm90IGFjdGlvbmFibGUgZXhjZXB0IGZvciBsaWIgYXV0aG9yc1xuICAgICAgICAgICAgbWFudWFsUHJvcFR5cGVXYXJuaW5nQ291bnQgPCAzXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBwcmludFdhcm5pbmcoXG4gICAgICAgICAgICAgICdZb3UgYXJlIG1hbnVhbGx5IGNhbGxpbmcgYSBSZWFjdC5Qcm9wVHlwZXMgdmFsaWRhdGlvbiAnICtcbiAgICAgICAgICAgICAgJ2Z1bmN0aW9uIGZvciB0aGUgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBwcm9wIG9uIGAnICsgY29tcG9uZW50TmFtZSAgKyAnYC4gVGhpcyBpcyBkZXByZWNhdGVkICcgK1xuICAgICAgICAgICAgICAnYW5kIHdpbGwgdGhyb3cgaW4gdGhlIHN0YW5kYWxvbmUgYHByb3AtdHlwZXNgIHBhY2thZ2UuICcgK1xuICAgICAgICAgICAgICAnWW91IG1heSBiZSBzZWVpbmcgdGhpcyB3YXJuaW5nIGR1ZSB0byBhIHRoaXJkLXBhcnR5IFByb3BUeXBlcyAnICtcbiAgICAgICAgICAgICAgJ2xpYnJhcnkuIFNlZSBodHRwczovL2ZiLm1lL3JlYWN0LXdhcm5pbmctZG9udC1jYWxsLXByb3B0eXBlcyAnICsgJ2ZvciBkZXRhaWxzLidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBtYW51YWxQcm9wVHlwZUNhbGxDYWNoZVtjYWNoZUtleV0gPSB0cnVlO1xuICAgICAgICAgICAgbWFudWFsUHJvcFR5cGVXYXJuaW5nQ291bnQrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT0gbnVsbCkge1xuICAgICAgICBpZiAoaXNSZXF1aXJlZCkge1xuICAgICAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignVGhlICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBpcyBtYXJrZWQgYXMgcmVxdWlyZWQgJyArICgnaW4gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGJ1dCBpdHMgdmFsdWUgaXMgYG51bGxgLicpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdUaGUgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIGlzIG1hcmtlZCBhcyByZXF1aXJlZCBpbiAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgYnV0IGl0cyB2YWx1ZSBpcyBgdW5kZWZpbmVkYC4nKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgY2hhaW5lZENoZWNrVHlwZSA9IGNoZWNrVHlwZS5iaW5kKG51bGwsIGZhbHNlKTtcbiAgICBjaGFpbmVkQ2hlY2tUeXBlLmlzUmVxdWlyZWQgPSBjaGVja1R5cGUuYmluZChudWxsLCB0cnVlKTtcblxuICAgIHJldHVybiBjaGFpbmVkQ2hlY2tUeXBlO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoZXhwZWN0ZWRUeXBlKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBzZWNyZXQpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSBleHBlY3RlZFR5cGUpIHtcbiAgICAgICAgLy8gYHByb3BWYWx1ZWAgYmVpbmcgaW5zdGFuY2Ugb2YsIHNheSwgZGF0ZS9yZWdleHAsIHBhc3MgdGhlICdvYmplY3QnXG4gICAgICAgIC8vIGNoZWNrLCBidXQgd2UgY2FuIG9mZmVyIGEgbW9yZSBwcmVjaXNlIGVycm9yIG1lc3NhZ2UgaGVyZSByYXRoZXIgdGhhblxuICAgICAgICAvLyAnb2YgdHlwZSBgb2JqZWN0YCcuXG4gICAgICAgIHZhciBwcmVjaXNlVHlwZSA9IGdldFByZWNpc2VUeXBlKHByb3BWYWx1ZSk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJlY2lzZVR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgJykgKyAoJ2AnICsgZXhwZWN0ZWRUeXBlICsgJ2AuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVBbnlUeXBlQ2hlY2tlcigpIHtcbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIoZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbCk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVBcnJheU9mVHlwZUNoZWNrZXIodHlwZUNoZWNrZXIpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdHlwZUNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdQcm9wZXJ0eSBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIGNvbXBvbmVudCBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCBoYXMgaW52YWxpZCBQcm9wVHlwZSBub3RhdGlvbiBpbnNpZGUgYXJyYXlPZi4nKTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhbiBhcnJheS4nKSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BWYWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZXJyb3IgPSB0eXBlQ2hlY2tlcihwcm9wVmFsdWUsIGksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnWycgKyBpICsgJ10nLCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRUeXBlQ2hlY2tlcigpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBpZiAoIWlzVmFsaWRFbGVtZW50KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYSBzaW5nbGUgUmVhY3RFbGVtZW50LicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlRWxlbWVudFR5cGVUeXBlQ2hlY2tlcigpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBpZiAoIVJlYWN0SXMuaXNWYWxpZEVsZW1lbnRUeXBlKHByb3BWYWx1ZSkpIHtcbiAgICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYSBzaW5nbGUgUmVhY3RFbGVtZW50IHR5cGUuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVJbnN0YW5jZVR5cGVDaGVja2VyKGV4cGVjdGVkQ2xhc3MpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICghKHByb3BzW3Byb3BOYW1lXSBpbnN0YW5jZW9mIGV4cGVjdGVkQ2xhc3MpKSB7XG4gICAgICAgIHZhciBleHBlY3RlZENsYXNzTmFtZSA9IGV4cGVjdGVkQ2xhc3MubmFtZSB8fCBBTk9OWU1PVVM7XG4gICAgICAgIHZhciBhY3R1YWxDbGFzc05hbWUgPSBnZXRDbGFzc05hbWUocHJvcHNbcHJvcE5hbWVdKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgYWN0dWFsQ2xhc3NOYW1lICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkICcpICsgKCdpbnN0YW5jZSBvZiBgJyArIGV4cGVjdGVkQ2xhc3NOYW1lICsgJ2AuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVFbnVtVHlwZUNoZWNrZXIoZXhwZWN0ZWRWYWx1ZXMpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZXhwZWN0ZWRWYWx1ZXMpKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICBwcmludFdhcm5pbmcoXG4gICAgICAgICAgICAnSW52YWxpZCBhcmd1bWVudHMgc3VwcGxpZWQgdG8gb25lT2YsIGV4cGVjdGVkIGFuIGFycmF5LCBnb3QgJyArIGFyZ3VtZW50cy5sZW5ndGggKyAnIGFyZ3VtZW50cy4gJyArXG4gICAgICAgICAgICAnQSBjb21tb24gbWlzdGFrZSBpcyB0byB3cml0ZSBvbmVPZih4LCB5LCB6KSBpbnN0ZWFkIG9mIG9uZU9mKFt4LCB5LCB6XSkuJ1xuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJpbnRXYXJuaW5nKCdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mLCBleHBlY3RlZCBhbiBhcnJheS4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHBlY3RlZFZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaXMocHJvcFZhbHVlLCBleHBlY3RlZFZhbHVlc1tpXSkpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgdmFsdWVzU3RyaW5nID0gSlNPTi5zdHJpbmdpZnkoZXhwZWN0ZWRWYWx1ZXMsIGZ1bmN0aW9uIHJlcGxhY2VyKGtleSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIHR5cGUgPSBnZXRQcmVjaXNlVHlwZSh2YWx1ZSk7XG4gICAgICAgIGlmICh0eXBlID09PSAnc3ltYm9sJykge1xuICAgICAgICAgIHJldHVybiBTdHJpbmcodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB2YWx1ZSBgJyArIFN0cmluZyhwcm9wVmFsdWUpICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIG9uZSBvZiAnICsgdmFsdWVzU3RyaW5nICsgJy4nKSk7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVPYmplY3RPZlR5cGVDaGVja2VyKHR5cGVDaGVja2VyKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAodHlwZW9mIHR5cGVDaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignUHJvcGVydHkgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiBjb21wb25lbnQgYCcgKyBjb21wb25lbnROYW1lICsgJ2AgaGFzIGludmFsaWQgUHJvcFR5cGUgbm90YXRpb24gaW5zaWRlIG9iamVjdE9mLicpO1xuICAgICAgfVxuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGFuIG9iamVjdC4nKSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBrZXkgaW4gcHJvcFZhbHVlKSB7XG4gICAgICAgIGlmIChoYXMocHJvcFZhbHVlLCBrZXkpKSB7XG4gICAgICAgICAgdmFyIGVycm9yID0gdHlwZUNoZWNrZXIocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXksIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVVbmlvblR5cGVDaGVja2VyKGFycmF5T2ZUeXBlQ2hlY2tlcnMpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyYXlPZlR5cGVDaGVja2VycykpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBwcmludFdhcm5pbmcoJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2ZUeXBlLCBleHBlY3RlZCBhbiBpbnN0YW5jZSBvZiBhcnJheS4nKSA6IHZvaWQgMDtcbiAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uVGhhdFJldHVybnNOdWxsO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXlPZlR5cGVDaGVja2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoZWNrZXIgPSBhcnJheU9mVHlwZUNoZWNrZXJzW2ldO1xuICAgICAgaWYgKHR5cGVvZiBjaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAnSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZlR5cGUuIEV4cGVjdGVkIGFuIGFycmF5IG9mIGNoZWNrIGZ1bmN0aW9ucywgYnV0ICcgK1xuICAgICAgICAgICdyZWNlaXZlZCAnICsgZ2V0UG9zdGZpeEZvclR5cGVXYXJuaW5nKGNoZWNrZXIpICsgJyBhdCBpbmRleCAnICsgaSArICcuJ1xuICAgICAgICApO1xuICAgICAgICByZXR1cm4gZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXlPZlR5cGVDaGVja2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hlY2tlciA9IGFycmF5T2ZUeXBlQ2hlY2tlcnNbaV07XG4gICAgICAgIGlmIChjaGVja2VyKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIHN1cHBsaWVkIHRvICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLicpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZU5vZGVDaGVja2VyKCkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKCFpc05vZGUocHJvcHNbcHJvcE5hbWVdKSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIHN1cHBsaWVkIHRvICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIFJlYWN0Tm9kZS4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVNoYXBlVHlwZUNoZWNrZXIoc2hhcGVUeXBlcykge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSBgJyArIHByb3BUeXBlICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGBvYmplY3RgLicpKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGtleSBpbiBzaGFwZVR5cGVzKSB7XG4gICAgICAgIHZhciBjaGVja2VyID0gc2hhcGVUeXBlc1trZXldO1xuICAgICAgICBpZiAoIWNoZWNrZXIpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXJyb3IgPSBjaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVTdHJpY3RTaGFwZVR5cGVDaGVja2VyKHNoYXBlVHlwZXMpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgYCcgKyBwcm9wVHlwZSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBgb2JqZWN0YC4nKSk7XG4gICAgICB9XG4gICAgICAvLyBXZSBuZWVkIHRvIGNoZWNrIGFsbCBrZXlzIGluIGNhc2Ugc29tZSBhcmUgcmVxdWlyZWQgYnV0IG1pc3NpbmcgZnJvbVxuICAgICAgLy8gcHJvcHMuXG4gICAgICB2YXIgYWxsS2V5cyA9IGFzc2lnbih7fSwgcHJvcHNbcHJvcE5hbWVdLCBzaGFwZVR5cGVzKTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBhbGxLZXlzKSB7XG4gICAgICAgIHZhciBjaGVja2VyID0gc2hhcGVUeXBlc1trZXldO1xuICAgICAgICBpZiAoIWNoZWNrZXIpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoXG4gICAgICAgICAgICAnSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Aga2V5IGAnICsga2V5ICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AuJyArXG4gICAgICAgICAgICAnXFxuQmFkIG9iamVjdDogJyArIEpTT04uc3RyaW5naWZ5KHByb3BzW3Byb3BOYW1lXSwgbnVsbCwgJyAgJykgK1xuICAgICAgICAgICAgJ1xcblZhbGlkIGtleXM6ICcgKyAgSlNPTi5zdHJpbmdpZnkoT2JqZWN0LmtleXMoc2hhcGVUeXBlcyksIG51bGwsICcgICcpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXJyb3IgPSBjaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzTm9kZShwcm9wVmFsdWUpIHtcbiAgICBzd2l0Y2ggKHR5cGVvZiBwcm9wVmFsdWUpIHtcbiAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgcmV0dXJuICFwcm9wVmFsdWU7XG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHByb3BWYWx1ZS5ldmVyeShpc05vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9wVmFsdWUgPT09IG51bGwgfHwgaXNWYWxpZEVsZW1lbnQocHJvcFZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKHByb3BWYWx1ZSk7XG4gICAgICAgIGlmIChpdGVyYXRvckZuKSB7XG4gICAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKHByb3BWYWx1ZSk7XG4gICAgICAgICAgdmFyIHN0ZXA7XG4gICAgICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IHByb3BWYWx1ZS5lbnRyaWVzKSB7XG4gICAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICAgIGlmICghaXNOb2RlKHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEl0ZXJhdG9yIHdpbGwgcHJvdmlkZSBlbnRyeSBbayx2XSB0dXBsZXMgcmF0aGVyIHRoYW4gdmFsdWVzLlxuICAgICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgICB2YXIgZW50cnkgPSBzdGVwLnZhbHVlO1xuICAgICAgICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzTm9kZShlbnRyeVsxXSkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNTeW1ib2wocHJvcFR5cGUsIHByb3BWYWx1ZSkge1xuICAgIC8vIE5hdGl2ZSBTeW1ib2wuXG4gICAgaWYgKHByb3BUeXBlID09PSAnc3ltYm9sJykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gZmFsc3kgdmFsdWUgY2FuJ3QgYmUgYSBTeW1ib2xcbiAgICBpZiAoIXByb3BWYWx1ZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIDE5LjQuMy41IFN5bWJvbC5wcm90b3R5cGVbQEB0b1N0cmluZ1RhZ10gPT09ICdTeW1ib2wnXG4gICAgaWYgKHByb3BWYWx1ZVsnQEB0b1N0cmluZ1RhZyddID09PSAnU3ltYm9sJykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gRmFsbGJhY2sgZm9yIG5vbi1zcGVjIGNvbXBsaWFudCBTeW1ib2xzIHdoaWNoIGFyZSBwb2x5ZmlsbGVkLlxuICAgIGlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHByb3BWYWx1ZSBpbnN0YW5jZW9mIFN5bWJvbCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gRXF1aXZhbGVudCBvZiBgdHlwZW9mYCBidXQgd2l0aCBzcGVjaWFsIGhhbmRsaW5nIGZvciBhcnJheSBhbmQgcmVnZXhwLlxuICBmdW5jdGlvbiBnZXRQcm9wVHlwZShwcm9wVmFsdWUpIHtcbiAgICB2YXIgcHJvcFR5cGUgPSB0eXBlb2YgcHJvcFZhbHVlO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgIHJldHVybiAnYXJyYXknO1xuICAgIH1cbiAgICBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAvLyBPbGQgd2Via2l0cyAoYXQgbGVhc3QgdW50aWwgQW5kcm9pZCA0LjApIHJldHVybiAnZnVuY3Rpb24nIHJhdGhlciB0aGFuXG4gICAgICAvLyAnb2JqZWN0JyBmb3IgdHlwZW9mIGEgUmVnRXhwLiBXZSdsbCBub3JtYWxpemUgdGhpcyBoZXJlIHNvIHRoYXQgL2JsYS9cbiAgICAgIC8vIHBhc3NlcyBQcm9wVHlwZXMub2JqZWN0LlxuICAgICAgcmV0dXJuICdvYmplY3QnO1xuICAgIH1cbiAgICBpZiAoaXNTeW1ib2wocHJvcFR5cGUsIHByb3BWYWx1ZSkpIHtcbiAgICAgIHJldHVybiAnc3ltYm9sJztcbiAgICB9XG4gICAgcmV0dXJuIHByb3BUeXBlO1xuICB9XG5cbiAgLy8gVGhpcyBoYW5kbGVzIG1vcmUgdHlwZXMgdGhhbiBgZ2V0UHJvcFR5cGVgLiBPbmx5IHVzZWQgZm9yIGVycm9yIG1lc3NhZ2VzLlxuICAvLyBTZWUgYGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyYC5cbiAgZnVuY3Rpb24gZ2V0UHJlY2lzZVR5cGUocHJvcFZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiBwcm9wVmFsdWUgPT09ICd1bmRlZmluZWQnIHx8IHByb3BWYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuICcnICsgcHJvcFZhbHVlO1xuICAgIH1cbiAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgIGlmIChwcm9wVHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIHJldHVybiAnZGF0ZSc7XG4gICAgICB9IGVsc2UgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICByZXR1cm4gJ3JlZ2V4cCc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwcm9wVHlwZTtcbiAgfVxuXG4gIC8vIFJldHVybnMgYSBzdHJpbmcgdGhhdCBpcyBwb3N0Zml4ZWQgdG8gYSB3YXJuaW5nIGFib3V0IGFuIGludmFsaWQgdHlwZS5cbiAgLy8gRm9yIGV4YW1wbGUsIFwidW5kZWZpbmVkXCIgb3IgXCJvZiB0eXBlIGFycmF5XCJcbiAgZnVuY3Rpb24gZ2V0UG9zdGZpeEZvclR5cGVXYXJuaW5nKHZhbHVlKSB7XG4gICAgdmFyIHR5cGUgPSBnZXRQcmVjaXNlVHlwZSh2YWx1ZSk7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICdhcnJheSc6XG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICByZXR1cm4gJ2FuICcgKyB0eXBlO1xuICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICBjYXNlICdkYXRlJzpcbiAgICAgIGNhc2UgJ3JlZ2V4cCc6XG4gICAgICAgIHJldHVybiAnYSAnICsgdHlwZTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgIH1cbiAgfVxuXG4gIC8vIFJldHVybnMgY2xhc3MgbmFtZSBvZiB0aGUgb2JqZWN0LCBpZiBhbnkuXG4gIGZ1bmN0aW9uIGdldENsYXNzTmFtZShwcm9wVmFsdWUpIHtcbiAgICBpZiAoIXByb3BWYWx1ZS5jb25zdHJ1Y3RvciB8fCAhcHJvcFZhbHVlLmNvbnN0cnVjdG9yLm5hbWUpIHtcbiAgICAgIHJldHVybiBBTk9OWU1PVVM7XG4gICAgfVxuICAgIHJldHVybiBwcm9wVmFsdWUuY29uc3RydWN0b3IubmFtZTtcbiAgfVxuXG4gIFJlYWN0UHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzID0gY2hlY2tQcm9wVHlwZXM7XG4gIFJlYWN0UHJvcFR5cGVzLnJlc2V0V2FybmluZ0NhY2hlID0gY2hlY2tQcm9wVHlwZXMucmVzZXRXYXJuaW5nQ2FjaGU7XG4gIFJlYWN0UHJvcFR5cGVzLlByb3BUeXBlcyA9IFJlYWN0UHJvcFR5cGVzO1xuXG4gIHJldHVybiBSZWFjdFByb3BUeXBlcztcbn07XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBSZWFjdElzID0gcmVxdWlyZSgncmVhY3QtaXMnKTtcblxuICAvLyBCeSBleHBsaWNpdGx5IHVzaW5nIGBwcm9wLXR5cGVzYCB5b3UgYXJlIG9wdGluZyBpbnRvIG5ldyBkZXZlbG9wbWVudCBiZWhhdmlvci5cbiAgLy8gaHR0cDovL2ZiLm1lL3Byb3AtdHlwZXMtaW4tcHJvZFxuICB2YXIgdGhyb3dPbkRpcmVjdEFjY2VzcyA9IHRydWU7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9mYWN0b3J5V2l0aFR5cGVDaGVja2VycycpKFJlYWN0SXMuaXNFbGVtZW50LCB0aHJvd09uRGlyZWN0QWNjZXNzKTtcbn0gZWxzZSB7XG4gIC8vIEJ5IGV4cGxpY2l0bHkgdXNpbmcgYHByb3AtdHlwZXNgIHlvdSBhcmUgb3B0aW5nIGludG8gbmV3IHByb2R1Y3Rpb24gYmVoYXZpb3IuXG4gIC8vIGh0dHA6Ly9mYi5tZS9wcm9wLXR5cGVzLWluLXByb2RcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2ZhY3RvcnlXaXRoVGhyb3dpbmdTaGltcycpKCk7XG59XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gJ1NFQ1JFVF9ET19OT1RfUEFTU19USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEJztcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFByb3BUeXBlc1NlY3JldDtcbiIsInZhciBfX3JlYWQgPSAodGhpcyAmJiB0aGlzLl9fcmVhZCkgfHwgZnVuY3Rpb24gKG8sIG4pIHtcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XG4gICAgaWYgKCFtKSByZXR1cm4gbztcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcbiAgICB0cnkge1xuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cbiAgICB9XG4gICAgcmV0dXJuIGFyO1xufTtcbmV4cG9ydCB2YXIgc3R5bGVUb09iamVjdCA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgIHZhciBhdHRyaWJ1dGVzID0gaW5wdXQuc3BsaXQoLyA/OyA/Lyk7XG4gICAgcmV0dXJuIGF0dHJpYnV0ZXMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGQpIHtcbiAgICAgICAgdmFyIF9hID0gX19yZWFkKGQuc3BsaXQoLyA/OiA/LyksIDIpLCBrZXkgPSBfYVswXSwgdmFsdWUgPSBfYVsxXTtcbiAgICAgICAgaWYgKGtleSAmJiB2YWx1ZSkge1xuICAgICAgICAgICAgYWNjW2tleS5yZXBsYWNlKC8tKFxcdykvZywgZnVuY3Rpb24gKF8kMCwgJDEpIHsgcmV0dXJuICQxLnRvVXBwZXJDYXNlKCk7IH0pXSA9IE51bWJlci5pc05hTihOdW1iZXIodmFsdWUpKVxuICAgICAgICAgICAgICAgID8gdmFsdWVcbiAgICAgICAgICAgICAgICA6IE51bWJlcih2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB7fSk7XG59O1xuZXhwb3J0IHZhciBub1RleHRDaGlsZE5vZGVzID0gW1xuICAgICdicicsXG4gICAgJ2NvbCcsXG4gICAgJ2NvbGdyb3VwJyxcbiAgICAnZGwnLFxuICAgICdocicsXG4gICAgJ2lmcmFtZScsXG4gICAgJ2ltZycsXG4gICAgJ2lucHV0JyxcbiAgICAnbGluaycsXG4gICAgJ21lbnVpdGVtJyxcbiAgICAnbWV0YScsXG4gICAgJ29sJyxcbiAgICAncGFyYW0nLFxuICAgICdzZWxlY3QnLFxuICAgICd0YWJsZScsXG4gICAgJ3Rib2R5JyxcbiAgICAndGZvb3QnLFxuICAgICd0aGVhZCcsXG4gICAgJ3RyJyxcbiAgICAndWwnLFxuICAgICd3YnInLFxuXTtcbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbi8vIFRha2VuIGZyb20gaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2ZhY2Vib29rL3JlYWN0L2JhZmY1Y2MyZjY5ZDMwNTg5YTVkYzY1YjA4OWU0Nzc2NTQzNzI5NGIvcGFja2FnZXMvcmVhY3QtZG9tL3NyYy9zaGFyZWQvcG9zc2libGVTdGFuZGFyZE5hbWVzLmpzXG4vLyB0c2xpbnQ6ZGlzYWJsZTpvYmplY3QtbGl0ZXJhbC1zb3J0LWtleXNcbmV4cG9ydCB2YXIgcG9zc2libGVTdGFuZGFyZE5hbWVzID0ge1xuICAgIC8vIEhUTUxcbiAgICAnYWNjZXB0LWNoYXJzZXQnOiAnYWNjZXB0Q2hhcnNldCcsXG4gICAgYWNjZXB0Y2hhcnNldDogJ2FjY2VwdENoYXJzZXQnLFxuICAgIGFjY2Vzc2tleTogJ2FjY2Vzc0tleScsXG4gICAgYWxsb3dmdWxsc2NyZWVuOiAnYWxsb3dGdWxsU2NyZWVuJyxcbiAgICBhdXRvY2FwaXRhbGl6ZTogJ2F1dG9DYXBpdGFsaXplJyxcbiAgICBhdXRvY29tcGxldGU6ICdhdXRvQ29tcGxldGUnLFxuICAgIGF1dG9jb3JyZWN0OiAnYXV0b0NvcnJlY3QnLFxuICAgIGF1dG9mb2N1czogJ2F1dG9Gb2N1cycsXG4gICAgYXV0b3BsYXk6ICdhdXRvUGxheScsXG4gICAgYXV0b3NhdmU6ICdhdXRvU2F2ZScsXG4gICAgY2VsbHBhZGRpbmc6ICdjZWxsUGFkZGluZycsXG4gICAgY2VsbHNwYWNpbmc6ICdjZWxsU3BhY2luZycsXG4gICAgY2hhcnNldDogJ2NoYXJTZXQnLFxuICAgIGNsYXNzOiAnY2xhc3NOYW1lJyxcbiAgICBjbGFzc2lkOiAnY2xhc3NJRCcsXG4gICAgY2xhc3NuYW1lOiAnY2xhc3NOYW1lJyxcbiAgICBjb2xzcGFuOiAnY29sU3BhbicsXG4gICAgY29udGVudGVkaXRhYmxlOiAnY29udGVudEVkaXRhYmxlJyxcbiAgICBjb250ZXh0bWVudTogJ2NvbnRleHRNZW51JyxcbiAgICBjb250cm9sc2xpc3Q6ICdjb250cm9sc0xpc3QnLFxuICAgIGNyb3Nzb3JpZ2luOiAnY3Jvc3NPcmlnaW4nLFxuICAgIGRhbmdlcm91c2x5c2V0aW5uZXJodG1sOiAnZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwnLFxuICAgIGRhdGV0aW1lOiAnZGF0ZVRpbWUnLFxuICAgIGRlZmF1bHRjaGVja2VkOiAnZGVmYXVsdENoZWNrZWQnLFxuICAgIGRlZmF1bHR2YWx1ZTogJ2RlZmF1bHRWYWx1ZScsXG4gICAgZW5jdHlwZTogJ2VuY1R5cGUnLFxuICAgIGZvcjogJ2h0bWxGb3InLFxuICAgIGZvcm1tZXRob2Q6ICdmb3JtTWV0aG9kJyxcbiAgICBmb3JtYWN0aW9uOiAnZm9ybUFjdGlvbicsXG4gICAgZm9ybWVuY3R5cGU6ICdmb3JtRW5jVHlwZScsXG4gICAgZm9ybW5vdmFsaWRhdGU6ICdmb3JtTm9WYWxpZGF0ZScsXG4gICAgZm9ybXRhcmdldDogJ2Zvcm1UYXJnZXQnLFxuICAgIGZyYW1lYm9yZGVyOiAnZnJhbWVCb3JkZXInLFxuICAgIGhyZWZsYW5nOiAnaHJlZkxhbmcnLFxuICAgIGh0bWxmb3I6ICdodG1sRm9yJyxcbiAgICBodHRwZXF1aXY6ICdodHRwRXF1aXYnLFxuICAgICdodHRwLWVxdWl2JzogJ2h0dHBFcXVpdicsXG4gICAgaWNvbjogJ2ljb24nLFxuICAgIGlubmVyaHRtbDogJ2lubmVySFRNTCcsXG4gICAgaW5wdXRtb2RlOiAnaW5wdXRNb2RlJyxcbiAgICBpdGVtaWQ6ICdpdGVtSUQnLFxuICAgIGl0ZW1wcm9wOiAnaXRlbVByb3AnLFxuICAgIGl0ZW1yZWY6ICdpdGVtUmVmJyxcbiAgICBpdGVtc2NvcGU6ICdpdGVtU2NvcGUnLFxuICAgIGl0ZW10eXBlOiAnaXRlbVR5cGUnLFxuICAgIGtleXBhcmFtczogJ2tleVBhcmFtcycsXG4gICAga2V5dHlwZTogJ2tleVR5cGUnLFxuICAgIG1hcmdpbndpZHRoOiAnbWFyZ2luV2lkdGgnLFxuICAgIG1hcmdpbmhlaWdodDogJ21hcmdpbkhlaWdodCcsXG4gICAgbWF4bGVuZ3RoOiAnbWF4TGVuZ3RoJyxcbiAgICBtZWRpYWdyb3VwOiAnbWVkaWFHcm91cCcsXG4gICAgbWlubGVuZ3RoOiAnbWluTGVuZ3RoJyxcbiAgICBub21vZHVsZTogJ25vTW9kdWxlJyxcbiAgICBub3ZhbGlkYXRlOiAnbm9WYWxpZGF0ZScsXG4gICAgcGxheXNpbmxpbmU6ICdwbGF5c0lubGluZScsXG4gICAgcmFkaW9ncm91cDogJ3JhZGlvR3JvdXAnLFxuICAgIHJlYWRvbmx5OiAncmVhZE9ubHknLFxuICAgIHJlZmVycmVycG9saWN5OiAncmVmZXJyZXJQb2xpY3knLFxuICAgIHJvd3NwYW46ICdyb3dTcGFuJyxcbiAgICBzcGVsbGNoZWNrOiAnc3BlbGxDaGVjaycsXG4gICAgc3JjZG9jOiAnc3JjRG9jJyxcbiAgICBzcmNsYW5nOiAnc3JjTGFuZycsXG4gICAgc3Jjc2V0OiAnc3JjU2V0JyxcbiAgICB0YWJpbmRleDogJ3RhYkluZGV4JyxcbiAgICB0eXBlbXVzdG1hdGNoOiAndHlwZU11c3RNYXRjaCcsXG4gICAgdXNlbWFwOiAndXNlTWFwJyxcbiAgICAvLyBTVkdcbiAgICBhY2NlbnRoZWlnaHQ6ICdhY2NlbnRIZWlnaHQnLFxuICAgICdhY2NlbnQtaGVpZ2h0JzogJ2FjY2VudEhlaWdodCcsXG4gICAgYWxpZ25tZW50YmFzZWxpbmU6ICdhbGlnbm1lbnRCYXNlbGluZScsXG4gICAgJ2FsaWdubWVudC1iYXNlbGluZSc6ICdhbGlnbm1lbnRCYXNlbGluZScsXG4gICAgYWxsb3dyZW9yZGVyOiAnYWxsb3dSZW9yZGVyJyxcbiAgICBhcmFiaWNmb3JtOiAnYXJhYmljRm9ybScsXG4gICAgJ2FyYWJpYy1mb3JtJzogJ2FyYWJpY0Zvcm0nLFxuICAgIGF0dHJpYnV0ZW5hbWU6ICdhdHRyaWJ1dGVOYW1lJyxcbiAgICBhdHRyaWJ1dGV0eXBlOiAnYXR0cmlidXRlVHlwZScsXG4gICAgYXV0b3JldmVyc2U6ICdhdXRvUmV2ZXJzZScsXG4gICAgYmFzZWZyZXF1ZW5jeTogJ2Jhc2VGcmVxdWVuY3knLFxuICAgIGJhc2VsaW5lc2hpZnQ6ICdiYXNlbGluZVNoaWZ0JyxcbiAgICAnYmFzZWxpbmUtc2hpZnQnOiAnYmFzZWxpbmVTaGlmdCcsXG4gICAgYmFzZXByb2ZpbGU6ICdiYXNlUHJvZmlsZScsXG4gICAgY2FsY21vZGU6ICdjYWxjTW9kZScsXG4gICAgY2FwaGVpZ2h0OiAnY2FwSGVpZ2h0JyxcbiAgICAnY2FwLWhlaWdodCc6ICdjYXBIZWlnaHQnLFxuICAgIGNsaXBwYXRoOiAnY2xpcFBhdGgnLFxuICAgICdjbGlwLXBhdGgnOiAnY2xpcFBhdGgnLFxuICAgIGNsaXBwYXRodW5pdHM6ICdjbGlwUGF0aFVuaXRzJyxcbiAgICBjbGlwcnVsZTogJ2NsaXBSdWxlJyxcbiAgICAnY2xpcC1ydWxlJzogJ2NsaXBSdWxlJyxcbiAgICBjb2xvcmludGVycG9sYXRpb246ICdjb2xvckludGVycG9sYXRpb24nLFxuICAgICdjb2xvci1pbnRlcnBvbGF0aW9uJzogJ2NvbG9ySW50ZXJwb2xhdGlvbicsXG4gICAgY29sb3JpbnRlcnBvbGF0aW9uZmlsdGVyczogJ2NvbG9ySW50ZXJwb2xhdGlvbkZpbHRlcnMnLFxuICAgICdjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnMnOiAnY29sb3JJbnRlcnBvbGF0aW9uRmlsdGVycycsXG4gICAgY29sb3Jwcm9maWxlOiAnY29sb3JQcm9maWxlJyxcbiAgICAnY29sb3ItcHJvZmlsZSc6ICdjb2xvclByb2ZpbGUnLFxuICAgIGNvbG9ycmVuZGVyaW5nOiAnY29sb3JSZW5kZXJpbmcnLFxuICAgICdjb2xvci1yZW5kZXJpbmcnOiAnY29sb3JSZW5kZXJpbmcnLFxuICAgIGNvbnRlbnRzY3JpcHR0eXBlOiAnY29udGVudFNjcmlwdFR5cGUnLFxuICAgIGNvbnRlbnRzdHlsZXR5cGU6ICdjb250ZW50U3R5bGVUeXBlJyxcbiAgICBkaWZmdXNlY29uc3RhbnQ6ICdkaWZmdXNlQ29uc3RhbnQnLFxuICAgIGRvbWluYW50YmFzZWxpbmU6ICdkb21pbmFudEJhc2VsaW5lJyxcbiAgICAnZG9taW5hbnQtYmFzZWxpbmUnOiAnZG9taW5hbnRCYXNlbGluZScsXG4gICAgZWRnZW1vZGU6ICdlZGdlTW9kZScsXG4gICAgZW5hYmxlYmFja2dyb3VuZDogJ2VuYWJsZUJhY2tncm91bmQnLFxuICAgICdlbmFibGUtYmFja2dyb3VuZCc6ICdlbmFibGVCYWNrZ3JvdW5kJyxcbiAgICBleHRlcm5hbHJlc291cmNlc3JlcXVpcmVkOiAnZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZCcsXG4gICAgZmlsbG9wYWNpdHk6ICdmaWxsT3BhY2l0eScsXG4gICAgJ2ZpbGwtb3BhY2l0eSc6ICdmaWxsT3BhY2l0eScsXG4gICAgZmlsbHJ1bGU6ICdmaWxsUnVsZScsXG4gICAgJ2ZpbGwtcnVsZSc6ICdmaWxsUnVsZScsXG4gICAgZmlsdGVycmVzOiAnZmlsdGVyUmVzJyxcbiAgICBmaWx0ZXJ1bml0czogJ2ZpbHRlclVuaXRzJyxcbiAgICBmbG9vZG9wYWNpdHk6ICdmbG9vZE9wYWNpdHknLFxuICAgICdmbG9vZC1vcGFjaXR5JzogJ2Zsb29kT3BhY2l0eScsXG4gICAgZmxvb2Rjb2xvcjogJ2Zsb29kQ29sb3InLFxuICAgICdmbG9vZC1jb2xvcic6ICdmbG9vZENvbG9yJyxcbiAgICBmb250ZmFtaWx5OiAnZm9udEZhbWlseScsXG4gICAgJ2ZvbnQtZmFtaWx5JzogJ2ZvbnRGYW1pbHknLFxuICAgIGZvbnRzaXplOiAnZm9udFNpemUnLFxuICAgICdmb250LXNpemUnOiAnZm9udFNpemUnLFxuICAgIGZvbnRzaXplYWRqdXN0OiAnZm9udFNpemVBZGp1c3QnLFxuICAgICdmb250LXNpemUtYWRqdXN0JzogJ2ZvbnRTaXplQWRqdXN0JyxcbiAgICBmb250c3RyZXRjaDogJ2ZvbnRTdHJldGNoJyxcbiAgICAnZm9udC1zdHJldGNoJzogJ2ZvbnRTdHJldGNoJyxcbiAgICBmb250c3R5bGU6ICdmb250U3R5bGUnLFxuICAgICdmb250LXN0eWxlJzogJ2ZvbnRTdHlsZScsXG4gICAgZm9udHZhcmlhbnQ6ICdmb250VmFyaWFudCcsXG4gICAgJ2ZvbnQtdmFyaWFudCc6ICdmb250VmFyaWFudCcsXG4gICAgZm9udHdlaWdodDogJ2ZvbnRXZWlnaHQnLFxuICAgICdmb250LXdlaWdodCc6ICdmb250V2VpZ2h0JyxcbiAgICBnbHlwaG5hbWU6ICdnbHlwaE5hbWUnLFxuICAgICdnbHlwaC1uYW1lJzogJ2dseXBoTmFtZScsXG4gICAgZ2x5cGhvcmllbnRhdGlvbmhvcml6b250YWw6ICdnbHlwaE9yaWVudGF0aW9uSG9yaXpvbnRhbCcsXG4gICAgJ2dseXBoLW9yaWVudGF0aW9uLWhvcml6b250YWwnOiAnZ2x5cGhPcmllbnRhdGlvbkhvcml6b250YWwnLFxuICAgIGdseXBob3JpZW50YXRpb252ZXJ0aWNhbDogJ2dseXBoT3JpZW50YXRpb25WZXJ0aWNhbCcsXG4gICAgJ2dseXBoLW9yaWVudGF0aW9uLXZlcnRpY2FsJzogJ2dseXBoT3JpZW50YXRpb25WZXJ0aWNhbCcsXG4gICAgZ2x5cGhyZWY6ICdnbHlwaFJlZicsXG4gICAgZ3JhZGllbnR0cmFuc2Zvcm06ICdncmFkaWVudFRyYW5zZm9ybScsXG4gICAgZ3JhZGllbnR1bml0czogJ2dyYWRpZW50VW5pdHMnLFxuICAgIGhvcml6YWR2eDogJ2hvcml6QWR2WCcsXG4gICAgJ2hvcml6LWFkdi14JzogJ2hvcml6QWR2WCcsXG4gICAgaG9yaXpvcmlnaW54OiAnaG9yaXpPcmlnaW5YJyxcbiAgICAnaG9yaXotb3JpZ2luLXgnOiAnaG9yaXpPcmlnaW5YJyxcbiAgICBpbWFnZXJlbmRlcmluZzogJ2ltYWdlUmVuZGVyaW5nJyxcbiAgICAnaW1hZ2UtcmVuZGVyaW5nJzogJ2ltYWdlUmVuZGVyaW5nJyxcbiAgICBrZXJuZWxtYXRyaXg6ICdrZXJuZWxNYXRyaXgnLFxuICAgIGtlcm5lbHVuaXRsZW5ndGg6ICdrZXJuZWxVbml0TGVuZ3RoJyxcbiAgICBrZXlwb2ludHM6ICdrZXlQb2ludHMnLFxuICAgIGtleXNwbGluZXM6ICdrZXlTcGxpbmVzJyxcbiAgICBrZXl0aW1lczogJ2tleVRpbWVzJyxcbiAgICBsZW5ndGhhZGp1c3Q6ICdsZW5ndGhBZGp1c3QnLFxuICAgIGxldHRlcnNwYWNpbmc6ICdsZXR0ZXJTcGFjaW5nJyxcbiAgICAnbGV0dGVyLXNwYWNpbmcnOiAnbGV0dGVyU3BhY2luZycsXG4gICAgbGlnaHRpbmdjb2xvcjogJ2xpZ2h0aW5nQ29sb3InLFxuICAgICdsaWdodGluZy1jb2xvcic6ICdsaWdodGluZ0NvbG9yJyxcbiAgICBsaW1pdGluZ2NvbmVhbmdsZTogJ2xpbWl0aW5nQ29uZUFuZ2xlJyxcbiAgICBtYXJrZXJlbmQ6ICdtYXJrZXJFbmQnLFxuICAgICdtYXJrZXItZW5kJzogJ21hcmtlckVuZCcsXG4gICAgbWFya2VyaGVpZ2h0OiAnbWFya2VySGVpZ2h0JyxcbiAgICBtYXJrZXJtaWQ6ICdtYXJrZXJNaWQnLFxuICAgICdtYXJrZXItbWlkJzogJ21hcmtlck1pZCcsXG4gICAgbWFya2Vyc3RhcnQ6ICdtYXJrZXJTdGFydCcsXG4gICAgJ21hcmtlci1zdGFydCc6ICdtYXJrZXJTdGFydCcsXG4gICAgbWFya2VydW5pdHM6ICdtYXJrZXJVbml0cycsXG4gICAgbWFya2Vyd2lkdGg6ICdtYXJrZXJXaWR0aCcsXG4gICAgbWFza2NvbnRlbnR1bml0czogJ21hc2tDb250ZW50VW5pdHMnLFxuICAgIG1hc2t1bml0czogJ21hc2tVbml0cycsXG4gICAgbnVtb2N0YXZlczogJ251bU9jdGF2ZXMnLFxuICAgIG92ZXJsaW5lcG9zaXRpb246ICdvdmVybGluZVBvc2l0aW9uJyxcbiAgICAnb3ZlcmxpbmUtcG9zaXRpb24nOiAnb3ZlcmxpbmVQb3NpdGlvbicsXG4gICAgb3ZlcmxpbmV0aGlja25lc3M6ICdvdmVybGluZVRoaWNrbmVzcycsXG4gICAgJ292ZXJsaW5lLXRoaWNrbmVzcyc6ICdvdmVybGluZVRoaWNrbmVzcycsXG4gICAgcGFpbnRvcmRlcjogJ3BhaW50T3JkZXInLFxuICAgICdwYWludC1vcmRlcic6ICdwYWludE9yZGVyJyxcbiAgICAncGFub3NlLTEnOiAncGFub3NlMScsXG4gICAgcGF0aGxlbmd0aDogJ3BhdGhMZW5ndGgnLFxuICAgIHBhdHRlcm5jb250ZW50dW5pdHM6ICdwYXR0ZXJuQ29udGVudFVuaXRzJyxcbiAgICBwYXR0ZXJudHJhbnNmb3JtOiAncGF0dGVyblRyYW5zZm9ybScsXG4gICAgcGF0dGVybnVuaXRzOiAncGF0dGVyblVuaXRzJyxcbiAgICBwb2ludGVyZXZlbnRzOiAncG9pbnRlckV2ZW50cycsXG4gICAgJ3BvaW50ZXItZXZlbnRzJzogJ3BvaW50ZXJFdmVudHMnLFxuICAgIHBvaW50c2F0eDogJ3BvaW50c0F0WCcsXG4gICAgcG9pbnRzYXR5OiAncG9pbnRzQXRZJyxcbiAgICBwb2ludHNhdHo6ICdwb2ludHNBdFonLFxuICAgIHByZXNlcnZlYWxwaGE6ICdwcmVzZXJ2ZUFscGhhJyxcbiAgICBwcmVzZXJ2ZWFzcGVjdHJhdGlvOiAncHJlc2VydmVBc3BlY3RSYXRpbycsXG4gICAgcHJpbWl0aXZldW5pdHM6ICdwcmltaXRpdmVVbml0cycsXG4gICAgcmVmeDogJ3JlZlgnLFxuICAgIHJlZnk6ICdyZWZZJyxcbiAgICByZW5kZXJpbmdpbnRlbnQ6ICdyZW5kZXJpbmdJbnRlbnQnLFxuICAgICdyZW5kZXJpbmctaW50ZW50JzogJ3JlbmRlcmluZ0ludGVudCcsXG4gICAgcmVwZWF0Y291bnQ6ICdyZXBlYXRDb3VudCcsXG4gICAgcmVwZWF0ZHVyOiAncmVwZWF0RHVyJyxcbiAgICByZXF1aXJlZGV4dGVuc2lvbnM6ICdyZXF1aXJlZEV4dGVuc2lvbnMnLFxuICAgIHJlcXVpcmVkZmVhdHVyZXM6ICdyZXF1aXJlZEZlYXR1cmVzJyxcbiAgICBzaGFwZXJlbmRlcmluZzogJ3NoYXBlUmVuZGVyaW5nJyxcbiAgICAnc2hhcGUtcmVuZGVyaW5nJzogJ3NoYXBlUmVuZGVyaW5nJyxcbiAgICBzcGVjdWxhcmNvbnN0YW50OiAnc3BlY3VsYXJDb25zdGFudCcsXG4gICAgc3BlY3VsYXJleHBvbmVudDogJ3NwZWN1bGFyRXhwb25lbnQnLFxuICAgIHNwcmVhZG1ldGhvZDogJ3NwcmVhZE1ldGhvZCcsXG4gICAgc3RhcnRvZmZzZXQ6ICdzdGFydE9mZnNldCcsXG4gICAgc3RkZGV2aWF0aW9uOiAnc3RkRGV2aWF0aW9uJyxcbiAgICBzdGl0Y2h0aWxlczogJ3N0aXRjaFRpbGVzJyxcbiAgICBzdG9wY29sb3I6ICdzdG9wQ29sb3InLFxuICAgICdzdG9wLWNvbG9yJzogJ3N0b3BDb2xvcicsXG4gICAgc3RvcG9wYWNpdHk6ICdzdG9wT3BhY2l0eScsXG4gICAgJ3N0b3Atb3BhY2l0eSc6ICdzdG9wT3BhY2l0eScsXG4gICAgc3RyaWtldGhyb3VnaHBvc2l0aW9uOiAnc3RyaWtldGhyb3VnaFBvc2l0aW9uJyxcbiAgICAnc3RyaWtldGhyb3VnaC1wb3NpdGlvbic6ICdzdHJpa2V0aHJvdWdoUG9zaXRpb24nLFxuICAgIHN0cmlrZXRocm91Z2h0aGlja25lc3M6ICdzdHJpa2V0aHJvdWdoVGhpY2tuZXNzJyxcbiAgICAnc3RyaWtldGhyb3VnaC10aGlja25lc3MnOiAnc3RyaWtldGhyb3VnaFRoaWNrbmVzcycsXG4gICAgc3Ryb2tlZGFzaGFycmF5OiAnc3Ryb2tlRGFzaGFycmF5JyxcbiAgICAnc3Ryb2tlLWRhc2hhcnJheSc6ICdzdHJva2VEYXNoYXJyYXknLFxuICAgIHN0cm9rZWRhc2hvZmZzZXQ6ICdzdHJva2VEYXNob2Zmc2V0JyxcbiAgICAnc3Ryb2tlLWRhc2hvZmZzZXQnOiAnc3Ryb2tlRGFzaG9mZnNldCcsXG4gICAgc3Ryb2tlbGluZWNhcDogJ3N0cm9rZUxpbmVjYXAnLFxuICAgICdzdHJva2UtbGluZWNhcCc6ICdzdHJva2VMaW5lY2FwJyxcbiAgICBzdHJva2VsaW5lam9pbjogJ3N0cm9rZUxpbmVqb2luJyxcbiAgICAnc3Ryb2tlLWxpbmVqb2luJzogJ3N0cm9rZUxpbmVqb2luJyxcbiAgICBzdHJva2VtaXRlcmxpbWl0OiAnc3Ryb2tlTWl0ZXJsaW1pdCcsXG4gICAgJ3N0cm9rZS1taXRlcmxpbWl0JzogJ3N0cm9rZU1pdGVybGltaXQnLFxuICAgIHN0cm9rZXdpZHRoOiAnc3Ryb2tlV2lkdGgnLFxuICAgICdzdHJva2Utd2lkdGgnOiAnc3Ryb2tlV2lkdGgnLFxuICAgIHN0cm9rZW9wYWNpdHk6ICdzdHJva2VPcGFjaXR5JyxcbiAgICAnc3Ryb2tlLW9wYWNpdHknOiAnc3Ryb2tlT3BhY2l0eScsXG4gICAgc3VwcHJlc3Njb250ZW50ZWRpdGFibGV3YXJuaW5nOiAnc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nJyxcbiAgICBzdXBwcmVzc2h5ZHJhdGlvbndhcm5pbmc6ICdzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcnLFxuICAgIHN1cmZhY2VzY2FsZTogJ3N1cmZhY2VTY2FsZScsXG4gICAgc3lzdGVtbGFuZ3VhZ2U6ICdzeXN0ZW1MYW5ndWFnZScsXG4gICAgdGFibGV2YWx1ZXM6ICd0YWJsZVZhbHVlcycsXG4gICAgdGFyZ2V0eDogJ3RhcmdldFgnLFxuICAgIHRhcmdldHk6ICd0YXJnZXRZJyxcbiAgICB0ZXh0YW5jaG9yOiAndGV4dEFuY2hvcicsXG4gICAgJ3RleHQtYW5jaG9yJzogJ3RleHRBbmNob3InLFxuICAgIHRleHRkZWNvcmF0aW9uOiAndGV4dERlY29yYXRpb24nLFxuICAgICd0ZXh0LWRlY29yYXRpb24nOiAndGV4dERlY29yYXRpb24nLFxuICAgIHRleHRsZW5ndGg6ICd0ZXh0TGVuZ3RoJyxcbiAgICB0ZXh0cmVuZGVyaW5nOiAndGV4dFJlbmRlcmluZycsXG4gICAgJ3RleHQtcmVuZGVyaW5nJzogJ3RleHRSZW5kZXJpbmcnLFxuICAgIHVuZGVybGluZXBvc2l0aW9uOiAndW5kZXJsaW5lUG9zaXRpb24nLFxuICAgICd1bmRlcmxpbmUtcG9zaXRpb24nOiAndW5kZXJsaW5lUG9zaXRpb24nLFxuICAgIHVuZGVybGluZXRoaWNrbmVzczogJ3VuZGVybGluZVRoaWNrbmVzcycsXG4gICAgJ3VuZGVybGluZS10aGlja25lc3MnOiAndW5kZXJsaW5lVGhpY2tuZXNzJyxcbiAgICB1bmljb2RlYmlkaTogJ3VuaWNvZGVCaWRpJyxcbiAgICAndW5pY29kZS1iaWRpJzogJ3VuaWNvZGVCaWRpJyxcbiAgICB1bmljb2RlcmFuZ2U6ICd1bmljb2RlUmFuZ2UnLFxuICAgICd1bmljb2RlLXJhbmdlJzogJ3VuaWNvZGVSYW5nZScsXG4gICAgdW5pdHNwZXJlbTogJ3VuaXRzUGVyRW0nLFxuICAgICd1bml0cy1wZXItZW0nOiAndW5pdHNQZXJFbScsXG4gICAgdW5zZWxlY3RhYmxlOiAndW5zZWxlY3RhYmxlJyxcbiAgICB2YWxwaGFiZXRpYzogJ3ZBbHBoYWJldGljJyxcbiAgICAndi1hbHBoYWJldGljJzogJ3ZBbHBoYWJldGljJyxcbiAgICB2ZWN0b3JlZmZlY3Q6ICd2ZWN0b3JFZmZlY3QnLFxuICAgICd2ZWN0b3ItZWZmZWN0JzogJ3ZlY3RvckVmZmVjdCcsXG4gICAgdmVydGFkdnk6ICd2ZXJ0QWR2WScsXG4gICAgJ3ZlcnQtYWR2LXknOiAndmVydEFkdlknLFxuICAgIHZlcnRvcmlnaW54OiAndmVydE9yaWdpblgnLFxuICAgICd2ZXJ0LW9yaWdpbi14JzogJ3ZlcnRPcmlnaW5YJyxcbiAgICB2ZXJ0b3JpZ2lueTogJ3ZlcnRPcmlnaW5ZJyxcbiAgICAndmVydC1vcmlnaW4teSc6ICd2ZXJ0T3JpZ2luWScsXG4gICAgdmhhbmdpbmc6ICd2SGFuZ2luZycsXG4gICAgJ3YtaGFuZ2luZyc6ICd2SGFuZ2luZycsXG4gICAgdmlkZW9ncmFwaGljOiAndklkZW9ncmFwaGljJyxcbiAgICAndi1pZGVvZ3JhcGhpYyc6ICd2SWRlb2dyYXBoaWMnLFxuICAgIHZpZXdib3g6ICd2aWV3Qm94JyxcbiAgICB2aWV3dGFyZ2V0OiAndmlld1RhcmdldCcsXG4gICAgdm1hdGhlbWF0aWNhbDogJ3ZNYXRoZW1hdGljYWwnLFxuICAgICd2LW1hdGhlbWF0aWNhbCc6ICd2TWF0aGVtYXRpY2FsJyxcbiAgICB3b3Jkc3BhY2luZzogJ3dvcmRTcGFjaW5nJyxcbiAgICAnd29yZC1zcGFjaW5nJzogJ3dvcmRTcGFjaW5nJyxcbiAgICB3cml0aW5nbW9kZTogJ3dyaXRpbmdNb2RlJyxcbiAgICAnd3JpdGluZy1tb2RlJzogJ3dyaXRpbmdNb2RlJyxcbiAgICB4Y2hhbm5lbHNlbGVjdG9yOiAneENoYW5uZWxTZWxlY3RvcicsXG4gICAgeGhlaWdodDogJ3hIZWlnaHQnLFxuICAgICd4LWhlaWdodCc6ICd4SGVpZ2h0JyxcbiAgICB4bGlua2FjdHVhdGU6ICd4bGlua0FjdHVhdGUnLFxuICAgICd4bGluazphY3R1YXRlJzogJ3hsaW5rQWN0dWF0ZScsXG4gICAgeGxpbmthcmNyb2xlOiAneGxpbmtBcmNyb2xlJyxcbiAgICAneGxpbms6YXJjcm9sZSc6ICd4bGlua0FyY3JvbGUnLFxuICAgIHhsaW5raHJlZjogJ3hsaW5rSHJlZicsXG4gICAgJ3hsaW5rOmhyZWYnOiAneGxpbmtIcmVmJyxcbiAgICB4bGlua3JvbGU6ICd4bGlua1JvbGUnLFxuICAgICd4bGluazpyb2xlJzogJ3hsaW5rUm9sZScsXG4gICAgeGxpbmtzaG93OiAneGxpbmtTaG93JyxcbiAgICAneGxpbms6c2hvdyc6ICd4bGlua1Nob3cnLFxuICAgIHhsaW5rdGl0bGU6ICd4bGlua1RpdGxlJyxcbiAgICAneGxpbms6dGl0bGUnOiAneGxpbmtUaXRsZScsXG4gICAgeGxpbmt0eXBlOiAneGxpbmtUeXBlJyxcbiAgICAneGxpbms6dHlwZSc6ICd4bGlua1R5cGUnLFxuICAgIHhtbGJhc2U6ICd4bWxCYXNlJyxcbiAgICAneG1sOmJhc2UnOiAneG1sQmFzZScsXG4gICAgeG1sbGFuZzogJ3htbExhbmcnLFxuICAgICd4bWw6bGFuZyc6ICd4bWxMYW5nJyxcbiAgICAneG1sOnNwYWNlJzogJ3htbFNwYWNlJyxcbiAgICB4bWxuc3hsaW5rOiAneG1sbnNYbGluaycsXG4gICAgJ3htbG5zOnhsaW5rJzogJ3htbG5zWGxpbmsnLFxuICAgIHhtbHNwYWNlOiAneG1sU3BhY2UnLFxuICAgIHljaGFubmVsc2VsZWN0b3I6ICd5Q2hhbm5lbFNlbGVjdG9yJyxcbiAgICB6b29tYW5kcGFuOiAnem9vbUFuZFBhbicsXG4gICAgLy8gZXZlbnQgaGFuZGxlcnNcbiAgICBvbmJsdXI6ICdvbkJsdXInLFxuICAgIG9uY2hhbmdlOiAnb25DaGFuZ2UnLFxuICAgIG9uY2xpY2s6ICdvbkNsaWNrJyxcbiAgICBvbmNvbnRleHRtZW51OiAnb25Db250ZXh0TWVudScsXG4gICAgb25kb3VibGVjbGljazogJ29uRG91YmxlQ2xpY2snLFxuICAgIG9uZHJhZzogJ29uRHJhZycsXG4gICAgb25kcmFnZW5kOiAnb25EcmFnRW5kJyxcbiAgICBvbmRyYWdlbnRlcjogJ29uRHJhZ0VudGVyJyxcbiAgICBvbmRyYWdleGl0OiAnb25EcmFnRXhpdCcsXG4gICAgb25kcmFnbGVhdmU6ICdvbkRyYWdMZWF2ZScsXG4gICAgb25kcmFnb3ZlcjogJ29uRHJhZ092ZXInLFxuICAgIG9uZHJhZ3N0YXJ0OiAnb25EcmFnU3RhcnQnLFxuICAgIG9uZHJvcDogJ29uRHJvcCcsXG4gICAgb25lcnJvcjogJ29uRXJyb3InLFxuICAgIG9uZm9jdXM6ICdvbkZvY3VzJyxcbiAgICBvbmlucHV0OiAnb25JbnB1dCcsXG4gICAgb25pbnZhbGlkOiAnb25JbnZhbGlkJyxcbiAgICBvbmtleWRvd246ICdvbktleURvd24nLFxuICAgIG9ua2V5cHJlc3M6ICdvbktleVByZXNzJyxcbiAgICBvbmtleXVwOiAnb25LZXlVcCcsXG4gICAgb25sb2FkOiAnb25Mb2FkJyxcbiAgICBvbm1vdXNlZG93bjogJ29uTW91c2VEb3duJyxcbiAgICBvbm1vdXNlZW50ZXI6ICdvbk1vdXNlRW50ZXInLFxuICAgIG9ubW91c2VsZWF2ZTogJ29uTW91c2VMZWF2ZScsXG4gICAgb25tb3VzZW1vdmU6ICdvbk1vdXNlTW92ZScsXG4gICAgb25tb3VzZW91dDogJ29uTW91c2VPdXQnLFxuICAgIG9ubW91c2VvdmVyOiAnb25Nb3VzZU92ZXInLFxuICAgIG9ubW91c2V1cDogJ29uTW91c2VVcCcsXG4gICAgb25zY3JvbGw6ICdvblNjcm9sbCcsXG4gICAgb25zdWJtaXQ6ICdvblN1Ym1pdCcsXG4gICAgb250b3VjaGNhbmNlbDogJ29uVG91Y2hDYW5jZWwnLFxuICAgIG9udG91Y2hlbmQ6ICdvblRvdWNoRW5kJyxcbiAgICBvbnRvdWNobW92ZTogJ29uVG91Y2hNb3ZlJyxcbiAgICBvbnRvdWNoc3RhcnQ6ICdvblRvdWNoU3RhcnQnLFxuICAgIG9ud2hlZWw6ICdvbldoZWVsJyxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oZWxwZXJzLmpzLm1hcCIsInZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG52YXIgX19yZWFkID0gKHRoaXMgJiYgdGhpcy5fX3JlYWQpIHx8IGZ1bmN0aW9uIChvLCBuKSB7XG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgIGlmICghbSkgcmV0dXJuIG87XG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XG4gICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiBhcjtcbn07XG52YXIgX19zcHJlYWQgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgYXIgPSBbXSwgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIGFyID0gYXIuY29uY2F0KF9fcmVhZChhcmd1bWVudHNbaV0pKTtcbiAgICByZXR1cm4gYXI7XG59O1xuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lICovXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBub1RleHRDaGlsZE5vZGVzLCBwb3NzaWJsZVN0YW5kYXJkTmFtZXMsIHN0eWxlVG9PYmplY3QgfSBmcm9tICcuL2hlbHBlcnMnO1xuZnVuY3Rpb24gcGFyc2VBdHRyaWJ1dGVzKG5vZGUsIHJlYWN0S2V5KSB7XG4gICAgdmFyIGF0dHJpYnV0ZXMgPSB7XG4gICAgICAgIGtleTogcmVhY3RLZXksXG4gICAgfTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChub2RlIGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgICAgICB2YXIgbm9kZUNsYXNzTmFtZXMgPSBub2RlLmdldEF0dHJpYnV0ZSgnY2xhc3MnKTtcbiAgICAgICAgaWYgKG5vZGVDbGFzc05hbWVzKSB7XG4gICAgICAgICAgICBhdHRyaWJ1dGVzLmNsYXNzTmFtZSA9IG5vZGVDbGFzc05hbWVzO1xuICAgICAgICB9XG4gICAgICAgIF9fc3ByZWFkKG5vZGUuYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgc3dpdGNoIChkLm5hbWUpIHtcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIG1hbnVhbGx5IGhhbmRsZWQgYWJvdmUsIHNvIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2NsYXNzJzpcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3R5bGUnOlxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzW2QubmFtZV0gPSBzdHlsZVRvT2JqZWN0KGQudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdhbGxvd2Z1bGxzY3JlZW4nOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2FsbG93cGF5bWVudHJlcXVlc3QnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2FzeW5jJzpcbiAgICAgICAgICAgICAgICBjYXNlICdhdXRvZm9jdXMnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2F1dG9wbGF5JzpcbiAgICAgICAgICAgICAgICBjYXNlICdjaGVja2VkJzpcbiAgICAgICAgICAgICAgICBjYXNlICdjb250cm9scyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnZGVmYXVsdCc6XG4gICAgICAgICAgICAgICAgY2FzZSAnZGVmZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Rpc2FibGVkJzpcbiAgICAgICAgICAgICAgICBjYXNlICdmb3Jtbm92YWxpZGF0ZSc6XG4gICAgICAgICAgICAgICAgY2FzZSAnaGlkZGVuJzpcbiAgICAgICAgICAgICAgICBjYXNlICdpc21hcCc6XG4gICAgICAgICAgICAgICAgY2FzZSAnaXRlbXNjb3BlJzpcbiAgICAgICAgICAgICAgICBjYXNlICdsb29wJzpcbiAgICAgICAgICAgICAgICBjYXNlICdtdWx0aXBsZSc6XG4gICAgICAgICAgICAgICAgY2FzZSAnbXV0ZWQnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ25vbW9kdWxlJzpcbiAgICAgICAgICAgICAgICBjYXNlICdub3ZhbGlkYXRlJzpcbiAgICAgICAgICAgICAgICBjYXNlICdvcGVuJzpcbiAgICAgICAgICAgICAgICBjYXNlICdyZWFkb25seSc6XG4gICAgICAgICAgICAgICAgY2FzZSAncmVxdWlyZWQnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ3JldmVyc2VkJzpcbiAgICAgICAgICAgICAgICBjYXNlICdzZWxlY3RlZCc6XG4gICAgICAgICAgICAgICAgY2FzZSAndHlwZW11c3RtYXRjaCc6XG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXNbcG9zc2libGVTdGFuZGFyZE5hbWVzW2QubmFtZV0gfHwgZC5uYW1lXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXNbcG9zc2libGVTdGFuZGFyZE5hbWVzW2QubmFtZV0gfHwgZC5uYW1lXSA9IGQudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gYXR0cmlidXRlcztcbn1cbmZ1bmN0aW9uIHBhcnNlQ2hpbGRyZW4oY2hpbGROb2RlTGlzdCwgbGV2ZWwsIG9wdGlvbnMpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBfX3NwcmVhZChjaGlsZE5vZGVMaXN0KS5tYXAoZnVuY3Rpb24gKG5vZGUsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBjb252ZXJ0RnJvbU5vZGUobm9kZSwgX19hc3NpZ24oX19hc3NpZ24oe30sIG9wdGlvbnMpLCB7IGluZGV4OiBpbmRleCwgbGV2ZWw6IGxldmVsICsgMSB9KSk7XG4gICAgfSlcbiAgICAgICAgLmZpbHRlcihCb29sZWFuKTtcbiAgICBpZiAoIWNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNoaWxkcmVuO1xufVxuZnVuY3Rpb24gcGFyc2VOYW1lKG5vZGVOYW1lKSB7XG4gICAgaWYgKC9bYS16XStbQS1aXStbYS16XSsvLnRlc3Qobm9kZU5hbWUpKSB7XG4gICAgICAgIHJldHVybiBub2RlTmFtZTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG59XG5leHBvcnQgZnVuY3Rpb24gY29udmVydEZyb21Ob2RlKGlucHV0LCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICBpZiAoIWlucHV0IHx8ICEoaW5wdXQgaW5zdGFuY2VvZiBOb2RlKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIF9hID0gb3B0aW9ucy5hY3Rpb25zLCBhY3Rpb25zID0gX2EgPT09IHZvaWQgMCA/IFtdIDogX2EsIF9iID0gb3B0aW9ucy5pbmRleCwgaW5kZXggPSBfYiA9PT0gdm9pZCAwID8gMCA6IF9iLCBfYyA9IG9wdGlvbnMubGV2ZWwsIGxldmVsID0gX2MgPT09IHZvaWQgMCA/IDAgOiBfYztcbiAgICB2YXIgbm9kZSA9IGlucHV0O1xuICAgIHZhciBrZXkgPSBsZXZlbCArIFwiLVwiICsgaW5kZXg7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYWN0aW9ucykpIHtcbiAgICAgICAgYWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICAgICAgICAgIGlmIChhY3Rpb24uY29uZGl0aW9uKG5vZGUsIGtleSwgbGV2ZWwpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBhY3Rpb24ucHJlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSBhY3Rpb24ucHJlKG5vZGUsIGtleSwgbGV2ZWwpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShub2RlIGluc3RhbmNlb2YgTm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSBpbnB1dDtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdUaGUgYHByZWAgbWV0aG9kIGFsd2F5cyBtdXN0IHJldHVybiBhIHZhbGlkIERvbU5vZGUgKGluc3RhbmNlb2YgTm9kZSkgLSB5b3VyIG1vZGlmaWNhdGlvbiB3aWxsIGJlIGlnbm9yZWQgKEhpbnQ6IGlmIHlvdSB3YW50IHRvIHJlbmRlciBhIFJlYWN0LWNvbXBvbmVudCwgdXNlIHRoZSBgcG9zdGAgbWV0aG9kIGluc3RlYWQpJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBhY3Rpb24ucG9zdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChhY3Rpb24ucG9zdChub2RlLCBrZXksIGxldmVsKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHJlc3VsdC5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgc3dpdGNoIChub2RlLm5vZGVUeXBlKSB7XG4gICAgICAgIGNhc2UgMToge1xuICAgICAgICAgICAgLy8gcmVndWxhciBkb20tbm9kZVxuICAgICAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQocGFyc2VOYW1lKG5vZGUubm9kZU5hbWUpLCBwYXJzZUF0dHJpYnV0ZXMobm9kZSwga2V5KSwgcGFyc2VDaGlsZHJlbihub2RlLmNoaWxkTm9kZXMsIGxldmVsLCBvcHRpb25zKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAzOiB7XG4gICAgICAgICAgICAvLyB0ZXh0bm9kZVxuICAgICAgICAgICAgdmFyIG5vZGVUZXh0ID0gbm9kZS5ub2RlVmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgICBpZiAoL15cXHMrJC8udGVzdChub2RlVGV4dCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICBpZiAoIW5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlVGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwYXJlbnROb2RlTmFtZSA9IG5vZGUucGFyZW50Tm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgaWYgKG5vVGV4dENoaWxkTm9kZXMuaW5kZXhPZihwYXJlbnROb2RlTmFtZSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgICAgICBpZiAoL1xcUy8udGVzdChub2RlVGV4dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiQSB0ZXh0Tm9kZSBpcyBub3QgYWxsb3dlZCBpbnNpZGUgJ1wiICsgcGFyZW50Tm9kZU5hbWUgKyBcIicuIFlvdXIgdGV4dCBcXFwiXCIgKyBub2RlVGV4dCArIFwiXFxcIiB3aWxsIGJlIGlnbm9yZWRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5vZGVUZXh0O1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgODoge1xuICAgICAgICAgICAgLy8gaHRtbC1jb21tZW50XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0RnJvbVN0cmluZyhpbnB1dCwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgaWYgKCFpbnB1dCB8fCB0eXBlb2YgaW5wdXQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgX2EgPSBvcHRpb25zLm5vZGVPbmx5LCBub2RlT25seSA9IF9hID09PSB2b2lkIDAgPyBmYWxzZSA6IF9hLCBfYiA9IG9wdGlvbnMuc2VsZWN0b3IsIHNlbGVjdG9yID0gX2IgPT09IHZvaWQgMCA/ICdib2R5ID4gKicgOiBfYiwgX2MgPSBvcHRpb25zLnR5cGUsIHR5cGUgPSBfYyA9PT0gdm9pZCAwID8gJ3RleHQvaHRtbCcgOiBfYztcbiAgICB0cnkge1xuICAgICAgICB2YXIgcGFyc2VyID0gbmV3IERPTVBhcnNlcigpO1xuICAgICAgICB2YXIgZG9jID0gcGFyc2VyLnBhcnNlRnJvbVN0cmluZyhpbnB1dCwgdHlwZSk7XG4gICAgICAgIHZhciBub2RlID0gZG9jLnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpO1xuICAgICAgICBpZiAoIShub2RlIGluc3RhbmNlb2YgTm9kZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgcGFyc2luZyBpbnB1dCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlT25seSkge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbnZlcnRGcm9tTm9kZShub2RlLCBvcHRpb25zKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb252ZXJ0KGlucHV0LCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gY29udmVydEZyb21TdHJpbmcoaW5wdXQsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBOb2RlKSB7XG4gICAgICAgIHJldHVybiBjb252ZXJ0RnJvbU5vZGUoaW5wdXQsIG9wdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsImltcG9ydCB7IGNhblVzZURPTSBhcyBjYW5Vc2VET01GbGFnIH0gZnJvbSAnZXhlbnYnO1xuZXhwb3J0IHZhciBTVEFUVVMgPSB7XG4gICAgRkFJTEVEOiAnZmFpbGVkJyxcbiAgICBMT0FERUQ6ICdsb2FkZWQnLFxuICAgIExPQURJTkc6ICdsb2FkaW5nJyxcbiAgICBQRU5ESU5HOiAncGVuZGluZycsXG4gICAgUkVBRFk6ICdyZWFkeScsXG4gICAgVU5TVVBQT1JURUQ6ICd1bnN1cHBvcnRlZCcsXG59O1xuZXhwb3J0IGZ1bmN0aW9uIGNhblVzZURPTSgpIHtcbiAgICByZXR1cm4gY2FuVXNlRE9NRmxhZztcbn1cbmV4cG9ydCBmdW5jdGlvbiBzdXBwb3J0c0lubGluZVNWRygpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIGlmICghZG9jdW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZGl2LmlubmVySFRNTCA9ICc8c3ZnIC8+JztcbiAgICByZXR1cm4gISFkaXYuZmlyc3RDaGlsZCAmJiBkaXYuZmlyc3RDaGlsZC5uYW1lc3BhY2VVUkkgPT09ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zyc7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNTdXBwb3J0ZWRFbnZpcm9ubWVudCgpIHtcbiAgICByZXR1cm4gc3VwcG9ydHNJbmxpbmVTVkcoKSAmJiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cgIT09IG51bGw7XG59XG5leHBvcnQgZnVuY3Rpb24gcmFuZG9tU3RyaW5nKGxlbmd0aCkge1xuICAgIHZhciBsZXR0ZXJzID0gJ2FiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6JztcbiAgICB2YXIgbnVtYmVycyA9ICcxMjM0NTY3ODkwJztcbiAgICB2YXIgY2hhcnNldCA9IFwiXCIgKyBsZXR0ZXJzICsgbGV0dGVycy50b1VwcGVyQ2FzZSgpICsgbnVtYmVycztcbiAgICB2YXIgcmFuZG9tQ2hhcmFjdGVyID0gZnVuY3Rpb24gKGNoYXJhY3Rlcikge1xuICAgICAgICByZXR1cm4gY2hhcmFjdGVyW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGNoYXJhY3Rlci5sZW5ndGgpXTtcbiAgICB9O1xuICAgIHZhciBSID0gJyc7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBSICs9IHJhbmRvbUNoYXJhY3RlcihjaGFyc2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIFI7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oZWxwZXJzLmpzLm1hcCIsInZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbnZhciBfX3Jlc3QgPSAodGhpcyAmJiB0aGlzLl9fcmVzdCkgfHwgZnVuY3Rpb24gKHMsIGUpIHtcbiAgICB2YXIgdCA9IHt9O1xuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxuICAgICAgICB0W3BdID0gc1twXTtcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcbiAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcbiAgICAgICAgfVxuICAgIHJldHVybiB0O1xufTtcbnZhciBfX3JlYWQgPSAodGhpcyAmJiB0aGlzLl9fcmVhZCkgfHwgZnVuY3Rpb24gKG8sIG4pIHtcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XG4gICAgaWYgKCFtKSByZXR1cm4gbztcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcbiAgICB0cnkge1xuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cbiAgICB9XG4gICAgcmV0dXJuIGFyO1xufTtcbnZhciBfX3NwcmVhZCA9ICh0aGlzICYmIHRoaXMuX19zcHJlYWQpIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBhciA9IFtdLCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgYXIgPSBhci5jb25jYXQoX19yZWFkKGFyZ3VtZW50c1tpXSkpO1xuICAgIHJldHVybiBhcjtcbn07XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgY29udmVydCBmcm9tICdyZWFjdC1mcm9tLWRvbSc7XG5pbXBvcnQgeyBTVEFUVVMsIGNhblVzZURPTSwgaXNTdXBwb3J0ZWRFbnZpcm9ubWVudCwgcmFuZG9tU3RyaW5nIH0gZnJvbSAnLi9oZWxwZXJzJztcbnZhciBjYWNoZVN0b3JlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbnZhciBJbmxpbmVTVkcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKElubGluZVNWRywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBJbmxpbmVTVkcocHJvcHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcHJvcHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmlzQWN0aXZlID0gZmFsc2U7XG4gICAgICAgIF90aGlzLmhhbmRsZUxvYWQgPSBmdW5jdGlvbiAoY29udGVudCkge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgIGlmIChfdGhpcy5pc0FjdGl2ZSkge1xuICAgICAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogY29udGVudCxcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBTVEFUVVMuTE9BREVELFxuICAgICAgICAgICAgICAgIH0sIF90aGlzLmdldEVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5oYW5kbGVFcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgdmFyIG9uRXJyb3IgPSBfdGhpcy5wcm9wcy5vbkVycm9yO1xuICAgICAgICAgICAgdmFyIHN0YXR1cyA9IGVycm9yLm1lc3NhZ2UgPT09ICdCcm93c2VyIGRvZXMgbm90IHN1cHBvcnQgU1ZHJyA/IFNUQVRVUy5VTlNVUFBPUlRFRCA6IFNUQVRVUy5GQUlMRUQ7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgIGlmIChfdGhpcy5pc0FjdGl2ZSkge1xuICAgICAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKHsgc3RhdHVzOiBzdGF0dXMgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9uRXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnJlcXVlc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSBfdGhpcy5wcm9wcywgY2FjaGVSZXF1ZXN0cyA9IF9hLmNhY2hlUmVxdWVzdHMsIHNyYyA9IF9hLnNyYztcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlUmVxdWVzdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVTdG9yZVtzcmNdID0geyBjb250ZW50OiAnJywgc3RhdHVzOiBTVEFUVVMuTE9BRElORywgcXVldWU6IFtdIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmZXRjaChzcmMpXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29udGVudFR5cGUgPSByZXNwb25zZS5oZWFkZXJzLmdldCgnY29udGVudC10eXBlJyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYSA9IF9fcmVhZCgoY29udGVudFR5cGUgfHwgJycpLnNwbGl0KC8gPzsgPy8pLCAxKSwgZmlsZVR5cGUgPSBfYVswXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA+IDI5OSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgZm91bmQnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIVsnaW1hZ2Uvc3ZnK3htbCcsICd0ZXh0L3BsYWluJ10uc29tZShmdW5jdGlvbiAoZCkgeyByZXR1cm4gZmlsZVR5cGUuaW5kZXhPZihkKSA+PSAwOyB9KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29udGVudCB0eXBlIGlzbid0IHZhbGlkOiBcIiArIGZpbGVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGV4dCgpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChjb250ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmhhbmRsZUxvYWQoY29udGVudCk7XG4gICAgICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgICAgICAgICAgIGlmIChjYWNoZVJlcXVlc3RzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2FjaGUgPSBjYWNoZVN0b3JlW3NyY107XG4gICAgICAgICAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhY2hlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGUuY29udGVudCA9IGNvbnRlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGUuc3RhdHVzID0gU1RBVFVTLkxPQURFRDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZS5xdWV1ZSA9IGNhY2hlLnF1ZXVlLmZpbHRlcihmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2IoY29udGVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhY2hlUmVxdWVzdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBjYWNoZVN0b3JlW3NyY107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuaGFuZGxlRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmhhbmRsZUVycm9yKG5ldyBFcnJvcihlcnJvci5tZXNzYWdlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgY29udGVudDogJycsXG4gICAgICAgICAgICBlbGVtZW50OiBudWxsLFxuICAgICAgICAgICAgaGFzQ2FjaGU6ICEhcHJvcHMuY2FjaGVSZXF1ZXN0cyAmJiAhIWNhY2hlU3RvcmVbcHJvcHMuc3JjXSxcbiAgICAgICAgICAgIHN0YXR1czogU1RBVFVTLlBFTkRJTkcsXG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmhhc2ggPSBwcm9wcy51bmlxdWVIYXNoIHx8IHJhbmRvbVN0cmluZyg4KTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBJbmxpbmVTVkcucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlzQWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgaWYgKCFjYW5Vc2VET00oKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdGF0dXMgPSB0aGlzLnN0YXRlLnN0YXR1cztcbiAgICAgICAgdmFyIHNyYyA9IHRoaXMucHJvcHMuc3JjO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgIGlmIChzdGF0dXMgPT09IFNUQVRVUy5QRU5ESU5HKSB7XG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgICAgICBpZiAoIWlzU3VwcG9ydGVkRW52aXJvbm1lbnQoKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Jyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBTVkcnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgICAgICBpZiAoIXNyYykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3Npbmcgc3JjJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMubG9hZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVFcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIElubGluZVNWRy5wcm90b3R5cGUuY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gKHByZXZQcm9wcywgcHJldlN0YXRlKSB7XG4gICAgICAgIGlmICghY2FuVXNlRE9NKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX2EgPSB0aGlzLnN0YXRlLCBoYXNDYWNoZSA9IF9hLmhhc0NhY2hlLCBzdGF0dXMgPSBfYS5zdGF0dXM7XG4gICAgICAgIHZhciBfYiA9IHRoaXMucHJvcHMsIG9uTG9hZCA9IF9iLm9uTG9hZCwgc3JjID0gX2Iuc3JjO1xuICAgICAgICBpZiAocHJldlN0YXRlLnN0YXR1cyAhPT0gU1RBVFVTLlJFQURZICYmIHN0YXR1cyA9PT0gU1RBVFVTLlJFQURZKSB7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgaWYgKG9uTG9hZCkge1xuICAgICAgICAgICAgICAgIG9uTG9hZChzcmMsIGhhc0NhY2hlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocHJldlByb3BzLnNyYyAhPT0gc3JjKSB7XG4gICAgICAgICAgICBpZiAoIXNyYykge1xuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlRXJyb3IobmV3IEVycm9yKCdNaXNzaW5nIHNyYycpKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmxvYWQoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSW5saW5lU1ZHLnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pc0FjdGl2ZSA9IGZhbHNlO1xuICAgIH07XG4gICAgSW5saW5lU1ZHLnByb3RvdHlwZS5wcm9jZXNzU1ZHID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29udGVudCA9IHRoaXMuc3RhdGUuY29udGVudDtcbiAgICAgICAgdmFyIHByZVByb2Nlc3NvciA9IHRoaXMucHJvcHMucHJlUHJvY2Vzc29yO1xuICAgICAgICBpZiAocHJlUHJvY2Vzc29yKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJlUHJvY2Vzc29yKGNvbnRlbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb250ZW50O1xuICAgIH07XG4gICAgSW5saW5lU1ZHLnByb3RvdHlwZS51cGRhdGVTVkdBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIF9hID0gdGhpcy5wcm9wcywgX2IgPSBfYS5iYXNlVVJMLCBiYXNlVVJMID0gX2IgPT09IHZvaWQgMCA/ICcnIDogX2IsIHVuaXF1aWZ5SURzID0gX2EudW5pcXVpZnlJRHM7XG4gICAgICAgIHZhciByZXBsYWNlYWJsZUF0dHJpYnV0ZXMgPSBbJ2lkJywgJ2hyZWYnLCAneGxpbms6aHJlZicsICd4bGluazpyb2xlJywgJ3hsaW5rOmFyY3JvbGUnXTtcbiAgICAgICAgdmFyIGxpbmtBdHRyaWJ1dGVzID0gWydocmVmJywgJ3hsaW5rOmhyZWYnXTtcbiAgICAgICAgdmFyIGlzRGF0YVZhbHVlID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gbGlua0F0dHJpYnV0ZXMuaW5kZXhPZihuYW1lKSA+PSAwICYmICh2YWx1ZSA/IHZhbHVlLmluZGV4T2YoJyMnKSA8IDAgOiBmYWxzZSk7XG4gICAgICAgIH07XG4gICAgICAgIGlmICghdW5pcXVpZnlJRHMpIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9XG4gICAgICAgIF9fc3ByZWFkKG5vZGUuY2hpbGRyZW4pLm1hcChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgaWYgKGQuYXR0cmlidXRlcyAmJiBkLmF0dHJpYnV0ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZXNfMSA9IE9iamVjdC52YWx1ZXMoZC5hdHRyaWJ1dGVzKS5tYXAoZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGF0dHIgPSBhO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWF0Y2ggPSBhLnZhbHVlLm1hdGNoKC91cmxcXCgoLio/KVxcKS8pO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2ggJiYgbWF0Y2hbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHIudmFsdWUgPSBhLnZhbHVlLnJlcGxhY2UobWF0Y2hbMF0sIFwidXJsKFwiICsgYmFzZVVSTCArIG1hdGNoWzFdICsgXCJfX1wiICsgX3RoaXMuaGFzaCArIFwiKVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXR0cjtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXBsYWNlYWJsZUF0dHJpYnV0ZXMuZm9yRWFjaChmdW5jdGlvbiAocikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXR0cmlidXRlID0gYXR0cmlidXRlc18xLmZpbmQoZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGEubmFtZSA9PT0gcjsgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhdHRyaWJ1dGUgJiYgIWlzRGF0YVZhbHVlKHIsIGF0dHJpYnV0ZS52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZS52YWx1ZSA9IGF0dHJpYnV0ZS52YWx1ZSArIFwiX19cIiArIF90aGlzLmhhc2g7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy51cGRhdGVTVkdBdHRyaWJ1dGVzKGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9O1xuICAgIElubGluZVNWRy5wcm90b3R5cGUuZ2V0Tm9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5wcm9wcywgZGVzY3JpcHRpb24gPSBfYS5kZXNjcmlwdGlvbiwgdGl0bGUgPSBfYS50aXRsZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBzdmdUZXh0ID0gdGhpcy5wcm9jZXNzU1ZHKCk7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IGNvbnZlcnQoc3ZnVGV4dCwgeyBub2RlT25seTogdHJ1ZSB9KTtcbiAgICAgICAgICAgIGlmICghbm9kZSB8fCAhKG5vZGUgaW5zdGFuY2VvZiBTVkdTVkdFbGVtZW50KSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGNvbnZlcnQgdGhlIHNyYyB0byBhIERPTSBOb2RlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc3ZnID0gdGhpcy51cGRhdGVTVkdBdHRyaWJ1dGVzKG5vZGUpO1xuICAgICAgICAgICAgaWYgKGRlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9yaWdpbmFsRGVzYyA9IHN2Zy5xdWVyeVNlbGVjdG9yKCdkZXNjJyk7XG4gICAgICAgICAgICAgICAgaWYgKG9yaWdpbmFsRGVzYyAmJiBvcmlnaW5hbERlc2MucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbERlc2MucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChvcmlnaW5hbERlc2MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgZGVzY0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkZXNjJyk7XG4gICAgICAgICAgICAgICAgZGVzY0VsZW1lbnQuaW5uZXJIVE1MID0gZGVzY3JpcHRpb247XG4gICAgICAgICAgICAgICAgc3ZnLnByZXBlbmQoZGVzY0VsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRpdGxlKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9yaWdpbmFsVGl0bGUgPSBzdmcucXVlcnlTZWxlY3RvcigndGl0bGUnKTtcbiAgICAgICAgICAgICAgICBpZiAob3JpZ2luYWxUaXRsZSAmJiBvcmlnaW5hbFRpdGxlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxUaXRsZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG9yaWdpbmFsVGl0bGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgdGl0bGVFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGl0bGUnKTtcbiAgICAgICAgICAgICAgICB0aXRsZUVsZW1lbnQuaW5uZXJIVE1MID0gdGl0bGU7XG4gICAgICAgICAgICAgICAgc3ZnLnByZXBlbmQodGl0bGVFbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdmc7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVFcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIElubGluZVNWRy5wcm90b3R5cGUuZ2V0RWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5nZXROb2RlKCk7XG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IGNvbnZlcnQobm9kZSk7XG4gICAgICAgICAgICBpZiAoIWVsZW1lbnQgfHwgIVJlYWN0LmlzVmFsaWRFbGVtZW50KGVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgY29udmVydCB0aGUgc3JjIHRvIGEgUmVhY3QgZWxlbWVudCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgZWxlbWVudDogZWxlbWVudCxcbiAgICAgICAgICAgICAgICBzdGF0dXM6IFNUQVRVUy5SRUFEWSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVFcnJvcihuZXcgRXJyb3IoZXJyb3IubWVzc2FnZSkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBJbmxpbmVTVkcucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgIGlmICh0aGlzLmlzQWN0aXZlKSB7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICBjb250ZW50OiAnJyxcbiAgICAgICAgICAgICAgICBlbGVtZW50OiBudWxsLFxuICAgICAgICAgICAgICAgIHN0YXR1czogU1RBVFVTLkxPQURJTkcsXG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hID0gX3RoaXMucHJvcHMsIGNhY2hlUmVxdWVzdHMgPSBfYS5jYWNoZVJlcXVlc3RzLCBzcmMgPSBfYS5zcmM7XG4gICAgICAgICAgICAgICAgdmFyIGNhY2hlID0gY2FjaGVSZXF1ZXN0cyAmJiBjYWNoZVN0b3JlW3NyY107XG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgICAgICAgICAgIGlmIChjYWNoZS5zdGF0dXMgPT09IFNUQVRVUy5MT0FESU5HKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZS5xdWV1ZS5wdXNoKF90aGlzLmhhbmRsZUxvYWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNhY2hlLnN0YXR1cyA9PT0gU1RBVFVTLkxPQURFRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuaGFuZGxlTG9hZChjYWNoZS5jb250ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBkYXRhVVJJID0gc3JjLm1hdGNoKC9kYXRhOmltYWdlXFwvc3ZnW14sXSo/KDtiYXNlNjQpPywoLiopLyk7XG4gICAgICAgICAgICAgICAgdmFyIGlubGluZVNyYztcbiAgICAgICAgICAgICAgICBpZiAoZGF0YVVSSSkge1xuICAgICAgICAgICAgICAgICAgICBpbmxpbmVTcmMgPSBkYXRhVVJJWzFdID8gYXRvYihkYXRhVVJJWzJdKSA6IGRlY29kZVVSSUNvbXBvbmVudChkYXRhVVJJWzJdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc3JjLmluZGV4T2YoJzxzdmcnKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlubGluZVNyYyA9IHNyYztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlubGluZVNyYykge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5oYW5kbGVMb2FkKGlubGluZVNyYyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3RoaXMucmVxdWVzdCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIElubGluZVNWRy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLnN0YXRlLCBlbGVtZW50ID0gX2EuZWxlbWVudCwgc3RhdHVzID0gX2Euc3RhdHVzO1xuICAgICAgICB2YXIgX2IgPSB0aGlzLnByb3BzLCBiYXNlVVJMID0gX2IuYmFzZVVSTCwgY2FjaGVSZXF1ZXN0cyA9IF9iLmNhY2hlUmVxdWVzdHMsIF9jID0gX2IuY2hpbGRyZW4sIGNoaWxkcmVuID0gX2MgPT09IHZvaWQgMCA/IG51bGwgOiBfYywgZGVzY3JpcHRpb24gPSBfYi5kZXNjcmlwdGlvbiwgaW5uZXJSZWYgPSBfYi5pbm5lclJlZiwgX2QgPSBfYi5sb2FkZXIsIGxvYWRlciA9IF9kID09PSB2b2lkIDAgPyBudWxsIDogX2QsIG9uRXJyb3IgPSBfYi5vbkVycm9yLCBvbkxvYWQgPSBfYi5vbkxvYWQsIHByZVByb2Nlc3NvciA9IF9iLnByZVByb2Nlc3Nvciwgc3JjID0gX2Iuc3JjLCB0aXRsZSA9IF9iLnRpdGxlLCB1bmlxdWVIYXNoID0gX2IudW5pcXVlSGFzaCwgdW5pcXVpZnlJRHMgPSBfYi51bmlxdWlmeUlEcywgcmVzdCA9IF9fcmVzdChfYiwgW1wiYmFzZVVSTFwiLCBcImNhY2hlUmVxdWVzdHNcIiwgXCJjaGlsZHJlblwiLCBcImRlc2NyaXB0aW9uXCIsIFwiaW5uZXJSZWZcIiwgXCJsb2FkZXJcIiwgXCJvbkVycm9yXCIsIFwib25Mb2FkXCIsIFwicHJlUHJvY2Vzc29yXCIsIFwic3JjXCIsIFwidGl0bGVcIiwgXCJ1bmlxdWVIYXNoXCIsIFwidW5pcXVpZnlJRHNcIl0pO1xuICAgICAgICBpZiAoIWNhblVzZURPTSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9hZGVyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gUmVhY3QuY2xvbmVFbGVtZW50KGVsZW1lbnQsIF9fYXNzaWduKHsgcmVmOiBpbm5lclJlZiB9LCByZXN0KSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFtTVEFUVVMuVU5TVVBQT1JURUQsIFNUQVRVUy5GQUlMRURdLmluZGV4T2Yoc3RhdHVzKSA+IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gY2hpbGRyZW47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvYWRlcjtcbiAgICB9O1xuICAgIElubGluZVNWRy5kZWZhdWx0UHJvcHMgPSB7XG4gICAgICAgIGNhY2hlUmVxdWVzdHM6IHRydWUsXG4gICAgICAgIHVuaXF1aWZ5SURzOiBmYWxzZSxcbiAgICB9O1xuICAgIHJldHVybiBJbmxpbmVTVkc7XG59KFJlYWN0LlB1cmVDb21wb25lbnQpKTtcbmV4cG9ydCBkZWZhdWx0IElubGluZVNWRztcbmV4cG9ydCAqIGZyb20gJy4vdHlwZXMnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHlwZXMuanMubWFwIiwiLyoqIEBsaWNlbnNlIFJlYWN0IHYxNi4xMy4xXG4gKiByZWFjdC1pcy5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgKGZ1bmN0aW9uKCkge1xuJ3VzZSBzdHJpY3QnO1xuXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy4gSWYgdGhlcmUgaXMgbm8gbmF0aXZlIFN5bWJvbFxuLy8gbm9yIHBvbHlmaWxsLCB0aGVuIGEgcGxhaW4gbnVtYmVyIGlzIHVzZWQgZm9yIHBlcmZvcm1hbmNlLlxudmFyIGhhc1N5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmZvcjtcbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgOiAweGVhYzc7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5wb3J0YWwnKSA6IDB4ZWFjYTtcbnZhciBSRUFDVF9GUkFHTUVOVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuZnJhZ21lbnQnKSA6IDB4ZWFjYjtcbnZhciBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3Quc3RyaWN0X21vZGUnKSA6IDB4ZWFjYztcbnZhciBSRUFDVF9QUk9GSUxFUl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QucHJvZmlsZXInKSA6IDB4ZWFkMjtcbnZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QucHJvdmlkZXInKSA6IDB4ZWFjZDtcbnZhciBSRUFDVF9DT05URVhUX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5jb250ZXh0JykgOiAweGVhY2U7IC8vIFRPRE86IFdlIGRvbid0IHVzZSBBc3luY01vZGUgb3IgQ29uY3VycmVudE1vZGUgYW55bW9yZS4gVGhleSB3ZXJlIHRlbXBvcmFyeVxuLy8gKHVuc3RhYmxlKSBBUElzIHRoYXQgaGF2ZSBiZWVuIHJlbW92ZWQuIENhbiB3ZSByZW1vdmUgdGhlIHN5bWJvbHM/XG5cbnZhciBSRUFDVF9BU1lOQ19NT0RFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5hc3luY19tb2RlJykgOiAweGVhY2Y7XG52YXIgUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5jb25jdXJyZW50X21vZGUnKSA6IDB4ZWFjZjtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuZm9yd2FyZF9yZWYnKSA6IDB4ZWFkMDtcbnZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2UnKSA6IDB4ZWFkMTtcbnZhciBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZV9saXN0JykgOiAweGVhZDg7XG52YXIgUkVBQ1RfTUVNT19UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QubWVtbycpIDogMHhlYWQzO1xudmFyIFJFQUNUX0xBWllfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmxhenknKSA6IDB4ZWFkNDtcbnZhciBSRUFDVF9CTE9DS19UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuYmxvY2snKSA6IDB4ZWFkOTtcbnZhciBSRUFDVF9GVU5EQU1FTlRBTF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuZnVuZGFtZW50YWwnKSA6IDB4ZWFkNTtcbnZhciBSRUFDVF9SRVNQT05ERVJfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnJlc3BvbmRlcicpIDogMHhlYWQ2O1xudmFyIFJFQUNUX1NDT1BFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5zY29wZScpIDogMHhlYWQ3O1xuXG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkge1xuICByZXR1cm4gdHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nIHx8IC8vIE5vdGU6IGl0cyB0eXBlb2YgbWlnaHQgYmUgb3RoZXIgdGhhbiAnc3ltYm9sJyBvciAnbnVtYmVyJyBpZiBpdCdzIGEgcG9seWZpbGwuXG4gIHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfUFJPRklMRVJfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIHx8IHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsICYmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRlVOREFNRU5UQUxfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9SRVNQT05ERVJfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9TQ09QRV9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0JMT0NLX1RZUEUpO1xufVxuXG5mdW5jdGlvbiB0eXBlT2Yob2JqZWN0KSB7XG4gIGlmICh0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwpIHtcbiAgICB2YXIgJCR0eXBlb2YgPSBvYmplY3QuJCR0eXBlb2Y7XG5cbiAgICBzd2l0Y2ggKCQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgdmFyIHR5cGUgPSBvYmplY3QudHlwZTtcblxuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICBjYXNlIFJFQUNUX0FTWU5DX01PREVfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiB0eXBlO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHZhciAkJHR5cGVvZlR5cGUgPSB0eXBlICYmIHR5cGUuJCR0eXBlb2Y7XG5cbiAgICAgICAgICAgIHN3aXRjaCAoJCR0eXBlb2ZUeXBlKSB7XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICAgICAgICAgIHJldHVybiAkJHR5cGVvZlR5cGU7XG5cbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gJCR0eXBlb2Y7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICByZXR1cm4gJCR0eXBlb2Y7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn0gLy8gQXN5bmNNb2RlIGlzIGRlcHJlY2F0ZWQgYWxvbmcgd2l0aCBpc0FzeW5jTW9kZVxuXG52YXIgQXN5bmNNb2RlID0gUkVBQ1RfQVNZTkNfTU9ERV9UWVBFO1xudmFyIENvbmN1cnJlbnRNb2RlID0gUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEU7XG52YXIgQ29udGV4dENvbnN1bWVyID0gUkVBQ1RfQ09OVEVYVF9UWVBFO1xudmFyIENvbnRleHRQcm92aWRlciA9IFJFQUNUX1BST1ZJREVSX1RZUEU7XG52YXIgRWxlbWVudCA9IFJFQUNUX0VMRU1FTlRfVFlQRTtcbnZhciBGb3J3YXJkUmVmID0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTtcbnZhciBGcmFnbWVudCA9IFJFQUNUX0ZSQUdNRU5UX1RZUEU7XG52YXIgTGF6eSA9IFJFQUNUX0xBWllfVFlQRTtcbnZhciBNZW1vID0gUkVBQ1RfTUVNT19UWVBFO1xudmFyIFBvcnRhbCA9IFJFQUNUX1BPUlRBTF9UWVBFO1xudmFyIFByb2ZpbGVyID0gUkVBQ1RfUFJPRklMRVJfVFlQRTtcbnZhciBTdHJpY3RNb2RlID0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRTtcbnZhciBTdXNwZW5zZSA9IFJFQUNUX1NVU1BFTlNFX1RZUEU7XG52YXIgaGFzV2FybmVkQWJvdXREZXByZWNhdGVkSXNBc3luY01vZGUgPSBmYWxzZTsgLy8gQXN5bmNNb2RlIHNob3VsZCBiZSBkZXByZWNhdGVkXG5cbmZ1bmN0aW9uIGlzQXN5bmNNb2RlKG9iamVjdCkge1xuICB7XG4gICAgaWYgKCFoYXNXYXJuZWRBYm91dERlcHJlY2F0ZWRJc0FzeW5jTW9kZSkge1xuICAgICAgaGFzV2FybmVkQWJvdXREZXByZWNhdGVkSXNBc3luY01vZGUgPSB0cnVlOyAvLyBVc2luZyBjb25zb2xlWyd3YXJuJ10gdG8gZXZhZGUgQmFiZWwgYW5kIEVTTGludFxuXG4gICAgICBjb25zb2xlWyd3YXJuJ10oJ1RoZSBSZWFjdElzLmlzQXN5bmNNb2RlKCkgYWxpYXMgaGFzIGJlZW4gZGVwcmVjYXRlZCwgJyArICdhbmQgd2lsbCBiZSByZW1vdmVkIGluIFJlYWN0IDE3Ky4gVXBkYXRlIHlvdXIgY29kZSB0byB1c2UgJyArICdSZWFjdElzLmlzQ29uY3VycmVudE1vZGUoKSBpbnN0ZWFkLiBJdCBoYXMgdGhlIGV4YWN0IHNhbWUgQVBJLicpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpc0NvbmN1cnJlbnRNb2RlKG9iamVjdCkgfHwgdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0FTWU5DX01PREVfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzQ29uY3VycmVudE1vZGUob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEU7XG59XG5mdW5jdGlvbiBpc0NvbnRleHRDb25zdW1lcihvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9DT05URVhUX1RZUEU7XG59XG5mdW5jdGlvbiBpc0NvbnRleHRQcm92aWRlcihvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9QUk9WSURFUl9UWVBFO1xufVxuZnVuY3Rpb24gaXNFbGVtZW50KG9iamVjdCkge1xuICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsICYmIG9iamVjdC4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xufVxuZnVuY3Rpb24gaXNGb3J3YXJkUmVmKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU7XG59XG5mdW5jdGlvbiBpc0ZyYWdtZW50KG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEU7XG59XG5mdW5jdGlvbiBpc0xhenkob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfTEFaWV9UWVBFO1xufVxuZnVuY3Rpb24gaXNNZW1vKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX01FTU9fVFlQRTtcbn1cbmZ1bmN0aW9uIGlzUG9ydGFsKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX1BPUlRBTF9UWVBFO1xufVxuZnVuY3Rpb24gaXNQcm9maWxlcihvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFO1xufVxuZnVuY3Rpb24gaXNTdHJpY3RNb2RlKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX1NUUklDVF9NT0RFX1RZUEU7XG59XG5mdW5jdGlvbiBpc1N1c3BlbnNlKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEU7XG59XG5cbmV4cG9ydHMuQXN5bmNNb2RlID0gQXN5bmNNb2RlO1xuZXhwb3J0cy5Db25jdXJyZW50TW9kZSA9IENvbmN1cnJlbnRNb2RlO1xuZXhwb3J0cy5Db250ZXh0Q29uc3VtZXIgPSBDb250ZXh0Q29uc3VtZXI7XG5leHBvcnRzLkNvbnRleHRQcm92aWRlciA9IENvbnRleHRQcm92aWRlcjtcbmV4cG9ydHMuRWxlbWVudCA9IEVsZW1lbnQ7XG5leHBvcnRzLkZvcndhcmRSZWYgPSBGb3J3YXJkUmVmO1xuZXhwb3J0cy5GcmFnbWVudCA9IEZyYWdtZW50O1xuZXhwb3J0cy5MYXp5ID0gTGF6eTtcbmV4cG9ydHMuTWVtbyA9IE1lbW87XG5leHBvcnRzLlBvcnRhbCA9IFBvcnRhbDtcbmV4cG9ydHMuUHJvZmlsZXIgPSBQcm9maWxlcjtcbmV4cG9ydHMuU3RyaWN0TW9kZSA9IFN0cmljdE1vZGU7XG5leHBvcnRzLlN1c3BlbnNlID0gU3VzcGVuc2U7XG5leHBvcnRzLmlzQXN5bmNNb2RlID0gaXNBc3luY01vZGU7XG5leHBvcnRzLmlzQ29uY3VycmVudE1vZGUgPSBpc0NvbmN1cnJlbnRNb2RlO1xuZXhwb3J0cy5pc0NvbnRleHRDb25zdW1lciA9IGlzQ29udGV4dENvbnN1bWVyO1xuZXhwb3J0cy5pc0NvbnRleHRQcm92aWRlciA9IGlzQ29udGV4dFByb3ZpZGVyO1xuZXhwb3J0cy5pc0VsZW1lbnQgPSBpc0VsZW1lbnQ7XG5leHBvcnRzLmlzRm9yd2FyZFJlZiA9IGlzRm9yd2FyZFJlZjtcbmV4cG9ydHMuaXNGcmFnbWVudCA9IGlzRnJhZ21lbnQ7XG5leHBvcnRzLmlzTGF6eSA9IGlzTGF6eTtcbmV4cG9ydHMuaXNNZW1vID0gaXNNZW1vO1xuZXhwb3J0cy5pc1BvcnRhbCA9IGlzUG9ydGFsO1xuZXhwb3J0cy5pc1Byb2ZpbGVyID0gaXNQcm9maWxlcjtcbmV4cG9ydHMuaXNTdHJpY3RNb2RlID0gaXNTdHJpY3RNb2RlO1xuZXhwb3J0cy5pc1N1c3BlbnNlID0gaXNTdXNwZW5zZTtcbmV4cG9ydHMuaXNWYWxpZEVsZW1lbnRUeXBlID0gaXNWYWxpZEVsZW1lbnRUeXBlO1xuZXhwb3J0cy50eXBlT2YgPSB0eXBlT2Y7XG4gIH0pKCk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtaXMucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtaXMuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiIsIi8qKiBAbGljZW5zZSBSZWFjdCB2MTYuMTMuMVxuICogcmVhY3QuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cblxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG52YXIgY2hlY2tQcm9wVHlwZXMgPSByZXF1aXJlKCdwcm9wLXR5cGVzL2NoZWNrUHJvcFR5cGVzJyk7XG5cbnZhciBSZWFjdFZlcnNpb24gPSAnMTYuMTMuMSc7XG5cbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudC1saWtlIHR5cGVzLiBJZiB0aGVyZSBpcyBubyBuYXRpdmUgU3ltYm9sXG4vLyBub3IgcG9seWZpbGwsIHRoZW4gYSBwbGFpbiBudW1iZXIgaXMgdXNlZCBmb3IgcGVyZm9ybWFuY2UuXG52YXIgaGFzU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuZm9yO1xudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSA6IDB4ZWFjNztcbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnBvcnRhbCcpIDogMHhlYWNhO1xudmFyIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5mcmFnbWVudCcpIDogMHhlYWNiO1xudmFyIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5zdHJpY3RfbW9kZScpIDogMHhlYWNjO1xudmFyIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5wcm9maWxlcicpIDogMHhlYWQyO1xudmFyIFJFQUNUX1BST1ZJREVSX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5wcm92aWRlcicpIDogMHhlYWNkO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbnRleHQnKSA6IDB4ZWFjZTsgLy8gVE9ETzogV2UgZG9uJ3QgdXNlIEFzeW5jTW9kZSBvciBDb25jdXJyZW50TW9kZSBhbnltb3JlLiBUaGV5IHdlcmUgdGVtcG9yYXJ5XG52YXIgUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5jb25jdXJyZW50X21vZGUnKSA6IDB4ZWFjZjtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuZm9yd2FyZF9yZWYnKSA6IDB4ZWFkMDtcbnZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2UnKSA6IDB4ZWFkMTtcbnZhciBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZV9saXN0JykgOiAweGVhZDg7XG52YXIgUkVBQ1RfTUVNT19UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QubWVtbycpIDogMHhlYWQzO1xudmFyIFJFQUNUX0xBWllfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmxhenknKSA6IDB4ZWFkNDtcbnZhciBSRUFDVF9CTE9DS19UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuYmxvY2snKSA6IDB4ZWFkOTtcbnZhciBSRUFDVF9GVU5EQU1FTlRBTF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuZnVuZGFtZW50YWwnKSA6IDB4ZWFkNTtcbnZhciBSRUFDVF9SRVNQT05ERVJfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnJlc3BvbmRlcicpIDogMHhlYWQ2O1xudmFyIFJFQUNUX1NDT1BFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5zY29wZScpIDogMHhlYWQ3O1xudmFyIE1BWUJFX0lURVJBVE9SX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLml0ZXJhdG9yO1xudmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InO1xuZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gIGlmIChtYXliZUl0ZXJhYmxlID09PSBudWxsIHx8IHR5cGVvZiBtYXliZUl0ZXJhYmxlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIG1heWJlSXRlcmF0b3IgPSBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtNQVlCRV9JVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdO1xuXG4gIGlmICh0eXBlb2YgbWF5YmVJdGVyYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBtYXliZUl0ZXJhdG9yO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogS2VlcHMgdHJhY2sgb2YgdGhlIGN1cnJlbnQgZGlzcGF0Y2hlci5cbiAqL1xudmFyIFJlYWN0Q3VycmVudERpc3BhdGNoZXIgPSB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHR5cGUge1JlYWN0Q29tcG9uZW50fVxuICAgKi9cbiAgY3VycmVudDogbnVsbFxufTtcblxuLyoqXG4gKiBLZWVwcyB0cmFjayBvZiB0aGUgY3VycmVudCBiYXRjaCdzIGNvbmZpZ3VyYXRpb24gc3VjaCBhcyBob3cgbG9uZyBhbiB1cGRhdGVcbiAqIHNob3VsZCBzdXNwZW5kIGZvciBpZiBpdCBuZWVkcyB0by5cbiAqL1xudmFyIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnID0ge1xuICBzdXNwZW5zZTogbnVsbFxufTtcblxuLyoqXG4gKiBLZWVwcyB0cmFjayBvZiB0aGUgY3VycmVudCBvd25lci5cbiAqXG4gKiBUaGUgY3VycmVudCBvd25lciBpcyB0aGUgY29tcG9uZW50IHdobyBzaG91bGQgb3duIGFueSBjb21wb25lbnRzIHRoYXQgYXJlXG4gKiBjdXJyZW50bHkgYmVpbmcgY29uc3RydWN0ZWQuXG4gKi9cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAdHlwZSB7UmVhY3RDb21wb25lbnR9XG4gICAqL1xuICBjdXJyZW50OiBudWxsXG59O1xuXG52YXIgQkVGT1JFX1NMQVNIX1JFID0gL14oLiopW1xcXFxcXC9dLztcbmZ1bmN0aW9uIGRlc2NyaWJlQ29tcG9uZW50RnJhbWUgKG5hbWUsIHNvdXJjZSwgb3duZXJOYW1lKSB7XG4gIHZhciBzb3VyY2VJbmZvID0gJyc7XG5cbiAgaWYgKHNvdXJjZSkge1xuICAgIHZhciBwYXRoID0gc291cmNlLmZpbGVOYW1lO1xuICAgIHZhciBmaWxlTmFtZSA9IHBhdGgucmVwbGFjZShCRUZPUkVfU0xBU0hfUkUsICcnKTtcblxuICAgIHtcbiAgICAgIC8vIEluIERFViwgaW5jbHVkZSBjb2RlIGZvciBhIGNvbW1vbiBzcGVjaWFsIGNhc2U6XG4gICAgICAvLyBwcmVmZXIgXCJmb2xkZXIvaW5kZXguanNcIiBpbnN0ZWFkIG9mIGp1c3QgXCJpbmRleC5qc1wiLlxuICAgICAgaWYgKC9eaW5kZXhcXC4vLnRlc3QoZmlsZU5hbWUpKSB7XG4gICAgICAgIHZhciBtYXRjaCA9IHBhdGgubWF0Y2goQkVGT1JFX1NMQVNIX1JFKTtcblxuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICB2YXIgcGF0aEJlZm9yZVNsYXNoID0gbWF0Y2hbMV07XG5cbiAgICAgICAgICBpZiAocGF0aEJlZm9yZVNsYXNoKSB7XG4gICAgICAgICAgICB2YXIgZm9sZGVyTmFtZSA9IHBhdGhCZWZvcmVTbGFzaC5yZXBsYWNlKEJFRk9SRV9TTEFTSF9SRSwgJycpO1xuICAgICAgICAgICAgZmlsZU5hbWUgPSBmb2xkZXJOYW1lICsgJy8nICsgZmlsZU5hbWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgc291cmNlSW5mbyA9ICcgKGF0ICcgKyBmaWxlTmFtZSArICc6JyArIHNvdXJjZS5saW5lTnVtYmVyICsgJyknO1xuICB9IGVsc2UgaWYgKG93bmVyTmFtZSkge1xuICAgIHNvdXJjZUluZm8gPSAnIChjcmVhdGVkIGJ5ICcgKyBvd25lck5hbWUgKyAnKSc7XG4gIH1cblxuICByZXR1cm4gJ1xcbiAgICBpbiAnICsgKG5hbWUgfHwgJ1Vua25vd24nKSArIHNvdXJjZUluZm87XG59XG5cbnZhciBSZXNvbHZlZCA9IDE7XG5mdW5jdGlvbiByZWZpbmVSZXNvbHZlZExhenlDb21wb25lbnQobGF6eUNvbXBvbmVudCkge1xuICByZXR1cm4gbGF6eUNvbXBvbmVudC5fc3RhdHVzID09PSBSZXNvbHZlZCA/IGxhenlDb21wb25lbnQuX3Jlc3VsdCA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldFdyYXBwZWROYW1lKG91dGVyVHlwZSwgaW5uZXJUeXBlLCB3cmFwcGVyTmFtZSkge1xuICB2YXIgZnVuY3Rpb25OYW1lID0gaW5uZXJUeXBlLmRpc3BsYXlOYW1lIHx8IGlubmVyVHlwZS5uYW1lIHx8ICcnO1xuICByZXR1cm4gb3V0ZXJUeXBlLmRpc3BsYXlOYW1lIHx8IChmdW5jdGlvbk5hbWUgIT09ICcnID8gd3JhcHBlck5hbWUgKyBcIihcIiArIGZ1bmN0aW9uTmFtZSArIFwiKVwiIDogd3JhcHBlck5hbWUpO1xufVxuXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIC8vIEhvc3Qgcm9vdCwgdGV4dCBub2RlIG9yIGp1c3QgaW52YWxpZCB0eXBlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAge1xuICAgIGlmICh0eXBlb2YgdHlwZS50YWcgPT09ICdudW1iZXInKSB7XG4gICAgICBlcnJvcignUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZSgpLiAnICsgJ1RoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgbnVsbDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgIHJldHVybiAnRnJhZ21lbnQnO1xuXG4gICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgIHJldHVybiAnUG9ydGFsJztcblxuICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgIHJldHVybiBcIlByb2ZpbGVyXCI7XG5cbiAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N0cmljdE1vZGUnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2VMaXN0JztcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICByZXR1cm4gJ0NvbnRleHQuQ29uc3VtZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX1BST1ZJREVSX1RZUEU6XG4gICAgICAgIHJldHVybiAnQ29udGV4dC5Qcm92aWRlcic7XG5cbiAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgcmV0dXJuIGdldFdyYXBwZWROYW1lKHR5cGUsIHR5cGUucmVuZGVyLCAnRm9yd2FyZFJlZicpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWUodHlwZS50eXBlKTtcblxuICAgICAgY2FzZSBSRUFDVF9CTE9DS19UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZSh0eXBlLnJlbmRlcik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHRoZW5hYmxlID0gdHlwZTtcbiAgICAgICAgICB2YXIgcmVzb2x2ZWRUaGVuYWJsZSA9IHJlZmluZVJlc29sdmVkTGF6eUNvbXBvbmVudCh0aGVuYWJsZSk7XG5cbiAgICAgICAgICBpZiAocmVzb2x2ZWRUaGVuYWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWUocmVzb2x2ZWRUaGVuYWJsZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSB7fTtcbnZhciBjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCA9IG51bGw7XG5mdW5jdGlvbiBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KSB7XG4gIHtcbiAgICBjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCA9IGVsZW1lbnQ7XG4gIH1cbn1cblxue1xuICAvLyBTdGFjayBpbXBsZW1lbnRhdGlvbiBpbmplY3RlZCBieSB0aGUgY3VycmVudCByZW5kZXJlci5cbiAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRDdXJyZW50U3RhY2sgPSBudWxsO1xuXG4gIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc3RhY2sgPSAnJzsgLy8gQWRkIGFuIGV4dHJhIHRvcCBmcmFtZSB3aGlsZSBhbiBlbGVtZW50IGlzIGJlaW5nIHZhbGlkYXRlZFxuXG4gICAgaWYgKGN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KSB7XG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoY3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQudHlwZSk7XG4gICAgICB2YXIgb3duZXIgPSBjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudC5fb3duZXI7XG4gICAgICBzdGFjayArPSBkZXNjcmliZUNvbXBvbmVudEZyYW1lKG5hbWUsIGN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50Ll9zb3VyY2UsIG93bmVyICYmIGdldENvbXBvbmVudE5hbWUob3duZXIudHlwZSkpO1xuICAgIH0gLy8gRGVsZWdhdGUgdG8gdGhlIGluamVjdGVkIHJlbmRlcmVyLXNwZWNpZmljIGltcGxlbWVudGF0aW9uXG5cblxuICAgIHZhciBpbXBsID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRDdXJyZW50U3RhY2s7XG5cbiAgICBpZiAoaW1wbCkge1xuICAgICAgc3RhY2sgKz0gaW1wbCgpIHx8ICcnO1xuICAgIH1cblxuICAgIHJldHVybiBzdGFjaztcbiAgfTtcbn1cblxuLyoqXG4gKiBVc2VkIGJ5IGFjdCgpIHRvIHRyYWNrIHdoZXRoZXIgeW91J3JlIGluc2lkZSBhbiBhY3QoKSBzY29wZS5cbiAqL1xudmFyIElzU29tZVJlbmRlcmVyQWN0aW5nID0ge1xuICBjdXJyZW50OiBmYWxzZVxufTtcblxudmFyIFJlYWN0U2hhcmVkSW50ZXJuYWxzID0ge1xuICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyOiBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLFxuICBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZzogUmVhY3RDdXJyZW50QmF0Y2hDb25maWcsXG4gIFJlYWN0Q3VycmVudE93bmVyOiBSZWFjdEN1cnJlbnRPd25lcixcbiAgSXNTb21lUmVuZGVyZXJBY3Rpbmc6IElzU29tZVJlbmRlcmVyQWN0aW5nLFxuICAvLyBVc2VkIGJ5IHJlbmRlcmVycyB0byBhdm9pZCBidW5kbGluZyBvYmplY3QtYXNzaWduIHR3aWNlIGluIFVNRCBidW5kbGVzOlxuICBhc3NpZ246IF9hc3NpZ25cbn07XG5cbntcbiAgX2Fzc2lnbihSZWFjdFNoYXJlZEludGVybmFscywge1xuICAgIC8vIFRoZXNlIHNob3VsZCBub3QgYmUgaW5jbHVkZWQgaW4gcHJvZHVjdGlvbi5cbiAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lOiBSZWFjdERlYnVnQ3VycmVudEZyYW1lLFxuICAgIC8vIFNoaW0gZm9yIFJlYWN0IERPTSAxNi4wLjAgd2hpY2ggc3RpbGwgZGVzdHJ1Y3R1cmVkIChidXQgbm90IHVzZWQpIHRoaXMuXG4gICAgLy8gVE9ETzogcmVtb3ZlIGluIFJlYWN0IDE3LjAuXG4gICAgUmVhY3RDb21wb25lbnRUcmVlSG9vazoge31cbiAgfSk7XG59XG5cbi8vIGJ5IGNhbGxzIHRvIHRoZXNlIG1ldGhvZHMgYnkgYSBCYWJlbCBwbHVnaW4uXG4vL1xuLy8gSW4gUFJPRCAob3IgaW4gcGFja2FnZXMgd2l0aG91dCBhY2Nlc3MgdG8gUmVhY3QgaW50ZXJuYWxzKSxcbi8vIHRoZXkgYXJlIGxlZnQgYXMgdGhleSBhcmUgaW5zdGVhZC5cblxuZnVuY3Rpb24gd2Fybihmb3JtYXQpIHtcbiAge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHByaW50V2FybmluZygnd2FybicsIGZvcm1hdCwgYXJncyk7XG4gIH1cbn1cbmZ1bmN0aW9uIGVycm9yKGZvcm1hdCkge1xuICB7XG4gICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgfVxuXG4gICAgcHJpbnRXYXJuaW5nKCdlcnJvcicsIGZvcm1hdCwgYXJncyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJpbnRXYXJuaW5nKGxldmVsLCBmb3JtYXQsIGFyZ3MpIHtcbiAgLy8gV2hlbiBjaGFuZ2luZyB0aGlzIGxvZ2ljLCB5b3UgbWlnaHQgd2FudCB0byBhbHNvXG4gIC8vIHVwZGF0ZSBjb25zb2xlV2l0aFN0YWNrRGV2Lnd3dy5qcyBhcyB3ZWxsLlxuICB7XG4gICAgdmFyIGhhc0V4aXN0aW5nU3RhY2sgPSBhcmdzLmxlbmd0aCA+IDAgJiYgdHlwZW9mIGFyZ3NbYXJncy5sZW5ndGggLSAxXSA9PT0gJ3N0cmluZycgJiYgYXJnc1thcmdzLmxlbmd0aCAtIDFdLmluZGV4T2YoJ1xcbiAgICBpbicpID09PSAwO1xuXG4gICAgaWYgKCFoYXNFeGlzdGluZ1N0YWNrKSB7XG4gICAgICB2YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG4gICAgICB2YXIgc3RhY2sgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0oKTtcblxuICAgICAgaWYgKHN0YWNrICE9PSAnJykge1xuICAgICAgICBmb3JtYXQgKz0gJyVzJztcbiAgICAgICAgYXJncyA9IGFyZ3MuY29uY2F0KFtzdGFja10pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBhcmdzV2l0aEZvcm1hdCA9IGFyZ3MubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gJycgKyBpdGVtO1xuICAgIH0pOyAvLyBDYXJlZnVsOiBSTiBjdXJyZW50bHkgZGVwZW5kcyBvbiB0aGlzIHByZWZpeFxuXG4gICAgYXJnc1dpdGhGb3JtYXQudW5zaGlmdCgnV2FybmluZzogJyArIGZvcm1hdCk7IC8vIFdlIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIHNwcmVhZCAob3IgLmFwcGx5KSBkaXJlY3RseSBiZWNhdXNlIGl0XG4gICAgLy8gYnJlYWtzIElFOTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMzYxMFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmdcblxuICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGVbbGV2ZWxdLCBjb25zb2xlLCBhcmdzV2l0aEZvcm1hdCk7XG5cbiAgICB0cnkge1xuICAgICAgLy8gLS0tIFdlbGNvbWUgdG8gZGVidWdnaW5nIFJlYWN0IC0tLVxuICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICsgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG4gICAgICB9KTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9IGNhdGNoICh4KSB7fVxuICB9XG59XG5cbnZhciBkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnQgPSB7fTtcblxuZnVuY3Rpb24gd2Fybk5vb3AocHVibGljSW5zdGFuY2UsIGNhbGxlck5hbWUpIHtcbiAge1xuICAgIHZhciBfY29uc3RydWN0b3IgPSBwdWJsaWNJbnN0YW5jZS5jb25zdHJ1Y3RvcjtcbiAgICB2YXIgY29tcG9uZW50TmFtZSA9IF9jb25zdHJ1Y3RvciAmJiAoX2NvbnN0cnVjdG9yLmRpc3BsYXlOYW1lIHx8IF9jb25zdHJ1Y3Rvci5uYW1lKSB8fCAnUmVhY3RDbGFzcyc7XG4gICAgdmFyIHdhcm5pbmdLZXkgPSBjb21wb25lbnROYW1lICsgXCIuXCIgKyBjYWxsZXJOYW1lO1xuXG4gICAgaWYgKGRpZFdhcm5TdGF0ZVVwZGF0ZUZvclVubW91bnRlZENvbXBvbmVudFt3YXJuaW5nS2V5XSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVycm9yKFwiQ2FuJ3QgY2FsbCAlcyBvbiBhIGNvbXBvbmVudCB0aGF0IGlzIG5vdCB5ZXQgbW91bnRlZC4gXCIgKyAnVGhpcyBpcyBhIG5vLW9wLCBidXQgaXQgbWlnaHQgaW5kaWNhdGUgYSBidWcgaW4geW91ciBhcHBsaWNhdGlvbi4gJyArICdJbnN0ZWFkLCBhc3NpZ24gdG8gYHRoaXMuc3RhdGVgIGRpcmVjdGx5IG9yIGRlZmluZSBhIGBzdGF0ZSA9IHt9O2AgJyArICdjbGFzcyBwcm9wZXJ0eSB3aXRoIHRoZSBkZXNpcmVkIHN0YXRlIGluIHRoZSAlcyBjb21wb25lbnQuJywgY2FsbGVyTmFtZSwgY29tcG9uZW50TmFtZSk7XG5cbiAgICBkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnRbd2FybmluZ0tleV0gPSB0cnVlO1xuICB9XG59XG4vKipcbiAqIFRoaXMgaXMgdGhlIGFic3RyYWN0IEFQSSBmb3IgYW4gdXBkYXRlIHF1ZXVlLlxuICovXG5cblxudmFyIFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlID0ge1xuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgb3Igbm90IHRoaXMgY29tcG9zaXRlIGNvbXBvbmVudCBpcyBtb3VudGVkLlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB3ZSB3YW50IHRvIHRlc3QuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgbW91bnRlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBmaW5hbFxuICAgKi9cbiAgaXNNb3VudGVkOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZvcmNlcyBhbiB1cGRhdGUuIFRoaXMgc2hvdWxkIG9ubHkgYmUgaW52b2tlZCB3aGVuIGl0IGlzIGtub3duIHdpdGhcbiAgICogY2VydGFpbnR5IHRoYXQgd2UgYXJlICoqbm90KiogaW4gYSBET00gdHJhbnNhY3Rpb24uXG4gICAqXG4gICAqIFlvdSBtYXkgd2FudCB0byBjYWxsIHRoaXMgd2hlbiB5b3Uga25vdyB0aGF0IHNvbWUgZGVlcGVyIGFzcGVjdCBvZiB0aGVcbiAgICogY29tcG9uZW50J3Mgc3RhdGUgaGFzIGNoYW5nZWQgYnV0IGBzZXRTdGF0ZWAgd2FzIG5vdCBjYWxsZWQuXG4gICAqXG4gICAqIFRoaXMgd2lsbCBub3QgaW52b2tlIGBzaG91bGRDb21wb25lbnRVcGRhdGVgLCBidXQgaXQgd2lsbCBpbnZva2VcbiAgICogYGNvbXBvbmVudFdpbGxVcGRhdGVgIGFuZCBgY29tcG9uZW50RGlkVXBkYXRlYC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgY29tcG9uZW50IGlzIHVwZGF0ZWQuXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gY2FsbGVyTmFtZSBuYW1lIG9mIHRoZSBjYWxsaW5nIGZ1bmN0aW9uIGluIHRoZSBwdWJsaWMgQVBJLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVGb3JjZVVwZGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAnZm9yY2VVcGRhdGUnKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVwbGFjZXMgYWxsIG9mIHRoZSBzdGF0ZS4gQWx3YXlzIHVzZSB0aGlzIG9yIGBzZXRTdGF0ZWAgdG8gbXV0YXRlIHN0YXRlLlxuICAgKiBZb3Ugc2hvdWxkIHRyZWF0IGB0aGlzLnN0YXRlYCBhcyBpbW11dGFibGUuXG4gICAqXG4gICAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGB0aGlzLnN0YXRlYCB3aWxsIGJlIGltbWVkaWF0ZWx5IHVwZGF0ZWQsIHNvXG4gICAqIGFjY2Vzc2luZyBgdGhpcy5zdGF0ZWAgYWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZCBtYXkgcmV0dXJuIHRoZSBvbGQgdmFsdWUuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0ge29iamVjdH0gY29tcGxldGVTdGF0ZSBOZXh0IHN0YXRlLlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIGNvbXBvbmVudCBpcyB1cGRhdGVkLlxuICAgKiBAcGFyYW0gez9zdHJpbmd9IGNhbGxlck5hbWUgbmFtZSBvZiB0aGUgY2FsbGluZyBmdW5jdGlvbiBpbiB0aGUgcHVibGljIEFQSS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlUmVwbGFjZVN0YXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIGNvbXBsZXRlU3RhdGUsIGNhbGxiYWNrLCBjYWxsZXJOYW1lKSB7XG4gICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdyZXBsYWNlU3RhdGUnKTtcbiAgfSxcblxuICAvKipcbiAgICogU2V0cyBhIHN1YnNldCBvZiB0aGUgc3RhdGUuIFRoaXMgb25seSBleGlzdHMgYmVjYXVzZSBfcGVuZGluZ1N0YXRlIGlzXG4gICAqIGludGVybmFsLiBUaGlzIHByb3ZpZGVzIGEgbWVyZ2luZyBzdHJhdGVneSB0aGF0IGlzIG5vdCBhdmFpbGFibGUgdG8gZGVlcFxuICAgKiBwcm9wZXJ0aWVzIHdoaWNoIGlzIGNvbmZ1c2luZy4gVE9ETzogRXhwb3NlIHBlbmRpbmdTdGF0ZSBvciBkb24ndCB1c2UgaXRcbiAgICogZHVyaW5nIHRoZSBtZXJnZS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJ0aWFsU3RhdGUgTmV4dCBwYXJ0aWFsIHN0YXRlIHRvIGJlIG1lcmdlZCB3aXRoIHN0YXRlLlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIGNvbXBvbmVudCBpcyB1cGRhdGVkLlxuICAgKiBAcGFyYW0gez9zdHJpbmd9IE5hbWUgb2YgdGhlIGNhbGxpbmcgZnVuY3Rpb24gaW4gdGhlIHB1YmxpYyBBUEkuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZVNldFN0YXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIHBhcnRpYWxTdGF0ZSwgY2FsbGJhY2ssIGNhbGxlck5hbWUpIHtcbiAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgJ3NldFN0YXRlJyk7XG4gIH1cbn07XG5cbnZhciBlbXB0eU9iamVjdCA9IHt9O1xuXG57XG4gIE9iamVjdC5mcmVlemUoZW1wdHlPYmplY3QpO1xufVxuLyoqXG4gKiBCYXNlIGNsYXNzIGhlbHBlcnMgZm9yIHRoZSB1cGRhdGluZyBzdGF0ZSBvZiBhIGNvbXBvbmVudC5cbiAqL1xuXG5cbmZ1bmN0aW9uIENvbXBvbmVudChwcm9wcywgY29udGV4dCwgdXBkYXRlcikge1xuICB0aGlzLnByb3BzID0gcHJvcHM7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7IC8vIElmIGEgY29tcG9uZW50IGhhcyBzdHJpbmcgcmVmcywgd2Ugd2lsbCBhc3NpZ24gYSBkaWZmZXJlbnQgb2JqZWN0IGxhdGVyLlxuXG4gIHRoaXMucmVmcyA9IGVtcHR5T2JqZWN0OyAvLyBXZSBpbml0aWFsaXplIHRoZSBkZWZhdWx0IHVwZGF0ZXIgYnV0IHRoZSByZWFsIG9uZSBnZXRzIGluamVjdGVkIGJ5IHRoZVxuICAvLyByZW5kZXJlci5cblxuICB0aGlzLnVwZGF0ZXIgPSB1cGRhdGVyIHx8IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlO1xufVxuXG5Db21wb25lbnQucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQgPSB7fTtcbi8qKlxuICogU2V0cyBhIHN1YnNldCBvZiB0aGUgc3RhdGUuIEFsd2F5cyB1c2UgdGhpcyB0byBtdXRhdGVcbiAqIHN0YXRlLiBZb3Ugc2hvdWxkIHRyZWF0IGB0aGlzLnN0YXRlYCBhcyBpbW11dGFibGUuXG4gKlxuICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgYHRoaXMuc3RhdGVgIHdpbGwgYmUgaW1tZWRpYXRlbHkgdXBkYXRlZCwgc29cbiAqIGFjY2Vzc2luZyBgdGhpcy5zdGF0ZWAgYWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZCBtYXkgcmV0dXJuIHRoZSBvbGQgdmFsdWUuXG4gKlxuICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgY2FsbHMgdG8gYHNldFN0YXRlYCB3aWxsIHJ1biBzeW5jaHJvbm91c2x5LFxuICogYXMgdGhleSBtYXkgZXZlbnR1YWxseSBiZSBiYXRjaGVkIHRvZ2V0aGVyLiAgWW91IGNhbiBwcm92aWRlIGFuIG9wdGlvbmFsXG4gKiBjYWxsYmFjayB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgd2hlbiB0aGUgY2FsbCB0byBzZXRTdGF0ZSBpcyBhY3R1YWxseVxuICogY29tcGxldGVkLlxuICpcbiAqIFdoZW4gYSBmdW5jdGlvbiBpcyBwcm92aWRlZCB0byBzZXRTdGF0ZSwgaXQgd2lsbCBiZSBjYWxsZWQgYXQgc29tZSBwb2ludCBpblxuICogdGhlIGZ1dHVyZSAobm90IHN5bmNocm9ub3VzbHkpLiBJdCB3aWxsIGJlIGNhbGxlZCB3aXRoIHRoZSB1cCB0byBkYXRlXG4gKiBjb21wb25lbnQgYXJndW1lbnRzIChzdGF0ZSwgcHJvcHMsIGNvbnRleHQpLiBUaGVzZSB2YWx1ZXMgY2FuIGJlIGRpZmZlcmVudFxuICogZnJvbSB0aGlzLiogYmVjYXVzZSB5b3VyIGZ1bmN0aW9uIG1heSBiZSBjYWxsZWQgYWZ0ZXIgcmVjZWl2ZVByb3BzIGJ1dCBiZWZvcmVcbiAqIHNob3VsZENvbXBvbmVudFVwZGF0ZSwgYW5kIHRoaXMgbmV3IHN0YXRlLCBwcm9wcywgYW5kIGNvbnRleHQgd2lsbCBub3QgeWV0IGJlXG4gKiBhc3NpZ25lZCB0byB0aGlzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fGZ1bmN0aW9ufSBwYXJ0aWFsU3RhdGUgTmV4dCBwYXJ0aWFsIHN0YXRlIG9yIGZ1bmN0aW9uIHRvXG4gKiAgICAgICAgcHJvZHVjZSBuZXh0IHBhcnRpYWwgc3RhdGUgdG8gYmUgbWVyZ2VkIHdpdGggY3VycmVudCBzdGF0ZS5cbiAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgc3RhdGUgaXMgdXBkYXRlZC5cbiAqIEBmaW5hbFxuICogQHByb3RlY3RlZFxuICovXG5cbkNvbXBvbmVudC5wcm90b3R5cGUuc2V0U3RhdGUgPSBmdW5jdGlvbiAocGFydGlhbFN0YXRlLCBjYWxsYmFjaykge1xuICBpZiAoISh0eXBlb2YgcGFydGlhbFN0YXRlID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgcGFydGlhbFN0YXRlID09PSAnZnVuY3Rpb24nIHx8IHBhcnRpYWxTdGF0ZSA9PSBudWxsKSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcInNldFN0YXRlKC4uLik6IHRha2VzIGFuIG9iamVjdCBvZiBzdGF0ZSB2YXJpYWJsZXMgdG8gdXBkYXRlIG9yIGEgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhbiBvYmplY3Qgb2Ygc3RhdGUgdmFyaWFibGVzLlwiICk7XG4gICAgfVxuICB9XG5cbiAgdGhpcy51cGRhdGVyLmVucXVldWVTZXRTdGF0ZSh0aGlzLCBwYXJ0aWFsU3RhdGUsIGNhbGxiYWNrLCAnc2V0U3RhdGUnKTtcbn07XG4vKipcbiAqIEZvcmNlcyBhbiB1cGRhdGUuIFRoaXMgc2hvdWxkIG9ubHkgYmUgaW52b2tlZCB3aGVuIGl0IGlzIGtub3duIHdpdGhcbiAqIGNlcnRhaW50eSB0aGF0IHdlIGFyZSAqKm5vdCoqIGluIGEgRE9NIHRyYW5zYWN0aW9uLlxuICpcbiAqIFlvdSBtYXkgd2FudCB0byBjYWxsIHRoaXMgd2hlbiB5b3Uga25vdyB0aGF0IHNvbWUgZGVlcGVyIGFzcGVjdCBvZiB0aGVcbiAqIGNvbXBvbmVudCdzIHN0YXRlIGhhcyBjaGFuZ2VkIGJ1dCBgc2V0U3RhdGVgIHdhcyBub3QgY2FsbGVkLlxuICpcbiAqIFRoaXMgd2lsbCBub3QgaW52b2tlIGBzaG91bGRDb21wb25lbnRVcGRhdGVgLCBidXQgaXQgd2lsbCBpbnZva2VcbiAqIGBjb21wb25lbnRXaWxsVXBkYXRlYCBhbmQgYGNvbXBvbmVudERpZFVwZGF0ZWAuXG4gKlxuICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciB1cGRhdGUgaXMgY29tcGxldGUuXG4gKiBAZmluYWxcbiAqIEBwcm90ZWN0ZWRcbiAqL1xuXG5cbkNvbXBvbmVudC5wcm90b3R5cGUuZm9yY2VVcGRhdGUgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgdGhpcy51cGRhdGVyLmVucXVldWVGb3JjZVVwZGF0ZSh0aGlzLCBjYWxsYmFjaywgJ2ZvcmNlVXBkYXRlJyk7XG59O1xuLyoqXG4gKiBEZXByZWNhdGVkIEFQSXMuIFRoZXNlIEFQSXMgdXNlZCB0byBleGlzdCBvbiBjbGFzc2ljIFJlYWN0IGNsYXNzZXMgYnV0IHNpbmNlXG4gKiB3ZSB3b3VsZCBsaWtlIHRvIGRlcHJlY2F0ZSB0aGVtLCB3ZSdyZSBub3QgZ29pbmcgdG8gbW92ZSB0aGVtIG92ZXIgdG8gdGhpc1xuICogbW9kZXJuIGJhc2UgY2xhc3MuIEluc3RlYWQsIHdlIGRlZmluZSBhIGdldHRlciB0aGF0IHdhcm5zIGlmIGl0J3MgYWNjZXNzZWQuXG4gKi9cblxuXG57XG4gIHZhciBkZXByZWNhdGVkQVBJcyA9IHtcbiAgICBpc01vdW50ZWQ6IFsnaXNNb3VudGVkJywgJ0luc3RlYWQsIG1ha2Ugc3VyZSB0byBjbGVhbiB1cCBzdWJzY3JpcHRpb25zIGFuZCBwZW5kaW5nIHJlcXVlc3RzIGluICcgKyAnY29tcG9uZW50V2lsbFVubW91bnQgdG8gcHJldmVudCBtZW1vcnkgbGVha3MuJ10sXG4gICAgcmVwbGFjZVN0YXRlOiBbJ3JlcGxhY2VTdGF0ZScsICdSZWZhY3RvciB5b3VyIGNvZGUgdG8gdXNlIHNldFN0YXRlIGluc3RlYWQgKHNlZSAnICsgJ2h0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMzIzNikuJ11cbiAgfTtcblxuICB2YXIgZGVmaW5lRGVwcmVjYXRpb25XYXJuaW5nID0gZnVuY3Rpb24gKG1ldGhvZE5hbWUsIGluZm8pIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcG9uZW50LnByb3RvdHlwZSwgbWV0aG9kTmFtZSwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHdhcm4oJyVzKC4uLikgaXMgZGVwcmVjYXRlZCBpbiBwbGFpbiBKYXZhU2NyaXB0IFJlYWN0IGNsYXNzZXMuICVzJywgaW5mb1swXSwgaW5mb1sxXSk7XG5cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBmb3IgKHZhciBmbk5hbWUgaW4gZGVwcmVjYXRlZEFQSXMpIHtcbiAgICBpZiAoZGVwcmVjYXRlZEFQSXMuaGFzT3duUHJvcGVydHkoZm5OYW1lKSkge1xuICAgICAgZGVmaW5lRGVwcmVjYXRpb25XYXJuaW5nKGZuTmFtZSwgZGVwcmVjYXRlZEFQSXNbZm5OYW1lXSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIENvbXBvbmVudER1bW15KCkge31cblxuQ29tcG9uZW50RHVtbXkucHJvdG90eXBlID0gQ29tcG9uZW50LnByb3RvdHlwZTtcbi8qKlxuICogQ29udmVuaWVuY2UgY29tcG9uZW50IHdpdGggZGVmYXVsdCBzaGFsbG93IGVxdWFsaXR5IGNoZWNrIGZvciBzQ1UuXG4gKi9cblxuZnVuY3Rpb24gUHVyZUNvbXBvbmVudChwcm9wcywgY29udGV4dCwgdXBkYXRlcikge1xuICB0aGlzLnByb3BzID0gcHJvcHM7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7IC8vIElmIGEgY29tcG9uZW50IGhhcyBzdHJpbmcgcmVmcywgd2Ugd2lsbCBhc3NpZ24gYSBkaWZmZXJlbnQgb2JqZWN0IGxhdGVyLlxuXG4gIHRoaXMucmVmcyA9IGVtcHR5T2JqZWN0O1xuICB0aGlzLnVwZGF0ZXIgPSB1cGRhdGVyIHx8IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlO1xufVxuXG52YXIgcHVyZUNvbXBvbmVudFByb3RvdHlwZSA9IFB1cmVDb21wb25lbnQucHJvdG90eXBlID0gbmV3IENvbXBvbmVudER1bW15KCk7XG5wdXJlQ29tcG9uZW50UHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUHVyZUNvbXBvbmVudDsgLy8gQXZvaWQgYW4gZXh0cmEgcHJvdG90eXBlIGp1bXAgZm9yIHRoZXNlIG1ldGhvZHMuXG5cbl9hc3NpZ24ocHVyZUNvbXBvbmVudFByb3RvdHlwZSwgQ29tcG9uZW50LnByb3RvdHlwZSk7XG5cbnB1cmVDb21wb25lbnRQcm90b3R5cGUuaXNQdXJlUmVhY3RDb21wb25lbnQgPSB0cnVlO1xuXG4vLyBhbiBpbW11dGFibGUgb2JqZWN0IHdpdGggYSBzaW5nbGUgbXV0YWJsZSB2YWx1ZVxuZnVuY3Rpb24gY3JlYXRlUmVmKCkge1xuICB2YXIgcmVmT2JqZWN0ID0ge1xuICAgIGN1cnJlbnQ6IG51bGxcbiAgfTtcblxuICB7XG4gICAgT2JqZWN0LnNlYWwocmVmT2JqZWN0KTtcbiAgfVxuXG4gIHJldHVybiByZWZPYmplY3Q7XG59XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgUkVTRVJWRURfUFJPUFMgPSB7XG4gIGtleTogdHJ1ZSxcbiAgcmVmOiB0cnVlLFxuICBfX3NlbGY6IHRydWUsXG4gIF9fc291cmNlOiB0cnVlXG59O1xudmFyIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duLCBzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93biwgZGlkV2FybkFib3V0U3RyaW5nUmVmcztcblxue1xuICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzID0ge307XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkUmVmKGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAncmVmJykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ3JlZicpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcucmVmICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkS2V5KGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAna2V5JykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ2tleScpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcua2V5ICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB2YXIgd2FybkFib3V0QWNjZXNzaW5nS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYGtleWAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vZmIubWUvcmVhY3Qtc3BlY2lhbC1wcm9wcyknLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHdhcm5BYm91dEFjY2Vzc2luZ0tleS5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ2tleScsIHtcbiAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ0tleSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB2YXIgd2FybkFib3V0QWNjZXNzaW5nUmVmID0gZnVuY3Rpb24gKCkge1xuICAgIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYHJlZmAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vZmIubWUvcmVhY3Qtc3BlY2lhbC1wcm9wcyknLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHdhcm5BYm91dEFjY2Vzc2luZ1JlZi5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ3JlZicsIHtcbiAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcpIHtcbiAge1xuICAgIGlmICh0eXBlb2YgY29uZmlnLnJlZiA9PT0gJ3N0cmluZycgJiYgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCAmJiBjb25maWcuX19zZWxmICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQuc3RhdGVOb2RlICE9PSBjb25maWcuX19zZWxmKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgIGVycm9yKCdDb21wb25lbnQgXCIlc1wiIGNvbnRhaW5zIHRoZSBzdHJpbmcgcmVmIFwiJXNcIi4gJyArICdTdXBwb3J0IGZvciBzdHJpbmcgcmVmcyB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gJyArICdUaGlzIGNhc2UgY2Fubm90IGJlIGF1dG9tYXRpY2FsbHkgY29udmVydGVkIHRvIGFuIGFycm93IGZ1bmN0aW9uLiAnICsgJ1dlIGFzayB5b3UgdG8gbWFudWFsbHkgZml4IHRoaXMgY2FzZSBieSB1c2luZyB1c2VSZWYoKSBvciBjcmVhdGVSZWYoKSBpbnN0ZWFkLiAnICsgJ0xlYXJuIG1vcmUgYWJvdXQgdXNpbmcgcmVmcyBzYWZlbHkgaGVyZTogJyArICdodHRwczovL2ZiLm1lL3JlYWN0LXN0cmljdC1tb2RlLXN0cmluZy1yZWYnLCBnZXRDb21wb25lbnROYW1lKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQudHlwZSksIGNvbmZpZy5yZWYpO1xuXG4gICAgICAgIGRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBGYWN0b3J5IG1ldGhvZCB0byBjcmVhdGUgYSBuZXcgUmVhY3QgZWxlbWVudC4gVGhpcyBubyBsb25nZXIgYWRoZXJlcyB0b1xuICogdGhlIGNsYXNzIHBhdHRlcm4sIHNvIGRvIG5vdCB1c2UgbmV3IHRvIGNhbGwgaXQuIEFsc28sIGluc3RhbmNlb2YgY2hlY2tcbiAqIHdpbGwgbm90IHdvcmsuIEluc3RlYWQgdGVzdCAkJHR5cGVvZiBmaWVsZCBhZ2FpbnN0IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSB0byBjaGVja1xuICogaWYgc29tZXRoaW5nIGlzIGEgUmVhY3QgRWxlbWVudC5cbiAqXG4gKiBAcGFyYW0geyp9IHR5cGVcbiAqIEBwYXJhbSB7Kn0gcHJvcHNcbiAqIEBwYXJhbSB7Kn0ga2V5XG4gKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IHJlZlxuICogQHBhcmFtIHsqfSBvd25lclxuICogQHBhcmFtIHsqfSBzZWxmIEEgKnRlbXBvcmFyeSogaGVscGVyIHRvIGRldGVjdCBwbGFjZXMgd2hlcmUgYHRoaXNgIGlzXG4gKiBkaWZmZXJlbnQgZnJvbSB0aGUgYG93bmVyYCB3aGVuIFJlYWN0LmNyZWF0ZUVsZW1lbnQgaXMgY2FsbGVkLCBzbyB0aGF0IHdlXG4gKiBjYW4gd2Fybi4gV2Ugd2FudCB0byBnZXQgcmlkIG9mIG93bmVyIGFuZCByZXBsYWNlIHN0cmluZyBgcmVmYHMgd2l0aCBhcnJvd1xuICogZnVuY3Rpb25zLCBhbmQgYXMgbG9uZyBhcyBgdGhpc2AgYW5kIG93bmVyIGFyZSB0aGUgc2FtZSwgdGhlcmUgd2lsbCBiZSBub1xuICogY2hhbmdlIGluIGJlaGF2aW9yLlxuICogQHBhcmFtIHsqfSBzb3VyY2UgQW4gYW5ub3RhdGlvbiBvYmplY3QgKGFkZGVkIGJ5IGEgdHJhbnNwaWxlciBvciBvdGhlcndpc2UpXG4gKiBpbmRpY2F0aW5nIGZpbGVuYW1lLCBsaW5lIG51bWJlciwgYW5kL29yIG90aGVyIGluZm9ybWF0aW9uLlxuICogQGludGVybmFsXG4gKi9cblxuXG52YXIgUmVhY3RFbGVtZW50ID0gZnVuY3Rpb24gKHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIG93bmVyLCBwcm9wcykge1xuICB2YXIgZWxlbWVudCA9IHtcbiAgICAvLyBUaGlzIHRhZyBhbGxvd3MgdXMgdG8gdW5pcXVlbHkgaWRlbnRpZnkgdGhpcyBhcyBhIFJlYWN0IEVsZW1lbnRcbiAgICAkJHR5cGVvZjogUkVBQ1RfRUxFTUVOVF9UWVBFLFxuICAgIC8vIEJ1aWx0LWluIHByb3BlcnRpZXMgdGhhdCBiZWxvbmcgb24gdGhlIGVsZW1lbnRcbiAgICB0eXBlOiB0eXBlLFxuICAgIGtleToga2V5LFxuICAgIHJlZjogcmVmLFxuICAgIHByb3BzOiBwcm9wcyxcbiAgICAvLyBSZWNvcmQgdGhlIGNvbXBvbmVudCByZXNwb25zaWJsZSBmb3IgY3JlYXRpbmcgdGhpcyBlbGVtZW50LlxuICAgIF9vd25lcjogb3duZXJcbiAgfTtcblxuICB7XG4gICAgLy8gVGhlIHZhbGlkYXRpb24gZmxhZyBpcyBjdXJyZW50bHkgbXV0YXRpdmUuIFdlIHB1dCBpdCBvblxuICAgIC8vIGFuIGV4dGVybmFsIGJhY2tpbmcgc3RvcmUgc28gdGhhdCB3ZSBjYW4gZnJlZXplIHRoZSB3aG9sZSBvYmplY3QuXG4gICAgLy8gVGhpcyBjYW4gYmUgcmVwbGFjZWQgd2l0aCBhIFdlYWtNYXAgb25jZSB0aGV5IGFyZSBpbXBsZW1lbnRlZCBpblxuICAgIC8vIGNvbW1vbmx5IHVzZWQgZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzLlxuICAgIGVsZW1lbnQuX3N0b3JlID0ge307IC8vIFRvIG1ha2UgY29tcGFyaW5nIFJlYWN0RWxlbWVudHMgZWFzaWVyIGZvciB0ZXN0aW5nIHB1cnBvc2VzLCB3ZSBtYWtlXG4gICAgLy8gdGhlIHZhbGlkYXRpb24gZmxhZyBub24tZW51bWVyYWJsZSAod2hlcmUgcG9zc2libGUsIHdoaWNoIHNob3VsZFxuICAgIC8vIGluY2x1ZGUgZXZlcnkgZW52aXJvbm1lbnQgd2UgcnVuIHRlc3RzIGluKSwgc28gdGhlIHRlc3QgZnJhbWV3b3JrXG4gICAgLy8gaWdub3JlcyBpdC5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50Ll9zdG9yZSwgJ3ZhbGlkYXRlZCcsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IGZhbHNlXG4gICAgfSk7IC8vIHNlbGYgYW5kIHNvdXJjZSBhcmUgREVWIG9ubHkgcHJvcGVydGllcy5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NlbGYnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogc2VsZlxuICAgIH0pOyAvLyBUd28gZWxlbWVudHMgY3JlYXRlZCBpbiB0d28gZGlmZmVyZW50IHBsYWNlcyBzaG91bGQgYmUgY29uc2lkZXJlZFxuICAgIC8vIGVxdWFsIGZvciB0ZXN0aW5nIHB1cnBvc2VzIGFuZCB0aGVyZWZvcmUgd2UgaGlkZSBpdCBmcm9tIGVudW1lcmF0aW9uLlxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc291cmNlJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNvdXJjZVxuICAgIH0pO1xuXG4gICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudC5wcm9wcyk7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBlbGVtZW50O1xufTtcbi8qKlxuICogQ3JlYXRlIGFuZCByZXR1cm4gYSBuZXcgUmVhY3RFbGVtZW50IG9mIHRoZSBnaXZlbiB0eXBlLlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNjcmVhdGVlbGVtZW50XG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCh0eXBlLCBjb25maWcsIGNoaWxkcmVuKSB7XG4gIHZhciBwcm9wTmFtZTsgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuXG4gIHZhciBwcm9wcyA9IHt9O1xuICB2YXIga2V5ID0gbnVsbDtcbiAgdmFyIHJlZiA9IG51bGw7XG4gIHZhciBzZWxmID0gbnVsbDtcbiAgdmFyIHNvdXJjZSA9IG51bGw7XG5cbiAgaWYgKGNvbmZpZyAhPSBudWxsKSB7XG4gICAgaWYgKGhhc1ZhbGlkUmVmKGNvbmZpZykpIHtcbiAgICAgIHJlZiA9IGNvbmZpZy5yZWY7XG5cbiAgICAgIHtcbiAgICAgICAgd2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkKGNvbmZpZyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICB9XG5cbiAgICBzZWxmID0gY29uZmlnLl9fc2VsZiA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNvbmZpZy5fX3NlbGY7XG4gICAgc291cmNlID0gY29uZmlnLl9fc291cmNlID09PSB1bmRlZmluZWQgPyBudWxsIDogY29uZmlnLl9fc291cmNlOyAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBhcmUgYWRkZWQgdG8gYSBuZXcgcHJvcHMgb2JqZWN0XG5cbiAgICBmb3IgKHByb3BOYW1lIGluIGNvbmZpZykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBwcm9wTmFtZSkgJiYgIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyBDaGlsZHJlbiBjYW4gYmUgbW9yZSB0aGFuIG9uZSBhcmd1bWVudCwgYW5kIHRob3NlIGFyZSB0cmFuc2ZlcnJlZCBvbnRvXG4gIC8vIHRoZSBuZXdseSBhbGxvY2F0ZWQgcHJvcHMgb2JqZWN0LlxuXG5cbiAgdmFyIGNoaWxkcmVuTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCAtIDI7XG5cbiAgaWYgKGNoaWxkcmVuTGVuZ3RoID09PSAxKSB7XG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgfSBlbHNlIGlmIChjaGlsZHJlbkxlbmd0aCA+IDEpIHtcbiAgICB2YXIgY2hpbGRBcnJheSA9IEFycmF5KGNoaWxkcmVuTGVuZ3RoKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW5MZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGRBcnJheVtpXSA9IGFyZ3VtZW50c1tpICsgMl07XG4gICAgfVxuXG4gICAge1xuICAgICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgICAgT2JqZWN0LmZyZWV6ZShjaGlsZEFycmF5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkQXJyYXk7XG4gIH0gLy8gUmVzb2x2ZSBkZWZhdWx0IHByb3BzXG5cblxuICBpZiAodHlwZSAmJiB0eXBlLmRlZmF1bHRQcm9wcykge1xuICAgIHZhciBkZWZhdWx0UHJvcHMgPSB0eXBlLmRlZmF1bHRQcm9wcztcblxuICAgIGZvciAocHJvcE5hbWUgaW4gZGVmYXVsdFByb3BzKSB7XG4gICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB7XG4gICAgaWYgKGtleSB8fCByZWYpIHtcbiAgICAgIHZhciBkaXNwbGF5TmFtZSA9IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nID8gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgJ1Vua25vd24nIDogdHlwZTtcblxuICAgICAgaWYgKGtleSkge1xuICAgICAgICBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVmKSB7XG4gICAgICAgIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFJlYWN0RWxlbWVudCh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LCBwcm9wcyk7XG59XG5mdW5jdGlvbiBjbG9uZUFuZFJlcGxhY2VLZXkob2xkRWxlbWVudCwgbmV3S2V5KSB7XG4gIHZhciBuZXdFbGVtZW50ID0gUmVhY3RFbGVtZW50KG9sZEVsZW1lbnQudHlwZSwgbmV3S2V5LCBvbGRFbGVtZW50LnJlZiwgb2xkRWxlbWVudC5fc2VsZiwgb2xkRWxlbWVudC5fc291cmNlLCBvbGRFbGVtZW50Ll9vd25lciwgb2xkRWxlbWVudC5wcm9wcyk7XG4gIHJldHVybiBuZXdFbGVtZW50O1xufVxuLyoqXG4gKiBDbG9uZSBhbmQgcmV0dXJuIGEgbmV3IFJlYWN0RWxlbWVudCB1c2luZyBlbGVtZW50IGFzIHRoZSBzdGFydGluZyBwb2ludC5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjY2xvbmVlbGVtZW50XG4gKi9cblxuZnVuY3Rpb24gY2xvbmVFbGVtZW50KGVsZW1lbnQsIGNvbmZpZywgY2hpbGRyZW4pIHtcbiAgaWYgKCEhKGVsZW1lbnQgPT09IG51bGwgfHwgZWxlbWVudCA9PT0gdW5kZWZpbmVkKSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcIlJlYWN0LmNsb25lRWxlbWVudCguLi4pOiBUaGUgYXJndW1lbnQgbXVzdCBiZSBhIFJlYWN0IGVsZW1lbnQsIGJ1dCB5b3UgcGFzc2VkIFwiICsgZWxlbWVudCArIFwiLlwiICk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHByb3BOYW1lOyAvLyBPcmlnaW5hbCBwcm9wcyBhcmUgY29waWVkXG5cbiAgdmFyIHByb3BzID0gX2Fzc2lnbih7fSwgZWxlbWVudC5wcm9wcyk7IC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcblxuXG4gIHZhciBrZXkgPSBlbGVtZW50LmtleTtcbiAgdmFyIHJlZiA9IGVsZW1lbnQucmVmOyAvLyBTZWxmIGlzIHByZXNlcnZlZCBzaW5jZSB0aGUgb3duZXIgaXMgcHJlc2VydmVkLlxuXG4gIHZhciBzZWxmID0gZWxlbWVudC5fc2VsZjsgLy8gU291cmNlIGlzIHByZXNlcnZlZCBzaW5jZSBjbG9uZUVsZW1lbnQgaXMgdW5saWtlbHkgdG8gYmUgdGFyZ2V0ZWQgYnkgYVxuICAvLyB0cmFuc3BpbGVyLCBhbmQgdGhlIG9yaWdpbmFsIHNvdXJjZSBpcyBwcm9iYWJseSBhIGJldHRlciBpbmRpY2F0b3Igb2YgdGhlXG4gIC8vIHRydWUgb3duZXIuXG5cbiAgdmFyIHNvdXJjZSA9IGVsZW1lbnQuX3NvdXJjZTsgLy8gT3duZXIgd2lsbCBiZSBwcmVzZXJ2ZWQsIHVubGVzcyByZWYgaXMgb3ZlcnJpZGRlblxuXG4gIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuXG4gIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICAvLyBTaWxlbnRseSBzdGVhbCB0aGUgcmVmIGZyb20gdGhlIHBhcmVudC5cbiAgICAgIHJlZiA9IGNvbmZpZy5yZWY7XG4gICAgICBvd25lciA9IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQ7XG4gICAgfVxuXG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICB9IC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIG92ZXJyaWRlIGV4aXN0aW5nIHByb3BzXG5cblxuICAgIHZhciBkZWZhdWx0UHJvcHM7XG5cbiAgICBpZiAoZWxlbWVudC50eXBlICYmIGVsZW1lbnQudHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICAgIGRlZmF1bHRQcm9wcyA9IGVsZW1lbnQudHlwZS5kZWZhdWx0UHJvcHM7XG4gICAgfVxuXG4gICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgcHJvcE5hbWUpICYmICFSRVNFUlZFRF9QUk9QUy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgaWYgKGNvbmZpZ1twcm9wTmFtZV0gPT09IHVuZGVmaW5lZCAmJiBkZWZhdWx0UHJvcHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wc1xuICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSAvLyBDaGlsZHJlbiBjYW4gYmUgbW9yZSB0aGFuIG9uZSBhcmd1bWVudCwgYW5kIHRob3NlIGFyZSB0cmFuc2ZlcnJlZCBvbnRvXG4gIC8vIHRoZSBuZXdseSBhbGxvY2F0ZWQgcHJvcHMgb2JqZWN0LlxuXG5cbiAgdmFyIGNoaWxkcmVuTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCAtIDI7XG5cbiAgaWYgKGNoaWxkcmVuTGVuZ3RoID09PSAxKSB7XG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgfSBlbHNlIGlmIChjaGlsZHJlbkxlbmd0aCA+IDEpIHtcbiAgICB2YXIgY2hpbGRBcnJheSA9IEFycmF5KGNoaWxkcmVuTGVuZ3RoKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW5MZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGRBcnJheVtpXSA9IGFyZ3VtZW50c1tpICsgMl07XG4gICAgfVxuXG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZEFycmF5O1xuICB9XG5cbiAgcmV0dXJuIFJlYWN0RWxlbWVudChlbGVtZW50LnR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIG93bmVyLCBwcm9wcyk7XG59XG4vKipcbiAqIFZlcmlmaWVzIHRoZSBvYmplY3QgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2lzdmFsaWRlbGVtZW50XG4gKiBAcGFyYW0gez9vYmplY3R9IG9iamVjdFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBgb2JqZWN0YCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIEBmaW5hbFxuICovXG5cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50KG9iamVjdCkge1xuICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsICYmIG9iamVjdC4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xufVxuXG52YXIgU0VQQVJBVE9SID0gJy4nO1xudmFyIFNVQlNFUEFSQVRPUiA9ICc6Jztcbi8qKlxuICogRXNjYXBlIGFuZCB3cmFwIGtleSBzbyBpdCBpcyBzYWZlIHRvIHVzZSBhcyBhIHJlYWN0aWRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IHRvIGJlIGVzY2FwZWQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSBlc2NhcGVkIGtleS5cbiAqL1xuXG5mdW5jdGlvbiBlc2NhcGUoa2V5KSB7XG4gIHZhciBlc2NhcGVSZWdleCA9IC9bPTpdL2c7XG4gIHZhciBlc2NhcGVyTG9va3VwID0ge1xuICAgICc9JzogJz0wJyxcbiAgICAnOic6ICc9MidcbiAgfTtcbiAgdmFyIGVzY2FwZWRTdHJpbmcgPSAoJycgKyBrZXkpLnJlcGxhY2UoZXNjYXBlUmVnZXgsIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgIHJldHVybiBlc2NhcGVyTG9va3VwW21hdGNoXTtcbiAgfSk7XG4gIHJldHVybiAnJCcgKyBlc2NhcGVkU3RyaW5nO1xufVxuLyoqXG4gKiBUT0RPOiBUZXN0IHRoYXQgYSBzaW5nbGUgY2hpbGQgYW5kIGFuIGFycmF5IHdpdGggb25lIGl0ZW0gaGF2ZSB0aGUgc2FtZSBrZXlcbiAqIHBhdHRlcm4uXG4gKi9cblxuXG52YXIgZGlkV2FybkFib3V0TWFwcyA9IGZhbHNlO1xudmFyIHVzZXJQcm92aWRlZEtleUVzY2FwZVJlZ2V4ID0gL1xcLysvZztcblxuZnVuY3Rpb24gZXNjYXBlVXNlclByb3ZpZGVkS2V5KHRleHQpIHtcbiAgcmV0dXJuICgnJyArIHRleHQpLnJlcGxhY2UodXNlclByb3ZpZGVkS2V5RXNjYXBlUmVnZXgsICckJi8nKTtcbn1cblxudmFyIFBPT0xfU0laRSA9IDEwO1xudmFyIHRyYXZlcnNlQ29udGV4dFBvb2wgPSBbXTtcblxuZnVuY3Rpb24gZ2V0UG9vbGVkVHJhdmVyc2VDb250ZXh0KG1hcFJlc3VsdCwga2V5UHJlZml4LCBtYXBGdW5jdGlvbiwgbWFwQ29udGV4dCkge1xuICBpZiAodHJhdmVyc2VDb250ZXh0UG9vbC5sZW5ndGgpIHtcbiAgICB2YXIgdHJhdmVyc2VDb250ZXh0ID0gdHJhdmVyc2VDb250ZXh0UG9vbC5wb3AoKTtcbiAgICB0cmF2ZXJzZUNvbnRleHQucmVzdWx0ID0gbWFwUmVzdWx0O1xuICAgIHRyYXZlcnNlQ29udGV4dC5rZXlQcmVmaXggPSBrZXlQcmVmaXg7XG4gICAgdHJhdmVyc2VDb250ZXh0LmZ1bmMgPSBtYXBGdW5jdGlvbjtcbiAgICB0cmF2ZXJzZUNvbnRleHQuY29udGV4dCA9IG1hcENvbnRleHQ7XG4gICAgdHJhdmVyc2VDb250ZXh0LmNvdW50ID0gMDtcbiAgICByZXR1cm4gdHJhdmVyc2VDb250ZXh0O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7XG4gICAgICByZXN1bHQ6IG1hcFJlc3VsdCxcbiAgICAgIGtleVByZWZpeDoga2V5UHJlZml4LFxuICAgICAgZnVuYzogbWFwRnVuY3Rpb24sXG4gICAgICBjb250ZXh0OiBtYXBDb250ZXh0LFxuICAgICAgY291bnQ6IDBcbiAgICB9O1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbGVhc2VUcmF2ZXJzZUNvbnRleHQodHJhdmVyc2VDb250ZXh0KSB7XG4gIHRyYXZlcnNlQ29udGV4dC5yZXN1bHQgPSBudWxsO1xuICB0cmF2ZXJzZUNvbnRleHQua2V5UHJlZml4ID0gbnVsbDtcbiAgdHJhdmVyc2VDb250ZXh0LmZ1bmMgPSBudWxsO1xuICB0cmF2ZXJzZUNvbnRleHQuY29udGV4dCA9IG51bGw7XG4gIHRyYXZlcnNlQ29udGV4dC5jb3VudCA9IDA7XG5cbiAgaWYgKHRyYXZlcnNlQ29udGV4dFBvb2wubGVuZ3RoIDwgUE9PTF9TSVpFKSB7XG4gICAgdHJhdmVyc2VDb250ZXh0UG9vbC5wdXNoKHRyYXZlcnNlQ29udGV4dCk7XG4gIH1cbn1cbi8qKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcGFyYW0geyFzdHJpbmd9IG5hbWVTb0ZhciBOYW1lIG9mIHRoZSBrZXkgcGF0aCBzbyBmYXIuXG4gKiBAcGFyYW0geyFmdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgdG8gaW52b2tlIHdpdGggZWFjaCBjaGlsZCBmb3VuZC5cbiAqIEBwYXJhbSB7Pyp9IHRyYXZlcnNlQ29udGV4dCBVc2VkIHRvIHBhc3MgaW5mb3JtYXRpb24gdGhyb3VnaG91dCB0aGUgdHJhdmVyc2FsXG4gKiBwcm9jZXNzLlxuICogQHJldHVybiB7IW51bWJlcn0gVGhlIG51bWJlciBvZiBjaGlsZHJlbiBpbiB0aGlzIHN1YnRyZWUuXG4gKi9cblxuXG5mdW5jdGlvbiB0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbChjaGlsZHJlbiwgbmFtZVNvRmFyLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIGNoaWxkcmVuO1xuXG4gIGlmICh0eXBlID09PSAndW5kZWZpbmVkJyB8fCB0eXBlID09PSAnYm9vbGVhbicpIHtcbiAgICAvLyBBbGwgb2YgdGhlIGFib3ZlIGFyZSBwZXJjZWl2ZWQgYXMgbnVsbC5cbiAgICBjaGlsZHJlbiA9IG51bGw7XG4gIH1cblxuICB2YXIgaW52b2tlQ2FsbGJhY2sgPSBmYWxzZTtcblxuICBpZiAoY2hpbGRyZW4gPT09IG51bGwpIHtcbiAgICBpbnZva2VDYWxsYmFjayA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgaW52b2tlQ2FsbGJhY2sgPSB0cnVlO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgc3dpdGNoIChjaGlsZHJlbi4kJHR5cGVvZikge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAgICBpbnZva2VDYWxsYmFjayA9IHRydWU7XG4gICAgICAgIH1cblxuICAgIH1cbiAgfVxuXG4gIGlmIChpbnZva2VDYWxsYmFjaykge1xuICAgIGNhbGxiYWNrKHRyYXZlcnNlQ29udGV4dCwgY2hpbGRyZW4sIC8vIElmIGl0J3MgdGhlIG9ubHkgY2hpbGQsIHRyZWF0IHRoZSBuYW1lIGFzIGlmIGl0IHdhcyB3cmFwcGVkIGluIGFuIGFycmF5XG4gICAgLy8gc28gdGhhdCBpdCdzIGNvbnNpc3RlbnQgaWYgdGhlIG51bWJlciBvZiBjaGlsZHJlbiBncm93cy5cbiAgICBuYW1lU29GYXIgPT09ICcnID8gU0VQQVJBVE9SICsgZ2V0Q29tcG9uZW50S2V5KGNoaWxkcmVuLCAwKSA6IG5hbWVTb0Zhcik7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICB2YXIgY2hpbGQ7XG4gIHZhciBuZXh0TmFtZTtcbiAgdmFyIHN1YnRyZWVDb3VudCA9IDA7IC8vIENvdW50IG9mIGNoaWxkcmVuIGZvdW5kIGluIHRoZSBjdXJyZW50IHN1YnRyZWUuXG5cbiAgdmFyIG5leHROYW1lUHJlZml4ID0gbmFtZVNvRmFyID09PSAnJyA/IFNFUEFSQVRPUiA6IG5hbWVTb0ZhciArIFNVQlNFUEFSQVRPUjtcblxuICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgbmV4dE5hbWUgPSBuZXh0TmFtZVByZWZpeCArIGdldENvbXBvbmVudEtleShjaGlsZCwgaSk7XG4gICAgICBzdWJ0cmVlQ291bnQgKz0gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGQsIG5leHROYW1lLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKGNoaWxkcmVuKTtcblxuICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuXG4gICAgICB7XG4gICAgICAgIC8vIFdhcm4gYWJvdXQgdXNpbmcgTWFwcyBhcyBjaGlsZHJlblxuICAgICAgICBpZiAoaXRlcmF0b3JGbiA9PT0gY2hpbGRyZW4uZW50cmllcykge1xuICAgICAgICAgIGlmICghZGlkV2FybkFib3V0TWFwcykge1xuICAgICAgICAgICAgd2FybignVXNpbmcgTWFwcyBhcyBjaGlsZHJlbiBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gJyArICdhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiBDb25zaWRlciBjb252ZXJ0aW5nIGNoaWxkcmVuIHRvICcgKyAnYW4gYXJyYXkgb2Yga2V5ZWQgUmVhY3RFbGVtZW50cyBpbnN0ZWFkLicpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRpZFdhcm5BYm91dE1hcHMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChjaGlsZHJlbik7XG4gICAgICB2YXIgc3RlcDtcbiAgICAgIHZhciBpaSA9IDA7XG5cbiAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgY2hpbGQgPSBzdGVwLnZhbHVlO1xuICAgICAgICBuZXh0TmFtZSA9IG5leHROYW1lUHJlZml4ICsgZ2V0Q29tcG9uZW50S2V5KGNoaWxkLCBpaSsrKTtcbiAgICAgICAgc3VidHJlZUNvdW50ICs9IHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkLCBuZXh0TmFtZSwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgdmFyIGFkZGVuZHVtID0gJyc7XG5cbiAgICAgIHtcbiAgICAgICAgYWRkZW5kdW0gPSAnIElmIHlvdSBtZWFudCB0byByZW5kZXIgYSBjb2xsZWN0aW9uIG9mIGNoaWxkcmVuLCB1c2UgYW4gYXJyYXkgJyArICdpbnN0ZWFkLicgKyBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0oKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNoaWxkcmVuU3RyaW5nID0gJycgKyBjaGlsZHJlbjtcblxuICAgICAge1xuICAgICAgICB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoIFwiT2JqZWN0cyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQgKGZvdW5kOiBcIiArIChjaGlsZHJlblN0cmluZyA9PT0gJ1tvYmplY3QgT2JqZWN0XScgPyAnb2JqZWN0IHdpdGgga2V5cyB7JyArIE9iamVjdC5rZXlzKGNoaWxkcmVuKS5qb2luKCcsICcpICsgJ30nIDogY2hpbGRyZW5TdHJpbmcpICsgXCIpLlwiICsgYWRkZW5kdW0gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdWJ0cmVlQ291bnQ7XG59XG4vKipcbiAqIFRyYXZlcnNlcyBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmAsIGJ1dFxuICogbWlnaHQgYWxzbyBiZSBzcGVjaWZpZWQgdGhyb3VnaCBhdHRyaWJ1dGVzOlxuICpcbiAqIC0gYHRyYXZlcnNlQWxsQ2hpbGRyZW4odGhpcy5wcm9wcy5jaGlsZHJlbiwgLi4uKWBcbiAqIC0gYHRyYXZlcnNlQWxsQ2hpbGRyZW4odGhpcy5wcm9wcy5sZWZ0UGFuZWxDaGlsZHJlbiwgLi4uKWBcbiAqXG4gKiBUaGUgYHRyYXZlcnNlQ29udGV4dGAgaXMgYW4gb3B0aW9uYWwgYXJndW1lbnQgdGhhdCBpcyBwYXNzZWQgdGhyb3VnaCB0aGVcbiAqIGVudGlyZSB0cmF2ZXJzYWwuIEl0IGNhbiBiZSB1c2VkIHRvIHN0b3JlIGFjY3VtdWxhdGlvbnMgb3IgYW55dGhpbmcgZWxzZSB0aGF0XG4gKiB0aGUgY2FsbGJhY2sgbWlnaHQgZmluZCByZWxldmFudC5cbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIG9iamVjdC5cbiAqIEBwYXJhbSB7IWZ1bmN0aW9ufSBjYWxsYmFjayBUbyBpbnZva2UgdXBvbiB0cmF2ZXJzaW5nIGVhY2ggY2hpbGQuXG4gKiBAcGFyYW0gez8qfSB0cmF2ZXJzZUNvbnRleHQgQ29udGV4dCBmb3IgdHJhdmVyc2FsLlxuICogQHJldHVybiB7IW51bWJlcn0gVGhlIG51bWJlciBvZiBjaGlsZHJlbiBpbiB0aGlzIHN1YnRyZWUuXG4gKi9cblxuXG5mdW5jdGlvbiB0cmF2ZXJzZUFsbENoaWxkcmVuKGNoaWxkcmVuLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KSB7XG4gIGlmIChjaGlsZHJlbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICByZXR1cm4gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGRyZW4sICcnLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KTtcbn1cbi8qKlxuICogR2VuZXJhdGUgYSBrZXkgc3RyaW5nIHRoYXQgaWRlbnRpZmllcyBhIGNvbXBvbmVudCB3aXRoaW4gYSBzZXQuXG4gKlxuICogQHBhcmFtIHsqfSBjb21wb25lbnQgQSBjb21wb25lbnQgdGhhdCBjb3VsZCBjb250YWluIGEgbWFudWFsIGtleS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleCB0aGF0IGlzIHVzZWQgaWYgYSBtYW51YWwga2V5IGlzIG5vdCBwcm92aWRlZC5cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuXG5cbmZ1bmN0aW9uIGdldENvbXBvbmVudEtleShjb21wb25lbnQsIGluZGV4KSB7XG4gIC8vIERvIHNvbWUgdHlwZWNoZWNraW5nIGhlcmUgc2luY2Ugd2UgY2FsbCB0aGlzIGJsaW5kbHkuIFdlIHdhbnQgdG8gZW5zdXJlXG4gIC8vIHRoYXQgd2UgZG9uJ3QgYmxvY2sgcG90ZW50aWFsIGZ1dHVyZSBFUyBBUElzLlxuICBpZiAodHlwZW9mIGNvbXBvbmVudCA9PT0gJ29iamVjdCcgJiYgY29tcG9uZW50ICE9PSBudWxsICYmIGNvbXBvbmVudC5rZXkgIT0gbnVsbCkge1xuICAgIC8vIEV4cGxpY2l0IGtleVxuICAgIHJldHVybiBlc2NhcGUoY29tcG9uZW50LmtleSk7XG4gIH0gLy8gSW1wbGljaXQga2V5IGRldGVybWluZWQgYnkgdGhlIGluZGV4IGluIHRoZSBzZXRcblxuXG4gIHJldHVybiBpbmRleC50b1N0cmluZygzNik7XG59XG5cbmZ1bmN0aW9uIGZvckVhY2hTaW5nbGVDaGlsZChib29rS2VlcGluZywgY2hpbGQsIG5hbWUpIHtcbiAgdmFyIGZ1bmMgPSBib29rS2VlcGluZy5mdW5jLFxuICAgICAgY29udGV4dCA9IGJvb2tLZWVwaW5nLmNvbnRleHQ7XG4gIGZ1bmMuY2FsbChjb250ZXh0LCBjaGlsZCwgYm9va0tlZXBpbmcuY291bnQrKyk7XG59XG4vKipcbiAqIEl0ZXJhdGVzIHRocm91Z2ggY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3RjaGlsZHJlbmZvcmVhY2hcbiAqXG4gKiBUaGUgcHJvdmlkZWQgZm9yRWFjaEZ1bmMoY2hpbGQsIGluZGV4KSB3aWxsIGJlIGNhbGxlZCBmb3IgZWFjaFxuICogbGVhZiBjaGlsZC5cbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKiwgaW50KX0gZm9yRWFjaEZ1bmNcbiAqIEBwYXJhbSB7Kn0gZm9yRWFjaENvbnRleHQgQ29udGV4dCBmb3IgZm9yRWFjaENvbnRleHQuXG4gKi9cblxuXG5mdW5jdGlvbiBmb3JFYWNoQ2hpbGRyZW4oY2hpbGRyZW4sIGZvckVhY2hGdW5jLCBmb3JFYWNoQ29udGV4dCkge1xuICBpZiAoY2hpbGRyZW4gPT0gbnVsbCkge1xuICAgIHJldHVybiBjaGlsZHJlbjtcbiAgfVxuXG4gIHZhciB0cmF2ZXJzZUNvbnRleHQgPSBnZXRQb29sZWRUcmF2ZXJzZUNvbnRleHQobnVsbCwgbnVsbCwgZm9yRWFjaEZ1bmMsIGZvckVhY2hDb250ZXh0KTtcbiAgdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgZm9yRWFjaFNpbmdsZUNoaWxkLCB0cmF2ZXJzZUNvbnRleHQpO1xuICByZWxlYXNlVHJhdmVyc2VDb250ZXh0KHRyYXZlcnNlQ29udGV4dCk7XG59XG5cbmZ1bmN0aW9uIG1hcFNpbmdsZUNoaWxkSW50b0NvbnRleHQoYm9va0tlZXBpbmcsIGNoaWxkLCBjaGlsZEtleSkge1xuICB2YXIgcmVzdWx0ID0gYm9va0tlZXBpbmcucmVzdWx0LFxuICAgICAga2V5UHJlZml4ID0gYm9va0tlZXBpbmcua2V5UHJlZml4LFxuICAgICAgZnVuYyA9IGJvb2tLZWVwaW5nLmZ1bmMsXG4gICAgICBjb250ZXh0ID0gYm9va0tlZXBpbmcuY29udGV4dDtcbiAgdmFyIG1hcHBlZENoaWxkID0gZnVuYy5jYWxsKGNvbnRleHQsIGNoaWxkLCBib29rS2VlcGluZy5jb3VudCsrKTtcblxuICBpZiAoQXJyYXkuaXNBcnJheShtYXBwZWRDaGlsZCkpIHtcbiAgICBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsKG1hcHBlZENoaWxkLCByZXN1bHQsIGNoaWxkS2V5LCBmdW5jdGlvbiAoYykge1xuICAgICAgcmV0dXJuIGM7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAobWFwcGVkQ2hpbGQgIT0gbnVsbCkge1xuICAgIGlmIChpc1ZhbGlkRWxlbWVudChtYXBwZWRDaGlsZCkpIHtcbiAgICAgIG1hcHBlZENoaWxkID0gY2xvbmVBbmRSZXBsYWNlS2V5KG1hcHBlZENoaWxkLCAvLyBLZWVwIGJvdGggdGhlIChtYXBwZWQpIGFuZCBvbGQga2V5cyBpZiB0aGV5IGRpZmZlciwganVzdCBhc1xuICAgICAgLy8gdHJhdmVyc2VBbGxDaGlsZHJlbiB1c2VkIHRvIGRvIGZvciBvYmplY3RzIGFzIGNoaWxkcmVuXG4gICAgICBrZXlQcmVmaXggKyAobWFwcGVkQ2hpbGQua2V5ICYmICghY2hpbGQgfHwgY2hpbGQua2V5ICE9PSBtYXBwZWRDaGlsZC5rZXkpID8gZXNjYXBlVXNlclByb3ZpZGVkS2V5KG1hcHBlZENoaWxkLmtleSkgKyAnLycgOiAnJykgKyBjaGlsZEtleSk7XG4gICAgfVxuXG4gICAgcmVzdWx0LnB1c2gobWFwcGVkQ2hpbGQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hcEludG9XaXRoS2V5UHJlZml4SW50ZXJuYWwoY2hpbGRyZW4sIGFycmF5LCBwcmVmaXgsIGZ1bmMsIGNvbnRleHQpIHtcbiAgdmFyIGVzY2FwZWRQcmVmaXggPSAnJztcblxuICBpZiAocHJlZml4ICE9IG51bGwpIHtcbiAgICBlc2NhcGVkUHJlZml4ID0gZXNjYXBlVXNlclByb3ZpZGVkS2V5KHByZWZpeCkgKyAnLyc7XG4gIH1cblxuICB2YXIgdHJhdmVyc2VDb250ZXh0ID0gZ2V0UG9vbGVkVHJhdmVyc2VDb250ZXh0KGFycmF5LCBlc2NhcGVkUHJlZml4LCBmdW5jLCBjb250ZXh0KTtcbiAgdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgbWFwU2luZ2xlQ2hpbGRJbnRvQ29udGV4dCwgdHJhdmVyc2VDb250ZXh0KTtcbiAgcmVsZWFzZVRyYXZlcnNlQ29udGV4dCh0cmF2ZXJzZUNvbnRleHQpO1xufVxuLyoqXG4gKiBNYXBzIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI3JlYWN0Y2hpbGRyZW5tYXBcbiAqXG4gKiBUaGUgcHJvdmlkZWQgbWFwRnVuY3Rpb24oY2hpbGQsIGtleSwgaW5kZXgpIHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoXG4gKiBsZWFmIGNoaWxkLlxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHBhcmFtIHtmdW5jdGlvbigqLCBpbnQpfSBmdW5jIFRoZSBtYXAgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgQ29udGV4dCBmb3IgbWFwRnVuY3Rpb24uXG4gKiBAcmV0dXJuIHtvYmplY3R9IE9iamVjdCBjb250YWluaW5nIHRoZSBvcmRlcmVkIG1hcCBvZiByZXN1bHRzLlxuICovXG5cblxuZnVuY3Rpb24gbWFwQ2hpbGRyZW4oY2hpbGRyZW4sIGZ1bmMsIGNvbnRleHQpIHtcbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICByZXR1cm4gY2hpbGRyZW47XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gW107XG4gIG1hcEludG9XaXRoS2V5UHJlZml4SW50ZXJuYWwoY2hpbGRyZW4sIHJlc3VsdCwgbnVsbCwgZnVuYywgY29udGV4dCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIENvdW50IHRoZSBudW1iZXIgb2YgY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhc1xuICogYHByb3BzLmNoaWxkcmVuYC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI3JlYWN0Y2hpbGRyZW5jb3VudFxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNoaWxkcmVuLlxuICovXG5cblxuZnVuY3Rpb24gY291bnRDaGlsZHJlbihjaGlsZHJlbikge1xuICByZXR1cm4gdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9LCBudWxsKTtcbn1cbi8qKlxuICogRmxhdHRlbiBhIGNoaWxkcmVuIG9iamVjdCAodHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gKSBhbmRcbiAqIHJldHVybiBhbiBhcnJheSB3aXRoIGFwcHJvcHJpYXRlbHkgcmUta2V5ZWQgY2hpbGRyZW4uXG4gKlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdGNoaWxkcmVudG9hcnJheVxuICovXG5cblxuZnVuY3Rpb24gdG9BcnJheShjaGlsZHJlbikge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIG1hcEludG9XaXRoS2V5UHJlZml4SW50ZXJuYWwoY2hpbGRyZW4sIHJlc3VsdCwgbnVsbCwgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgcmV0dXJuIGNoaWxkO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgZmlyc3QgY2hpbGQgaW4gYSBjb2xsZWN0aW9uIG9mIGNoaWxkcmVuIGFuZCB2ZXJpZmllcyB0aGF0IHRoZXJlXG4gKiBpcyBvbmx5IG9uZSBjaGlsZCBpbiB0aGUgY29sbGVjdGlvbi5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI3JlYWN0Y2hpbGRyZW5vbmx5XG4gKlxuICogVGhlIGN1cnJlbnQgaW1wbGVtZW50YXRpb24gb2YgdGhpcyBmdW5jdGlvbiBhc3N1bWVzIHRoYXQgYSBzaW5nbGUgY2hpbGQgZ2V0c1xuICogcGFzc2VkIHdpdGhvdXQgYSB3cmFwcGVyLCBidXQgdGhlIHB1cnBvc2Ugb2YgdGhpcyBoZWxwZXIgZnVuY3Rpb24gaXMgdG9cbiAqIGFic3RyYWN0IGF3YXkgdGhlIHBhcnRpY3VsYXIgc3RydWN0dXJlIG9mIGNoaWxkcmVuLlxuICpcbiAqIEBwYXJhbSB7P29iamVjdH0gY2hpbGRyZW4gQ2hpbGQgY29sbGVjdGlvbiBzdHJ1Y3R1cmUuXG4gKiBAcmV0dXJuIHtSZWFjdEVsZW1lbnR9IFRoZSBmaXJzdCBhbmQgb25seSBgUmVhY3RFbGVtZW50YCBjb250YWluZWQgaW4gdGhlXG4gKiBzdHJ1Y3R1cmUuXG4gKi9cblxuXG5mdW5jdGlvbiBvbmx5Q2hpbGQoY2hpbGRyZW4pIHtcbiAgaWYgKCFpc1ZhbGlkRWxlbWVudChjaGlsZHJlbikpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJSZWFjdC5DaGlsZHJlbi5vbmx5IGV4cGVjdGVkIHRvIHJlY2VpdmUgYSBzaW5nbGUgUmVhY3QgZWxlbWVudCBjaGlsZC5cIiApO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjaGlsZHJlbjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29udGV4dChkZWZhdWx0VmFsdWUsIGNhbGN1bGF0ZUNoYW5nZWRCaXRzKSB7XG4gIGlmIChjYWxjdWxhdGVDaGFuZ2VkQml0cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgY2FsY3VsYXRlQ2hhbmdlZEJpdHMgPSBudWxsO1xuICB9IGVsc2Uge1xuICAgIHtcbiAgICAgIGlmIChjYWxjdWxhdGVDaGFuZ2VkQml0cyAhPT0gbnVsbCAmJiB0eXBlb2YgY2FsY3VsYXRlQ2hhbmdlZEJpdHMgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZXJyb3IoJ2NyZWF0ZUNvbnRleHQ6IEV4cGVjdGVkIHRoZSBvcHRpb25hbCBzZWNvbmQgYXJndW1lbnQgdG8gYmUgYSAnICsgJ2Z1bmN0aW9uLiBJbnN0ZWFkIHJlY2VpdmVkOiAlcycsIGNhbGN1bGF0ZUNoYW5nZWRCaXRzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgY29udGV4dCA9IHtcbiAgICAkJHR5cGVvZjogUkVBQ1RfQ09OVEVYVF9UWVBFLFxuICAgIF9jYWxjdWxhdGVDaGFuZ2VkQml0czogY2FsY3VsYXRlQ2hhbmdlZEJpdHMsXG4gICAgLy8gQXMgYSB3b3JrYXJvdW5kIHRvIHN1cHBvcnQgbXVsdGlwbGUgY29uY3VycmVudCByZW5kZXJlcnMsIHdlIGNhdGVnb3JpemVcbiAgICAvLyBzb21lIHJlbmRlcmVycyBhcyBwcmltYXJ5IGFuZCBvdGhlcnMgYXMgc2Vjb25kYXJ5LiBXZSBvbmx5IGV4cGVjdFxuICAgIC8vIHRoZXJlIHRvIGJlIHR3byBjb25jdXJyZW50IHJlbmRlcmVycyBhdCBtb3N0OiBSZWFjdCBOYXRpdmUgKHByaW1hcnkpIGFuZFxuICAgIC8vIEZhYnJpYyAoc2Vjb25kYXJ5KTsgUmVhY3QgRE9NIChwcmltYXJ5KSBhbmQgUmVhY3QgQVJUIChzZWNvbmRhcnkpLlxuICAgIC8vIFNlY29uZGFyeSByZW5kZXJlcnMgc3RvcmUgdGhlaXIgY29udGV4dCB2YWx1ZXMgb24gc2VwYXJhdGUgZmllbGRzLlxuICAgIF9jdXJyZW50VmFsdWU6IGRlZmF1bHRWYWx1ZSxcbiAgICBfY3VycmVudFZhbHVlMjogZGVmYXVsdFZhbHVlLFxuICAgIC8vIFVzZWQgdG8gdHJhY2sgaG93IG1hbnkgY29uY3VycmVudCByZW5kZXJlcnMgdGhpcyBjb250ZXh0IGN1cnJlbnRseVxuICAgIC8vIHN1cHBvcnRzIHdpdGhpbiBpbiBhIHNpbmdsZSByZW5kZXJlci4gU3VjaCBhcyBwYXJhbGxlbCBzZXJ2ZXIgcmVuZGVyaW5nLlxuICAgIF90aHJlYWRDb3VudDogMCxcbiAgICAvLyBUaGVzZSBhcmUgY2lyY3VsYXJcbiAgICBQcm92aWRlcjogbnVsbCxcbiAgICBDb25zdW1lcjogbnVsbFxuICB9O1xuICBjb250ZXh0LlByb3ZpZGVyID0ge1xuICAgICQkdHlwZW9mOiBSRUFDVF9QUk9WSURFUl9UWVBFLFxuICAgIF9jb250ZXh0OiBjb250ZXh0XG4gIH07XG4gIHZhciBoYXNXYXJuZWRBYm91dFVzaW5nTmVzdGVkQ29udGV4dENvbnN1bWVycyA9IGZhbHNlO1xuICB2YXIgaGFzV2FybmVkQWJvdXRVc2luZ0NvbnN1bWVyUHJvdmlkZXIgPSBmYWxzZTtcblxuICB7XG4gICAgLy8gQSBzZXBhcmF0ZSBvYmplY3QsIGJ1dCBwcm94aWVzIGJhY2sgdG8gdGhlIG9yaWdpbmFsIGNvbnRleHQgb2JqZWN0IGZvclxuICAgIC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LiBJdCBoYXMgYSBkaWZmZXJlbnQgJCR0eXBlb2YsIHNvIHdlIGNhbiBwcm9wZXJseVxuICAgIC8vIHdhcm4gZm9yIHRoZSBpbmNvcnJlY3QgdXNhZ2Ugb2YgQ29udGV4dCBhcyBhIENvbnN1bWVyLlxuICAgIHZhciBDb25zdW1lciA9IHtcbiAgICAgICQkdHlwZW9mOiBSRUFDVF9DT05URVhUX1RZUEUsXG4gICAgICBfY29udGV4dDogY29udGV4dCxcbiAgICAgIF9jYWxjdWxhdGVDaGFuZ2VkQml0czogY29udGV4dC5fY2FsY3VsYXRlQ2hhbmdlZEJpdHNcbiAgICB9OyAvLyAkRmxvd0ZpeE1lOiBGbG93IGNvbXBsYWlucyBhYm91dCBub3Qgc2V0dGluZyBhIHZhbHVlLCB3aGljaCBpcyBpbnRlbnRpb25hbCBoZXJlXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhDb25zdW1lciwge1xuICAgICAgUHJvdmlkZXI6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKCFoYXNXYXJuZWRBYm91dFVzaW5nQ29uc3VtZXJQcm92aWRlcikge1xuICAgICAgICAgICAgaGFzV2FybmVkQWJvdXRVc2luZ0NvbnN1bWVyUHJvdmlkZXIgPSB0cnVlO1xuXG4gICAgICAgICAgICBlcnJvcignUmVuZGVyaW5nIDxDb250ZXh0LkNvbnN1bWVyLlByb3ZpZGVyPiBpcyBub3Qgc3VwcG9ydGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gJyArICdhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiBEaWQgeW91IG1lYW4gdG8gcmVuZGVyIDxDb250ZXh0LlByb3ZpZGVyPiBpbnN0ZWFkPycpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBjb250ZXh0LlByb3ZpZGVyO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChfUHJvdmlkZXIpIHtcbiAgICAgICAgICBjb250ZXh0LlByb3ZpZGVyID0gX1Byb3ZpZGVyO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgX2N1cnJlbnRWYWx1ZToge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gY29udGV4dC5fY3VycmVudFZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChfY3VycmVudFZhbHVlKSB7XG4gICAgICAgICAgY29udGV4dC5fY3VycmVudFZhbHVlID0gX2N1cnJlbnRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIF9jdXJyZW50VmFsdWUyOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBjb250ZXh0Ll9jdXJyZW50VmFsdWUyO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChfY3VycmVudFZhbHVlMikge1xuICAgICAgICAgIGNvbnRleHQuX2N1cnJlbnRWYWx1ZTIgPSBfY3VycmVudFZhbHVlMjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIF90aHJlYWRDb3VudDoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gY29udGV4dC5fdGhyZWFkQ291bnQ7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKF90aHJlYWRDb3VudCkge1xuICAgICAgICAgIGNvbnRleHQuX3RocmVhZENvdW50ID0gX3RocmVhZENvdW50O1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgQ29uc3VtZXI6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKCFoYXNXYXJuZWRBYm91dFVzaW5nTmVzdGVkQ29udGV4dENvbnN1bWVycykge1xuICAgICAgICAgICAgaGFzV2FybmVkQWJvdXRVc2luZ05lc3RlZENvbnRleHRDb25zdW1lcnMgPSB0cnVlO1xuXG4gICAgICAgICAgICBlcnJvcignUmVuZGVyaW5nIDxDb250ZXh0LkNvbnN1bWVyLkNvbnN1bWVyPiBpcyBub3Qgc3VwcG9ydGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gJyArICdhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiBEaWQgeW91IG1lYW4gdG8gcmVuZGVyIDxDb250ZXh0LkNvbnN1bWVyPiBpbnN0ZWFkPycpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBjb250ZXh0LkNvbnN1bWVyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7IC8vICRGbG93Rml4TWU6IEZsb3cgY29tcGxhaW5zIGFib3V0IG1pc3NpbmcgcHJvcGVydGllcyBiZWNhdXNlIGl0IGRvZXNuJ3QgdW5kZXJzdGFuZCBkZWZpbmVQcm9wZXJ0eVxuXG4gICAgY29udGV4dC5Db25zdW1lciA9IENvbnN1bWVyO1xuICB9XG5cbiAge1xuICAgIGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlciA9IG51bGw7XG4gICAgY29udGV4dC5fY3VycmVudFJlbmRlcmVyMiA9IG51bGw7XG4gIH1cblxuICByZXR1cm4gY29udGV4dDtcbn1cblxuZnVuY3Rpb24gbGF6eShjdG9yKSB7XG4gIHZhciBsYXp5VHlwZSA9IHtcbiAgICAkJHR5cGVvZjogUkVBQ1RfTEFaWV9UWVBFLFxuICAgIF9jdG9yOiBjdG9yLFxuICAgIC8vIFJlYWN0IHVzZXMgdGhlc2UgZmllbGRzIHRvIHN0b3JlIHRoZSByZXN1bHQuXG4gICAgX3N0YXR1czogLTEsXG4gICAgX3Jlc3VsdDogbnVsbFxuICB9O1xuXG4gIHtcbiAgICAvLyBJbiBwcm9kdWN0aW9uLCB0aGlzIHdvdWxkIGp1c3Qgc2V0IGl0IG9uIHRoZSBvYmplY3QuXG4gICAgdmFyIGRlZmF1bHRQcm9wcztcbiAgICB2YXIgcHJvcFR5cGVzO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGxhenlUeXBlLCB7XG4gICAgICBkZWZhdWx0UHJvcHM6IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gZGVmYXVsdFByb3BzO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChuZXdEZWZhdWx0UHJvcHMpIHtcbiAgICAgICAgICBlcnJvcignUmVhY3QubGF6eSguLi4pOiBJdCBpcyBub3Qgc3VwcG9ydGVkIHRvIGFzc2lnbiBgZGVmYXVsdFByb3BzYCB0byAnICsgJ2EgbGF6eSBjb21wb25lbnQgaW1wb3J0LiBFaXRoZXIgc3BlY2lmeSB0aGVtIHdoZXJlIHRoZSBjb21wb25lbnQgJyArICdpcyBkZWZpbmVkLCBvciBjcmVhdGUgYSB3cmFwcGluZyBjb21wb25lbnQgYXJvdW5kIGl0LicpO1xuXG4gICAgICAgICAgZGVmYXVsdFByb3BzID0gbmV3RGVmYXVsdFByb3BzOyAvLyBNYXRjaCBwcm9kdWN0aW9uIGJlaGF2aW9yIG1vcmUgY2xvc2VseTpcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShsYXp5VHlwZSwgJ2RlZmF1bHRQcm9wcycsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHByb3BUeXBlczoge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBwcm9wVHlwZXM7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKG5ld1Byb3BUeXBlcykge1xuICAgICAgICAgIGVycm9yKCdSZWFjdC5sYXp5KC4uLik6IEl0IGlzIG5vdCBzdXBwb3J0ZWQgdG8gYXNzaWduIGBwcm9wVHlwZXNgIHRvICcgKyAnYSBsYXp5IGNvbXBvbmVudCBpbXBvcnQuIEVpdGhlciBzcGVjaWZ5IHRoZW0gd2hlcmUgdGhlIGNvbXBvbmVudCAnICsgJ2lzIGRlZmluZWQsIG9yIGNyZWF0ZSBhIHdyYXBwaW5nIGNvbXBvbmVudCBhcm91bmQgaXQuJyk7XG5cbiAgICAgICAgICBwcm9wVHlwZXMgPSBuZXdQcm9wVHlwZXM7IC8vIE1hdGNoIHByb2R1Y3Rpb24gYmVoYXZpb3IgbW9yZSBjbG9zZWx5OlxuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGxhenlUeXBlLCAncHJvcFR5cGVzJywge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gbGF6eVR5cGU7XG59XG5cbmZ1bmN0aW9uIGZvcndhcmRSZWYocmVuZGVyKSB7XG4gIHtcbiAgICBpZiAocmVuZGVyICE9IG51bGwgJiYgcmVuZGVyLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUpIHtcbiAgICAgIGVycm9yKCdmb3J3YXJkUmVmIHJlcXVpcmVzIGEgcmVuZGVyIGZ1bmN0aW9uIGJ1dCByZWNlaXZlZCBhIGBtZW1vYCAnICsgJ2NvbXBvbmVudC4gSW5zdGVhZCBvZiBmb3J3YXJkUmVmKG1lbW8oLi4uKSksIHVzZSAnICsgJ21lbW8oZm9yd2FyZFJlZiguLi4pKS4nKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiByZW5kZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVycm9yKCdmb3J3YXJkUmVmIHJlcXVpcmVzIGEgcmVuZGVyIGZ1bmN0aW9uIGJ1dCB3YXMgZ2l2ZW4gJXMuJywgcmVuZGVyID09PSBudWxsID8gJ251bGwnIDogdHlwZW9mIHJlbmRlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChyZW5kZXIubGVuZ3RoICE9PSAwICYmIHJlbmRlci5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgZXJyb3IoJ2ZvcndhcmRSZWYgcmVuZGVyIGZ1bmN0aW9ucyBhY2NlcHQgZXhhY3RseSB0d28gcGFyYW1ldGVyczogcHJvcHMgYW5kIHJlZi4gJXMnLCByZW5kZXIubGVuZ3RoID09PSAxID8gJ0RpZCB5b3UgZm9yZ2V0IHRvIHVzZSB0aGUgcmVmIHBhcmFtZXRlcj8nIDogJ0FueSBhZGRpdGlvbmFsIHBhcmFtZXRlciB3aWxsIGJlIHVuZGVmaW5lZC4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocmVuZGVyICE9IG51bGwpIHtcbiAgICAgIGlmIChyZW5kZXIuZGVmYXVsdFByb3BzICE9IG51bGwgfHwgcmVuZGVyLnByb3BUeXBlcyAhPSBudWxsKSB7XG4gICAgICAgIGVycm9yKCdmb3J3YXJkUmVmIHJlbmRlciBmdW5jdGlvbnMgZG8gbm90IHN1cHBvcnQgcHJvcFR5cGVzIG9yIGRlZmF1bHRQcm9wcy4gJyArICdEaWQgeW91IGFjY2lkZW50YWxseSBwYXNzIGEgUmVhY3QgY29tcG9uZW50PycpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUsXG4gICAgcmVuZGVyOiByZW5kZXJcbiAgfTtcbn1cblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpIHtcbiAgcmV0dXJuIHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCAvLyBOb3RlOiBpdHMgdHlwZW9mIG1pZ2h0IGJlIG90aGVyIHRoYW4gJ3N5bWJvbCcgb3IgJ251bWJlcicgaWYgaXQncyBhIHBvbHlmaWxsLlxuICB0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZVTkRBTUVOVEFMX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfUkVTUE9OREVSX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfU0NPUEVfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9CTE9DS19UWVBFKTtcbn1cblxuZnVuY3Rpb24gbWVtbyh0eXBlLCBjb21wYXJlKSB7XG4gIHtcbiAgICBpZiAoIWlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKSkge1xuICAgICAgZXJyb3IoJ21lbW86IFRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgY29tcG9uZW50LiBJbnN0ZWFkICcgKyAncmVjZWl2ZWQ6ICVzJywgdHlwZSA9PT0gbnVsbCA/ICdudWxsJyA6IHR5cGVvZiB0eXBlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgICQkdHlwZW9mOiBSRUFDVF9NRU1PX1RZUEUsXG4gICAgdHlwZTogdHlwZSxcbiAgICBjb21wYXJlOiBjb21wYXJlID09PSB1bmRlZmluZWQgPyBudWxsIDogY29tcGFyZVxuICB9O1xufVxuXG5mdW5jdGlvbiByZXNvbHZlRGlzcGF0Y2hlcigpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQ7XG5cbiAgaWYgKCEoZGlzcGF0Y2hlciAhPT0gbnVsbCkpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJJbnZhbGlkIGhvb2sgY2FsbC4gSG9va3MgY2FuIG9ubHkgYmUgY2FsbGVkIGluc2lkZSBvZiB0aGUgYm9keSBvZiBhIGZ1bmN0aW9uIGNvbXBvbmVudC4gVGhpcyBjb3VsZCBoYXBwZW4gZm9yIG9uZSBvZiB0aGUgZm9sbG93aW5nIHJlYXNvbnM6XFxuMS4gWW91IG1pZ2h0IGhhdmUgbWlzbWF0Y2hpbmcgdmVyc2lvbnMgb2YgUmVhY3QgYW5kIHRoZSByZW5kZXJlciAoc3VjaCBhcyBSZWFjdCBET00pXFxuMi4gWW91IG1pZ2h0IGJlIGJyZWFraW5nIHRoZSBSdWxlcyBvZiBIb29rc1xcbjMuIFlvdSBtaWdodCBoYXZlIG1vcmUgdGhhbiBvbmUgY29weSBvZiBSZWFjdCBpbiB0aGUgc2FtZSBhcHBcXG5TZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC1pbnZhbGlkLWhvb2stY2FsbCBmb3IgdGlwcyBhYm91dCBob3cgdG8gZGVidWcgYW5kIGZpeCB0aGlzIHByb2JsZW0uXCIgKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZGlzcGF0Y2hlcjtcbn1cblxuZnVuY3Rpb24gdXNlQ29udGV4dChDb250ZXh0LCB1bnN0YWJsZV9vYnNlcnZlZEJpdHMpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuXG4gIHtcbiAgICBpZiAodW5zdGFibGVfb2JzZXJ2ZWRCaXRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGVycm9yKCd1c2VDb250ZXh0KCkgc2Vjb25kIGFyZ3VtZW50IGlzIHJlc2VydmVkIGZvciBmdXR1cmUgJyArICd1c2UgaW4gUmVhY3QuIFBhc3NpbmcgaXQgaXMgbm90IHN1cHBvcnRlZC4gJyArICdZb3UgcGFzc2VkOiAlcy4lcycsIHVuc3RhYmxlX29ic2VydmVkQml0cywgdHlwZW9mIHVuc3RhYmxlX29ic2VydmVkQml0cyA9PT0gJ251bWJlcicgJiYgQXJyYXkuaXNBcnJheShhcmd1bWVudHNbMl0pID8gJ1xcblxcbkRpZCB5b3UgY2FsbCBhcnJheS5tYXAodXNlQ29udGV4dCk/ICcgKyAnQ2FsbGluZyBIb29rcyBpbnNpZGUgYSBsb29wIGlzIG5vdCBzdXBwb3J0ZWQuICcgKyAnTGVhcm4gbW9yZSBhdCBodHRwczovL2ZiLm1lL3J1bGVzLW9mLWhvb2tzJyA6ICcnKTtcbiAgICB9IC8vIFRPRE86IGFkZCBhIG1vcmUgZ2VuZXJpYyB3YXJuaW5nIGZvciBpbnZhbGlkIHZhbHVlcy5cblxuXG4gICAgaWYgKENvbnRleHQuX2NvbnRleHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIHJlYWxDb250ZXh0ID0gQ29udGV4dC5fY29udGV4dDsgLy8gRG9uJ3QgZGVkdXBsaWNhdGUgYmVjYXVzZSB0aGlzIGxlZ2l0aW1hdGVseSBjYXVzZXMgYnVnc1xuICAgICAgLy8gYW5kIG5vYm9keSBzaG91bGQgYmUgdXNpbmcgdGhpcyBpbiBleGlzdGluZyBjb2RlLlxuXG4gICAgICBpZiAocmVhbENvbnRleHQuQ29uc3VtZXIgPT09IENvbnRleHQpIHtcbiAgICAgICAgZXJyb3IoJ0NhbGxpbmcgdXNlQ29udGV4dChDb250ZXh0LkNvbnN1bWVyKSBpcyBub3Qgc3VwcG9ydGVkLCBtYXkgY2F1c2UgYnVncywgYW5kIHdpbGwgYmUgJyArICdyZW1vdmVkIGluIGEgZnV0dXJlIG1ham9yIHJlbGVhc2UuIERpZCB5b3UgbWVhbiB0byBjYWxsIHVzZUNvbnRleHQoQ29udGV4dCkgaW5zdGVhZD8nKTtcbiAgICAgIH0gZWxzZSBpZiAocmVhbENvbnRleHQuUHJvdmlkZXIgPT09IENvbnRleHQpIHtcbiAgICAgICAgZXJyb3IoJ0NhbGxpbmcgdXNlQ29udGV4dChDb250ZXh0LlByb3ZpZGVyKSBpcyBub3Qgc3VwcG9ydGVkLiAnICsgJ0RpZCB5b3UgbWVhbiB0byBjYWxsIHVzZUNvbnRleHQoQ29udGV4dCkgaW5zdGVhZD8nKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gZGlzcGF0Y2hlci51c2VDb250ZXh0KENvbnRleHQsIHVuc3RhYmxlX29ic2VydmVkQml0cyk7XG59XG5mdW5jdGlvbiB1c2VTdGF0ZShpbml0aWFsU3RhdGUpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VTdGF0ZShpbml0aWFsU3RhdGUpO1xufVxuZnVuY3Rpb24gdXNlUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KTtcbn1cbmZ1bmN0aW9uIHVzZVJlZihpbml0aWFsVmFsdWUpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VSZWYoaW5pdGlhbFZhbHVlKTtcbn1cbmZ1bmN0aW9uIHVzZUVmZmVjdChjcmVhdGUsIGRlcHMpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbn1cbmZ1bmN0aW9uIHVzZUxheW91dEVmZmVjdChjcmVhdGUsIGRlcHMpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VMYXlvdXRFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbn1cbmZ1bmN0aW9uIHVzZUNhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlQ2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpO1xufVxuZnVuY3Rpb24gdXNlTWVtbyhjcmVhdGUsIGRlcHMpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VNZW1vKGNyZWF0ZSwgZGVwcyk7XG59XG5mdW5jdGlvbiB1c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYsIGNyZWF0ZSwgZGVwcyk7XG59XG5mdW5jdGlvbiB1c2VEZWJ1Z1ZhbHVlKHZhbHVlLCBmb3JtYXR0ZXJGbikge1xuICB7XG4gICAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICAgIHJldHVybiBkaXNwYXRjaGVyLnVzZURlYnVnVmFsdWUodmFsdWUsIGZvcm1hdHRlckZuKTtcbiAgfVxufVxuXG52YXIgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd247XG5cbntcbiAgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24gPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCkge1xuICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnR5cGUpO1xuXG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIHJldHVybiAnXFxuXFxuQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBuYW1lICsgJ2AuJztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG5cbmZ1bmN0aW9uIGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtKHNvdXJjZSkge1xuICBpZiAoc291cmNlICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgZmlsZU5hbWUgPSBzb3VyY2UuZmlsZU5hbWUucmVwbGFjZSgvXi4qW1xcXFxcXC9dLywgJycpO1xuICAgIHZhciBsaW5lTnVtYmVyID0gc291cmNlLmxpbmVOdW1iZXI7XG4gICAgcmV0dXJuICdcXG5cXG5DaGVjayB5b3VyIGNvZGUgYXQgJyArIGZpbGVOYW1lICsgJzonICsgbGluZU51bWJlciArICcuJztcbiAgfVxuXG4gIHJldHVybiAnJztcbn1cblxuZnVuY3Rpb24gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW1Gb3JQcm9wcyhlbGVtZW50UHJvcHMpIHtcbiAgaWYgKGVsZW1lbnRQcm9wcyAhPT0gbnVsbCAmJiBlbGVtZW50UHJvcHMgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShlbGVtZW50UHJvcHMuX19zb3VyY2UpO1xuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuLyoqXG4gKiBXYXJuIGlmIHRoZXJlJ3Mgbm8ga2V5IGV4cGxpY2l0bHkgc2V0IG9uIGR5bmFtaWMgYXJyYXlzIG9mIGNoaWxkcmVuIG9yXG4gKiBvYmplY3Qga2V5cyBhcmUgbm90IHZhbGlkLiBUaGlzIGFsbG93cyB1cyB0byBrZWVwIHRyYWNrIG9mIGNoaWxkcmVuIGJldHdlZW5cbiAqIHVwZGF0ZXMuXG4gKi9cblxuXG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSkge1xuICB2YXIgaW5mbyA9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpO1xuXG4gIGlmICghaW5mbykge1xuICAgIHZhciBwYXJlbnROYW1lID0gdHlwZW9mIHBhcmVudFR5cGUgPT09ICdzdHJpbmcnID8gcGFyZW50VHlwZSA6IHBhcmVudFR5cGUuZGlzcGxheU5hbWUgfHwgcGFyZW50VHlwZS5uYW1lO1xuXG4gICAgaWYgKHBhcmVudE5hbWUpIHtcbiAgICAgIGluZm8gPSBcIlxcblxcbkNoZWNrIHRoZSB0b3AtbGV2ZWwgcmVuZGVyIGNhbGwgdXNpbmcgPFwiICsgcGFyZW50TmFtZSArIFwiPi5cIjtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaW5mbztcbn1cbi8qKlxuICogV2FybiBpZiB0aGUgZWxlbWVudCBkb2Vzbid0IGhhdmUgYW4gZXhwbGljaXQga2V5IGFzc2lnbmVkIHRvIGl0LlxuICogVGhpcyBlbGVtZW50IGlzIGluIGFuIGFycmF5LiBUaGUgYXJyYXkgY291bGQgZ3JvdyBhbmQgc2hyaW5rIG9yIGJlXG4gKiByZW9yZGVyZWQuIEFsbCBjaGlsZHJlbiB0aGF0IGhhdmVuJ3QgYWxyZWFkeSBiZWVuIHZhbGlkYXRlZCBhcmUgcmVxdWlyZWQgdG9cbiAqIGhhdmUgYSBcImtleVwiIHByb3BlcnR5IGFzc2lnbmVkIHRvIGl0LiBFcnJvciBzdGF0dXNlcyBhcmUgY2FjaGVkIHNvIGEgd2FybmluZ1xuICogd2lsbCBvbmx5IGJlIHNob3duIG9uY2UuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRoYXQgcmVxdWlyZXMgYSBrZXkuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgZWxlbWVudCdzIHBhcmVudCdzIHR5cGUuXG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUV4cGxpY2l0S2V5KGVsZW1lbnQsIHBhcmVudFR5cGUpIHtcbiAgaWYgKCFlbGVtZW50Ll9zdG9yZSB8fCBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gIHZhciBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvID0gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKTtcblxuICBpZiAob3duZXJIYXNLZXlVc2VXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgb3duZXJIYXNLZXlVc2VXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dID0gdHJ1ZTsgLy8gVXN1YWxseSB0aGUgY3VycmVudCBvd25lciBpcyB0aGUgb2ZmZW5kZXIsIGJ1dCBpZiBpdCBhY2NlcHRzIGNoaWxkcmVuIGFzIGFcbiAgLy8gcHJvcGVydHksIGl0IG1heSBiZSB0aGUgY3JlYXRvciBvZiB0aGUgY2hpbGQgdGhhdCdzIHJlc3BvbnNpYmxlIGZvclxuICAvLyBhc3NpZ25pbmcgaXQgYSBrZXkuXG5cbiAgdmFyIGNoaWxkT3duZXIgPSAnJztcblxuICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgIC8vIEdpdmUgdGhlIGNvbXBvbmVudCB0aGF0IG9yaWdpbmFsbHkgY3JlYXRlZCB0aGlzIGNoaWxkLlxuICAgIGNoaWxkT3duZXIgPSBcIiBJdCB3YXMgcGFzc2VkIGEgY2hpbGQgZnJvbSBcIiArIGdldENvbXBvbmVudE5hbWUoZWxlbWVudC5fb3duZXIudHlwZSkgKyBcIi5cIjtcbiAgfVxuXG4gIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpO1xuXG4gIHtcbiAgICBlcnJvcignRWFjaCBjaGlsZCBpbiBhIGxpc3Qgc2hvdWxkIGhhdmUgYSB1bmlxdWUgXCJrZXlcIiBwcm9wLicgKyAnJXMlcyBTZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC13YXJuaW5nLWtleXMgZm9yIG1vcmUgaW5mb3JtYXRpb24uJywgY3VycmVudENvbXBvbmVudEVycm9ySW5mbywgY2hpbGRPd25lcik7XG4gIH1cblxuICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgZXZlcnkgZWxlbWVudCBlaXRoZXIgaXMgcGFzc2VkIGluIGEgc3RhdGljIGxvY2F0aW9uLCBpbiBhblxuICogYXJyYXkgd2l0aCBhbiBleHBsaWNpdCBrZXlzIHByb3BlcnR5IGRlZmluZWQsIG9yIGluIGFuIG9iamVjdCBsaXRlcmFsXG4gKiB3aXRoIHZhbGlkIGtleSBwcm9wZXJ0eS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3ROb2RlfSBub2RlIFN0YXRpY2FsbHkgcGFzc2VkIGNoaWxkIG9mIGFueSB0eXBlLlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIG5vZGUncyBwYXJlbnQncyB0eXBlLlxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVDaGlsZEtleXMobm9kZSwgcGFyZW50VHlwZSkge1xuICBpZiAodHlwZW9mIG5vZGUgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkobm9kZSkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGlsZCA9IG5vZGVbaV07XG5cbiAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChjaGlsZCkpIHtcbiAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShjaGlsZCwgcGFyZW50VHlwZSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzVmFsaWRFbGVtZW50KG5vZGUpKSB7XG4gICAgLy8gVGhpcyBlbGVtZW50IHdhcyBwYXNzZWQgaW4gYSB2YWxpZCBsb2NhdGlvbi5cbiAgICBpZiAobm9kZS5fc3RvcmUpIHtcbiAgICAgIG5vZGUuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgfVxuICB9IGVsc2UgaWYgKG5vZGUpIHtcbiAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obm9kZSk7XG5cbiAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIEVudHJ5IGl0ZXJhdG9ycyB1c2VkIHRvIHByb3ZpZGUgaW1wbGljaXQga2V5cyxcbiAgICAgIC8vIGJ1dCBub3cgd2UgcHJpbnQgYSBzZXBhcmF0ZSB3YXJuaW5nIGZvciB0aGVtIGxhdGVyLlxuICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IG5vZGUuZW50cmllcykge1xuICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobm9kZSk7XG4gICAgICAgIHZhciBzdGVwO1xuXG4gICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICBpZiAoaXNWYWxpZEVsZW1lbnQoc3RlcC52YWx1ZSkpIHtcbiAgICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoc3RlcC52YWx1ZSwgcGFyZW50VHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEdpdmVuIGFuIGVsZW1lbnQsIHZhbGlkYXRlIHRoYXQgaXRzIHByb3BzIGZvbGxvdyB0aGUgcHJvcFR5cGVzIGRlZmluaXRpb24sXG4gKiBwcm92aWRlZCBieSB0aGUgdHlwZS5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudFxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCkge1xuICB7XG4gICAgdmFyIHR5cGUgPSBlbGVtZW50LnR5cGU7XG5cbiAgICBpZiAodHlwZSA9PT0gbnVsbCB8fCB0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKHR5cGUpO1xuICAgIHZhciBwcm9wVHlwZXM7XG5cbiAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IC8vIE5vdGU6IE1lbW8gb25seSBjaGVja3Mgb3V0ZXIgcHJvcHMgaGVyZS5cbiAgICAvLyBJbm5lciBwcm9wcyBhcmUgY2hlY2tlZCBpbiB0aGUgcmVjb25jaWxlci5cbiAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUpKSB7XG4gICAgICBwcm9wVHlwZXMgPSB0eXBlLnByb3BUeXBlcztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChwcm9wVHlwZXMpIHtcbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgY2hlY2tQcm9wVHlwZXMocHJvcFR5cGVzLCBlbGVtZW50LnByb3BzLCAncHJvcCcsIG5hbWUsIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSk7XG4gICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICB9IGVsc2UgaWYgKHR5cGUuUHJvcFR5cGVzICE9PSB1bmRlZmluZWQgJiYgIXByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duKSB7XG4gICAgICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IHRydWU7XG5cbiAgICAgIGVycm9yKCdDb21wb25lbnQgJXMgZGVjbGFyZWQgYFByb3BUeXBlc2AgaW5zdGVhZCBvZiBgcHJvcFR5cGVzYC4gRGlkIHlvdSBtaXNzcGVsbCB0aGUgcHJvcGVydHkgYXNzaWdubWVudD8nLCBuYW1lIHx8ICdVbmtub3duJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB0eXBlLmdldERlZmF1bHRQcm9wcyA9PT0gJ2Z1bmN0aW9uJyAmJiAhdHlwZS5nZXREZWZhdWx0UHJvcHMuaXNSZWFjdENsYXNzQXBwcm92ZWQpIHtcbiAgICAgIGVycm9yKCdnZXREZWZhdWx0UHJvcHMgaXMgb25seSB1c2VkIG9uIGNsYXNzaWMgUmVhY3QuY3JlYXRlQ2xhc3MgJyArICdkZWZpbml0aW9ucy4gVXNlIGEgc3RhdGljIHByb3BlcnR5IG5hbWVkIGBkZWZhdWx0UHJvcHNgIGluc3RlYWQuJyk7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEdpdmVuIGEgZnJhZ21lbnQsIHZhbGlkYXRlIHRoYXQgaXQgY2FuIG9ubHkgYmUgcHJvdmlkZWQgd2l0aCBmcmFnbWVudCBwcm9wc1xuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGZyYWdtZW50XG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZnJhZ21lbnQpIHtcbiAge1xuICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGZyYWdtZW50KTtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGZyYWdtZW50LnByb3BzKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG5cbiAgICAgIGlmIChrZXkgIT09ICdjaGlsZHJlbicgJiYga2V5ICE9PSAna2V5Jykge1xuICAgICAgICBlcnJvcignSW52YWxpZCBwcm9wIGAlc2Agc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4gJyArICdSZWFjdC5GcmFnbWVudCBjYW4gb25seSBoYXZlIGBrZXlgIGFuZCBgY2hpbGRyZW5gIHByb3BzLicsIGtleSk7XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGZyYWdtZW50LnJlZiAhPT0gbnVsbCkge1xuICAgICAgZXJyb3IoJ0ludmFsaWQgYXR0cmlidXRlIGByZWZgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuJyk7XG4gICAgfVxuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRXaXRoVmFsaWRhdGlvbih0eXBlLCBwcm9wcywgY2hpbGRyZW4pIHtcbiAgdmFyIHZhbGlkVHlwZSA9IGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKTsgLy8gV2Ugd2FybiBpbiB0aGlzIGNhc2UgYnV0IGRvbid0IHRocm93LiBXZSBleHBlY3QgdGhlIGVsZW1lbnQgY3JlYXRpb24gdG9cbiAgLy8gc3VjY2VlZCBhbmQgdGhlcmUgd2lsbCBsaWtlbHkgYmUgZXJyb3JzIGluIHJlbmRlci5cblxuICBpZiAoIXZhbGlkVHlwZSkge1xuICAgIHZhciBpbmZvID0gJyc7XG5cbiAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsICYmIE9iamVjdC5rZXlzKHR5cGUpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgaW5mbyArPSAnIFlvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBmcm9tIHRoZSBmaWxlICcgKyBcIml0J3MgZGVmaW5lZCBpbiwgb3IgeW91IG1pZ2h0IGhhdmUgbWl4ZWQgdXAgZGVmYXVsdCBhbmQgbmFtZWQgaW1wb3J0cy5cIjtcbiAgICB9XG5cbiAgICB2YXIgc291cmNlSW5mbyA9IGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtRm9yUHJvcHMocHJvcHMpO1xuXG4gICAgaWYgKHNvdXJjZUluZm8pIHtcbiAgICAgIGluZm8gKz0gc291cmNlSW5mbztcbiAgICB9IGVsc2Uge1xuICAgICAgaW5mbyArPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcbiAgICB9XG5cbiAgICB2YXIgdHlwZVN0cmluZztcblxuICAgIGlmICh0eXBlID09PSBudWxsKSB7XG4gICAgICB0eXBlU3RyaW5nID0gJ251bGwnO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh0eXBlKSkge1xuICAgICAgdHlwZVN0cmluZyA9ICdhcnJheSc7XG4gICAgfSBlbHNlIGlmICh0eXBlICE9PSB1bmRlZmluZWQgJiYgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFKSB7XG4gICAgICB0eXBlU3RyaW5nID0gXCI8XCIgKyAoZ2V0Q29tcG9uZW50TmFtZSh0eXBlLnR5cGUpIHx8ICdVbmtub3duJykgKyBcIiAvPlwiO1xuICAgICAgaW5mbyA9ICcgRGlkIHlvdSBhY2NpZGVudGFsbHkgZXhwb3J0IGEgSlNYIGxpdGVyYWwgaW5zdGVhZCBvZiBhIGNvbXBvbmVudD8nO1xuICAgIH0gZWxzZSB7XG4gICAgICB0eXBlU3RyaW5nID0gdHlwZW9mIHR5cGU7XG4gICAgfVxuXG4gICAge1xuICAgICAgZXJyb3IoJ1JlYWN0LmNyZWF0ZUVsZW1lbnQ6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yICcgKyAnYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSAnICsgJ2NvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJywgdHlwZVN0cmluZywgaW5mbyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGVsZW1lbnQgPSBjcmVhdGVFbGVtZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IC8vIFRoZSByZXN1bHQgY2FuIGJlIG51bGxpc2ggaWYgYSBtb2NrIG9yIGEgY3VzdG9tIGZ1bmN0aW9uIGlzIHVzZWQuXG4gIC8vIFRPRE86IERyb3AgdGhpcyB3aGVuIHRoZXNlIGFyZSBubyBsb25nZXIgYWxsb3dlZCBhcyB0aGUgdHlwZSBhcmd1bWVudC5cblxuICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH0gLy8gU2tpcCBrZXkgd2FybmluZyBpZiB0aGUgdHlwZSBpc24ndCB2YWxpZCBzaW5jZSBvdXIga2V5IHZhbGlkYXRpb24gbG9naWNcbiAgLy8gZG9lc24ndCBleHBlY3QgYSBub24tc3RyaW5nL2Z1bmN0aW9uIHR5cGUgYW5kIGNhbiB0aHJvdyBjb25mdXNpbmcgZXJyb3JzLlxuICAvLyBXZSBkb24ndCB3YW50IGV4Y2VwdGlvbiBiZWhhdmlvciB0byBkaWZmZXIgYmV0d2VlbiBkZXYgYW5kIHByb2QuXG4gIC8vIChSZW5kZXJpbmcgd2lsbCB0aHJvdyB3aXRoIGEgaGVscGZ1bCBtZXNzYWdlIGFuZCBhcyBzb29uIGFzIHRoZSB0eXBlIGlzXG4gIC8vIGZpeGVkLCB0aGUga2V5IHdhcm5pbmdzIHdpbGwgYXBwZWFyLilcblxuXG4gIGlmICh2YWxpZFR5cGUpIHtcbiAgICBmb3IgKHZhciBpID0gMjsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFsaWRhdGVDaGlsZEtleXMoYXJndW1lbnRzW2ldLCB0eXBlKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkge1xuICAgIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhlbGVtZW50KTtcbiAgfSBlbHNlIHtcbiAgICB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KTtcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50O1xufVxudmFyIGRpZFdhcm5BYm91dERlcHJlY2F0ZWRDcmVhdGVGYWN0b3J5ID0gZmFsc2U7XG5mdW5jdGlvbiBjcmVhdGVGYWN0b3J5V2l0aFZhbGlkYXRpb24odHlwZSkge1xuICB2YXIgdmFsaWRhdGVkRmFjdG9yeSA9IGNyZWF0ZUVsZW1lbnRXaXRoVmFsaWRhdGlvbi5iaW5kKG51bGwsIHR5cGUpO1xuICB2YWxpZGF0ZWRGYWN0b3J5LnR5cGUgPSB0eXBlO1xuXG4gIHtcbiAgICBpZiAoIWRpZFdhcm5BYm91dERlcHJlY2F0ZWRDcmVhdGVGYWN0b3J5KSB7XG4gICAgICBkaWRXYXJuQWJvdXREZXByZWNhdGVkQ3JlYXRlRmFjdG9yeSA9IHRydWU7XG5cbiAgICAgIHdhcm4oJ1JlYWN0LmNyZWF0ZUZhY3RvcnkoKSBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gJyArICdhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiBDb25zaWRlciB1c2luZyBKU1ggJyArICdvciB1c2UgUmVhY3QuY3JlYXRlRWxlbWVudCgpIGRpcmVjdGx5IGluc3RlYWQuJyk7XG4gICAgfSAvLyBMZWdhY3kgaG9vazogcmVtb3ZlIGl0XG5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2YWxpZGF0ZWRGYWN0b3J5LCAndHlwZScsIHtcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHdhcm4oJ0ZhY3RvcnkudHlwZSBpcyBkZXByZWNhdGVkLiBBY2Nlc3MgdGhlIGNsYXNzIGRpcmVjdGx5ICcgKyAnYmVmb3JlIHBhc3NpbmcgaXQgdG8gY3JlYXRlRmFjdG9yeS4nKTtcblxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3R5cGUnLCB7XG4gICAgICAgICAgdmFsdWU6IHR5cGVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHZhbGlkYXRlZEZhY3Rvcnk7XG59XG5mdW5jdGlvbiBjbG9uZUVsZW1lbnRXaXRoVmFsaWRhdGlvbihlbGVtZW50LCBwcm9wcywgY2hpbGRyZW4pIHtcbiAgdmFyIG5ld0VsZW1lbnQgPSBjbG9uZUVsZW1lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICBmb3IgKHZhciBpID0gMjsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGFyZ3VtZW50c1tpXSwgbmV3RWxlbWVudC50eXBlKTtcbiAgfVxuXG4gIHZhbGlkYXRlUHJvcFR5cGVzKG5ld0VsZW1lbnQpO1xuICByZXR1cm4gbmV3RWxlbWVudDtcbn1cblxue1xuXG4gIHRyeSB7XG4gICAgdmFyIGZyb3plbk9iamVjdCA9IE9iamVjdC5mcmVlemUoe30pO1xuICAgIHZhciB0ZXN0TWFwID0gbmV3IE1hcChbW2Zyb3plbk9iamVjdCwgbnVsbF1dKTtcbiAgICB2YXIgdGVzdFNldCA9IG5ldyBTZXQoW2Zyb3plbk9iamVjdF0pOyAvLyBUaGlzIGlzIG5lY2Vzc2FyeSBmb3IgUm9sbHVwIHRvIG5vdCBjb25zaWRlciB0aGVzZSB1bnVzZWQuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3JvbGx1cC9yb2xsdXAvaXNzdWVzLzE3NzFcbiAgICAvLyBUT0RPOiB3ZSBjYW4gcmVtb3ZlIHRoZXNlIGlmIFJvbGx1cCBmaXhlcyB0aGUgYnVnLlxuXG4gICAgdGVzdE1hcC5zZXQoMCwgMCk7XG4gICAgdGVzdFNldC5hZGQoMCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgfVxufVxuXG52YXIgY3JlYXRlRWxlbWVudCQxID0gIGNyZWF0ZUVsZW1lbnRXaXRoVmFsaWRhdGlvbiA7XG52YXIgY2xvbmVFbGVtZW50JDEgPSAgY2xvbmVFbGVtZW50V2l0aFZhbGlkYXRpb24gO1xudmFyIGNyZWF0ZUZhY3RvcnkgPSAgY3JlYXRlRmFjdG9yeVdpdGhWYWxpZGF0aW9uIDtcbnZhciBDaGlsZHJlbiA9IHtcbiAgbWFwOiBtYXBDaGlsZHJlbixcbiAgZm9yRWFjaDogZm9yRWFjaENoaWxkcmVuLFxuICBjb3VudDogY291bnRDaGlsZHJlbixcbiAgdG9BcnJheTogdG9BcnJheSxcbiAgb25seTogb25seUNoaWxkXG59O1xuXG5leHBvcnRzLkNoaWxkcmVuID0gQ2hpbGRyZW47XG5leHBvcnRzLkNvbXBvbmVudCA9IENvbXBvbmVudDtcbmV4cG9ydHMuRnJhZ21lbnQgPSBSRUFDVF9GUkFHTUVOVF9UWVBFO1xuZXhwb3J0cy5Qcm9maWxlciA9IFJFQUNUX1BST0ZJTEVSX1RZUEU7XG5leHBvcnRzLlB1cmVDb21wb25lbnQgPSBQdXJlQ29tcG9uZW50O1xuZXhwb3J0cy5TdHJpY3RNb2RlID0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRTtcbmV4cG9ydHMuU3VzcGVuc2UgPSBSRUFDVF9TVVNQRU5TRV9UWVBFO1xuZXhwb3J0cy5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRCA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzO1xuZXhwb3J0cy5jbG9uZUVsZW1lbnQgPSBjbG9uZUVsZW1lbnQkMTtcbmV4cG9ydHMuY3JlYXRlQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ7XG5leHBvcnRzLmNyZWF0ZUVsZW1lbnQgPSBjcmVhdGVFbGVtZW50JDE7XG5leHBvcnRzLmNyZWF0ZUZhY3RvcnkgPSBjcmVhdGVGYWN0b3J5O1xuZXhwb3J0cy5jcmVhdGVSZWYgPSBjcmVhdGVSZWY7XG5leHBvcnRzLmZvcndhcmRSZWYgPSBmb3J3YXJkUmVmO1xuZXhwb3J0cy5pc1ZhbGlkRWxlbWVudCA9IGlzVmFsaWRFbGVtZW50O1xuZXhwb3J0cy5sYXp5ID0gbGF6eTtcbmV4cG9ydHMubWVtbyA9IG1lbW87XG5leHBvcnRzLnVzZUNhbGxiYWNrID0gdXNlQ2FsbGJhY2s7XG5leHBvcnRzLnVzZUNvbnRleHQgPSB1c2VDb250ZXh0O1xuZXhwb3J0cy51c2VEZWJ1Z1ZhbHVlID0gdXNlRGVidWdWYWx1ZTtcbmV4cG9ydHMudXNlRWZmZWN0ID0gdXNlRWZmZWN0O1xuZXhwb3J0cy51c2VJbXBlcmF0aXZlSGFuZGxlID0gdXNlSW1wZXJhdGl2ZUhhbmRsZTtcbmV4cG9ydHMudXNlTGF5b3V0RWZmZWN0ID0gdXNlTGF5b3V0RWZmZWN0O1xuZXhwb3J0cy51c2VNZW1vID0gdXNlTWVtbztcbmV4cG9ydHMudXNlUmVkdWNlciA9IHVzZVJlZHVjZXI7XG5leHBvcnRzLnVzZVJlZiA9IHVzZVJlZjtcbmV4cG9ydHMudXNlU3RhdGUgPSB1c2VTdGF0ZTtcbmV4cG9ydHMudmVyc2lvbiA9IFJlYWN0VmVyc2lvbjtcbiAgfSkoKTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC5kZXZlbG9wbWVudC5qcycpO1xufVxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG52YXIgcnVudGltZSA9IChmdW5jdGlvbiAoZXhwb3J0cykge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICB2YXIgT3AgPSBPYmplY3QucHJvdG90eXBlO1xuICB2YXIgaGFzT3duID0gT3AuaGFzT3duUHJvcGVydHk7XG4gIHZhciB1bmRlZmluZWQ7IC8vIE1vcmUgY29tcHJlc3NpYmxlIHRoYW4gdm9pZCAwLlxuICB2YXIgJFN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiA/IFN5bWJvbCA6IHt9O1xuICB2YXIgaXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLml0ZXJhdG9yIHx8IFwiQEBpdGVyYXRvclwiO1xuICB2YXIgYXN5bmNJdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuYXN5bmNJdGVyYXRvciB8fCBcIkBAYXN5bmNJdGVyYXRvclwiO1xuICB2YXIgdG9TdHJpbmdUYWdTeW1ib2wgPSAkU3ltYm9sLnRvU3RyaW5nVGFnIHx8IFwiQEB0b1N0cmluZ1RhZ1wiO1xuXG4gIGZ1bmN0aW9uIGRlZmluZShvYmosIGtleSwgdmFsdWUpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBvYmpba2V5XTtcbiAgfVxuICB0cnkge1xuICAgIC8vIElFIDggaGFzIGEgYnJva2VuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSB0aGF0IG9ubHkgd29ya3Mgb24gRE9NIG9iamVjdHMuXG4gICAgZGVmaW5lKHt9LCBcIlwiKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZGVmaW5lID0gZnVuY3Rpb24ob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgICByZXR1cm4gb2JqW2tleV0gPSB2YWx1ZTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIC8vIElmIG91dGVyRm4gcHJvdmlkZWQgYW5kIG91dGVyRm4ucHJvdG90eXBlIGlzIGEgR2VuZXJhdG9yLCB0aGVuIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yLlxuICAgIHZhciBwcm90b0dlbmVyYXRvciA9IG91dGVyRm4gJiYgb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IgPyBvdXRlckZuIDogR2VuZXJhdG9yO1xuICAgIHZhciBnZW5lcmF0b3IgPSBPYmplY3QuY3JlYXRlKHByb3RvR2VuZXJhdG9yLnByb3RvdHlwZSk7XG4gICAgdmFyIGNvbnRleHQgPSBuZXcgQ29udGV4dCh0cnlMb2NzTGlzdCB8fCBbXSk7XG5cbiAgICAvLyBUaGUgLl9pbnZva2UgbWV0aG9kIHVuaWZpZXMgdGhlIGltcGxlbWVudGF0aW9ucyBvZiB0aGUgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzLlxuICAgIGdlbmVyYXRvci5faW52b2tlID0gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcblxuICAgIHJldHVybiBnZW5lcmF0b3I7XG4gIH1cbiAgZXhwb3J0cy53cmFwID0gd3JhcDtcblxuICAvLyBUcnkvY2F0Y2ggaGVscGVyIHRvIG1pbmltaXplIGRlb3B0aW1pemF0aW9ucy4gUmV0dXJucyBhIGNvbXBsZXRpb25cbiAgLy8gcmVjb3JkIGxpa2UgY29udGV4dC50cnlFbnRyaWVzW2ldLmNvbXBsZXRpb24uIFRoaXMgaW50ZXJmYWNlIGNvdWxkXG4gIC8vIGhhdmUgYmVlbiAoYW5kIHdhcyBwcmV2aW91c2x5KSBkZXNpZ25lZCB0byB0YWtlIGEgY2xvc3VyZSB0byBiZVxuICAvLyBpbnZva2VkIHdpdGhvdXQgYXJndW1lbnRzLCBidXQgaW4gYWxsIHRoZSBjYXNlcyB3ZSBjYXJlIGFib3V0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhbiBleGlzdGluZyBtZXRob2Qgd2Ugd2FudCB0byBjYWxsLCBzbyB0aGVyZSdzIG5vIG5lZWRcbiAgLy8gdG8gY3JlYXRlIGEgbmV3IGZ1bmN0aW9uIG9iamVjdC4gV2UgY2FuIGV2ZW4gZ2V0IGF3YXkgd2l0aCBhc3N1bWluZ1xuICAvLyB0aGUgbWV0aG9kIHRha2VzIGV4YWN0bHkgb25lIGFyZ3VtZW50LCBzaW5jZSB0aGF0IGhhcHBlbnMgdG8gYmUgdHJ1ZVxuICAvLyBpbiBldmVyeSBjYXNlLCBzbyB3ZSBkb24ndCBoYXZlIHRvIHRvdWNoIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBUaGVcbiAgLy8gb25seSBhZGRpdGlvbmFsIGFsbG9jYXRpb24gcmVxdWlyZWQgaXMgdGhlIGNvbXBsZXRpb24gcmVjb3JkLCB3aGljaFxuICAvLyBoYXMgYSBzdGFibGUgc2hhcGUgYW5kIHNvIGhvcGVmdWxseSBzaG91bGQgYmUgY2hlYXAgdG8gYWxsb2NhdGUuXG4gIGZ1bmN0aW9uIHRyeUNhdGNoKGZuLCBvYmosIGFyZykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcIm5vcm1hbFwiLCBhcmc6IGZuLmNhbGwob2JqLCBhcmcpIH07XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcInRocm93XCIsIGFyZzogZXJyIH07XG4gICAgfVxuICB9XG5cbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkU3RhcnQgPSBcInN1c3BlbmRlZFN0YXJ0XCI7XG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkID0gXCJzdXNwZW5kZWRZaWVsZFwiO1xuICB2YXIgR2VuU3RhdGVFeGVjdXRpbmcgPSBcImV4ZWN1dGluZ1wiO1xuICB2YXIgR2VuU3RhdGVDb21wbGV0ZWQgPSBcImNvbXBsZXRlZFwiO1xuXG4gIC8vIFJldHVybmluZyB0aGlzIG9iamVjdCBmcm9tIHRoZSBpbm5lckZuIGhhcyB0aGUgc2FtZSBlZmZlY3QgYXNcbiAgLy8gYnJlYWtpbmcgb3V0IG9mIHRoZSBkaXNwYXRjaCBzd2l0Y2ggc3RhdGVtZW50LlxuICB2YXIgQ29udGludWVTZW50aW5lbCA9IHt9O1xuXG4gIC8vIER1bW15IGNvbnN0cnVjdG9yIGZ1bmN0aW9ucyB0aGF0IHdlIHVzZSBhcyB0aGUgLmNvbnN0cnVjdG9yIGFuZFxuICAvLyAuY29uc3RydWN0b3IucHJvdG90eXBlIHByb3BlcnRpZXMgZm9yIGZ1bmN0aW9ucyB0aGF0IHJldHVybiBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0cy4gRm9yIGZ1bGwgc3BlYyBjb21wbGlhbmNlLCB5b3UgbWF5IHdpc2ggdG8gY29uZmlndXJlIHlvdXJcbiAgLy8gbWluaWZpZXIgbm90IHRvIG1hbmdsZSB0aGUgbmFtZXMgb2YgdGhlc2UgdHdvIGZ1bmN0aW9ucy5cbiAgZnVuY3Rpb24gR2VuZXJhdG9yKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb24oKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSgpIHt9XG5cbiAgLy8gVGhpcyBpcyBhIHBvbHlmaWxsIGZvciAlSXRlcmF0b3JQcm90b3R5cGUlIGZvciBlbnZpcm9ubWVudHMgdGhhdFxuICAvLyBkb24ndCBuYXRpdmVseSBzdXBwb3J0IGl0LlxuICB2YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcbiAgSXRlcmF0b3JQcm90b3R5cGVbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbiAgdmFyIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG8gJiYgZ2V0UHJvdG8oZ2V0UHJvdG8odmFsdWVzKFtdKSkpO1xuICBpZiAoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgJiZcbiAgICAgIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICE9PSBPcCAmJlxuICAgICAgaGFzT3duLmNhbGwoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUsIGl0ZXJhdG9yU3ltYm9sKSkge1xuICAgIC8vIFRoaXMgZW52aXJvbm1lbnQgaGFzIGEgbmF0aXZlICVJdGVyYXRvclByb3RvdHlwZSU7IHVzZSBpdCBpbnN0ZWFkXG4gICAgLy8gb2YgdGhlIHBvbHlmaWxsLlxuICAgIEl0ZXJhdG9yUHJvdG90eXBlID0gTmF0aXZlSXRlcmF0b3JQcm90b3R5cGU7XG4gIH1cblxuICB2YXIgR3AgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5wcm90b3R5cGUgPVxuICAgIEdlbmVyYXRvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlKTtcbiAgR2VuZXJhdG9yRnVuY3Rpb24ucHJvdG90eXBlID0gR3AuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvbjtcbiAgR2VuZXJhdG9yRnVuY3Rpb24uZGlzcGxheU5hbWUgPSBkZWZpbmUoXG4gICAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsXG4gICAgdG9TdHJpbmdUYWdTeW1ib2wsXG4gICAgXCJHZW5lcmF0b3JGdW5jdGlvblwiXG4gICk7XG5cbiAgLy8gSGVscGVyIGZvciBkZWZpbmluZyB0aGUgLm5leHQsIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcyBvZiB0aGVcbiAgLy8gSXRlcmF0b3IgaW50ZXJmYWNlIGluIHRlcm1zIG9mIGEgc2luZ2xlIC5faW52b2tlIG1ldGhvZC5cbiAgZnVuY3Rpb24gZGVmaW5lSXRlcmF0b3JNZXRob2RzKHByb3RvdHlwZSkge1xuICAgIFtcIm5leHRcIiwgXCJ0aHJvd1wiLCBcInJldHVyblwiXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgZGVmaW5lKHByb3RvdHlwZSwgbWV0aG9kLCBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludm9rZShtZXRob2QsIGFyZyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIHZhciBjdG9yID0gdHlwZW9mIGdlbkZ1biA9PT0gXCJmdW5jdGlvblwiICYmIGdlbkZ1bi5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gY3RvclxuICAgICAgPyBjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fFxuICAgICAgICAvLyBGb3IgdGhlIG5hdGl2ZSBHZW5lcmF0b3JGdW5jdGlvbiBjb25zdHJ1Y3RvciwgdGhlIGJlc3Qgd2UgY2FuXG4gICAgICAgIC8vIGRvIGlzIHRvIGNoZWNrIGl0cyAubmFtZSBwcm9wZXJ0eS5cbiAgICAgICAgKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSA9PT0gXCJHZW5lcmF0b3JGdW5jdGlvblwiXG4gICAgICA6IGZhbHNlO1xuICB9O1xuXG4gIGV4cG9ydHMubWFyayA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIGlmIChPYmplY3Quc2V0UHJvdG90eXBlT2YpIHtcbiAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihnZW5GdW4sIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2VuRnVuLl9fcHJvdG9fXyA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICAgICAgZGVmaW5lKGdlbkZ1biwgdG9TdHJpbmdUYWdTeW1ib2wsIFwiR2VuZXJhdG9yRnVuY3Rpb25cIik7XG4gICAgfVxuICAgIGdlbkZ1bi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEdwKTtcbiAgICByZXR1cm4gZ2VuRnVuO1xuICB9O1xuXG4gIC8vIFdpdGhpbiB0aGUgYm9keSBvZiBhbnkgYXN5bmMgZnVuY3Rpb24sIGBhd2FpdCB4YCBpcyB0cmFuc2Zvcm1lZCB0b1xuICAvLyBgeWllbGQgcmVnZW5lcmF0b3JSdW50aW1lLmF3cmFwKHgpYCwgc28gdGhhdCB0aGUgcnVudGltZSBjYW4gdGVzdFxuICAvLyBgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKWAgdG8gZGV0ZXJtaW5lIGlmIHRoZSB5aWVsZGVkIHZhbHVlIGlzXG4gIC8vIG1lYW50IHRvIGJlIGF3YWl0ZWQuXG4gIGV4cG9ydHMuYXdyYXAgPSBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4geyBfX2F3YWl0OiBhcmcgfTtcbiAgfTtcblxuICBmdW5jdGlvbiBBc3luY0l0ZXJhdG9yKGdlbmVyYXRvciwgUHJvbWlzZUltcGwpIHtcbiAgICBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGdlbmVyYXRvclttZXRob2RdLCBnZW5lcmF0b3IsIGFyZyk7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICByZWplY3QocmVjb3JkLmFyZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmVzdWx0ID0gcmVjb3JkLmFyZztcbiAgICAgICAgdmFyIHZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICBpZiAodmFsdWUgJiZcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKSkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlSW1wbC5yZXNvbHZlKHZhbHVlLl9fYXdhaXQpLnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIGludm9rZShcIm5leHRcIiwgdmFsdWUsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJ0aHJvd1wiLCBlcnIsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUHJvbWlzZUltcGwucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbih1bndyYXBwZWQpIHtcbiAgICAgICAgICAvLyBXaGVuIGEgeWllbGRlZCBQcm9taXNlIGlzIHJlc29sdmVkLCBpdHMgZmluYWwgdmFsdWUgYmVjb21lc1xuICAgICAgICAgIC8vIHRoZSAudmFsdWUgb2YgdGhlIFByb21pc2U8e3ZhbHVlLGRvbmV9PiByZXN1bHQgZm9yIHRoZVxuICAgICAgICAgIC8vIGN1cnJlbnQgaXRlcmF0aW9uLlxuICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IHVud3JhcHBlZDtcbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgLy8gSWYgYSByZWplY3RlZCBQcm9taXNlIHdhcyB5aWVsZGVkLCB0aHJvdyB0aGUgcmVqZWN0aW9uIGJhY2tcbiAgICAgICAgICAvLyBpbnRvIHRoZSBhc3luYyBnZW5lcmF0b3IgZnVuY3Rpb24gc28gaXQgY2FuIGJlIGhhbmRsZWQgdGhlcmUuXG4gICAgICAgICAgcmV0dXJuIGludm9rZShcInRocm93XCIsIGVycm9yLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcHJldmlvdXNQcm9taXNlO1xuXG4gICAgZnVuY3Rpb24gZW5xdWV1ZShtZXRob2QsIGFyZykge1xuICAgICAgZnVuY3Rpb24gY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZUltcGwoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByZXZpb3VzUHJvbWlzZSA9XG4gICAgICAgIC8vIElmIGVucXVldWUgaGFzIGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIHdhaXQgdW50aWxcbiAgICAgICAgLy8gYWxsIHByZXZpb3VzIFByb21pc2VzIGhhdmUgYmVlbiByZXNvbHZlZCBiZWZvcmUgY2FsbGluZyBpbnZva2UsXG4gICAgICAgIC8vIHNvIHRoYXQgcmVzdWx0cyBhcmUgYWx3YXlzIGRlbGl2ZXJlZCBpbiB0aGUgY29ycmVjdCBvcmRlci4gSWZcbiAgICAgICAgLy8gZW5xdWV1ZSBoYXMgbm90IGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiBpdCBpcyBpbXBvcnRhbnQgdG9cbiAgICAgICAgLy8gY2FsbCBpbnZva2UgaW1tZWRpYXRlbHksIHdpdGhvdXQgd2FpdGluZyBvbiBhIGNhbGxiYWNrIHRvIGZpcmUsXG4gICAgICAgIC8vIHNvIHRoYXQgdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBoYXMgdGhlIG9wcG9ydHVuaXR5IHRvIGRvXG4gICAgICAgIC8vIGFueSBuZWNlc3Nhcnkgc2V0dXAgaW4gYSBwcmVkaWN0YWJsZSB3YXkuIFRoaXMgcHJlZGljdGFiaWxpdHlcbiAgICAgICAgLy8gaXMgd2h5IHRoZSBQcm9taXNlIGNvbnN0cnVjdG9yIHN5bmNocm9ub3VzbHkgaW52b2tlcyBpdHNcbiAgICAgICAgLy8gZXhlY3V0b3IgY2FsbGJhY2ssIGFuZCB3aHkgYXN5bmMgZnVuY3Rpb25zIHN5bmNocm9ub3VzbHlcbiAgICAgICAgLy8gZXhlY3V0ZSBjb2RlIGJlZm9yZSB0aGUgZmlyc3QgYXdhaXQuIFNpbmNlIHdlIGltcGxlbWVudCBzaW1wbGVcbiAgICAgICAgLy8gYXN5bmMgZnVuY3Rpb25zIGluIHRlcm1zIG9mIGFzeW5jIGdlbmVyYXRvcnMsIGl0IGlzIGVzcGVjaWFsbHlcbiAgICAgICAgLy8gaW1wb3J0YW50IHRvIGdldCB0aGlzIHJpZ2h0LCBldmVuIHRob3VnaCBpdCByZXF1aXJlcyBjYXJlLlxuICAgICAgICBwcmV2aW91c1Byb21pc2UgPyBwcmV2aW91c1Byb21pc2UudGhlbihcbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZyxcbiAgICAgICAgICAvLyBBdm9pZCBwcm9wYWdhdGluZyBmYWlsdXJlcyB0byBQcm9taXNlcyByZXR1cm5lZCBieSBsYXRlclxuICAgICAgICAgIC8vIGludm9jYXRpb25zIG9mIHRoZSBpdGVyYXRvci5cbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZ1xuICAgICAgICApIDogY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKTtcbiAgICB9XG5cbiAgICAvLyBEZWZpbmUgdGhlIHVuaWZpZWQgaGVscGVyIG1ldGhvZCB0aGF0IGlzIHVzZWQgdG8gaW1wbGVtZW50IC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gKHNlZSBkZWZpbmVJdGVyYXRvck1ldGhvZHMpLlxuICAgIHRoaXMuX2ludm9rZSA9IGVucXVldWU7XG4gIH1cblxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUpO1xuICBBc3luY0l0ZXJhdG9yLnByb3RvdHlwZVthc3luY0l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgZXhwb3J0cy5Bc3luY0l0ZXJhdG9yID0gQXN5bmNJdGVyYXRvcjtcblxuICAvLyBOb3RlIHRoYXQgc2ltcGxlIGFzeW5jIGZ1bmN0aW9ucyBhcmUgaW1wbGVtZW50ZWQgb24gdG9wIG9mXG4gIC8vIEFzeW5jSXRlcmF0b3Igb2JqZWN0czsgdGhleSBqdXN0IHJldHVybiBhIFByb21pc2UgZm9yIHRoZSB2YWx1ZSBvZlxuICAvLyB0aGUgZmluYWwgcmVzdWx0IHByb2R1Y2VkIGJ5IHRoZSBpdGVyYXRvci5cbiAgZXhwb3J0cy5hc3luYyA9IGZ1bmN0aW9uKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0LCBQcm9taXNlSW1wbCkge1xuICAgIGlmIChQcm9taXNlSW1wbCA9PT0gdm9pZCAwKSBQcm9taXNlSW1wbCA9IFByb21pc2U7XG5cbiAgICB2YXIgaXRlciA9IG5ldyBBc3luY0l0ZXJhdG9yKFxuICAgICAgd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCksXG4gICAgICBQcm9taXNlSW1wbFxuICAgICk7XG5cbiAgICByZXR1cm4gZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uKG91dGVyRm4pXG4gICAgICA/IGl0ZXIgLy8gSWYgb3V0ZXJGbiBpcyBhIGdlbmVyYXRvciwgcmV0dXJuIHRoZSBmdWxsIGl0ZXJhdG9yLlxuICAgICAgOiBpdGVyLm5leHQoKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQuZG9uZSA/IHJlc3VsdC52YWx1ZSA6IGl0ZXIubmV4dCgpO1xuICAgICAgICB9KTtcbiAgfTtcblxuICBmdW5jdGlvbiBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpIHtcbiAgICB2YXIgc3RhdGUgPSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZykge1xuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUV4ZWN1dGluZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBydW5uaW5nXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlQ29tcGxldGVkKSB7XG4gICAgICAgIGlmIChtZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHRocm93IGFyZztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJlIGZvcmdpdmluZywgcGVyIDI1LjMuMy4zLjMgb2YgdGhlIHNwZWM6XG4gICAgICAgIC8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1nZW5lcmF0b3JyZXN1bWVcbiAgICAgICAgcmV0dXJuIGRvbmVSZXN1bHQoKTtcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5tZXRob2QgPSBtZXRob2Q7XG4gICAgICBjb250ZXh0LmFyZyA9IGFyZztcblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIGRlbGVnYXRlID0gY29udGV4dC5kZWxlZ2F0ZTtcbiAgICAgICAgaWYgKGRlbGVnYXRlKSB7XG4gICAgICAgICAgdmFyIGRlbGVnYXRlUmVzdWx0ID0gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG4gICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0KSB7XG4gICAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQgPT09IENvbnRpbnVlU2VudGluZWwpIGNvbnRpbnVlO1xuICAgICAgICAgICAgcmV0dXJuIGRlbGVnYXRlUmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgICAvLyBTZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgICAgIGNvbnRleHQuc2VudCA9IGNvbnRleHQuX3NlbnQgPSBjb250ZXh0LmFyZztcblxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQpIHtcbiAgICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgICB0aHJvdyBjb250ZXh0LmFyZztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKTtcblxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInJldHVyblwiKSB7XG4gICAgICAgICAgY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgY29udGV4dC5hcmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUV4ZWN1dGluZztcblxuICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG4gICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIikge1xuICAgICAgICAgIC8vIElmIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gZnJvbSBpbm5lckZuLCB3ZSBsZWF2ZSBzdGF0ZSA9PT1cbiAgICAgICAgICAvLyBHZW5TdGF0ZUV4ZWN1dGluZyBhbmQgbG9vcCBiYWNrIGZvciBhbm90aGVyIGludm9jYXRpb24uXG4gICAgICAgICAgc3RhdGUgPSBjb250ZXh0LmRvbmVcbiAgICAgICAgICAgID8gR2VuU3RhdGVDb21wbGV0ZWRcbiAgICAgICAgICAgIDogR2VuU3RhdGVTdXNwZW5kZWRZaWVsZDtcblxuICAgICAgICAgIGlmIChyZWNvcmQuYXJnID09PSBDb250aW51ZVNlbnRpbmVsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IHJlY29yZC5hcmcsXG4gICAgICAgICAgICBkb25lOiBjb250ZXh0LmRvbmVcbiAgICAgICAgICB9O1xuXG4gICAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgLy8gRGlzcGF0Y2ggdGhlIGV4Y2VwdGlvbiBieSBsb29waW5nIGJhY2sgYXJvdW5kIHRvIHRoZVxuICAgICAgICAgIC8vIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpIGNhbGwgYWJvdmUuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8vIENhbGwgZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdKGNvbnRleHQuYXJnKSBhbmQgaGFuZGxlIHRoZVxuICAvLyByZXN1bHQsIGVpdGhlciBieSByZXR1cm5pbmcgYSB7IHZhbHVlLCBkb25lIH0gcmVzdWx0IGZyb20gdGhlXG4gIC8vIGRlbGVnYXRlIGl0ZXJhdG9yLCBvciBieSBtb2RpZnlpbmcgY29udGV4dC5tZXRob2QgYW5kIGNvbnRleHQuYXJnLFxuICAvLyBzZXR0aW5nIGNvbnRleHQuZGVsZWdhdGUgdG8gbnVsbCwgYW5kIHJldHVybmluZyB0aGUgQ29udGludWVTZW50aW5lbC5cbiAgZnVuY3Rpb24gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCkge1xuICAgIHZhciBtZXRob2QgPSBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF07XG4gICAgaWYgKG1ldGhvZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBBIC50aHJvdyBvciAucmV0dXJuIHdoZW4gdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBubyAudGhyb3dcbiAgICAgIC8vIG1ldGhvZCBhbHdheXMgdGVybWluYXRlcyB0aGUgeWllbGQqIGxvb3AuXG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgLy8gTm90ZTogW1wicmV0dXJuXCJdIG11c3QgYmUgdXNlZCBmb3IgRVMzIHBhcnNpbmcgY29tcGF0aWJpbGl0eS5cbiAgICAgICAgaWYgKGRlbGVnYXRlLml0ZXJhdG9yW1wicmV0dXJuXCJdKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBhIHJldHVybiBtZXRob2QsIGdpdmUgaXQgYVxuICAgICAgICAgIC8vIGNoYW5jZSB0byBjbGVhbiB1cC5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG5cbiAgICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgLy8gSWYgbWF5YmVJbnZva2VEZWxlZ2F0ZShjb250ZXh0KSBjaGFuZ2VkIGNvbnRleHQubWV0aG9kIGZyb21cbiAgICAgICAgICAgIC8vIFwicmV0dXJuXCIgdG8gXCJ0aHJvd1wiLCBsZXQgdGhhdCBvdmVycmlkZSB0aGUgVHlwZUVycm9yIGJlbG93LlxuICAgICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICBcIlRoZSBpdGVyYXRvciBkb2VzIG5vdCBwcm92aWRlIGEgJ3Rocm93JyBtZXRob2RcIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChtZXRob2QsIGRlbGVnYXRlLml0ZXJhdG9yLCBjb250ZXh0LmFyZyk7XG5cbiAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciBpbmZvID0gcmVjb3JkLmFyZztcblxuICAgIGlmICghIGluZm8pIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFwiaXRlcmF0b3IgcmVzdWx0IGlzIG5vdCBhbiBvYmplY3RcIik7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgIC8vIEFzc2lnbiB0aGUgcmVzdWx0IG9mIHRoZSBmaW5pc2hlZCBkZWxlZ2F0ZSB0byB0aGUgdGVtcG9yYXJ5XG4gICAgICAvLyB2YXJpYWJsZSBzcGVjaWZpZWQgYnkgZGVsZWdhdGUucmVzdWx0TmFtZSAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dFtkZWxlZ2F0ZS5yZXN1bHROYW1lXSA9IGluZm8udmFsdWU7XG5cbiAgICAgIC8vIFJlc3VtZSBleGVjdXRpb24gYXQgdGhlIGRlc2lyZWQgbG9jYXRpb24gKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHQubmV4dCA9IGRlbGVnYXRlLm5leHRMb2M7XG5cbiAgICAgIC8vIElmIGNvbnRleHQubWV0aG9kIHdhcyBcInRocm93XCIgYnV0IHRoZSBkZWxlZ2F0ZSBoYW5kbGVkIHRoZVxuICAgICAgLy8gZXhjZXB0aW9uLCBsZXQgdGhlIG91dGVyIGdlbmVyYXRvciBwcm9jZWVkIG5vcm1hbGx5LiBJZlxuICAgICAgLy8gY29udGV4dC5tZXRob2Qgd2FzIFwibmV4dFwiLCBmb3JnZXQgY29udGV4dC5hcmcgc2luY2UgaXQgaGFzIGJlZW5cbiAgICAgIC8vIFwiY29uc3VtZWRcIiBieSB0aGUgZGVsZWdhdGUgaXRlcmF0b3IuIElmIGNvbnRleHQubWV0aG9kIHdhc1xuICAgICAgLy8gXCJyZXR1cm5cIiwgYWxsb3cgdGhlIG9yaWdpbmFsIC5yZXR1cm4gY2FsbCB0byBjb250aW51ZSBpbiB0aGVcbiAgICAgIC8vIG91dGVyIGdlbmVyYXRvci5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCAhPT0gXCJyZXR1cm5cIikge1xuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZS15aWVsZCB0aGUgcmVzdWx0IHJldHVybmVkIGJ5IHRoZSBkZWxlZ2F0ZSBtZXRob2QuXG4gICAgICByZXR1cm4gaW5mbztcbiAgICB9XG5cbiAgICAvLyBUaGUgZGVsZWdhdGUgaXRlcmF0b3IgaXMgZmluaXNoZWQsIHNvIGZvcmdldCBpdCBhbmQgY29udGludWUgd2l0aFxuICAgIC8vIHRoZSBvdXRlciBnZW5lcmF0b3IuXG4gICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gIH1cblxuICAvLyBEZWZpbmUgR2VuZXJhdG9yLnByb3RvdHlwZS57bmV4dCx0aHJvdyxyZXR1cm59IGluIHRlcm1zIG9mIHRoZVxuICAvLyB1bmlmaWVkIC5faW52b2tlIGhlbHBlciBtZXRob2QuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhHcCk7XG5cbiAgZGVmaW5lKEdwLCB0b1N0cmluZ1RhZ1N5bWJvbCwgXCJHZW5lcmF0b3JcIik7XG5cbiAgLy8gQSBHZW5lcmF0b3Igc2hvdWxkIGFsd2F5cyByZXR1cm4gaXRzZWxmIGFzIHRoZSBpdGVyYXRvciBvYmplY3Qgd2hlbiB0aGVcbiAgLy8gQEBpdGVyYXRvciBmdW5jdGlvbiBpcyBjYWxsZWQgb24gaXQuIFNvbWUgYnJvd3NlcnMnIGltcGxlbWVudGF0aW9ucyBvZiB0aGVcbiAgLy8gaXRlcmF0b3IgcHJvdG90eXBlIGNoYWluIGluY29ycmVjdGx5IGltcGxlbWVudCB0aGlzLCBjYXVzaW5nIHRoZSBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0IHRvIG5vdCBiZSByZXR1cm5lZCBmcm9tIHRoaXMgY2FsbC4gVGhpcyBlbnN1cmVzIHRoYXQgZG9lc24ndCBoYXBwZW4uXG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVnZW5lcmF0b3IvaXNzdWVzLzI3NCBmb3IgbW9yZSBkZXRhaWxzLlxuICBHcFtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBHcC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBcIltvYmplY3QgR2VuZXJhdG9yXVwiO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHB1c2hUcnlFbnRyeShsb2NzKSB7XG4gICAgdmFyIGVudHJ5ID0geyB0cnlMb2M6IGxvY3NbMF0gfTtcblxuICAgIGlmICgxIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmNhdGNoTG9jID0gbG9jc1sxXTtcbiAgICB9XG5cbiAgICBpZiAoMiBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5maW5hbGx5TG9jID0gbG9jc1syXTtcbiAgICAgIGVudHJ5LmFmdGVyTG9jID0gbG9jc1szXTtcbiAgICB9XG5cbiAgICB0aGlzLnRyeUVudHJpZXMucHVzaChlbnRyeSk7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldFRyeUVudHJ5KGVudHJ5KSB7XG4gICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb24gfHwge307XG4gICAgcmVjb3JkLnR5cGUgPSBcIm5vcm1hbFwiO1xuICAgIGRlbGV0ZSByZWNvcmQuYXJnO1xuICAgIGVudHJ5LmNvbXBsZXRpb24gPSByZWNvcmQ7XG4gIH1cblxuICBmdW5jdGlvbiBDb250ZXh0KHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gVGhlIHJvb3QgZW50cnkgb2JqZWN0IChlZmZlY3RpdmVseSBhIHRyeSBzdGF0ZW1lbnQgd2l0aG91dCBhIGNhdGNoXG4gICAgLy8gb3IgYSBmaW5hbGx5IGJsb2NrKSBnaXZlcyB1cyBhIHBsYWNlIHRvIHN0b3JlIHZhbHVlcyB0aHJvd24gZnJvbVxuICAgIC8vIGxvY2F0aW9ucyB3aGVyZSB0aGVyZSBpcyBubyBlbmNsb3NpbmcgdHJ5IHN0YXRlbWVudC5cbiAgICB0aGlzLnRyeUVudHJpZXMgPSBbeyB0cnlMb2M6IFwicm9vdFwiIH1dO1xuICAgIHRyeUxvY3NMaXN0LmZvckVhY2gocHVzaFRyeUVudHJ5LCB0aGlzKTtcbiAgICB0aGlzLnJlc2V0KHRydWUpO1xuICB9XG5cbiAgZXhwb3J0cy5rZXlzID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICB9XG4gICAga2V5cy5yZXZlcnNlKCk7XG5cbiAgICAvLyBSYXRoZXIgdGhhbiByZXR1cm5pbmcgYW4gb2JqZWN0IHdpdGggYSBuZXh0IG1ldGhvZCwgd2Uga2VlcFxuICAgIC8vIHRoaW5ncyBzaW1wbGUgYW5kIHJldHVybiB0aGUgbmV4dCBmdW5jdGlvbiBpdHNlbGYuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICB3aGlsZSAoa2V5cy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXMucG9wKCk7XG4gICAgICAgIGlmIChrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgbmV4dC52YWx1ZSA9IGtleTtcbiAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUbyBhdm9pZCBjcmVhdGluZyBhbiBhZGRpdGlvbmFsIG9iamVjdCwgd2UganVzdCBoYW5nIHRoZSAudmFsdWVcbiAgICAgIC8vIGFuZCAuZG9uZSBwcm9wZXJ0aWVzIG9mZiB0aGUgbmV4dCBmdW5jdGlvbiBvYmplY3QgaXRzZWxmLiBUaGlzXG4gICAgICAvLyBhbHNvIGVuc3VyZXMgdGhhdCB0aGUgbWluaWZpZXIgd2lsbCBub3QgYW5vbnltaXplIHRoZSBmdW5jdGlvbi5cbiAgICAgIG5leHQuZG9uZSA9IHRydWU7XG4gICAgICByZXR1cm4gbmV4dDtcbiAgICB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIHZhbHVlcyhpdGVyYWJsZSkge1xuICAgIGlmIChpdGVyYWJsZSkge1xuICAgICAgdmFyIGl0ZXJhdG9yTWV0aG9kID0gaXRlcmFibGVbaXRlcmF0b3JTeW1ib2xdO1xuICAgICAgaWYgKGl0ZXJhdG9yTWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRvck1ldGhvZC5jYWxsKGl0ZXJhYmxlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBpdGVyYWJsZS5uZXh0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhYmxlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzTmFOKGl0ZXJhYmxlLmxlbmd0aCkpIHtcbiAgICAgICAgdmFyIGkgPSAtMSwgbmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgd2hpbGUgKCsraSA8IGl0ZXJhYmxlLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGhhc093bi5jYWxsKGl0ZXJhYmxlLCBpKSkge1xuICAgICAgICAgICAgICBuZXh0LnZhbHVlID0gaXRlcmFibGVbaV07XG4gICAgICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuZXh0LnZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG5leHQuZG9uZSA9IHRydWU7XG5cbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gbmV4dC5uZXh0ID0gbmV4dDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gYW4gaXRlcmF0b3Igd2l0aCBubyB2YWx1ZXMuXG4gICAgcmV0dXJuIHsgbmV4dDogZG9uZVJlc3VsdCB9O1xuICB9XG4gIGV4cG9ydHMudmFsdWVzID0gdmFsdWVzO1xuXG4gIGZ1bmN0aW9uIGRvbmVSZXN1bHQoKSB7XG4gICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICB9XG5cbiAgQ29udGV4dC5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IENvbnRleHQsXG5cbiAgICByZXNldDogZnVuY3Rpb24oc2tpcFRlbXBSZXNldCkge1xuICAgICAgdGhpcy5wcmV2ID0gMDtcbiAgICAgIHRoaXMubmV4dCA9IDA7XG4gICAgICAvLyBSZXNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgIHRoaXMuc2VudCA9IHRoaXMuX3NlbnQgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICB0aGlzLm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHRoaXMudHJ5RW50cmllcy5mb3JFYWNoKHJlc2V0VHJ5RW50cnkpO1xuXG4gICAgICBpZiAoIXNraXBUZW1wUmVzZXQpIHtcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzKSB7XG4gICAgICAgICAgLy8gTm90IHN1cmUgYWJvdXQgdGhlIG9wdGltYWwgb3JkZXIgb2YgdGhlc2UgY29uZGl0aW9uczpcbiAgICAgICAgICBpZiAobmFtZS5jaGFyQXQoMCkgPT09IFwidFwiICYmXG4gICAgICAgICAgICAgIGhhc093bi5jYWxsKHRoaXMsIG5hbWUpICYmXG4gICAgICAgICAgICAgICFpc05hTigrbmFtZS5zbGljZSgxKSkpIHtcbiAgICAgICAgICAgIHRoaXNbbmFtZV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcblxuICAgICAgdmFyIHJvb3RFbnRyeSA9IHRoaXMudHJ5RW50cmllc1swXTtcbiAgICAgIHZhciByb290UmVjb3JkID0gcm9vdEVudHJ5LmNvbXBsZXRpb247XG4gICAgICBpZiAocm9vdFJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcm9vdFJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnJ2YWw7XG4gICAgfSxcblxuICAgIGRpc3BhdGNoRXhjZXB0aW9uOiBmdW5jdGlvbihleGNlcHRpb24pIHtcbiAgICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29udGV4dCA9IHRoaXM7XG4gICAgICBmdW5jdGlvbiBoYW5kbGUobG9jLCBjYXVnaHQpIHtcbiAgICAgICAgcmVjb3JkLnR5cGUgPSBcInRocm93XCI7XG4gICAgICAgIHJlY29yZC5hcmcgPSBleGNlcHRpb247XG4gICAgICAgIGNvbnRleHQubmV4dCA9IGxvYztcblxuICAgICAgICBpZiAoY2F1Z2h0KSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRpc3BhdGNoZWQgZXhjZXB0aW9uIHdhcyBjYXVnaHQgYnkgYSBjYXRjaCBibG9jayxcbiAgICAgICAgICAvLyB0aGVuIGxldCB0aGF0IGNhdGNoIGJsb2NrIGhhbmRsZSB0aGUgZXhjZXB0aW9uIG5vcm1hbGx5LlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gISEgY2F1Z2h0O1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gXCJyb290XCIpIHtcbiAgICAgICAgICAvLyBFeGNlcHRpb24gdGhyb3duIG91dHNpZGUgb2YgYW55IHRyeSBibG9jayB0aGF0IGNvdWxkIGhhbmRsZVxuICAgICAgICAgIC8vIGl0LCBzbyBzZXQgdGhlIGNvbXBsZXRpb24gdmFsdWUgb2YgdGhlIGVudGlyZSBmdW5jdGlvbiB0b1xuICAgICAgICAgIC8vIHRocm93IHRoZSBleGNlcHRpb24uXG4gICAgICAgICAgcmV0dXJuIGhhbmRsZShcImVuZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2KSB7XG4gICAgICAgICAgdmFyIGhhc0NhdGNoID0gaGFzT3duLmNhbGwoZW50cnksIFwiY2F0Y2hMb2NcIik7XG4gICAgICAgICAgdmFyIGhhc0ZpbmFsbHkgPSBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpO1xuXG4gICAgICAgICAgaWYgKGhhc0NhdGNoICYmIGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNDYXRjaCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRyeSBzdGF0ZW1lbnQgd2l0aG91dCBjYXRjaCBvciBmaW5hbGx5XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBhYnJ1cHQ6IGZ1bmN0aW9uKHR5cGUsIGFyZykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2ICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpICYmXG4gICAgICAgICAgICB0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgdmFyIGZpbmFsbHlFbnRyeSA9IGVudHJ5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkgJiZcbiAgICAgICAgICAodHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgIHR5cGUgPT09IFwiY29udGludWVcIikgJiZcbiAgICAgICAgICBmaW5hbGx5RW50cnkudHJ5TG9jIDw9IGFyZyAmJlxuICAgICAgICAgIGFyZyA8PSBmaW5hbGx5RW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAvLyBJZ25vcmUgdGhlIGZpbmFsbHkgZW50cnkgaWYgY29udHJvbCBpcyBub3QganVtcGluZyB0byBhXG4gICAgICAgIC8vIGxvY2F0aW9uIG91dHNpZGUgdGhlIHRyeS9jYXRjaCBibG9jay5cbiAgICAgICAgZmluYWxseUVudHJ5ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlY29yZCA9IGZpbmFsbHlFbnRyeSA/IGZpbmFsbHlFbnRyeS5jb21wbGV0aW9uIDoge307XG4gICAgICByZWNvcmQudHlwZSA9IHR5cGU7XG4gICAgICByZWNvcmQuYXJnID0gYXJnO1xuXG4gICAgICBpZiAoZmluYWxseUVudHJ5KSB7XG4gICAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgIHRoaXMubmV4dCA9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jO1xuICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuY29tcGxldGUocmVjb3JkKTtcbiAgICB9LFxuXG4gICAgY29tcGxldGU6IGZ1bmN0aW9uKHJlY29yZCwgYWZ0ZXJMb2MpIHtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgcmVjb3JkLnR5cGUgPT09IFwiY29udGludWVcIikge1xuICAgICAgICB0aGlzLm5leHQgPSByZWNvcmQuYXJnO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICB0aGlzLnJ2YWwgPSB0aGlzLmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIHRoaXMubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gXCJlbmRcIjtcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIgJiYgYWZ0ZXJMb2MpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gYWZ0ZXJMb2M7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH0sXG5cbiAgICBmaW5pc2g6IGZ1bmN0aW9uKGZpbmFsbHlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkuZmluYWxseUxvYyA9PT0gZmluYWxseUxvYykge1xuICAgICAgICAgIHRoaXMuY29tcGxldGUoZW50cnkuY29tcGxldGlvbiwgZW50cnkuYWZ0ZXJMb2MpO1xuICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIFwiY2F0Y2hcIjogZnVuY3Rpb24odHJ5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gdHJ5TG9jKSB7XG4gICAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG4gICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIHZhciB0aHJvd24gPSByZWNvcmQuYXJnO1xuICAgICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aHJvd247XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVGhlIGNvbnRleHQuY2F0Y2ggbWV0aG9kIG11c3Qgb25seSBiZSBjYWxsZWQgd2l0aCBhIGxvY2F0aW9uXG4gICAgICAvLyBhcmd1bWVudCB0aGF0IGNvcnJlc3BvbmRzIHRvIGEga25vd24gY2F0Y2ggYmxvY2suXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIGNhdGNoIGF0dGVtcHRcIik7XG4gICAgfSxcblxuICAgIGRlbGVnYXRlWWllbGQ6IGZ1bmN0aW9uKGl0ZXJhYmxlLCByZXN1bHROYW1lLCBuZXh0TG9jKSB7XG4gICAgICB0aGlzLmRlbGVnYXRlID0ge1xuICAgICAgICBpdGVyYXRvcjogdmFsdWVzKGl0ZXJhYmxlKSxcbiAgICAgICAgcmVzdWx0TmFtZTogcmVzdWx0TmFtZSxcbiAgICAgICAgbmV4dExvYzogbmV4dExvY1xuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAvLyBEZWxpYmVyYXRlbHkgZm9yZ2V0IHRoZSBsYXN0IHNlbnQgdmFsdWUgc28gdGhhdCB3ZSBkb24ndFxuICAgICAgICAvLyBhY2NpZGVudGFsbHkgcGFzcyBpdCBvbiB0byB0aGUgZGVsZWdhdGUuXG4gICAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG4gIH07XG5cbiAgLy8gUmVnYXJkbGVzcyBvZiB3aGV0aGVyIHRoaXMgc2NyaXB0IGlzIGV4ZWN1dGluZyBhcyBhIENvbW1vbkpTIG1vZHVsZVxuICAvLyBvciBub3QsIHJldHVybiB0aGUgcnVudGltZSBvYmplY3Qgc28gdGhhdCB3ZSBjYW4gZGVjbGFyZSB0aGUgdmFyaWFibGVcbiAgLy8gcmVnZW5lcmF0b3JSdW50aW1lIGluIHRoZSBvdXRlciBzY29wZSwgd2hpY2ggYWxsb3dzIHRoaXMgbW9kdWxlIHRvIGJlXG4gIC8vIGluamVjdGVkIGVhc2lseSBieSBgYmluL3JlZ2VuZXJhdG9yIC0taW5jbHVkZS1ydW50aW1lIHNjcmlwdC5qc2AuXG4gIHJldHVybiBleHBvcnRzO1xuXG59KFxuICAvLyBJZiB0aGlzIHNjcmlwdCBpcyBleGVjdXRpbmcgYXMgYSBDb21tb25KUyBtb2R1bGUsIHVzZSBtb2R1bGUuZXhwb3J0c1xuICAvLyBhcyB0aGUgcmVnZW5lcmF0b3JSdW50aW1lIG5hbWVzcGFjZS4gT3RoZXJ3aXNlIGNyZWF0ZSBhIG5ldyBlbXB0eVxuICAvLyBvYmplY3QuIEVpdGhlciB3YXksIHRoZSByZXN1bHRpbmcgb2JqZWN0IHdpbGwgYmUgdXNlZCB0byBpbml0aWFsaXplXG4gIC8vIHRoZSByZWdlbmVyYXRvclJ1bnRpbWUgdmFyaWFibGUgYXQgdGhlIHRvcCBvZiB0aGlzIGZpbGUuXG4gIHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgPyBtb2R1bGUuZXhwb3J0cyA6IHt9XG4pKTtcblxudHJ5IHtcbiAgcmVnZW5lcmF0b3JSdW50aW1lID0gcnVudGltZTtcbn0gY2F0Y2ggKGFjY2lkZW50YWxTdHJpY3RNb2RlKSB7XG4gIC8vIFRoaXMgbW9kdWxlIHNob3VsZCBub3QgYmUgcnVubmluZyBpbiBzdHJpY3QgbW9kZSwgc28gdGhlIGFib3ZlXG4gIC8vIGFzc2lnbm1lbnQgc2hvdWxkIGFsd2F5cyB3b3JrIHVubGVzcyBzb21ldGhpbmcgaXMgbWlzY29uZmlndXJlZC4gSnVzdFxuICAvLyBpbiBjYXNlIHJ1bnRpbWUuanMgYWNjaWRlbnRhbGx5IHJ1bnMgaW4gc3RyaWN0IG1vZGUsIHdlIGNhbiBlc2NhcGVcbiAgLy8gc3RyaWN0IG1vZGUgdXNpbmcgYSBnbG9iYWwgRnVuY3Rpb24gY2FsbC4gVGhpcyBjb3VsZCBjb25jZWl2YWJseSBmYWlsXG4gIC8vIGlmIGEgQ29udGVudCBTZWN1cml0eSBQb2xpY3kgZm9yYmlkcyB1c2luZyBGdW5jdGlvbiwgYnV0IGluIHRoYXQgY2FzZVxuICAvLyB0aGUgcHJvcGVyIHNvbHV0aW9uIGlzIHRvIGZpeCB0aGUgYWNjaWRlbnRhbCBzdHJpY3QgbW9kZSBwcm9ibGVtLiBJZlxuICAvLyB5b3UndmUgbWlzY29uZmlndXJlZCB5b3VyIGJ1bmRsZXIgdG8gZm9yY2Ugc3RyaWN0IG1vZGUgYW5kIGFwcGxpZWQgYVxuICAvLyBDU1AgdG8gZm9yYmlkIEZ1bmN0aW9uLCBhbmQgeW91J3JlIG5vdCB3aWxsaW5nIHRvIGZpeCBlaXRoZXIgb2YgdGhvc2VcbiAgLy8gcHJvYmxlbXMsIHBsZWFzZSBkZXRhaWwgeW91ciB1bmlxdWUgcHJlZGljYW1lbnQgaW4gYSBHaXRIdWIgaXNzdWUuXG4gIEZ1bmN0aW9uKFwiclwiLCBcInJlZ2VuZXJhdG9yUnVudGltZSA9IHJcIikocnVudGltZSk7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIGlzT2xkSUUgPSBmdW5jdGlvbiBpc09sZElFKCkge1xuICB2YXIgbWVtbztcbiAgcmV0dXJuIGZ1bmN0aW9uIG1lbW9yaXplKCkge1xuICAgIGlmICh0eXBlb2YgbWVtbyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIFRlc3QgZm9yIElFIDw9IDkgYXMgcHJvcG9zZWQgYnkgQnJvd3NlcmhhY2tzXG4gICAgICAvLyBAc2VlIGh0dHA6Ly9icm93c2VyaGFja3MuY29tLyNoYWNrLWU3MWQ4NjkyZjY1MzM0MTczZmVlNzE1YzIyMmNiODA1XG4gICAgICAvLyBUZXN0cyBmb3IgZXhpc3RlbmNlIG9mIHN0YW5kYXJkIGdsb2JhbHMgaXMgdG8gYWxsb3cgc3R5bGUtbG9hZGVyXG4gICAgICAvLyB0byBvcGVyYXRlIGNvcnJlY3RseSBpbnRvIG5vbi1zdGFuZGFyZCBlbnZpcm9ubWVudHNcbiAgICAgIC8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi9zdHlsZS1sb2FkZXIvaXNzdWVzLzE3N1xuICAgICAgbWVtbyA9IEJvb2xlYW4od2luZG93ICYmIGRvY3VtZW50ICYmIGRvY3VtZW50LmFsbCAmJiAhd2luZG93LmF0b2IpO1xuICAgIH1cblxuICAgIHJldHVybiBtZW1vO1xuICB9O1xufSgpO1xuXG52YXIgZ2V0VGFyZ2V0ID0gZnVuY3Rpb24gZ2V0VGFyZ2V0KCkge1xuICB2YXIgbWVtbyA9IHt9O1xuICByZXR1cm4gZnVuY3Rpb24gbWVtb3JpemUodGFyZ2V0KSB7XG4gICAgaWYgKHR5cGVvZiBtZW1vW3RhcmdldF0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB2YXIgc3R5bGVUYXJnZXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhcmdldCk7IC8vIFNwZWNpYWwgY2FzZSB0byByZXR1cm4gaGVhZCBvZiBpZnJhbWUgaW5zdGVhZCBvZiBpZnJhbWUgaXRzZWxmXG5cbiAgICAgIGlmICh3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQgJiYgc3R5bGVUYXJnZXQgaW5zdGFuY2VvZiB3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFjY2VzcyB0byBpZnJhbWUgaXMgYmxvY2tlZFxuICAgICAgICAgIC8vIGR1ZSB0byBjcm9zcy1vcmlnaW4gcmVzdHJpY3Rpb25zXG4gICAgICAgICAgc3R5bGVUYXJnZXQgPSBzdHlsZVRhcmdldC5jb250ZW50RG9jdW1lbnQuaGVhZDtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgICAgc3R5bGVUYXJnZXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG1lbW9bdGFyZ2V0XSA9IHN0eWxlVGFyZ2V0O1xuICAgIH1cblxuICAgIHJldHVybiBtZW1vW3RhcmdldF07XG4gIH07XG59KCk7XG5cbnZhciBzdHlsZXNJbkRvbSA9IFtdO1xuXG5mdW5jdGlvbiBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKSB7XG4gIHZhciByZXN1bHQgPSAtMTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlc0luRG9tLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHN0eWxlc0luRG9tW2ldLmlkZW50aWZpZXIgPT09IGlkZW50aWZpZXIpIHtcbiAgICAgIHJlc3VsdCA9IGk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBtb2R1bGVzVG9Eb20obGlzdCwgb3B0aW9ucykge1xuICB2YXIgaWRDb3VudE1hcCA9IHt9O1xuICB2YXIgaWRlbnRpZmllcnMgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaXRlbSA9IGxpc3RbaV07XG4gICAgdmFyIGlkID0gb3B0aW9ucy5iYXNlID8gaXRlbVswXSArIG9wdGlvbnMuYmFzZSA6IGl0ZW1bMF07XG4gICAgdmFyIGNvdW50ID0gaWRDb3VudE1hcFtpZF0gfHwgMDtcbiAgICB2YXIgaWRlbnRpZmllciA9IFwiXCIuY29uY2F0KGlkLCBcIiBcIikuY29uY2F0KGNvdW50KTtcbiAgICBpZENvdW50TWFwW2lkXSA9IGNvdW50ICsgMTtcbiAgICB2YXIgaW5kZXggPSBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKTtcbiAgICB2YXIgb2JqID0ge1xuICAgICAgY3NzOiBpdGVtWzFdLFxuICAgICAgbWVkaWE6IGl0ZW1bMl0sXG4gICAgICBzb3VyY2VNYXA6IGl0ZW1bM11cbiAgICB9O1xuXG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgc3R5bGVzSW5Eb21baW5kZXhdLnJlZmVyZW5jZXMrKztcbiAgICAgIHN0eWxlc0luRG9tW2luZGV4XS51cGRhdGVyKG9iaik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlc0luRG9tLnB1c2goe1xuICAgICAgICBpZGVudGlmaWVyOiBpZGVudGlmaWVyLFxuICAgICAgICB1cGRhdGVyOiBhZGRTdHlsZShvYmosIG9wdGlvbnMpLFxuICAgICAgICByZWZlcmVuY2VzOiAxXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZGVudGlmaWVycy5wdXNoKGlkZW50aWZpZXIpO1xuICB9XG5cbiAgcmV0dXJuIGlkZW50aWZpZXJzO1xufVxuXG5mdW5jdGlvbiBpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucykge1xuICB2YXIgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICB2YXIgYXR0cmlidXRlcyA9IG9wdGlvbnMuYXR0cmlidXRlcyB8fCB7fTtcblxuICBpZiAodHlwZW9mIGF0dHJpYnV0ZXMubm9uY2UgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIG5vbmNlID0gdHlwZW9mIF9fd2VicGFja19ub25jZV9fICE9PSAndW5kZWZpbmVkJyA/IF9fd2VicGFja19ub25jZV9fIDogbnVsbDtcblxuICAgIGlmIChub25jZSkge1xuICAgICAgYXR0cmlidXRlcy5ub25jZSA9IG5vbmNlO1xuICAgIH1cbiAgfVxuXG4gIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIHN0eWxlLnNldEF0dHJpYnV0ZShrZXksIGF0dHJpYnV0ZXNba2V5XSk7XG4gIH0pO1xuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5pbnNlcnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBvcHRpb25zLmluc2VydChzdHlsZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHRhcmdldCA9IGdldFRhcmdldChvcHRpb25zLmluc2VydCB8fCAnaGVhZCcpO1xuXG4gICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGZpbmQgYSBzdHlsZSB0YXJnZXQuIFRoaXMgcHJvYmFibHkgbWVhbnMgdGhhdCB0aGUgdmFsdWUgZm9yIHRoZSAnaW5zZXJ0JyBwYXJhbWV0ZXIgaXMgaW52YWxpZC5cIik7XG4gICAgfVxuXG4gICAgdGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgfVxuXG4gIHJldHVybiBzdHlsZTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlKSB7XG4gIC8vIGlzdGFuYnVsIGlnbm9yZSBpZlxuICBpZiAoc3R5bGUucGFyZW50Tm9kZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHN0eWxlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGUpO1xufVxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5cblxudmFyIHJlcGxhY2VUZXh0ID0gZnVuY3Rpb24gcmVwbGFjZVRleHQoKSB7XG4gIHZhciB0ZXh0U3RvcmUgPSBbXTtcbiAgcmV0dXJuIGZ1bmN0aW9uIHJlcGxhY2UoaW5kZXgsIHJlcGxhY2VtZW50KSB7XG4gICAgdGV4dFN0b3JlW2luZGV4XSA9IHJlcGxhY2VtZW50O1xuICAgIHJldHVybiB0ZXh0U3RvcmUuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ1xcbicpO1xuICB9O1xufSgpO1xuXG5mdW5jdGlvbiBhcHBseVRvU2luZ2xldG9uVGFnKHN0eWxlLCBpbmRleCwgcmVtb3ZlLCBvYmopIHtcbiAgdmFyIGNzcyA9IHJlbW92ZSA/ICcnIDogb2JqLm1lZGlhID8gXCJAbWVkaWEgXCIuY29uY2F0KG9iai5tZWRpYSwgXCIge1wiKS5jb25jYXQob2JqLmNzcywgXCJ9XCIpIDogb2JqLmNzczsgLy8gRm9yIG9sZCBJRVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAgKi9cblxuICBpZiAoc3R5bGUuc3R5bGVTaGVldCkge1xuICAgIHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IHJlcGxhY2VUZXh0KGluZGV4LCBjc3MpO1xuICB9IGVsc2Uge1xuICAgIHZhciBjc3NOb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKTtcbiAgICB2YXIgY2hpbGROb2RlcyA9IHN0eWxlLmNoaWxkTm9kZXM7XG5cbiAgICBpZiAoY2hpbGROb2Rlc1tpbmRleF0pIHtcbiAgICAgIHN0eWxlLnJlbW92ZUNoaWxkKGNoaWxkTm9kZXNbaW5kZXhdKTtcbiAgICB9XG5cbiAgICBpZiAoY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgIHN0eWxlLmluc2VydEJlZm9yZShjc3NOb2RlLCBjaGlsZE5vZGVzW2luZGV4XSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlLmFwcGVuZENoaWxkKGNzc05vZGUpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhcHBseVRvVGFnKHN0eWxlLCBvcHRpb25zLCBvYmopIHtcbiAgdmFyIGNzcyA9IG9iai5jc3M7XG4gIHZhciBtZWRpYSA9IG9iai5tZWRpYTtcbiAgdmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XG5cbiAgaWYgKG1lZGlhKSB7XG4gICAgc3R5bGUuc2V0QXR0cmlidXRlKCdtZWRpYScsIG1lZGlhKTtcbiAgfSBlbHNlIHtcbiAgICBzdHlsZS5yZW1vdmVBdHRyaWJ1dGUoJ21lZGlhJyk7XG4gIH1cblxuICBpZiAoc291cmNlTWFwICYmIGJ0b2EpIHtcbiAgICBjc3MgKz0gXCJcXG4vKiMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LFwiLmNvbmNhdChidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpLCBcIiAqL1wiKTtcbiAgfSAvLyBGb3Igb2xkIElFXG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICAqL1xuXG5cbiAgaWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcbiAgICBzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKHN0eWxlLmZpcnN0Q2hpbGQpIHtcbiAgICAgIHN0eWxlLnJlbW92ZUNoaWxkKHN0eWxlLmZpcnN0Q2hpbGQpO1xuICAgIH1cblxuICAgIHN0eWxlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xuICB9XG59XG5cbnZhciBzaW5nbGV0b24gPSBudWxsO1xudmFyIHNpbmdsZXRvbkNvdW50ZXIgPSAwO1xuXG5mdW5jdGlvbiBhZGRTdHlsZShvYmosIG9wdGlvbnMpIHtcbiAgdmFyIHN0eWxlO1xuICB2YXIgdXBkYXRlO1xuICB2YXIgcmVtb3ZlO1xuXG4gIGlmIChvcHRpb25zLnNpbmdsZXRvbikge1xuICAgIHZhciBzdHlsZUluZGV4ID0gc2luZ2xldG9uQ291bnRlcisrO1xuICAgIHN0eWxlID0gc2luZ2xldG9uIHx8IChzaW5nbGV0b24gPSBpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucykpO1xuICAgIHVwZGF0ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZSwgc3R5bGVJbmRleCwgZmFsc2UpO1xuICAgIHJlbW92ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZSwgc3R5bGVJbmRleCwgdHJ1ZSk7XG4gIH0gZWxzZSB7XG4gICAgc3R5bGUgPSBpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucyk7XG4gICAgdXBkYXRlID0gYXBwbHlUb1RhZy5iaW5kKG51bGwsIHN0eWxlLCBvcHRpb25zKTtcblxuICAgIHJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgIHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZSk7XG4gICAgfTtcbiAgfVxuXG4gIHVwZGF0ZShvYmopO1xuICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlU3R5bGUobmV3T2JqKSB7XG4gICAgaWYgKG5ld09iaikge1xuICAgICAgaWYgKG5ld09iai5jc3MgPT09IG9iai5jc3MgJiYgbmV3T2JqLm1lZGlhID09PSBvYmoubWVkaWEgJiYgbmV3T2JqLnNvdXJjZU1hcCA9PT0gb2JqLnNvdXJjZU1hcCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHVwZGF0ZShvYmogPSBuZXdPYmopO1xuICAgIH0gZWxzZSB7XG4gICAgICByZW1vdmUoKTtcbiAgICB9XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGxpc3QsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307IC8vIEZvcmNlIHNpbmdsZS10YWcgc29sdXRpb24gb24gSUU2LTksIHdoaWNoIGhhcyBhIGhhcmQgbGltaXQgb24gdGhlICMgb2YgPHN0eWxlPlxuICAvLyB0YWdzIGl0IHdpbGwgYWxsb3cgb24gYSBwYWdlXG5cbiAgaWYgKCFvcHRpb25zLnNpbmdsZXRvbiAmJiB0eXBlb2Ygb3B0aW9ucy5zaW5nbGV0b24gIT09ICdib29sZWFuJykge1xuICAgIG9wdGlvbnMuc2luZ2xldG9uID0gaXNPbGRJRSgpO1xuICB9XG5cbiAgbGlzdCA9IGxpc3QgfHwgW107XG4gIHZhciBsYXN0SWRlbnRpZmllcnMgPSBtb2R1bGVzVG9Eb20obGlzdCwgb3B0aW9ucyk7XG4gIHJldHVybiBmdW5jdGlvbiB1cGRhdGUobmV3TGlzdCkge1xuICAgIG5ld0xpc3QgPSBuZXdMaXN0IHx8IFtdO1xuXG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChuZXdMaXN0KSAhPT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGFzdElkZW50aWZpZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaWRlbnRpZmllciA9IGxhc3RJZGVudGlmaWVyc1tpXTtcbiAgICAgIHZhciBpbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpO1xuICAgICAgc3R5bGVzSW5Eb21baW5kZXhdLnJlZmVyZW5jZXMtLTtcbiAgICB9XG5cbiAgICB2YXIgbmV3TGFzdElkZW50aWZpZXJzID0gbW9kdWxlc1RvRG9tKG5ld0xpc3QsIG9wdGlvbnMpO1xuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGxhc3RJZGVudGlmaWVycy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBfaWRlbnRpZmllciA9IGxhc3RJZGVudGlmaWVyc1tfaV07XG5cbiAgICAgIHZhciBfaW5kZXggPSBnZXRJbmRleEJ5SWRlbnRpZmllcihfaWRlbnRpZmllcik7XG5cbiAgICAgIGlmIChzdHlsZXNJbkRvbVtfaW5kZXhdLnJlZmVyZW5jZXMgPT09IDApIHtcbiAgICAgICAgc3R5bGVzSW5Eb21bX2luZGV4XS51cGRhdGVyKCk7XG5cbiAgICAgICAgc3R5bGVzSW5Eb20uc3BsaWNlKF9pbmRleCwgMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGFzdElkZW50aWZpZXJzID0gbmV3TGFzdElkZW50aWZpZXJzO1xuICB9O1xufTsiLCJ2YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG59IGNhdGNoIChlKSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSBnID0gd2luZG93O1xufVxuXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGc7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9yaWdpbmFsTW9kdWxlKSB7XG5cdGlmICghb3JpZ2luYWxNb2R1bGUud2VicGFja1BvbHlmaWxsKSB7XG5cdFx0dmFyIG1vZHVsZSA9IE9iamVjdC5jcmVhdGUob3JpZ2luYWxNb2R1bGUpO1xuXHRcdC8vIG1vZHVsZS5wYXJlbnQgPSB1bmRlZmluZWQgYnkgZGVmYXVsdFxuXHRcdGlmICghbW9kdWxlLmNoaWxkcmVuKSBtb2R1bGUuY2hpbGRyZW4gPSBbXTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImxvYWRlZFwiLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5sO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwiaWRcIiwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBtb2R1bGUuaTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImV4cG9ydHNcIiwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZVxuXHRcdH0pO1xuXHRcdG1vZHVsZS53ZWJwYWNrUG9seWZpbGwgPSAxO1xuXHR9XG5cdHJldHVybiBtb2R1bGU7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtb2R1bGUpIHtcblx0aWYgKCFtb2R1bGUud2VicGFja1BvbHlmaWxsKSB7XG5cdFx0bW9kdWxlLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKCkge307XG5cdFx0bW9kdWxlLnBhdGhzID0gW107XG5cdFx0Ly8gbW9kdWxlLnBhcmVudCA9IHVuZGVmaW5lZCBieSBkZWZhdWx0XG5cdFx0aWYgKCFtb2R1bGUuY2hpbGRyZW4pIG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwibG9hZGVkXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmw7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJpZFwiLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdG1vZHVsZS53ZWJwYWNrUG9seWZpbGwgPSAxO1xuXHR9XG5cdHJldHVybiBtb2R1bGU7XG59O1xuIiwiaW1wb3J0ICcuLi93d3cvc2hhcmVkL3N0eWxlcy9nbG9iYWwvaW5kZXguY3NzJztcblxuZXhwb3J0IHsgZGVmYXVsdCB9IGZyb20gJy4uL3d3dy9hcHAnO1xuIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgSGVhZCBmcm9tICduZXh0L2hlYWQnO1xuaW1wb3J0IExheW91dCBmcm9tICcuLi9zaGFyZWQvY29tcG9uZW50cy9sYXlvdXQnO1xuXG5pbXBvcnQgZmF2aWNvbiBmcm9tICcuLi9zaGFyZWQvbWVkaWEvZmF2aWNvbnMvZmF2aWNvbi5pY28nO1xuXG5jb25zdCBBcHAgPSAoeyBDb21wb25lbnQsIHBhZ2VQcm9wcyB9KSA9PiAoXG4gIDw+XG4gICAgPEhlYWQ+XG4gICAgICA8dGl0bGU+TmV4dCBCb2lsZXJwbGF0ZTwvdGl0bGU+XG4gICAgICA8bGluayByZWw9XCJzaG9ydGN1dCBpY29uXCIgdHlwZT1cImltYWdlL3gtaWNvblwiIGhyZWY9eyBmYXZpY29uIH0gLz5cbiAgICA8L0hlYWQ+XG4gICAgPExheW91dD5cbiAgICAgIDxDb21wb25lbnQgeyAuLi5wYWdlUHJvcHMgfSAvPlxuICAgIDwvTGF5b3V0PlxuICA8Lz5cbik7XG5cbkFwcC5wcm9wVHlwZXMgPSB7XG4gIENvbXBvbmVudDogUHJvcFR5cGVzLmVsZW1lbnRUeXBlLmlzUmVxdWlyZWQsXG4gIHBhZ2VQcm9wczogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxufTtcblxuZXhwb3J0IGRlZmF1bHQgQXBwO1xuIiwiZXhwb3J0IHsgZGVmYXVsdCB9IGZyb20gJy4vQXBwJztcbiIsImltcG9ydCBSZWFjdCwgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjbGFzc05hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0IGJyb3dzZXJzIGZyb20gJy4uLy4uL3V0aWxzL2Jyb3dzZXJzJztcblxuaW1wb3J0IHN0eWxlcyBmcm9tICcuL0dyYWluLm1vZHVsZS5jc3MnO1xuXG5jb25zdCBHcmFpbiA9ICh7IGNsYXNzTmFtZSB9KSA9PiB7XG4gIGNvbnN0IFt6SW5kZXgsIHNldFpJbmRleF0gPSB1c2VTdGF0ZSgwKTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHNldFpJbmRleChicm93c2Vycy5pc1NhZmFyaSgpID8gLTEgOiAwKTtcbiAgfSwgW3NldFpJbmRleF0pO1xuXG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9eyBjbGFzc05hbWVzKHN0eWxlcy5ncmFpbiwgY2xhc3NOYW1lKSB9IHN0eWxlPXsgeyB6SW5kZXggfSB9IC8+XG4gICk7XG59O1xuXG5HcmFpbi5wcm9wVHlwZXMgPSB7XG4gIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEdyYWluO1xuIiwidmFyIGFwaSA9IHJlcXVpcmUoXCIhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzXCIpO1xuICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS01LW9uZU9mLTItMSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Bvc3Rjc3MtbG9hZGVyL2luZGV4LmpzPz9fX25leHRqc19wb3N0Y3NzIS4vR3JhaW4ubW9kdWxlLmNzc1wiKTtcblxuICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuX19lc01vZHVsZSA/IGNvbnRlbnQuZGVmYXVsdCA6IGNvbnRlbnQ7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuICAgICAgICAgICAgfVxuXG52YXIgb3B0aW9ucyA9IHt9O1xuXG5vcHRpb25zLmluc2VydCA9IGZ1bmN0aW9uKGVsZW1lbnQpey8vIFRoZXNlIGVsZW1lbnRzIHNob3VsZCBhbHdheXMgZXhpc3QuIElmIHRoZXkgZG8gbm90LFxuLy8gdGhpcyBjb2RlIHNob3VsZCBmYWlsLlxudmFyIGFuY2hvckVsZW1lbnQ9ZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI19fbmV4dF9jc3NfX0RPX05PVF9VU0VfXycpO3ZhciBwYXJlbnROb2RlPWFuY2hvckVsZW1lbnQucGFyZW50Tm9kZTsvLyBOb3JtYWxseSA8aGVhZD5cbi8vIEVhY2ggc3R5bGUgdGFnIHNob3VsZCBiZSBwbGFjZWQgcmlnaHQgYmVmb3JlIG91clxuLy8gYW5jaG9yLiBCeSBpbnNlcnRpbmcgYmVmb3JlIGFuZCBub3QgYWZ0ZXIsIHdlIGRvIG5vdFxuLy8gbmVlZCB0byB0cmFjayB0aGUgbGFzdCBpbnNlcnRlZCBlbGVtZW50LlxucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZWxlbWVudCxhbmNob3JFbGVtZW50KTt9O1xub3B0aW9ucy5zaW5nbGV0b24gPSBmYWxzZTtcblxudmFyIHVwZGF0ZSA9IGFwaShjb250ZW50LCBvcHRpb25zKTtcblxuXG5pZiAobW9kdWxlLmhvdCkge1xuICBpZiAoIWNvbnRlbnQubG9jYWxzIHx8IG1vZHVsZS5ob3QuaW52YWxpZGF0ZSkge1xuICAgIHZhciBpc0VxdWFsTG9jYWxzID0gZnVuY3Rpb24gaXNFcXVhbExvY2FscyhhLCBiKSB7XG4gIGlmICghYSAmJiBiIHx8IGEgJiYgIWIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgcDtcblxuICBmb3IgKHAgaW4gYSkge1xuICAgIGlmIChhW3BdICE9PSBiW3BdKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgZm9yIChwIGluIGIpIHtcbiAgICBpZiAoIWFbcF0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG4gICAgdmFyIG9sZExvY2FscyA9IGNvbnRlbnQubG9jYWxzO1xuXG4gICAgbW9kdWxlLmhvdC5hY2NlcHQoXG4gICAgICBcIiEhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tNS1vbmVPZi0yLTEhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9wb3N0Y3NzLWxvYWRlci9pbmRleC5qcz8/X19uZXh0anNfcG9zdGNzcyEuL0dyYWluLm1vZHVsZS5jc3NcIixcbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTUtb25lT2YtMi0xIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcG9zdGNzcy1sb2FkZXIvaW5kZXguanM/P19fbmV4dGpzX3Bvc3Rjc3MhLi9HcmFpbi5tb2R1bGUuY3NzXCIpO1xuXG4gICAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50Ll9fZXNNb2R1bGUgPyBjb250ZW50LmRlZmF1bHQgOiBjb250ZW50O1xuXG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoIWlzRXF1YWxMb2NhbHMob2xkTG9jYWxzLCBjb250ZW50LmxvY2FscykpIHtcbiAgICAgICAgICAgICAgICBtb2R1bGUuaG90LmludmFsaWRhdGUoKTtcblxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIG9sZExvY2FscyA9IGNvbnRlbnQubG9jYWxzO1xuXG4gICAgICAgICAgICAgIHVwZGF0ZShjb250ZW50KTtcbiAgICAgIH1cbiAgICApXG4gIH1cblxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7XG4gICAgdXBkYXRlKCk7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzIHx8IHt9OyIsImV4cG9ydCB7IGRlZmF1bHQgfSBmcm9tICcuL0dyYWluJztcbiIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgTmV4dExpbmsgZnJvbSAnQG1veHkvbmV4dC1saW5rJztcbmltcG9ydCBMaW5rIGZyb20gJy4uL2xpbmsnO1xuaW1wb3J0IHsgR2l0aHViSWNvbiwgTGlua2VkaW5JY29uIH0gZnJvbSAnLi4vaWNvbnMnO1xuXG5pbXBvcnQgc3R5bGVzIGZyb20gJy4vSGVhZGVyLm1vZHVsZS5jc3MnO1xuXG5jb25zdCBIZWFkZXIgPSAoKSA9PiAoXG4gIDxoZWFkZXIgY2xhc3NOYW1lPXsgc3R5bGVzLmhlYWRlciB9PlxuICAgIDxkaXYgY2xhc3NOYW1lPXsgc3R5bGVzLmNvbnRlbnQgfT5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPXsgc3R5bGVzLm5hbWUgfT5cbiAgICAgICAgPExpbmsgZXh0ZXJuYWwgaHJlZj1cIiNoZXJvXCIgZGF0YS1oZWFkZXJsaW5rPVwicGF1bG9cIj5cbiAgICAgICAgICA8Yj5QYXVsbzwvYj4gTWFyY29zXG4gICAgICAgIDwvTGluaz5cbiAgICAgIDwvZGl2PlxuICAgICAgPGRpdiBjbGFzc05hbWU9eyBzdHlsZXMubGlua3MgfT5cbiAgICAgICAgPExpbmsgZXh0ZXJuYWwgaHJlZj1cIiNleHBlcnRpc2VcIiBkYXRhLWhlYWRlcmxpbms9XCJleHBlcnRpc2VcIj5FeHBlcnRpc2U8L0xpbms+XG4gICAgICAgIDxMaW5rIGV4dGVybmFsIGhyZWY9XCIjZXhwZXJpZW5jZVwiIGRhdGEtaGVhZGVybGluaz1cImV4cGVyaWVuY2VcIj5FeHBlcmllbmNlPC9MaW5rPlxuICAgICAgICA8TGluayBleHRlcm5hbCBocmVmPVwiI3BvcnRmb2xpb1wiIGRhdGEtaGVhZGVybGluaz1cInBvcnRmb2xpb1wiPlBvcnRmb2xpbzwvTGluaz5cbiAgICAgICAgPExpbmsgZXh0ZXJuYWwgaHJlZj1cIiNjb250YWN0c1wiIGRhdGEtaGVhZGVybGluaz1cImNvbnRhY3RzXCI+Q29udGFjdHM8L0xpbms+XG4gICAgICA8L2Rpdj5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPXsgc3R5bGVzLnNvY2lhbCB9PlxuICAgICAgICA8TmV4dExpbmsgZXh0ZXJuYWwgbmV3VGFiIGhyZWY9XCJodHRwczovL2dpdGh1Yi5jb20vcGF1bG9ibWFyY29zXCI+PEdpdGh1Ykljb24gLz48L05leHRMaW5rPlxuICAgICAgICA8TmV4dExpbmsgZXh0ZXJuYWwgbmV3VGFiIGhyZWY9XCJodHRwczovL3d3dy5saW5rZWRpbi5jb20vaW4vcGF1bG9ibWFyY29zXCI+PExpbmtlZGluSWNvbiAvPjwvTmV4dExpbms+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgPC9oZWFkZXI+XG4pO1xuXG5IZWFkZXIucHJvcFR5cGVzID0ge307XG5cbmV4cG9ydCBkZWZhdWx0IEhlYWRlcjtcbiIsInZhciBhcGkgPSByZXF1aXJlKFwiIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qc1wiKTtcbiAgICAgICAgICAgIHZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tNS1vbmVPZi0yLTEhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9wb3N0Y3NzLWxvYWRlci9pbmRleC5qcz8/X19uZXh0anNfcG9zdGNzcyEuL0hlYWRlci5tb2R1bGUuY3NzXCIpO1xuXG4gICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5fX2VzTW9kdWxlID8gY29udGVudC5kZWZhdWx0IDogY29udGVudDtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4gICAgICAgICAgICB9XG5cbnZhciBvcHRpb25zID0ge307XG5cbm9wdGlvbnMuaW5zZXJ0ID0gZnVuY3Rpb24oZWxlbWVudCl7Ly8gVGhlc2UgZWxlbWVudHMgc2hvdWxkIGFsd2F5cyBleGlzdC4gSWYgdGhleSBkbyBub3QsXG4vLyB0aGlzIGNvZGUgc2hvdWxkIGZhaWwuXG52YXIgYW5jaG9yRWxlbWVudD1kb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjX19uZXh0X2Nzc19fRE9fTk9UX1VTRV9fJyk7dmFyIHBhcmVudE5vZGU9YW5jaG9yRWxlbWVudC5wYXJlbnROb2RlOy8vIE5vcm1hbGx5IDxoZWFkPlxuLy8gRWFjaCBzdHlsZSB0YWcgc2hvdWxkIGJlIHBsYWNlZCByaWdodCBiZWZvcmUgb3VyXG4vLyBhbmNob3IuIEJ5IGluc2VydGluZyBiZWZvcmUgYW5kIG5vdCBhZnRlciwgd2UgZG8gbm90XG4vLyBuZWVkIHRvIHRyYWNrIHRoZSBsYXN0IGluc2VydGVkIGVsZW1lbnQuXG5wYXJlbnROb2RlLmluc2VydEJlZm9yZShlbGVtZW50LGFuY2hvckVsZW1lbnQpO307XG5vcHRpb25zLnNpbmdsZXRvbiA9IGZhbHNlO1xuXG52YXIgdXBkYXRlID0gYXBpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5cbmlmIChtb2R1bGUuaG90KSB7XG4gIGlmICghY29udGVudC5sb2NhbHMgfHwgbW9kdWxlLmhvdC5pbnZhbGlkYXRlKSB7XG4gICAgdmFyIGlzRXF1YWxMb2NhbHMgPSBmdW5jdGlvbiBpc0VxdWFsTG9jYWxzKGEsIGIpIHtcbiAgaWYgKCFhICYmIGIgfHwgYSAmJiAhYikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBwO1xuXG4gIGZvciAocCBpbiBhKSB7XG4gICAgaWYgKGFbcF0gIT09IGJbcF0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmb3IgKHAgaW4gYikge1xuICAgIGlmICghYVtwXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcbiAgICB2YXIgb2xkTG9jYWxzID0gY29udGVudC5sb2NhbHM7XG5cbiAgICBtb2R1bGUuaG90LmFjY2VwdChcbiAgICAgIFwiISEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS01LW9uZU9mLTItMSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Bvc3Rjc3MtbG9hZGVyL2luZGV4LmpzPz9fX25leHRqc19wb3N0Y3NzIS4vSGVhZGVyLm1vZHVsZS5jc3NcIixcbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTUtb25lT2YtMi0xIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcG9zdGNzcy1sb2FkZXIvaW5kZXguanM/P19fbmV4dGpzX3Bvc3Rjc3MhLi9IZWFkZXIubW9kdWxlLmNzc1wiKTtcblxuICAgICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5fX2VzTW9kdWxlID8gY29udGVudC5kZWZhdWx0IDogY29udGVudDtcblxuICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKCFpc0VxdWFsTG9jYWxzKG9sZExvY2FscywgY29udGVudC5sb2NhbHMpKSB7XG4gICAgICAgICAgICAgICAgbW9kdWxlLmhvdC5pbnZhbGlkYXRlKCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBvbGRMb2NhbHMgPSBjb250ZW50LmxvY2FscztcblxuICAgICAgICAgICAgICB1cGRhdGUoY29udGVudCk7XG4gICAgICB9XG4gICAgKVxuICB9XG5cbiAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkge1xuICAgIHVwZGF0ZSgpO1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2FscyB8fCB7fTsiLCJleHBvcnQgeyBkZWZhdWx0IH0gZnJvbSAnLi9IZWFkZXInO1xuIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBTdmcgZnJvbSAncmVhY3QtaW5saW5lc3ZnJztcblxuaW1wb3J0IGFycm93TGVmdFN2ZyBmcm9tICcuLi8uLi9tZWRpYS9zdmdzL2Fycm93LWxlZnQuc3ZnJztcbmltcG9ydCBhcnJvd1JpZ2h0U3ZnIGZyb20gJy4uLy4uL21lZGlhL3N2Z3MvYXJyb3ctcmlnaHQuc3ZnJztcbmltcG9ydCBjdlN2ZyBmcm9tICcuLi8uLi9tZWRpYS9zdmdzL2N2LnN2Zyc7XG5pbXBvcnQgZ2l0aHViU3ZnIGZyb20gJy4uLy4uL21lZGlhL3N2Z3MvZ2l0aHViLnN2Zyc7XG5pbXBvcnQgbGlua2VkaW5TdmcgZnJvbSAnLi4vLi4vbWVkaWEvc3Zncy9saW5rZWRpbi5zdmcnO1xuaW1wb3J0IG1haWxTdmcgZnJvbSAnLi4vLi4vbWVkaWEvc3Zncy9tYWlsLnN2Zyc7XG5cbmNvbnN0IEFycm93TGVmdEljb24gPSAocHJvcHMpID0+IDxTdmcgeyAuLi5wcm9wcyB9IHNyYz17IGFycm93TGVmdFN2ZyB9IC8+O1xuY29uc3QgQXJyb3dSaWdodEljb24gPSAocHJvcHMpID0+IDxTdmcgeyAuLi5wcm9wcyB9IHNyYz17IGFycm93UmlnaHRTdmcgfSAvPjtcbmNvbnN0IEN2SWNvbiA9IChwcm9wcykgPT4gPFN2ZyB7IC4uLnByb3BzIH0gc3JjPXsgY3ZTdmcgfSAvPjtcbmNvbnN0IEdpdGh1Ykljb24gPSAocHJvcHMpID0+IDxTdmcgeyAuLi5wcm9wcyB9IHNyYz17IGdpdGh1YlN2ZyB9IC8+O1xuY29uc3QgTGlua2VkaW5JY29uID0gKHByb3BzKSA9PiA8U3ZnIHsgLi4ucHJvcHMgfSBzcmM9eyBsaW5rZWRpblN2ZyB9IC8+O1xuY29uc3QgTWFpbEljb24gPSAocHJvcHMpID0+IDxTdmcgeyAuLi5wcm9wcyB9IHNyYz17IG1haWxTdmcgfSAvPjtcblxuZXhwb3J0IHtcbiAgQXJyb3dMZWZ0SWNvbixcbiAgQXJyb3dSaWdodEljb24sXG4gIEN2SWNvbixcbiAgR2l0aHViSWNvbixcbiAgTGlua2VkaW5JY29uLFxuICBNYWlsSWNvbixcbn07XG4iLCJpbXBvcnQgUmVhY3QsIHsgdXNlUmVmLCB1c2VDYWxsYmFjaywgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBHcmFpbiBmcm9tICcuLi9ncmFpbic7XG5pbXBvcnQgSGVhZGVyIGZyb20gJy4uL2hlYWRlcic7XG5pbXBvcnQgeyBjaGFuZ2VTdHlsZSB9IGZyb20gJy4uLy4uL3V0aWxzJztcblxuaW1wb3J0IHN0eWxlcyBmcm9tICcuL0xheW91dC5tb2R1bGUuY3NzJztcblxuY29uc3QgTGF5b3V0ID0gKHsgY2hpbGRyZW4gfSkgPT4ge1xuICBjb25zdCBjb250ZW50UmVmID0gdXNlUmVmKCk7XG4gIGNvbnN0IHByb2dyZXNzUmVmID0gdXNlUmVmKCk7XG4gIGNvbnN0IHBlcmNlbnRhZ2VSZWYgPSB1c2VSZWYoKTtcblxuICBjb25zdCBoYW5kbGVTY3JvbGwgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgY29uc3QgeyBjbGllbnRIZWlnaHQsIHNjcm9sbEhlaWdodCwgc2Nyb2xsVG9wIH0gPSBjb250ZW50UmVmLmN1cnJlbnQ7XG4gICAgY29uc3QgcGVyY2VudGFnZSA9IChjbGllbnRIZWlnaHQgKyBzY3JvbGxUb3ApIC8gc2Nyb2xsSGVpZ2h0O1xuXG4gICAgY2hhbmdlU3R5bGUocGVyY2VudGFnZVJlZi5jdXJyZW50LCAndHJhbnNmb3JtJywgYHNjYWxlWSgke3BlcmNlbnRhZ2V9KWApO1xuICB9LCBbXSk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBjb250ZW50ID0gY29udGVudFJlZi5jdXJyZW50O1xuXG4gICAgY29udGVudC5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBoYW5kbGVTY3JvbGwsIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcblxuICAgIGhhbmRsZVNjcm9sbCgpO1xuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNvbnRlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgaGFuZGxlU2Nyb2xsLCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gICAgfTtcbiAgfSwgW2hhbmRsZVNjcm9sbF0pO1xuXG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9eyBzdHlsZXMubGF5b3V0IH0+XG4gICAgICA8R3JhaW4gY2xhc3NOYW1lPXsgc3R5bGVzLmdyYWluIH0gLz5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPXsgc3R5bGVzLmZyYW1lIH0gLz5cbiAgICAgIDxkaXYgcmVmPXsgcHJvZ3Jlc3NSZWYgfSBjbGFzc05hbWU9eyBzdHlsZXMucHJvZ3Jlc3MgfT5cbiAgICAgICAgPGRpdiByZWY9eyBwZXJjZW50YWdlUmVmIH0gY2xhc3NOYW1lPXsgc3R5bGVzLnBlcmNlbnRhZ2UgfSAvPlxuICAgICAgPC9kaXY+XG4gICAgICA8ZGl2XG4gICAgICAgIGlkPVwibGF5b3V0Q29udGVudFwiXG4gICAgICAgIHJlZj17IGNvbnRlbnRSZWYgfVxuICAgICAgICBjbGFzc05hbWU9eyBzdHlsZXMuY29udGVudCB9PlxuICAgICAgICA8SGVhZGVyIC8+XG4gICAgICAgIHsgY2hpbGRyZW4gfVxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gICk7XG59O1xuXG5MYXlvdXQucHJvcFR5cGVzID0ge1xuICBjaGlsZHJlbjogUHJvcFR5cGVzLmFueSxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IExheW91dDtcbiIsInZhciBhcGkgPSByZXF1aXJlKFwiIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qc1wiKTtcbiAgICAgICAgICAgIHZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tNS1vbmVPZi0yLTEhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9wb3N0Y3NzLWxvYWRlci9pbmRleC5qcz8/X19uZXh0anNfcG9zdGNzcyEuL0xheW91dC5tb2R1bGUuY3NzXCIpO1xuXG4gICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5fX2VzTW9kdWxlID8gY29udGVudC5kZWZhdWx0IDogY29udGVudDtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4gICAgICAgICAgICB9XG5cbnZhciBvcHRpb25zID0ge307XG5cbm9wdGlvbnMuaW5zZXJ0ID0gZnVuY3Rpb24oZWxlbWVudCl7Ly8gVGhlc2UgZWxlbWVudHMgc2hvdWxkIGFsd2F5cyBleGlzdC4gSWYgdGhleSBkbyBub3QsXG4vLyB0aGlzIGNvZGUgc2hvdWxkIGZhaWwuXG52YXIgYW5jaG9yRWxlbWVudD1kb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjX19uZXh0X2Nzc19fRE9fTk9UX1VTRV9fJyk7dmFyIHBhcmVudE5vZGU9YW5jaG9yRWxlbWVudC5wYXJlbnROb2RlOy8vIE5vcm1hbGx5IDxoZWFkPlxuLy8gRWFjaCBzdHlsZSB0YWcgc2hvdWxkIGJlIHBsYWNlZCByaWdodCBiZWZvcmUgb3VyXG4vLyBhbmNob3IuIEJ5IGluc2VydGluZyBiZWZvcmUgYW5kIG5vdCBhZnRlciwgd2UgZG8gbm90XG4vLyBuZWVkIHRvIHRyYWNrIHRoZSBsYXN0IGluc2VydGVkIGVsZW1lbnQuXG5wYXJlbnROb2RlLmluc2VydEJlZm9yZShlbGVtZW50LGFuY2hvckVsZW1lbnQpO307XG5vcHRpb25zLnNpbmdsZXRvbiA9IGZhbHNlO1xuXG52YXIgdXBkYXRlID0gYXBpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5cbmlmIChtb2R1bGUuaG90KSB7XG4gIGlmICghY29udGVudC5sb2NhbHMgfHwgbW9kdWxlLmhvdC5pbnZhbGlkYXRlKSB7XG4gICAgdmFyIGlzRXF1YWxMb2NhbHMgPSBmdW5jdGlvbiBpc0VxdWFsTG9jYWxzKGEsIGIpIHtcbiAgaWYgKCFhICYmIGIgfHwgYSAmJiAhYikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBwO1xuXG4gIGZvciAocCBpbiBhKSB7XG4gICAgaWYgKGFbcF0gIT09IGJbcF0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmb3IgKHAgaW4gYikge1xuICAgIGlmICghYVtwXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcbiAgICB2YXIgb2xkTG9jYWxzID0gY29udGVudC5sb2NhbHM7XG5cbiAgICBtb2R1bGUuaG90LmFjY2VwdChcbiAgICAgIFwiISEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS01LW9uZU9mLTItMSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Bvc3Rjc3MtbG9hZGVyL2luZGV4LmpzPz9fX25leHRqc19wb3N0Y3NzIS4vTGF5b3V0Lm1vZHVsZS5jc3NcIixcbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTUtb25lT2YtMi0xIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcG9zdGNzcy1sb2FkZXIvaW5kZXguanM/P19fbmV4dGpzX3Bvc3Rjc3MhLi9MYXlvdXQubW9kdWxlLmNzc1wiKTtcblxuICAgICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5fX2VzTW9kdWxlID8gY29udGVudC5kZWZhdWx0IDogY29udGVudDtcblxuICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKCFpc0VxdWFsTG9jYWxzKG9sZExvY2FscywgY29udGVudC5sb2NhbHMpKSB7XG4gICAgICAgICAgICAgICAgbW9kdWxlLmhvdC5pbnZhbGlkYXRlKCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBvbGRMb2NhbHMgPSBjb250ZW50LmxvY2FscztcblxuICAgICAgICAgICAgICB1cGRhdGUoY29udGVudCk7XG4gICAgICB9XG4gICAgKVxuICB9XG5cbiAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkge1xuICAgIHVwZGF0ZSgpO1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2FscyB8fCB7fTsiLCJleHBvcnQgeyBkZWZhdWx0IH0gZnJvbSAnLi9MYXlvdXQnO1xuIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY2xhc3NOYW1lcyBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCBOZXh0TGluayBmcm9tICdAbW94eS9uZXh0LWxpbmsnO1xuXG5pbXBvcnQgc3R5bGVzIGZyb20gJy4vTGluay5tb2R1bGUuY3NzJztcblxuY29uc3QgTGluayA9ICh7IGNsYXNzTmFtZSwgLi4ucmVzdCB9KSA9PiAoXG4gIDxOZXh0TGluayBjbGFzc05hbWU9eyBjbGFzc05hbWVzKHN0eWxlcy5saW5rLCBjbGFzc05hbWUpIH0geyAuLi5yZXN0IH0gLz5cbik7XG5cbkxpbmsucHJvcFR5cGVzID0ge1xuICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG59O1xuXG5leHBvcnQgZGVmYXVsdCBMaW5rO1xuIiwidmFyIGFwaSA9IHJlcXVpcmUoXCIhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzXCIpO1xuICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS01LW9uZU9mLTItMSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Bvc3Rjc3MtbG9hZGVyL2luZGV4LmpzPz9fX25leHRqc19wb3N0Y3NzIS4vTGluay5tb2R1bGUuY3NzXCIpO1xuXG4gICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5fX2VzTW9kdWxlID8gY29udGVudC5kZWZhdWx0IDogY29udGVudDtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4gICAgICAgICAgICB9XG5cbnZhciBvcHRpb25zID0ge307XG5cbm9wdGlvbnMuaW5zZXJ0ID0gZnVuY3Rpb24oZWxlbWVudCl7Ly8gVGhlc2UgZWxlbWVudHMgc2hvdWxkIGFsd2F5cyBleGlzdC4gSWYgdGhleSBkbyBub3QsXG4vLyB0aGlzIGNvZGUgc2hvdWxkIGZhaWwuXG52YXIgYW5jaG9yRWxlbWVudD1kb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjX19uZXh0X2Nzc19fRE9fTk9UX1VTRV9fJyk7dmFyIHBhcmVudE5vZGU9YW5jaG9yRWxlbWVudC5wYXJlbnROb2RlOy8vIE5vcm1hbGx5IDxoZWFkPlxuLy8gRWFjaCBzdHlsZSB0YWcgc2hvdWxkIGJlIHBsYWNlZCByaWdodCBiZWZvcmUgb3VyXG4vLyBhbmNob3IuIEJ5IGluc2VydGluZyBiZWZvcmUgYW5kIG5vdCBhZnRlciwgd2UgZG8gbm90XG4vLyBuZWVkIHRvIHRyYWNrIHRoZSBsYXN0IGluc2VydGVkIGVsZW1lbnQuXG5wYXJlbnROb2RlLmluc2VydEJlZm9yZShlbGVtZW50LGFuY2hvckVsZW1lbnQpO307XG5vcHRpb25zLnNpbmdsZXRvbiA9IGZhbHNlO1xuXG52YXIgdXBkYXRlID0gYXBpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5cbmlmIChtb2R1bGUuaG90KSB7XG4gIGlmICghY29udGVudC5sb2NhbHMgfHwgbW9kdWxlLmhvdC5pbnZhbGlkYXRlKSB7XG4gICAgdmFyIGlzRXF1YWxMb2NhbHMgPSBmdW5jdGlvbiBpc0VxdWFsTG9jYWxzKGEsIGIpIHtcbiAgaWYgKCFhICYmIGIgfHwgYSAmJiAhYikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBwO1xuXG4gIGZvciAocCBpbiBhKSB7XG4gICAgaWYgKGFbcF0gIT09IGJbcF0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmb3IgKHAgaW4gYikge1xuICAgIGlmICghYVtwXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcbiAgICB2YXIgb2xkTG9jYWxzID0gY29udGVudC5sb2NhbHM7XG5cbiAgICBtb2R1bGUuaG90LmFjY2VwdChcbiAgICAgIFwiISEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS01LW9uZU9mLTItMSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Bvc3Rjc3MtbG9hZGVyL2luZGV4LmpzPz9fX25leHRqc19wb3N0Y3NzIS4vTGluay5tb2R1bGUuY3NzXCIsXG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS01LW9uZU9mLTItMSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Bvc3Rjc3MtbG9hZGVyL2luZGV4LmpzPz9fX25leHRqc19wb3N0Y3NzIS4vTGluay5tb2R1bGUuY3NzXCIpO1xuXG4gICAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50Ll9fZXNNb2R1bGUgPyBjb250ZW50LmRlZmF1bHQgOiBjb250ZW50O1xuXG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoIWlzRXF1YWxMb2NhbHMob2xkTG9jYWxzLCBjb250ZW50LmxvY2FscykpIHtcbiAgICAgICAgICAgICAgICBtb2R1bGUuaG90LmludmFsaWRhdGUoKTtcblxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIG9sZExvY2FscyA9IGNvbnRlbnQubG9jYWxzO1xuXG4gICAgICAgICAgICAgIHVwZGF0ZShjb250ZW50KTtcbiAgICAgIH1cbiAgICApXG4gIH1cblxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7XG4gICAgdXBkYXRlKCk7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzIHx8IHt9OyIsImV4cG9ydCB7IGRlZmF1bHQgfSBmcm9tICcuL0xpbmsnO1xuIiwiZXhwb3J0IGRlZmF1bHQgXCIvX25leHQvc3RhdGljL2NodW5rcy9tZWRpYS9pbWFnZXMvZmF2aWNvbi5pY29cIjsiLCJtb2R1bGUuZXhwb3J0cyA9IFwiPHN2ZyB2ZXJzaW9uPVxcXCIxLjFcXFwiIGlkPVxcXCJDYXBhXzFcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCIgeG1sbnM6eGxpbms9XFxcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcXFwiIHg9XFxcIjBweFxcXCIgeT1cXFwiMHB4XFxcIiB2aWV3Qm94PVxcXCIwIDAgMTIzLjk1OSAxMjMuOTU5XFxcIiBzdHlsZT1cXFwiZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCAxMjMuOTU5IDEyMy45NTk7XFxcIiB4bWw6c3BhY2U9XFxcInByZXNlcnZlXFxcIj48Zz48cGF0aCBkPVxcXCJNODUuNzQyLDEuNzc5bC01Niw1NmMtMi4zLDIuMy0yLjMsNi4xLDAsOC40MDFsNTYsNTZjMy44MDEsMy44LDEwLjIsMS4xLDEwLjItNC4ydi0xMTIgQzk1Ljk0MiwwLjY3OSw4OS41NDMtMi4wMjEsODUuNzQyLDEuNzc5elxcXCI+PC9wYXRoPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48L3N2Zz5cIiIsIm1vZHVsZS5leHBvcnRzID0gXCI8c3ZnIHZlcnNpb249XFxcIjEuMVxcXCIgaWQ9XFxcIkNhcGFfMVxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIiB4bWxuczp4bGluaz1cXFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1xcXCIgeD1cXFwiMHB4XFxcIiB5PVxcXCIwcHhcXFwiIHZpZXdCb3g9XFxcIjAgMCAxMjMuOTU4IDEyMy45NTlcXFwiIHN0eWxlPVxcXCJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDEyMy45NTggMTIzLjk1OTtcXFwiIHhtbDpzcGFjZT1cXFwicHJlc2VydmVcXFwiPjxnPjxwYXRoIGQ9XFxcIk0zOC4yMTcsMS43NzljLTMuOC0zLjgtMTAuMi0xLjEtMTAuMiw0LjJ2MTEyYzAsNS4zLDYuNCw4LDEwLjIsNC4ybDU2LTU2YzIuMy0yLjMwMSwyLjMtNi4xMDEsMC04LjQwMUwzOC4yMTcsMS43Nzl6XFxcIj48L3BhdGg+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjwvc3ZnPlwiIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxzdmcgdmVyc2lvbj1cXFwiMS4xXFxcIiBpZD1cXFwiQ2FwYV8xXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiIHhtbG5zOnhsaW5rPVxcXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXFxcIiB4PVxcXCIwcHhcXFwiIHk9XFxcIjBweFxcXCIgdmlld0JveD1cXFwiMCAwIDQ1LjA1NyA0NS4wNTdcXFwiIHN0eWxlPVxcXCJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDQ1LjA1NyA0NS4wNTc7XFxcIiB4bWw6c3BhY2U9XFxcInByZXNlcnZlXFxcIj48Zz48ZyBpZD1cXFwiX3gzNV84XzI0X1xcXCI+PGc+PHBhdGggZD1cXFwiTTE5LjU1OCwyNS4zODljLTAuMDY3LDAuMTc2LTAuMTU1LDAuMzI4LTAuMjY0LDAuNDU1Yy0wLjEwOCwwLjEyOS0wLjI0LDAuMjI5LTAuMzk2LDAuMzAxIGMtMC4xNTYsMC4wNzItMC4zNDcsMC4xMDctMC41NywwLjEwN2MtMC4zMTMsMC0wLjU3Mi0wLjA2OC0wLjc4LTAuMjAzYy0wLjIwOC0wLjEzNy0wLjM3NC0wLjMxNi0wLjQ5OC0wLjU0MSBjLTAuMTI0LTAuMjIzLTAuMjE0LTAuNDc3LTAuMjctMC43NTZjLTAuMDU3LTAuMjc5LTAuMDg0LTAuNTY0LTAuMDg0LTAuODUyYzAtMC4yODksMC4wMjctMC41NzIsMC4wODQtMC44NTMgYzAuMDU2LTAuMjgxLDAuMTQ2LTAuNTMzLDAuMjctMC43NTZjMC4xMjQtMC4yMjUsMC4yOS0wLjQwNCwwLjQ5OC0wLjU0MWMwLjIwOC0wLjEzNywwLjQ2OC0wLjIwMywwLjc4LTAuMjAzIGMwLjI3MSwwLDAuNDk0LDAuMDUxLDAuNjY2LDAuMTU0YzAuMTcyLDAuMTA1LDAuMzEsMC4yMjUsMC40MTQsMC4zNjFjMC4xMDQsMC4xMzcsMC4xNzYsMC4yNzMsMC4yMTYsMC40MTQgYzAuMDQsMC4xMzksMC4wNjgsMC4yNSwwLjA4NCwwLjMzaDIuNTY4Yy0wLjExMi0xLjA4LTAuNDktMS45MTQtMS4xMzUtMi41MDJjLTAuNjQ0LTAuNTg4LTEuNTU4LTAuODg3LTIuNzQxLTAuODk1IGMtMC42NjQsMC0xLjI2MywwLjEwNy0xLjc5NCwwLjMyNGMtMC41MzIsMC4yMTUtMC45ODgsMC41Mi0xLjM2OCwwLjkxMmMtMC4zOCwwLjM5Mi0wLjY3MiwwLjg2My0wLjg3NiwxLjQxNiBjLTAuMjA0LDAuNTUxLTAuMzA3LDEuMTY1LTAuMzA3LDEuODM2YzAsMC42MzEsMC4wOTcsMS4yMjMsMC4yODgsMS43N2MwLjE5MiwwLjU0OSwwLjQ3NSwxLjAyMSwwLjg0NywxLjQyMiBzMC44MjUsMC43MTcsMS4zNjEsMC45NDljMC41MzYsMC4yMywxLjE1MiwwLjM0OCwxLjg0OSwwLjM0OGMwLjYyNCwwLDEuMTgtMC4xMDUsMS42NjgtMC4zMTIgYzAuNDg3LTAuMjA5LDAuODk3LTAuNDgyLDEuMjI5LTAuODIyczAuNTg0LTAuNzIzLDAuNzU2LTEuMTQ2YzAuMTcyLTAuNDIyLDAuMjU5LTAuODUyLDAuMjU5LTEuMjgzaC0yLjU5MyBDMTkuNjgsMjUuMDIzLDE5LjYyNywyNS4yMTQsMTkuNTU4LDI1LjM4OXpcXFwiPjwvcGF0aD48cG9seWdvbiBwb2ludHM9XFxcIjI2LjYyLDI0LjgxMiAyNi41OTYsMjQuODEyIDI1LjE5MiwxOS42MTYgMjIuNTI4LDE5LjYxNiAyNS4wODQsMjguMTg0IDI4LjAzNiwyOC4xODQgMzAuNzEzLDE5LjYxNiAyOCwxOS42MTYgXFxcIj48L3BvbHlnb24+PHBhdGggZD1cXFwiTTMzLjQzMSwwSDUuMTc5djQ1LjA1N2gzNC42OTlWNi4yNTFMMzMuNDMxLDB6IE0zNi44NzgsNDIuMDU2SDguMTc5VjNoMjMuNzA2djQuNzZoNC45OTJMMzYuODc4LDQyLjA1NkwzNi44NzgsNDIuMDU2elxcXCI+PC9wYXRoPjwvZz48L2c+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjwvc3ZnPlwiIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxzdmcgaWQ9XFxcIkJvbGRcXFwiIGVuYWJsZS1iYWNrZ3JvdW5kPVxcXCJuZXcgMCAwIDI0IDI0XFxcIiB2aWV3Qm94PVxcXCIwIDAgMjQgMjRcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+PHBhdGggZD1cXFwibTEyIC41Yy02LjYzIDAtMTIgNS4yOC0xMiAxMS43OTIgMCA1LjIxMSAzLjQzOCA5LjYzIDguMjA1IDExLjE4OC42LjExMS44Mi0uMjU0LjgyLS41NjcgMC0uMjgtLjAxLTEuMDIyLS4wMTUtMi4wMDUtMy4zMzguNzExLTQuMDQyLTEuNTgyLTQuMDQyLTEuNTgyLS41NDYtMS4zNjEtMS4zMzUtMS43MjUtMS4zMzUtMS43MjUtMS4wODctLjczMS4wODQtLjcxNi4wODQtLjcxNiAxLjIwNS4wODIgMS44MzggMS4yMTUgMS44MzggMS4yMTUgMS4wNyAxLjgwMyAyLjgwOSAxLjI4MiAzLjQ5NS45ODEuMTA4LS43NjMuNDE3LTEuMjgyLjc2LTEuNTc3LTIuNjY1LS4yOTUtNS40NjYtMS4zMDktNS40NjYtNS44MjcgMC0xLjI4Ny40NjUtMi4zMzkgMS4yMzUtMy4xNjQtLjEzNS0uMjk4LS41NC0xLjQ5Ny4xMDUtMy4xMjEgMCAwIDEuMDA1LS4zMTYgMy4zIDEuMjA5Ljk2LS4yNjIgMS45OC0uMzkyIDMtLjM5OCAxLjAyLjAwNiAyLjA0LjEzNiAzIC4zOTggMi4yOC0xLjUyNSAzLjI4NS0xLjIwOSAzLjI4NS0xLjIwOS42NDUgMS42MjQuMjQgMi44MjMuMTIgMy4xMjEuNzY1LjgyNSAxLjIzIDEuODc3IDEuMjMgMy4xNjQgMCA0LjUzLTIuODA1IDUuNTI3LTUuNDc1IDUuODE3LjQyLjM1NC44MSAxLjA3Ny44MSAyLjE4MiAwIDEuNTc4LS4wMTUgMi44NDYtLjAxNSAzLjIyOSAwIC4zMDkuMjEuNjc4LjgyNS41NiA0LjgwMS0xLjU0OCA4LjIzNi01Ljk3IDguMjM2LTExLjE3MyAwLTYuNTEyLTUuMzczLTExLjc5Mi0xMi0xMS43OTJ6XFxcIj48L3BhdGg+PC9zdmc+XCIiLCJtb2R1bGUuZXhwb3J0cyA9IFwiPHN2ZyBpZD1cXFwiQm9sZFxcXCIgZW5hYmxlLWJhY2tncm91bmQ9XFxcIm5ldyAwIDAgMjQgMjRcXFwiIHZpZXdCb3g9XFxcIjAgMCAyNCAyNFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj48cGF0aCBkPVxcXCJtMjMuOTk0IDI0di0uMDAxaC4wMDZ2LTguODAyYzAtNC4zMDYtLjkyNy03LjYyMy01Ljk2MS03LjYyMy0yLjQyIDAtNC4wNDQgMS4zMjgtNC43MDcgMi41ODdoLS4wN3YtMi4xODVoLTQuNzczdjE2LjAyM2g0Ljk3di03LjkzNGMwLTIuMDg5LjM5Ni00LjEwOSAyLjk4My00LjEwOSAyLjU0OSAwIDIuNTg3IDIuMzg0IDIuNTg3IDQuMjQzdjcuODAxelxcXCI+PC9wYXRoPjxwYXRoIGQ9XFxcIm0uMzk2IDcuOTc3aDQuOTc2djE2LjAyM2gtNC45NzZ6XFxcIj48L3BhdGg+PHBhdGggZD1cXFwibTIuODgyIDBjLTEuNTkxIDAtMi44ODIgMS4yOTEtMi44ODIgMi44ODJzMS4yOTEgMi45MDkgMi44ODIgMi45MDkgMi44ODItMS4zMTggMi44ODItMi45MDljLS4wMDEtMS41OTEtMS4yOTItMi44ODItMi44ODItMi44ODJ6XFxcIj48L3BhdGg+PC9zdmc+XCIiLCJtb2R1bGUuZXhwb3J0cyA9IFwiPHN2ZyB2ZXJzaW9uPVxcXCIxLjFcXFwiIGlkPVxcXCJDYXBhXzFcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCIgeG1sbnM6eGxpbms9XFxcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcXFwiIHg9XFxcIjBweFxcXCIgeT1cXFwiMHB4XFxcIiB2aWV3Qm94PVxcXCIwIDAgMjMwLjE3IDIzMC4xN1xcXCIgc3R5bGU9XFxcImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgMjMwLjE3IDIzMC4xNztcXFwiIHhtbDpzcGFjZT1cXFwicHJlc2VydmVcXFwiPjxnPjxwYXRoIGQ9XFxcIk0yMzAsNDkuNTg1YzAtMC4yNjMsMC4xODEtMC41MTksMC4xNjktMC43NzlsLTcwLjI0LDY3LjY4bDcwLjE1Niw2NS41MThjMC4wNDEtMC40NjgtMC4wODUtMC45NC0wLjA4NS0xLjQxOFY0OS41ODV6XFxcIj48L3BhdGg+PHBhdGggZD1cXFwiTTE0OS4yMDcsMTI2LjkwMWwtMjguNjc0LDI3LjU4OGMtMS40NTEsMS4zOTYtMy4zMjUsMi4wOTYtNS4yLDIuMDk2Yy0xLjgzNiwwLTMuNjcyLTAuNjctNS4xMTMtMi4wMTNsLTI4LjU5Ni0yNi42NDcgTDExLjAxLDE5NS45ODljMS43MTcsMC42MTcsMy41NiwxLjA5Niw1LjQ5LDEuMDk2aDE5Ny42NjdjMi44NjYsMCw1LjU1NC0wLjg3Myw3Ljg5MS0yLjE3NUwxNDkuMjA3LDEyNi45MDF6XFxcIj48L3BhdGg+PHBhdGggZD1cXFwiTTExNS4yNTEsMTM4Ljc1N0wyMjIuNDQ3LDM1LjQ5NmMtMi40MjctMS40NDMtNS4yNTItMi40MTEtOC4yOC0yLjQxMUgxNi41Yy0zLjk0MywwLTcuNTU2LDEuNTMxLTEwLjM3LDMuODY2IEwxMTUuMjUxLDEzOC43NTd6XFxcIj48L3BhdGg+PHBhdGggZD1cXFwiTTAsNTIuMXYxMjguNDg0YzAsMS40NzUsMC4zMzksMi44OTcsMC43MDcsNC4yNTZsNjkuNzM4LTY3LjE1NkwwLDUyLjF6XFxcIj48L3BhdGg+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjwvc3ZnPlwiIiwidmFyIGFwaSA9IHJlcXVpcmUoXCIhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzXCIpO1xuICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS01LW9uZU9mLTUtMSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Bvc3Rjc3MtbG9hZGVyL2luZGV4LmpzPz9fX25leHRqc19wb3N0Y3NzIS4vaW5kZXguY3NzXCIpO1xuXG4gICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5fX2VzTW9kdWxlID8gY29udGVudC5kZWZhdWx0IDogY29udGVudDtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4gICAgICAgICAgICB9XG5cbnZhciBvcHRpb25zID0ge307XG5cbm9wdGlvbnMuaW5zZXJ0ID0gZnVuY3Rpb24oZWxlbWVudCl7Ly8gVGhlc2UgZWxlbWVudHMgc2hvdWxkIGFsd2F5cyBleGlzdC4gSWYgdGhleSBkbyBub3QsXG4vLyB0aGlzIGNvZGUgc2hvdWxkIGZhaWwuXG52YXIgYW5jaG9yRWxlbWVudD1kb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjX19uZXh0X2Nzc19fRE9fTk9UX1VTRV9fJyk7dmFyIHBhcmVudE5vZGU9YW5jaG9yRWxlbWVudC5wYXJlbnROb2RlOy8vIE5vcm1hbGx5IDxoZWFkPlxuLy8gRWFjaCBzdHlsZSB0YWcgc2hvdWxkIGJlIHBsYWNlZCByaWdodCBiZWZvcmUgb3VyXG4vLyBhbmNob3IuIEJ5IGluc2VydGluZyBiZWZvcmUgYW5kIG5vdCBhZnRlciwgd2UgZG8gbm90XG4vLyBuZWVkIHRvIHRyYWNrIHRoZSBsYXN0IGluc2VydGVkIGVsZW1lbnQuXG5wYXJlbnROb2RlLmluc2VydEJlZm9yZShlbGVtZW50LGFuY2hvckVsZW1lbnQpO307XG5vcHRpb25zLnNpbmdsZXRvbiA9IGZhbHNlO1xuXG52YXIgdXBkYXRlID0gYXBpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5cbmlmIChtb2R1bGUuaG90KSB7XG4gIGlmICghY29udGVudC5sb2NhbHMgfHwgbW9kdWxlLmhvdC5pbnZhbGlkYXRlKSB7XG4gICAgdmFyIGlzRXF1YWxMb2NhbHMgPSBmdW5jdGlvbiBpc0VxdWFsTG9jYWxzKGEsIGIpIHtcbiAgaWYgKCFhICYmIGIgfHwgYSAmJiAhYikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBwO1xuXG4gIGZvciAocCBpbiBhKSB7XG4gICAgaWYgKGFbcF0gIT09IGJbcF0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmb3IgKHAgaW4gYikge1xuICAgIGlmICghYVtwXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcbiAgICB2YXIgb2xkTG9jYWxzID0gY29udGVudC5sb2NhbHM7XG5cbiAgICBtb2R1bGUuaG90LmFjY2VwdChcbiAgICAgIFwiISEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS01LW9uZU9mLTUtMSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Bvc3Rjc3MtbG9hZGVyL2luZGV4LmpzPz9fX25leHRqc19wb3N0Y3NzIS4vaW5kZXguY3NzXCIsXG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS01LW9uZU9mLTUtMSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Bvc3Rjc3MtbG9hZGVyL2luZGV4LmpzPz9fX25leHRqc19wb3N0Y3NzIS4vaW5kZXguY3NzXCIpO1xuXG4gICAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50Ll9fZXNNb2R1bGUgPyBjb250ZW50LmRlZmF1bHQgOiBjb250ZW50O1xuXG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoIWlzRXF1YWxMb2NhbHMob2xkTG9jYWxzLCBjb250ZW50LmxvY2FscykpIHtcbiAgICAgICAgICAgICAgICBtb2R1bGUuaG90LmludmFsaWRhdGUoKTtcblxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIG9sZExvY2FscyA9IGNvbnRlbnQubG9jYWxzO1xuXG4gICAgICAgICAgICAgIHVwZGF0ZShjb250ZW50KTtcbiAgICAgIH1cbiAgICApXG4gIH1cblxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7XG4gICAgdXBkYXRlKCk7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzIHx8IHt9OyIsIi8qIGVzbGludC1kaXNhYmxlICovXG4vLyBDT0RFIEZST006IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzk4NDc1ODAvaG93LXRvLWRldGVjdC1zYWZhcmktY2hyb21lLWllLWZpcmVmb3gtYW5kLW9wZXJhLWJyb3dzZXJcblxuLy8gT3BlcmEgOC4wK1xudmFyIGlzT3BlcmEgPSAoKSA9PiAoISF3aW5kb3cub3ByICYmICEhb3ByLmFkZG9ucykgfHwgISF3aW5kb3cub3BlcmEgfHwgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCcgT1BSLycpID49IDA7XG5cbi8vIEZpcmVmb3ggMS4wK1xudmFyIGlzRmlyZWZveCA9ICgpID0+IHR5cGVvZiBJbnN0YWxsVHJpZ2dlciAhPT0gJ3VuZGVmaW5lZCc7XG5cbi8vIFNhZmFyaSAzLjArIFwiW29iamVjdCBIVE1MRWxlbWVudENvbnN0cnVjdG9yXVwiIFxudmFyIGlzU2FmYXJpID0gKCkgPT4gL2NvbnN0cnVjdG9yL2kudGVzdCh3aW5kb3cuSFRNTEVsZW1lbnQpIHx8IChmdW5jdGlvbiAocCkgeyByZXR1cm4gcC50b1N0cmluZygpID09PSBcIltvYmplY3QgU2FmYXJpUmVtb3RlTm90aWZpY2F0aW9uXVwiOyB9KSghd2luZG93WydzYWZhcmknXSB8fCAodHlwZW9mIHNhZmFyaSAhPT0gJ3VuZGVmaW5lZCcgJiYgc2FmYXJpLnB1c2hOb3RpZmljYXRpb24pKTtcblxuLy8gSW50ZXJuZXQgRXhwbG9yZXIgNi0xMVxudmFyIGlzSUUgPSAoKSA9PiAvKkBjY19vbiFAKi9mYWxzZSB8fCAhIWRvY3VtZW50LmRvY3VtZW50TW9kZTtcblxuLy8gRWRnZSAyMCtcbnZhciBpc0VkZ2UgPSAoKSA9PiAhaXNJRSAmJiAhIXdpbmRvdy5TdHlsZU1lZGlhO1xuXG4vLyBDaHJvbWUgMSAtIDc5XG52YXIgaXNDaHJvbWUgPSAoKSA9PiAhIXdpbmRvdy5jaHJvbWUgJiYgKCEhd2luZG93LmNocm9tZS53ZWJzdG9yZSB8fCAhIXdpbmRvdy5jaHJvbWUucnVudGltZSk7XG5cbi8vIEVkZ2UgKGJhc2VkIG9uIGNocm9taXVtKSBkZXRlY3Rpb25cbnZhciBpc0VkZ2VDaHJvbWl1bSA9ICgpID0+IGlzQ2hyb21lICYmIChuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoXCJFZGdcIikgIT0gLTEpO1xuXG4vLyBCbGluayBlbmdpbmUgZGV0ZWN0aW9uXG52YXIgaXNCbGluayA9ICgpID0+IChpc0Nocm9tZSB8fCBpc09wZXJhKSAmJiAhIXdpbmRvdy5DU1M7XG5cblxuY29uc3QgYnJvd3NlciA9IHtcbiAgICBpc09wZXJhLFxuICAgIGlzRmlyZWZveCxcbiAgICBpc1NhZmFyaSxcbiAgICBpc0lFLFxuICAgIGlzRWRnZSxcbiAgICBpc0Nocm9tZSxcbiAgICBpc0VkZ2VDaHJvbWl1bSxcbiAgICBpc0JsaW5rLFxufTtcblxuZXhwb3J0IGRlZmF1bHQgYnJvd3NlcjtcbiIsImNvbnN0IGNoYW5nZVN0eWxlID0gKGVsZW1lbnQsIHByb3BlcnR5LCBuZXdWYWwpID0+IHtcbiAgLy8gSW1wcm92ZXMgUGVyZm9tYW5jZS4gQ2hhbmdlIHZhbHVlIG9ubHkgd2hlbiBuZWVkZWQuXG4gIGlmIChlbGVtZW50LnN0eWxlW3Byb3BlcnR5XSAhPT0gbmV3VmFsKSB7XG4gICAgZWxlbWVudC5zdHlsZVtwcm9wZXJ0eV0gPSBuZXdWYWw7XG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNoYW5nZVN0eWxlO1xuIiwiaW1wb3J0IGNsYW1wIGZyb20gJ2xvZGFzaC9jbGFtcCc7XG5cbmNvbnN0IGdldFJhbmdlUGVyY2VudGFnZSA9IChjdXJyZW50LCBtaW4sIG1heCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gIGNvbnN0IHByb2dyZXNzID0gKGN1cnJlbnQgLSBtaW4pIC8gKG1heCAtIG1pbik7XG5cbiAgaWYgKG9wdGlvbnMuY2xhbXApIHtcbiAgICByZXR1cm4gY2xhbXAocHJvZ3Jlc3MsIDAsIDEpO1xuICB9XG5cbiAgcmV0dXJuIHByb2dyZXNzO1xufTtcblxuY29uc3QgZ2V0UmFuZ2VWYWx1ZSA9IChwZXJjZW50YWdlLCBtaW4sIG1heCkgPT4ge1xuICBjb25zdCBwcm9ncmVzcyA9ICgobWF4IC0gbWluKSAqIHBlcmNlbnRhZ2UpICsgbWluO1xuXG4gIHJldHVybiBwcm9ncmVzcztcbn07XG5cbmV4cG9ydCB7XG4gIGdldFJhbmdlUGVyY2VudGFnZSxcbiAgZ2V0UmFuZ2VWYWx1ZSxcbn07XG4iLCJleHBvcnQgKiBmcm9tICcuL2dldC1yYW5nZSc7XG5cbmV4cG9ydCB7IGRlZmF1bHQgYXMgYnJvd3NlcnMgfSBmcm9tICcuL2Jyb3dzZXJzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgY2hhbmdlU3R5bGUgfSBmcm9tICcuL2NoYW5nZS1zdHlsZSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHVzZUZvcmNlVXBkYXRlIH0gZnJvbSAnLi91c2VGb3JjZVVwZGF0ZSc7XG4iLCJpbXBvcnQgeyB1c2VTdGF0ZSwgdXNlQ2FsbGJhY2sgfSBmcm9tICdyZWFjdCc7XG5cbmNvbnN0IHVzZUZvcmNlVXBkYXRlID0gKCkgPT4ge1xuICBjb25zdCBbLCBzZXRTdGF0ZV0gPSB1c2VTdGF0ZShmYWxzZSk7XG5cbiAgY29uc3QgdG9nZ2xlU3RhdGUgPSB1c2VDYWxsYmFjaygoKSA9PiBzZXRTdGF0ZSgoc3RhdGUpID0+ICFzdGF0ZSksIFtdKTtcblxuICByZXR1cm4gdG9nZ2xlU3RhdGU7XG59O1xuXG5leHBvcnQgZGVmYXVsdCB1c2VGb3JjZVVwZGF0ZTtcbiJdLCJzb3VyY2VSb290IjoiIn0=